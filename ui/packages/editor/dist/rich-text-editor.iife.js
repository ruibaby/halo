var RichTextEditor = (function (k, u) {
  "use strict";
  var _z = Object.defineProperty;
  var kz = (k, u, ri) =>
    u in k
      ? _z(k, u, { enumerable: !0, configurable: !0, writable: !0, value: ri })
      : (k[u] = ri);
  var oe = (k, u, ri) => kz(k, typeof u != "symbol" ? u + "" : u, ri);
  const ri = ["top", "right", "bottom", "left"],
    G0 = ["start", "end"],
    J0 = ri.reduce((t, e) => t.concat(e, e + "-" + G0[0], e + "-" + G0[1]), []),
    Zi = Math.min,
    ko = Math.max,
    Hx = { left: "right", right: "left", bottom: "top", top: "bottom" },
    zx = { start: "end", end: "start" };
  function Ed(t, e, n) {
    return ko(t, Zi(e, n));
  }
  function wo(t, e) {
    return typeof t == "function" ? t(e) : t;
  }
  function Dn(t) {
    return t.split("-")[0];
  }
  function kn(t) {
    return t.split("-")[1];
  }
  function Y0(t) {
    return t === "x" ? "y" : "x";
  }
  function Ad(t) {
    return t === "y" ? "height" : "width";
  }
  function Qi(t) {
    return ["top", "bottom"].includes(Dn(t)) ? "y" : "x";
  }
  function Sd(t) {
    return Y0(Qi(t));
  }
  function X0(t, e, n) {
    n === void 0 && (n = !1);
    const r = kn(t),
      o = Sd(t),
      i = Ad(o);
    let s =
      o === "x"
        ? r === (n ? "end" : "start")
          ? "right"
          : "left"
        : r === "start"
        ? "bottom"
        : "top";
    return e.reference[i] > e.floating[i] && (s = Ja(s)), [s, Ja(s)];
  }
  function Vx(t) {
    const e = Ja(t);
    return [Ga(t), e, Ga(e)];
  }
  function Ga(t) {
    return t.replace(/start|end/g, (e) => zx[e]);
  }
  function Ux(t, e, n) {
    const r = ["left", "right"],
      o = ["right", "left"],
      i = ["top", "bottom"],
      s = ["bottom", "top"];
    switch (t) {
      case "top":
      case "bottom":
        return n ? (e ? o : r) : e ? r : o;
      case "left":
      case "right":
        return e ? i : s;
      default:
        return [];
    }
  }
  function jx(t, e, n, r) {
    const o = kn(t);
    let i = Ux(Dn(t), n === "start", r);
    return (
      o && ((i = i.map((s) => s + "-" + o)), e && (i = i.concat(i.map(Ga)))), i
    );
  }
  function Ja(t) {
    return t.replace(/left|right|bottom|top/g, (e) => Hx[e]);
  }
  function Wx(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }
  function Z0(t) {
    return typeof t != "number"
      ? Wx(t)
      : { top: t, right: t, bottom: t, left: t };
  }
  function es(t) {
    return {
      ...t,
      top: t.y,
      left: t.x,
      right: t.x + t.width,
      bottom: t.y + t.height,
    };
  }
  function Q0(t, e, n) {
    let { reference: r, floating: o } = t;
    const i = Qi(e),
      s = Sd(e),
      a = Ad(s),
      l = Dn(e),
      c = i === "y",
      d = r.x + r.width / 2 - o.width / 2,
      f = r.y + r.height / 2 - o.height / 2,
      p = r[a] / 2 - o[a] / 2;
    let h;
    switch (l) {
      case "top":
        h = { x: d, y: r.y - o.height };
        break;
      case "bottom":
        h = { x: d, y: r.y + r.height };
        break;
      case "right":
        h = { x: r.x + r.width, y: f };
        break;
      case "left":
        h = { x: r.x - o.width, y: f };
        break;
      default:
        h = { x: r.x, y: r.y };
    }
    switch (kn(e)) {
      case "start":
        h[s] -= p * (n && c ? -1 : 1);
        break;
      case "end":
        h[s] += p * (n && c ? -1 : 1);
        break;
    }
    return h;
  }
  const qx = async (t, e, n) => {
    const {
        placement: r = "bottom",
        strategy: o = "absolute",
        middleware: i = [],
        platform: s,
      } = n,
      a = i.filter(Boolean),
      l = await (s.isRTL == null ? void 0 : s.isRTL(e));
    let c = await s.getElementRects({ reference: t, floating: e, strategy: o }),
      { x: d, y: f } = Q0(c, r, l),
      p = r,
      h = {},
      m = 0;
    for (let g = 0; g < a.length; g++) {
      const { name: b, fn: y } = a[g],
        {
          x,
          y: w,
          data: _,
          reset: v,
        } = await y({
          x: d,
          y: f,
          initialPlacement: r,
          placement: p,
          strategy: o,
          middlewareData: h,
          rects: c,
          platform: s,
          elements: { reference: t, floating: e },
        });
      if (
        ((d = x ?? d),
        (f = w ?? f),
        (h = { ...h, [b]: { ...h[b], ..._ } }),
        v && m <= 50)
      ) {
        m++,
          typeof v == "object" &&
            (v.placement && (p = v.placement),
            v.rects &&
              (c =
                v.rects === !0
                  ? await s.getElementRects({
                      reference: t,
                      floating: e,
                      strategy: o,
                    })
                  : v.rects),
            ({ x: d, y: f } = Q0(c, p, l))),
          (g = -1);
        continue;
      }
    }
    return { x: d, y: f, placement: p, strategy: o, middlewareData: h };
  };
  async function Ya(t, e) {
    var n;
    e === void 0 && (e = {});
    const { x: r, y: o, platform: i, rects: s, elements: a, strategy: l } = t,
      {
        boundary: c = "clippingAncestors",
        rootBoundary: d = "viewport",
        elementContext: f = "floating",
        altBoundary: p = !1,
        padding: h = 0,
      } = wo(e, t),
      m = Z0(h),
      b = a[p ? (f === "floating" ? "reference" : "floating") : f],
      y = es(
        await i.getClippingRect({
          element:
            (n = await (i.isElement == null ? void 0 : i.isElement(b))) ==
              null || n
              ? b
              : b.contextElement ||
                (await (i.getDocumentElement == null
                  ? void 0
                  : i.getDocumentElement(a.floating))),
          boundary: c,
          rootBoundary: d,
          strategy: l,
        })
      ),
      x = f === "floating" ? { ...s.floating, x: r, y: o } : s.reference,
      w = await (i.getOffsetParent == null
        ? void 0
        : i.getOffsetParent(a.floating)),
      _ = (await (i.isElement == null ? void 0 : i.isElement(w)))
        ? (await (i.getScale == null ? void 0 : i.getScale(w))) || {
            x: 1,
            y: 1,
          }
        : { x: 1, y: 1 },
      v = es(
        i.convertOffsetParentRelativeRectToViewportRelativeRect
          ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
              rect: x,
              offsetParent: w,
              strategy: l,
            })
          : x
      );
    return {
      top: (y.top - v.top + m.top) / _.y,
      bottom: (v.bottom - y.bottom + m.bottom) / _.y,
      left: (y.left - v.left + m.left) / _.x,
      right: (v.right - y.right + m.right) / _.x,
    };
  }
  const Kx = (t) => ({
    name: "arrow",
    options: t,
    async fn(e) {
      const {
          x: n,
          y: r,
          placement: o,
          rects: i,
          platform: s,
          elements: a,
          middlewareData: l,
        } = e,
        { element: c, padding: d = 0 } = wo(t, e) || {};
      if (c == null) return {};
      const f = Z0(d),
        p = { x: n, y: r },
        h = Sd(o),
        m = Ad(h),
        g = await s.getDimensions(c),
        b = h === "y",
        y = b ? "top" : "left",
        x = b ? "bottom" : "right",
        w = b ? "clientHeight" : "clientWidth",
        _ = i.reference[m] + i.reference[h] - p[h] - i.floating[m],
        v = p[h] - i.reference[h],
        C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
      let S = C ? C[w] : 0;
      (!S || !(await (s.isElement == null ? void 0 : s.isElement(C)))) &&
        (S = a.floating[w] || i.floating[m]);
      const N = _ / 2 - v / 2,
        M = S / 2 - g[m] / 2 - 1,
        L = Zi(f[y], M),
        $ = Zi(f[x], M),
        B = L,
        H = S - g[m] - $,
        Q = S / 2 - g[m] / 2 + N,
        X = Ed(B, Q, H),
        Y =
          !l.arrow &&
          kn(o) != null &&
          Q != X &&
          i.reference[m] / 2 - (Q < B ? L : $) - g[m] / 2 < 0,
        Z = Y ? (Q < B ? Q - B : Q - H) : 0;
      return {
        [h]: p[h] + Z,
        data: {
          [h]: X,
          centerOffset: Q - X - Z,
          ...(Y && { alignmentOffset: Z }),
        },
        reset: Y,
      };
    },
  });
  function Gx(t, e, n) {
    return (
      t
        ? [...n.filter((o) => kn(o) === t), ...n.filter((o) => kn(o) !== t)]
        : n.filter((o) => Dn(o) === o)
    ).filter((o) => (t ? kn(o) === t || (e ? Ga(o) !== o : !1) : !0));
  }
  const Jx = function (t) {
      return (
        t === void 0 && (t = {}),
        {
          name: "autoPlacement",
          options: t,
          async fn(e) {
            var n, r, o;
            const {
                rects: i,
                middlewareData: s,
                placement: a,
                platform: l,
                elements: c,
              } = e,
              {
                crossAxis: d = !1,
                alignment: f,
                allowedPlacements: p = J0,
                autoAlignment: h = !0,
                ...m
              } = wo(t, e),
              g = f !== void 0 || p === J0 ? Gx(f || null, h, p) : p,
              b = await Ya(e, m),
              y = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0,
              x = g[y];
            if (x == null) return {};
            const w = X0(
              x,
              i,
              await (l.isRTL == null ? void 0 : l.isRTL(c.floating))
            );
            if (a !== x) return { reset: { placement: g[0] } };
            const _ = [b[Dn(x)], b[w[0]], b[w[1]]],
              v = [
                ...(((r = s.autoPlacement) == null ? void 0 : r.overflows) ||
                  []),
                { placement: x, overflows: _ },
              ],
              C = g[y + 1];
            if (C)
              return {
                data: { index: y + 1, overflows: v },
                reset: { placement: C },
              };
            const S = v
                .map((L) => {
                  const $ = kn(L.placement);
                  return [
                    L.placement,
                    $ && d
                      ? L.overflows.slice(0, 2).reduce((B, H) => B + H, 0)
                      : L.overflows[0],
                    L.overflows,
                  ];
                })
                .sort((L, $) => L[1] - $[1]),
              M =
                ((o = S.filter((L) =>
                  L[2].slice(0, kn(L[0]) ? 2 : 3).every(($) => $ <= 0)
                )[0]) == null
                  ? void 0
                  : o[0]) || S[0][0];
            return M !== a
              ? {
                  data: { index: y + 1, overflows: v },
                  reset: { placement: M },
                }
              : {};
          },
        }
      );
    },
    Yx = function (t) {
      return (
        t === void 0 && (t = {}),
        {
          name: "flip",
          options: t,
          async fn(e) {
            var n, r;
            const {
                placement: o,
                middlewareData: i,
                rects: s,
                initialPlacement: a,
                platform: l,
                elements: c,
              } = e,
              {
                mainAxis: d = !0,
                crossAxis: f = !0,
                fallbackPlacements: p,
                fallbackStrategy: h = "bestFit",
                fallbackAxisSideDirection: m = "none",
                flipAlignment: g = !0,
                ...b
              } = wo(t, e);
            if ((n = i.arrow) != null && n.alignmentOffset) return {};
            const y = Dn(o),
              x = Dn(a) === a,
              w = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
              _ = p || (x || !g ? [Ja(a)] : Vx(a));
            !p && m !== "none" && _.push(...jx(a, g, m, w));
            const v = [a, ..._],
              C = await Ya(e, b),
              S = [];
            let N = ((r = i.flip) == null ? void 0 : r.overflows) || [];
            if ((d && S.push(C[y]), f)) {
              const B = X0(o, s, w);
              S.push(C[B[0]], C[B[1]]);
            }
            if (
              ((N = [...N, { placement: o, overflows: S }]),
              !S.every((B) => B <= 0))
            ) {
              var M, L;
              const B = (((M = i.flip) == null ? void 0 : M.index) || 0) + 1,
                H = v[B];
              if (H)
                return {
                  data: { index: B, overflows: N },
                  reset: { placement: H },
                };
              let Q =
                (L = N.filter((X) => X.overflows[0] <= 0).sort(
                  (X, Y) => X.overflows[1] - Y.overflows[1]
                )[0]) == null
                  ? void 0
                  : L.placement;
              if (!Q)
                switch (h) {
                  case "bestFit": {
                    var $;
                    const X =
                      ($ = N.map((Y) => [
                        Y.placement,
                        Y.overflows
                          .filter((Z) => Z > 0)
                          .reduce((Z, ce) => Z + ce, 0),
                      ]).sort((Y, Z) => Y[1] - Z[1])[0]) == null
                        ? void 0
                        : $[0];
                    X && (Q = X);
                    break;
                  }
                  case "initialPlacement":
                    Q = a;
                    break;
                }
              if (o !== Q) return { reset: { placement: Q } };
            }
            return {};
          },
        }
      );
    };
  async function Xx(t, e) {
    const { placement: n, platform: r, elements: o } = t,
      i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
      s = Dn(n),
      a = kn(n),
      l = Qi(n) === "y",
      c = ["left", "top"].includes(s) ? -1 : 1,
      d = i && l ? -1 : 1,
      f = wo(e, t);
    let {
      mainAxis: p,
      crossAxis: h,
      alignmentAxis: m,
    } = typeof f == "number"
      ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
      : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...f };
    return (
      a && typeof m == "number" && (h = a === "end" ? m * -1 : m),
      l ? { x: h * d, y: p * c } : { x: p * c, y: h * d }
    );
  }
  const Zx = function (t) {
      return (
        t === void 0 && (t = 0),
        {
          name: "offset",
          options: t,
          async fn(e) {
            var n, r;
            const { x: o, y: i, placement: s, middlewareData: a } = e,
              l = await Xx(e, t);
            return s === ((n = a.offset) == null ? void 0 : n.placement) &&
              (r = a.arrow) != null &&
              r.alignmentOffset
              ? {}
              : { x: o + l.x, y: i + l.y, data: { ...l, placement: s } };
          },
        }
      );
    },
    Qx = function (t) {
      return (
        t === void 0 && (t = {}),
        {
          name: "shift",
          options: t,
          async fn(e) {
            const { x: n, y: r, placement: o } = e,
              {
                mainAxis: i = !0,
                crossAxis: s = !1,
                limiter: a = {
                  fn: (b) => {
                    let { x: y, y: x } = b;
                    return { x: y, y: x };
                  },
                },
                ...l
              } = wo(t, e),
              c = { x: n, y: r },
              d = await Ya(e, l),
              f = Qi(Dn(o)),
              p = Y0(f);
            let h = c[p],
              m = c[f];
            if (i) {
              const b = p === "y" ? "top" : "left",
                y = p === "y" ? "bottom" : "right",
                x = h + d[b],
                w = h - d[y];
              h = Ed(x, h, w);
            }
            if (s) {
              const b = f === "y" ? "top" : "left",
                y = f === "y" ? "bottom" : "right",
                x = m + d[b],
                w = m - d[y];
              m = Ed(x, m, w);
            }
            const g = a.fn({ ...e, [p]: h, [f]: m });
            return { ...g, data: { x: g.x - n, y: g.y - r } };
          },
        }
      );
    },
    e4 = function (t) {
      return (
        t === void 0 && (t = {}),
        {
          name: "size",
          options: t,
          async fn(e) {
            const { placement: n, rects: r, platform: o, elements: i } = e,
              { apply: s = () => {}, ...a } = wo(t, e),
              l = await Ya(e, a),
              c = Dn(n),
              d = kn(n),
              f = Qi(n) === "y",
              { width: p, height: h } = r.floating;
            let m, g;
            c === "top" || c === "bottom"
              ? ((m = c),
                (g =
                  d ===
                  ((await (o.isRTL == null ? void 0 : o.isRTL(i.floating)))
                    ? "start"
                    : "end")
                    ? "left"
                    : "right"))
              : ((g = c), (m = d === "end" ? "top" : "bottom"));
            const b = h - l[m],
              y = p - l[g],
              x = !e.middlewareData.shift;
            let w = b,
              _ = y;
            if (f) {
              const C = p - l.left - l.right;
              _ = d || x ? Zi(y, C) : C;
            } else {
              const C = h - l.top - l.bottom;
              w = d || x ? Zi(b, C) : C;
            }
            if (x && !d) {
              const C = ko(l.left, 0),
                S = ko(l.right, 0),
                N = ko(l.top, 0),
                M = ko(l.bottom, 0);
              f
                ? (_ =
                    p - 2 * (C !== 0 || S !== 0 ? C + S : ko(l.left, l.right)))
                : (w =
                    h - 2 * (N !== 0 || M !== 0 ? N + M : ko(l.top, l.bottom)));
            }
            await s({ ...e, availableWidth: _, availableHeight: w });
            const v = await o.getDimensions(i.floating);
            return p !== v.width || h !== v.height
              ? { reset: { rects: !0 } }
              : {};
          },
        }
      );
    };
  function Jt(t) {
    var e;
    return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
  }
  function Ln(t) {
    return Jt(t).getComputedStyle(t);
  }
  const em = Math.min,
    ts = Math.max,
    Xa = Math.round;
  function tm(t) {
    const e = Ln(t);
    let n = parseFloat(e.width),
      r = parseFloat(e.height);
    const o = t.offsetWidth,
      i = t.offsetHeight,
      s = Xa(n) !== o || Xa(r) !== i;
    return s && ((n = o), (r = i)), { width: n, height: r, fallback: s };
  }
  function Sr(t) {
    return rm(t) ? (t.nodeName || "").toLowerCase() : "";
  }
  let Za;
  function nm() {
    if (Za) return Za;
    const t = navigator.userAgentData;
    return t && Array.isArray(t.brands)
      ? ((Za = t.brands.map((e) => e.brand + "/" + e.version).join(" ")), Za)
      : navigator.userAgent;
  }
  function In(t) {
    return t instanceof Jt(t).HTMLElement;
  }
  function Mr(t) {
    return t instanceof Jt(t).Element;
  }
  function rm(t) {
    return t instanceof Jt(t).Node;
  }
  function om(t) {
    return typeof ShadowRoot > "u"
      ? !1
      : t instanceof Jt(t).ShadowRoot || t instanceof ShadowRoot;
  }
  function Qa(t) {
    const { overflow: e, overflowX: n, overflowY: r, display: o } = Ln(t);
    return (
      /auto|scroll|overlay|hidden|clip/.test(e + r + n) &&
      !["inline", "contents"].includes(o)
    );
  }
  function t4(t) {
    return ["table", "td", "th"].includes(Sr(t));
  }
  function Md(t) {
    const e = /firefox/i.test(nm()),
      n = Ln(t),
      r = n.backdropFilter || n.WebkitBackdropFilter;
    return (
      n.transform !== "none" ||
      n.perspective !== "none" ||
      (!!r && r !== "none") ||
      (e && n.willChange === "filter") ||
      (e && !!n.filter && n.filter !== "none") ||
      ["transform", "perspective"].some((o) => n.willChange.includes(o)) ||
      ["paint", "layout", "strict", "content"].some((o) => {
        const i = n.contain;
        return i != null && i.includes(o);
      })
    );
  }
  function im() {
    return !/^((?!chrome|android).)*safari/i.test(nm());
  }
  function Td(t) {
    return ["html", "body", "#document"].includes(Sr(t));
  }
  function sm(t) {
    return Mr(t) ? t : t.contextElement;
  }
  const am = { x: 1, y: 1 };
  function oi(t) {
    const e = sm(t);
    if (!In(e)) return am;
    const n = e.getBoundingClientRect(),
      { width: r, height: o, fallback: i } = tm(e);
    let s = (i ? Xa(n.width) : n.width) / r,
      a = (i ? Xa(n.height) : n.height) / o;
    return (
      (s && Number.isFinite(s)) || (s = 1),
      (a && Number.isFinite(a)) || (a = 1),
      { x: s, y: a }
    );
  }
  function ns(t, e, n, r) {
    var o, i;
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    const s = t.getBoundingClientRect(),
      a = sm(t);
    let l = am;
    e && (r ? Mr(r) && (l = oi(r)) : (l = oi(t)));
    const c = a ? Jt(a) : window,
      d = !im() && n;
    let f =
        (s.left +
          ((d && ((o = c.visualViewport) == null ? void 0 : o.offsetLeft)) ||
            0)) /
        l.x,
      p =
        (s.top +
          ((d && ((i = c.visualViewport) == null ? void 0 : i.offsetTop)) ||
            0)) /
        l.y,
      h = s.width / l.x,
      m = s.height / l.y;
    if (a) {
      const g = Jt(a),
        b = r && Mr(r) ? Jt(r) : r;
      let y = g.frameElement;
      for (; y && r && b !== g; ) {
        const x = oi(y),
          w = y.getBoundingClientRect(),
          _ = getComputedStyle(y);
        (w.x += (y.clientLeft + parseFloat(_.paddingLeft)) * x.x),
          (w.y += (y.clientTop + parseFloat(_.paddingTop)) * x.y),
          (f *= x.x),
          (p *= x.y),
          (h *= x.x),
          (m *= x.y),
          (f += w.x),
          (p += w.y),
          (y = Jt(y).frameElement);
      }
    }
    return {
      width: h,
      height: m,
      top: p,
      right: f + h,
      bottom: p + m,
      left: f,
      x: f,
      y: p,
    };
  }
  function Tr(t) {
    return ((rm(t) ? t.ownerDocument : t.document) || window.document)
      .documentElement;
  }
  function el(t) {
    return Mr(t)
      ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
      : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
  }
  function lm(t) {
    return ns(Tr(t)).left + el(t).scrollLeft;
  }
  function rs(t) {
    if (Sr(t) === "html") return t;
    const e = t.assignedSlot || t.parentNode || (om(t) && t.host) || Tr(t);
    return om(e) ? e.host : e;
  }
  function cm(t) {
    const e = rs(t);
    return Td(e) ? e.ownerDocument.body : In(e) && Qa(e) ? e : cm(e);
  }
  function tl(t, e) {
    var n;
    e === void 0 && (e = []);
    const r = cm(t),
      o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
      i = Jt(r);
    return o
      ? e.concat(i, i.visualViewport || [], Qa(r) ? r : [])
      : e.concat(r, tl(r));
  }
  function um(t, e, n) {
    return e === "viewport"
      ? es(
          (function (r, o) {
            const i = Jt(r),
              s = Tr(r),
              a = i.visualViewport;
            let l = s.clientWidth,
              c = s.clientHeight,
              d = 0,
              f = 0;
            if (a) {
              (l = a.width), (c = a.height);
              const p = im();
              (p || (!p && o === "fixed")) &&
                ((d = a.offsetLeft), (f = a.offsetTop));
            }
            return { width: l, height: c, x: d, y: f };
          })(t, n)
        )
      : Mr(e)
      ? es(
          (function (r, o) {
            const i = ns(r, !0, o === "fixed"),
              s = i.top + r.clientTop,
              a = i.left + r.clientLeft,
              l = In(r) ? oi(r) : { x: 1, y: 1 };
            return {
              width: r.clientWidth * l.x,
              height: r.clientHeight * l.y,
              x: a * l.x,
              y: s * l.y,
            };
          })(e, n)
        )
      : es(
          (function (r) {
            const o = Tr(r),
              i = el(r),
              s = r.ownerDocument.body,
              a = ts(
                o.scrollWidth,
                o.clientWidth,
                s.scrollWidth,
                s.clientWidth
              ),
              l = ts(
                o.scrollHeight,
                o.clientHeight,
                s.scrollHeight,
                s.clientHeight
              );
            let c = -i.scrollLeft + lm(r);
            const d = -i.scrollTop;
            return (
              Ln(s).direction === "rtl" &&
                (c += ts(o.clientWidth, s.clientWidth) - a),
              { width: a, height: l, x: c, y: d }
            );
          })(Tr(t))
        );
  }
  function dm(t) {
    return In(t) && Ln(t).position !== "fixed" ? t.offsetParent : null;
  }
  function fm(t) {
    const e = Jt(t);
    let n = dm(t);
    for (; n && t4(n) && Ln(n).position === "static"; ) n = dm(n);
    return n &&
      (Sr(n) === "html" ||
        (Sr(n) === "body" && Ln(n).position === "static" && !Md(n)))
      ? e
      : n ||
          (function (r) {
            let o = rs(r);
            for (; In(o) && !Td(o); ) {
              if (Md(o)) return o;
              o = rs(o);
            }
            return null;
          })(t) ||
          e;
  }
  function n4(t, e, n) {
    const r = In(e),
      o = Tr(e),
      i = ns(t, !0, n === "fixed", e);
    let s = { scrollLeft: 0, scrollTop: 0 };
    const a = { x: 0, y: 0 };
    if (r || (!r && n !== "fixed"))
      if (((Sr(e) !== "body" || Qa(o)) && (s = el(e)), In(e))) {
        const l = ns(e, !0);
        (a.x = l.x + e.clientLeft), (a.y = l.y + e.clientTop);
      } else o && (a.x = lm(o));
    return {
      x: i.left + s.scrollLeft - a.x,
      y: i.top + s.scrollTop - a.y,
      width: i.width,
      height: i.height,
    };
  }
  const r4 = {
      getClippingRect: function (t) {
        let { element: e, boundary: n, rootBoundary: r, strategy: o } = t;
        const i =
            n === "clippingAncestors"
              ? (function (c, d) {
                  const f = d.get(c);
                  if (f) return f;
                  let p = tl(c).filter((b) => Mr(b) && Sr(b) !== "body"),
                    h = null;
                  const m = Ln(c).position === "fixed";
                  let g = m ? rs(c) : c;
                  for (; Mr(g) && !Td(g); ) {
                    const b = Ln(g),
                      y = Md(g);
                    (
                      m
                        ? y || h
                        : y ||
                          b.position !== "static" ||
                          !h ||
                          !["absolute", "fixed"].includes(h.position)
                    )
                      ? (h = b)
                      : (p = p.filter((x) => x !== g)),
                      (g = rs(g));
                  }
                  return d.set(c, p), p;
                })(e, this._c)
              : [].concat(n),
          s = [...i, r],
          a = s[0],
          l = s.reduce((c, d) => {
            const f = um(e, d, o);
            return (
              (c.top = ts(f.top, c.top)),
              (c.right = em(f.right, c.right)),
              (c.bottom = em(f.bottom, c.bottom)),
              (c.left = ts(f.left, c.left)),
              c
            );
          }, um(e, a, o));
        return {
          width: l.right - l.left,
          height: l.bottom - l.top,
          x: l.left,
          y: l.top,
        };
      },
      convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {
        let { rect: e, offsetParent: n, strategy: r } = t;
        const o = In(n),
          i = Tr(n);
        if (n === i) return e;
        let s = { scrollLeft: 0, scrollTop: 0 },
          a = { x: 1, y: 1 };
        const l = { x: 0, y: 0 };
        if (
          (o || (!o && r !== "fixed")) &&
          ((Sr(n) !== "body" || Qa(i)) && (s = el(n)), In(n))
        ) {
          const c = ns(n);
          (a = oi(n)), (l.x = c.x + n.clientLeft), (l.y = c.y + n.clientTop);
        }
        return {
          width: e.width * a.x,
          height: e.height * a.y,
          x: e.x * a.x - s.scrollLeft * a.x + l.x,
          y: e.y * a.y - s.scrollTop * a.y + l.y,
        };
      },
      isElement: Mr,
      getDimensions: function (t) {
        return In(t) ? tm(t) : t.getBoundingClientRect();
      },
      getOffsetParent: fm,
      getDocumentElement: Tr,
      getScale: oi,
      async getElementRects(t) {
        let { reference: e, floating: n, strategy: r } = t;
        const o = this.getOffsetParent || fm,
          i = this.getDimensions;
        return {
          reference: n4(e, await o(n), r),
          floating: { x: 0, y: 0, ...(await i(n)) },
        };
      },
      getClientRects: (t) => Array.from(t.getClientRects()),
      isRTL: (t) => Ln(t).direction === "rtl",
    },
    o4 = (t, e, n) => {
      const r = new Map(),
        o = { platform: r4, ...n },
        i = { ...o.platform, _c: r };
      return qx(t, e, { ...o, platform: i });
    },
    xo = {
      disabled: !1,
      distance: 5,
      skidding: 0,
      container: "body",
      boundary: void 0,
      instantMove: !1,
      disposeTimeout: 150,
      popperTriggers: [],
      strategy: "absolute",
      preventOverflow: !0,
      flip: !0,
      shift: !0,
      overflowPadding: 0,
      arrowPadding: 0,
      arrowOverflow: !0,
      autoHideOnMousedown: !1,
      themes: {
        tooltip: {
          placement: "top",
          triggers: ["hover", "focus", "touch"],
          hideTriggers: (t) => [...t, "click"],
          delay: { show: 200, hide: 0 },
          handleResize: !1,
          html: !1,
          loadingContent: "...",
        },
        dropdown: {
          placement: "bottom",
          triggers: ["click"],
          delay: 0,
          handleResize: !0,
          autoHide: !0,
        },
        menu: {
          $extend: "dropdown",
          triggers: ["hover", "focus"],
          popperTriggers: ["hover"],
          delay: { show: 0, hide: 400 },
        },
      },
    };
  function is(t, e) {
    let n = xo.themes[t] || {},
      r;
    do
      (r = n[e]),
        typeof r > "u"
          ? n.$extend
            ? (n = xo.themes[n.$extend] || {})
            : ((n = null), (r = xo[e]))
          : (n = null);
    while (n);
    return r;
  }
  function i4(t) {
    const e = [t];
    let n = xo.themes[t] || {};
    do
      n.$extend && !n.$resetCss
        ? (e.push(n.$extend), (n = xo.themes[n.$extend] || {}))
        : (n = null);
    while (n);
    return e.map((r) => `v-popper--theme-${r}`);
  }
  function pm(t) {
    const e = [t];
    let n = xo.themes[t] || {};
    do
      n.$extend
        ? (e.push(n.$extend), (n = xo.themes[n.$extend] || {}))
        : (n = null);
    while (n);
    return e;
  }
  let ss = !1;
  if (typeof window < "u") {
    ss = !1;
    try {
      const t = Object.defineProperty({}, "passive", {
        get() {
          ss = !0;
        },
      });
      window.addEventListener("test", null, t);
    } catch {}
  }
  let hm = !1;
  typeof window < "u" &&
    typeof navigator < "u" &&
    (hm = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
  const mm = ["auto", "top", "bottom", "left", "right"].reduce(
      (t, e) => t.concat([e, `${e}-start`, `${e}-end`]),
      []
    ),
    gm = {
      hover: "mouseenter",
      focus: "focus",
      click: "click",
      touch: "touchstart",
      pointer: "pointerdown",
    },
    bm = {
      hover: "mouseleave",
      focus: "blur",
      click: "click",
      touch: "touchend",
      pointer: "pointerup",
    };
  function ym(t, e) {
    const n = t.indexOf(e);
    n !== -1 && t.splice(n, 1);
  }
  function Nd() {
    return new Promise((t) =>
      requestAnimationFrame(() => {
        requestAnimationFrame(t);
      })
    );
  }
  const wn = [];
  let Co = null;
  const _m = {};
  function km(t) {
    let e = _m[t];
    return e || (e = _m[t] = []), e;
  }
  let Od = function () {};
  typeof window < "u" && (Od = window.Element);
  function pe(t) {
    return function (e) {
      return is(e.theme, t);
    };
  }
  const Rd = "__floating-vue__popper",
    wm = () =>
      u.defineComponent({
        name: "VPopper",
        provide() {
          return { [Rd]: { parentPopper: this } };
        },
        inject: { [Rd]: { default: null } },
        props: {
          theme: { type: String, required: !0 },
          targetNodes: { type: Function, required: !0 },
          referenceNode: { type: Function, default: null },
          popperNode: { type: Function, required: !0 },
          shown: { type: Boolean, default: !1 },
          showGroup: { type: String, default: null },
          ariaId: { default: null },
          disabled: { type: Boolean, default: pe("disabled") },
          positioningDisabled: {
            type: Boolean,
            default: pe("positioningDisabled"),
          },
          placement: {
            type: String,
            default: pe("placement"),
            validator: (t) => mm.includes(t),
          },
          delay: { type: [String, Number, Object], default: pe("delay") },
          distance: { type: [Number, String], default: pe("distance") },
          skidding: { type: [Number, String], default: pe("skidding") },
          triggers: { type: Array, default: pe("triggers") },
          showTriggers: {
            type: [Array, Function],
            default: pe("showTriggers"),
          },
          hideTriggers: {
            type: [Array, Function],
            default: pe("hideTriggers"),
          },
          popperTriggers: { type: Array, default: pe("popperTriggers") },
          popperShowTriggers: {
            type: [Array, Function],
            default: pe("popperShowTriggers"),
          },
          popperHideTriggers: {
            type: [Array, Function],
            default: pe("popperHideTriggers"),
          },
          container: {
            type: [String, Object, Od, Boolean],
            default: pe("container"),
          },
          boundary: { type: [String, Od], default: pe("boundary") },
          strategy: {
            type: String,
            validator: (t) => ["absolute", "fixed"].includes(t),
            default: pe("strategy"),
          },
          autoHide: { type: [Boolean, Function], default: pe("autoHide") },
          handleResize: { type: Boolean, default: pe("handleResize") },
          instantMove: { type: Boolean, default: pe("instantMove") },
          eagerMount: { type: Boolean, default: pe("eagerMount") },
          popperClass: {
            type: [String, Array, Object],
            default: pe("popperClass"),
          },
          computeTransformOrigin: {
            type: Boolean,
            default: pe("computeTransformOrigin"),
          },
          autoMinSize: { type: Boolean, default: pe("autoMinSize") },
          autoSize: { type: [Boolean, String], default: pe("autoSize") },
          autoMaxSize: { type: Boolean, default: pe("autoMaxSize") },
          autoBoundaryMaxSize: {
            type: Boolean,
            default: pe("autoBoundaryMaxSize"),
          },
          preventOverflow: { type: Boolean, default: pe("preventOverflow") },
          overflowPadding: {
            type: [Number, String],
            default: pe("overflowPadding"),
          },
          arrowPadding: { type: [Number, String], default: pe("arrowPadding") },
          arrowOverflow: { type: Boolean, default: pe("arrowOverflow") },
          flip: { type: Boolean, default: pe("flip") },
          shift: { type: Boolean, default: pe("shift") },
          shiftCrossAxis: { type: Boolean, default: pe("shiftCrossAxis") },
          noAutoFocus: { type: Boolean, default: pe("noAutoFocus") },
          disposeTimeout: { type: Number, default: pe("disposeTimeout") },
        },
        emits: {
          show: () => !0,
          hide: () => !0,
          "update:shown": (t) => !0,
          "apply-show": () => !0,
          "apply-hide": () => !0,
          "close-group": () => !0,
          "close-directive": () => !0,
          "auto-hide": () => !0,
          resize: () => !0,
        },
        data() {
          return {
            isShown: !1,
            isMounted: !1,
            skipTransition: !1,
            classes: { showFrom: !1, showTo: !1, hideFrom: !1, hideTo: !0 },
            result: {
              x: 0,
              y: 0,
              placement: "",
              strategy: this.strategy,
              arrow: { x: 0, y: 0, centerOffset: 0 },
              transformOrigin: null,
            },
            randomId: `popper_${[Math.random(), Date.now()]
              .map((t) => t.toString(36).substring(2, 10))
              .join("_")}`,
            shownChildren: new Set(),
            lastAutoHide: !0,
            pendingHide: !1,
            containsGlobalTarget: !1,
            isDisposed: !0,
            mouseDownContains: !1,
          };
        },
        computed: {
          popperId() {
            return this.ariaId != null ? this.ariaId : this.randomId;
          },
          shouldMountContent() {
            return this.eagerMount || this.isMounted;
          },
          slotData() {
            return {
              popperId: this.popperId,
              isShown: this.isShown,
              shouldMountContent: this.shouldMountContent,
              skipTransition: this.skipTransition,
              autoHide:
                typeof this.autoHide == "function"
                  ? this.lastAutoHide
                  : this.autoHide,
              show: this.show,
              hide: this.hide,
              handleResize: this.handleResize,
              onResize: this.onResize,
              classes: { ...this.classes, popperClass: this.popperClass },
              result: this.positioningDisabled ? null : this.result,
              attrs: this.$attrs,
            };
          },
          parentPopper() {
            var t;
            return (t = this[Rd]) == null ? void 0 : t.parentPopper;
          },
          hasPopperShowTriggerHover() {
            var t, e;
            return (
              ((t = this.popperTriggers) == null
                ? void 0
                : t.includes("hover")) ||
              ((e = this.popperShowTriggers) == null
                ? void 0
                : e.includes("hover"))
            );
          },
        },
        watch: {
          shown: "$_autoShowHide",
          disabled(t) {
            t ? this.dispose() : this.init();
          },
          async container() {
            this.isShown &&
              (this.$_ensureTeleport(), await this.$_computePosition());
          },
          triggers: { handler: "$_refreshListeners", deep: !0 },
          positioningDisabled: "$_refreshListeners",
          ...[
            "placement",
            "distance",
            "skidding",
            "boundary",
            "strategy",
            "overflowPadding",
            "arrowPadding",
            "preventOverflow",
            "shift",
            "shiftCrossAxis",
            "flip",
          ].reduce((t, e) => ((t[e] = "$_computePosition"), t), {}),
        },
        created() {
          this.autoMinSize &&
            console.warn(
              '[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'
            ),
            this.autoMaxSize &&
              console.warn(
                "[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead."
              );
        },
        mounted() {
          this.init(), this.$_detachPopperNode();
        },
        activated() {
          this.$_autoShowHide();
        },
        deactivated() {
          this.hide();
        },
        beforeUnmount() {
          this.dispose();
        },
        methods: {
          show({ event: t = null, skipDelay: e = !1, force: n = !1 } = {}) {
            var r, o;
            ((r = this.parentPopper) != null &&
              r.lockedChild &&
              this.parentPopper.lockedChild !== this) ||
              ((this.pendingHide = !1),
              (n || !this.disabled) &&
                (((o = this.parentPopper) == null ? void 0 : o.lockedChild) ===
                  this && (this.parentPopper.lockedChild = null),
                this.$_scheduleShow(t, e),
                this.$emit("show"),
                (this.$_showFrameLocked = !0),
                requestAnimationFrame(() => {
                  this.$_showFrameLocked = !1;
                })),
              this.$emit("update:shown", !0));
          },
          hide({ event: t = null, skipDelay: e = !1 } = {}) {
            var n;
            if (!this.$_hideInProgress) {
              if (this.shownChildren.size > 0) {
                this.pendingHide = !0;
                return;
              }
              if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
                this.parentPopper &&
                  ((this.parentPopper.lockedChild = this),
                  clearTimeout(this.parentPopper.lockedChildTimer),
                  (this.parentPopper.lockedChildTimer = setTimeout(() => {
                    this.parentPopper.lockedChild === this &&
                      (this.parentPopper.lockedChild.hide({ skipDelay: e }),
                      (this.parentPopper.lockedChild = null));
                  }, 1e3)));
                return;
              }
              ((n = this.parentPopper) == null ? void 0 : n.lockedChild) ===
                this && (this.parentPopper.lockedChild = null),
                (this.pendingHide = !1),
                this.$_scheduleHide(t, e),
                this.$emit("hide"),
                this.$emit("update:shown", !1);
            }
          },
          init() {
            var t;
            this.isDisposed &&
              ((this.isDisposed = !1),
              (this.isMounted = !1),
              (this.$_events = []),
              (this.$_preventShow = !1),
              (this.$_referenceNode =
                ((t = this.referenceNode) == null ? void 0 : t.call(this)) ??
                this.$el),
              (this.$_targetNodes = this.targetNodes().filter(
                (e) => e.nodeType === e.ELEMENT_NODE
              )),
              (this.$_popperNode = this.popperNode()),
              (this.$_innerNode =
                this.$_popperNode.querySelector(".v-popper__inner")),
              (this.$_arrowNode = this.$_popperNode.querySelector(
                ".v-popper__arrow-container"
              )),
              this.$_swapTargetAttrs("title", "data-original-title"),
              this.$_detachPopperNode(),
              this.triggers.length && this.$_addEventListeners(),
              this.shown && this.show());
          },
          dispose() {
            this.isDisposed ||
              ((this.isDisposed = !0),
              this.$_removeEventListeners(),
              this.hide({ skipDelay: !0 }),
              this.$_detachPopperNode(),
              (this.isMounted = !1),
              (this.isShown = !1),
              this.$_updateParentShownChildren(!1),
              this.$_swapTargetAttrs("data-original-title", "title"));
          },
          async onResize() {
            this.isShown &&
              (await this.$_computePosition(), this.$emit("resize"));
          },
          async $_computePosition() {
            if (this.isDisposed || this.positioningDisabled) return;
            const t = { strategy: this.strategy, middleware: [] };
            (this.distance || this.skidding) &&
              t.middleware.push(
                Zx({ mainAxis: this.distance, crossAxis: this.skidding })
              );
            const e = this.placement.startsWith("auto");
            if (
              (e
                ? t.middleware.push(
                    Jx({ alignment: this.placement.split("-")[1] ?? "" })
                  )
                : (t.placement = this.placement),
              this.preventOverflow &&
                (this.shift &&
                  t.middleware.push(
                    Qx({
                      padding: this.overflowPadding,
                      boundary: this.boundary,
                      crossAxis: this.shiftCrossAxis,
                    })
                  ),
                !e &&
                  this.flip &&
                  t.middleware.push(
                    Yx({
                      padding: this.overflowPadding,
                      boundary: this.boundary,
                    })
                  )),
              t.middleware.push(
                Kx({ element: this.$_arrowNode, padding: this.arrowPadding })
              ),
              this.arrowOverflow &&
                t.middleware.push({
                  name: "arrowOverflow",
                  fn: ({ placement: r, rects: o, middlewareData: i }) => {
                    let s;
                    const { centerOffset: a } = i.arrow;
                    return (
                      r.startsWith("top") || r.startsWith("bottom")
                        ? (s = Math.abs(a) > o.reference.width / 2)
                        : (s = Math.abs(a) > o.reference.height / 2),
                      { data: { overflow: s } }
                    );
                  },
                }),
              this.autoMinSize || this.autoSize)
            ) {
              const r = this.autoSize
                ? this.autoSize
                : this.autoMinSize
                ? "min"
                : null;
              t.middleware.push({
                name: "autoSize",
                fn: ({ rects: o, placement: i, middlewareData: s }) => {
                  var a;
                  if ((a = s.autoSize) != null && a.skip) return {};
                  let l, c;
                  return (
                    i.startsWith("top") || i.startsWith("bottom")
                      ? (l = o.reference.width)
                      : (c = o.reference.height),
                    (this.$_innerNode.style[
                      r === "min"
                        ? "minWidth"
                        : r === "max"
                        ? "maxWidth"
                        : "width"
                    ] = l != null ? `${l}px` : null),
                    (this.$_innerNode.style[
                      r === "min"
                        ? "minHeight"
                        : r === "max"
                        ? "maxHeight"
                        : "height"
                    ] = c != null ? `${c}px` : null),
                    { data: { skip: !0 }, reset: { rects: !0 } }
                  );
                },
              });
            }
            (this.autoMaxSize || this.autoBoundaryMaxSize) &&
              ((this.$_innerNode.style.maxWidth = null),
              (this.$_innerNode.style.maxHeight = null),
              t.middleware.push(
                e4({
                  boundary: this.boundary,
                  padding: this.overflowPadding,
                  apply: ({ availableWidth: r, availableHeight: o }) => {
                    (this.$_innerNode.style.maxWidth =
                      r != null ? `${r}px` : null),
                      (this.$_innerNode.style.maxHeight =
                        o != null ? `${o}px` : null);
                  },
                })
              ));
            const n = await o4(this.$_referenceNode, this.$_popperNode, t);
            Object.assign(this.result, {
              x: n.x,
              y: n.y,
              placement: n.placement,
              strategy: n.strategy,
              arrow: {
                ...n.middlewareData.arrow,
                ...n.middlewareData.arrowOverflow,
              },
            });
          },
          $_scheduleShow(t, e = !1) {
            if (
              (this.$_updateParentShownChildren(!0),
              (this.$_hideInProgress = !1),
              clearTimeout(this.$_scheduleTimer),
              Co &&
                this.instantMove &&
                Co.instantMove &&
                Co !== this.parentPopper)
            ) {
              Co.$_applyHide(!0), this.$_applyShow(!0);
              return;
            }
            e
              ? this.$_applyShow()
              : (this.$_scheduleTimer = setTimeout(
                  this.$_applyShow.bind(this),
                  this.$_computeDelay("show")
                ));
          },
          $_scheduleHide(t, e = !1) {
            if (this.shownChildren.size > 0) {
              this.pendingHide = !0;
              return;
            }
            this.$_updateParentShownChildren(!1),
              (this.$_hideInProgress = !0),
              clearTimeout(this.$_scheduleTimer),
              this.isShown && (Co = this),
              e
                ? this.$_applyHide()
                : (this.$_scheduleTimer = setTimeout(
                    this.$_applyHide.bind(this),
                    this.$_computeDelay("hide")
                  ));
          },
          $_computeDelay(t) {
            const e = this.delay;
            return parseInt((e && e[t]) || e || 0);
          },
          async $_applyShow(t = !1) {
            clearTimeout(this.$_disposeTimer),
              clearTimeout(this.$_scheduleTimer),
              (this.skipTransition = t),
              !this.isShown &&
                (this.$_ensureTeleport(),
                await Nd(),
                await this.$_computePosition(),
                await this.$_applyShowEffect(),
                this.positioningDisabled ||
                  this.$_registerEventListeners(
                    [...tl(this.$_referenceNode), ...tl(this.$_popperNode)],
                    "scroll",
                    () => {
                      this.$_computePosition();
                    }
                  ));
          },
          async $_applyShowEffect() {
            if (this.$_hideInProgress) return;
            if (this.computeTransformOrigin) {
              const e = this.$_referenceNode.getBoundingClientRect(),
                n = this.$_popperNode.querySelector(".v-popper__wrapper"),
                r = n.parentNode.getBoundingClientRect(),
                o = e.x + e.width / 2 - (r.left + n.offsetLeft),
                i = e.y + e.height / 2 - (r.top + n.offsetTop);
              this.result.transformOrigin = `${o}px ${i}px`;
            }
            (this.isShown = !0),
              this.$_applyAttrsToTarget({
                "aria-describedby": this.popperId,
                "data-popper-shown": "",
              });
            const t = this.showGroup;
            if (t) {
              let e;
              for (let n = 0; n < wn.length; n++)
                (e = wn[n]),
                  e.showGroup !== t && (e.hide(), e.$emit("close-group"));
            }
            wn.push(this), document.body.classList.add("v-popper--some-open");
            for (const e of pm(this.theme))
              km(e).push(this),
                document.body.classList.add(`v-popper--some-open--${e}`);
            this.$emit("apply-show"),
              (this.classes.showFrom = !0),
              (this.classes.showTo = !1),
              (this.classes.hideFrom = !1),
              (this.classes.hideTo = !1),
              await Nd(),
              (this.classes.showFrom = !1),
              (this.classes.showTo = !0),
              this.noAutoFocus || this.$_popperNode.focus();
          },
          async $_applyHide(t = !1) {
            if (this.shownChildren.size > 0) {
              (this.pendingHide = !0), (this.$_hideInProgress = !1);
              return;
            }
            if ((clearTimeout(this.$_scheduleTimer), !this.isShown)) return;
            (this.skipTransition = t),
              ym(wn, this),
              wn.length === 0 &&
                document.body.classList.remove("v-popper--some-open");
            for (const n of pm(this.theme)) {
              const r = km(n);
              ym(r, this),
                r.length === 0 &&
                  document.body.classList.remove(`v-popper--some-open--${n}`);
            }
            Co === this && (Co = null),
              (this.isShown = !1),
              this.$_applyAttrsToTarget({
                "aria-describedby": void 0,
                "data-popper-shown": void 0,
              }),
              clearTimeout(this.$_disposeTimer);
            const e = this.disposeTimeout;
            e !== null &&
              (this.$_disposeTimer = setTimeout(() => {
                this.$_popperNode &&
                  (this.$_detachPopperNode(), (this.isMounted = !1));
              }, e)),
              this.$_removeEventListeners("scroll"),
              this.$emit("apply-hide"),
              (this.classes.showFrom = !1),
              (this.classes.showTo = !1),
              (this.classes.hideFrom = !0),
              (this.classes.hideTo = !1),
              await Nd(),
              (this.classes.hideFrom = !1),
              (this.classes.hideTo = !0);
          },
          $_autoShowHide() {
            this.shown ? this.show() : this.hide();
          },
          $_ensureTeleport() {
            if (this.isDisposed) return;
            let t = this.container;
            if (
              (typeof t == "string"
                ? (t = window.document.querySelector(t))
                : t === !1 && (t = this.$_targetNodes[0].parentNode),
              !t)
            )
              throw new Error("No container for popover: " + this.container);
            t.appendChild(this.$_popperNode), (this.isMounted = !0);
          },
          $_addEventListeners() {
            const t = (n) => {
              (this.isShown && !this.$_hideInProgress) ||
                ((n.usedByTooltip = !0),
                !this.$_preventShow && this.show({ event: n }));
            };
            this.$_registerTriggerListeners(
              this.$_targetNodes,
              gm,
              this.triggers,
              this.showTriggers,
              t
            ),
              this.$_registerTriggerListeners(
                [this.$_popperNode],
                gm,
                this.popperTriggers,
                this.popperShowTriggers,
                t
              );
            const e = (n) => {
              n.usedByTooltip || this.hide({ event: n });
            };
            this.$_registerTriggerListeners(
              this.$_targetNodes,
              bm,
              this.triggers,
              this.hideTriggers,
              e
            ),
              this.$_registerTriggerListeners(
                [this.$_popperNode],
                bm,
                this.popperTriggers,
                this.popperHideTriggers,
                e
              );
          },
          $_registerEventListeners(t, e, n) {
            this.$_events.push({ targetNodes: t, eventType: e, handler: n }),
              t.forEach((r) =>
                r.addEventListener(e, n, ss ? { passive: !0 } : void 0)
              );
          },
          $_registerTriggerListeners(t, e, n, r, o) {
            let i = n;
            r != null && (i = typeof r == "function" ? r(i) : r),
              i.forEach((s) => {
                const a = e[s];
                a && this.$_registerEventListeners(t, a, o);
              });
          },
          $_removeEventListeners(t) {
            const e = [];
            this.$_events.forEach((n) => {
              const { targetNodes: r, eventType: o, handler: i } = n;
              !t || t === o
                ? r.forEach((s) => s.removeEventListener(o, i))
                : e.push(n);
            }),
              (this.$_events = e);
          },
          $_refreshListeners() {
            this.isDisposed ||
              (this.$_removeEventListeners(), this.$_addEventListeners());
          },
          $_handleGlobalClose(t, e = !1) {
            this.$_showFrameLocked ||
              (this.hide({ event: t }),
              t.closePopover
                ? this.$emit("close-directive")
                : this.$emit("auto-hide"),
              e &&
                ((this.$_preventShow = !0),
                setTimeout(() => {
                  this.$_preventShow = !1;
                }, 300)));
          },
          $_detachPopperNode() {
            this.$_popperNode.parentNode &&
              this.$_popperNode.parentNode.removeChild(this.$_popperNode);
          },
          $_swapTargetAttrs(t, e) {
            for (const n of this.$_targetNodes) {
              const r = n.getAttribute(t);
              r && (n.removeAttribute(t), n.setAttribute(e, r));
            }
          },
          $_applyAttrsToTarget(t) {
            for (const e of this.$_targetNodes)
              for (const n in t) {
                const r = t[n];
                r == null ? e.removeAttribute(n) : e.setAttribute(n, r);
              }
          },
          $_updateParentShownChildren(t) {
            let e = this.parentPopper;
            for (; e; )
              t
                ? e.shownChildren.add(this.randomId)
                : (e.shownChildren.delete(this.randomId),
                  e.pendingHide && e.hide()),
                (e = e.parentPopper);
          },
          $_isAimingPopper() {
            const t = this.$_referenceNode.getBoundingClientRect();
            if (
              as >= t.left &&
              as <= t.right &&
              ls >= t.top &&
              ls <= t.bottom
            ) {
              const e = this.$_popperNode.getBoundingClientRect(),
                n = as - Nr,
                r = ls - Or,
                o =
                  e.left +
                  e.width / 2 -
                  Nr +
                  (e.top + e.height / 2) -
                  Or +
                  e.width +
                  e.height,
                i = Nr + n * o,
                s = Or + r * o;
              return (
                nl(Nr, Or, i, s, e.left, e.top, e.left, e.bottom) ||
                nl(Nr, Or, i, s, e.left, e.top, e.right, e.top) ||
                nl(Nr, Or, i, s, e.right, e.top, e.right, e.bottom) ||
                nl(Nr, Or, i, s, e.left, e.bottom, e.right, e.bottom)
              );
            }
            return !1;
          },
        },
        render() {
          return this.$slots.default(this.slotData);
        },
      });
  if (typeof document < "u" && typeof window < "u") {
    if (hm) {
      const t = ss ? { passive: !0, capture: !0 } : !0;
      document.addEventListener("touchstart", (e) => xm(e), t),
        document.addEventListener("touchend", (e) => Cm(e, !0), t);
    } else
      window.addEventListener("mousedown", (t) => xm(t), !0),
        window.addEventListener("click", (t) => Cm(t, !1), !0);
    window.addEventListener("resize", l4);
  }
  function xm(t, e) {
    for (let n = 0; n < wn.length; n++) {
      const r = wn[n];
      try {
        r.mouseDownContains = r.popperNode().contains(t.target);
      } catch {}
    }
  }
  function Cm(t, e) {
    s4(t, e);
  }
  function s4(t, e) {
    const n = {};
    for (let r = wn.length - 1; r >= 0; r--) {
      const o = wn[r];
      try {
        const i = (o.containsGlobalTarget =
          o.mouseDownContains || o.popperNode().contains(t.target));
        (o.pendingHide = !1),
          requestAnimationFrame(() => {
            if (((o.pendingHide = !1), !n[o.randomId] && vm(o, i, t))) {
              if (
                (o.$_handleGlobalClose(t, e),
                !t.closeAllPopover && t.closePopover && i)
              ) {
                let a = o.parentPopper;
                for (; a; ) (n[a.randomId] = !0), (a = a.parentPopper);
                return;
              }
              let s = o.parentPopper;
              for (; s && vm(s, s.containsGlobalTarget, t); )
                s.$_handleGlobalClose(t, e), (s = s.parentPopper);
            }
          });
      } catch {}
    }
  }
  function vm(t, e, n) {
    return n.closeAllPopover || (n.closePopover && e) || (a4(t, n) && !e);
  }
  function a4(t, e) {
    if (typeof t.autoHide == "function") {
      const n = t.autoHide(e);
      return (t.lastAutoHide = n), n;
    }
    return t.autoHide;
  }
  function l4() {
    for (let t = 0; t < wn.length; t++) wn[t].$_computePosition();
  }
  let Nr = 0,
    Or = 0,
    as = 0,
    ls = 0;
  typeof window < "u" &&
    window.addEventListener(
      "mousemove",
      (t) => {
        (Nr = as), (Or = ls), (as = t.clientX), (ls = t.clientY);
      },
      ss ? { passive: !0 } : void 0
    );
  function nl(t, e, n, r, o, i, s, a) {
    const l =
        ((s - o) * (e - i) - (a - i) * (t - o)) /
        ((a - i) * (n - t) - (s - o) * (r - e)),
      c =
        ((n - t) * (e - i) - (r - e) * (t - o)) /
        ((a - i) * (n - t) - (s - o) * (r - e));
    return l >= 0 && l <= 1 && c >= 0 && c <= 1;
  }
  const c4 = { extends: wm() },
    rl = (t, e) => {
      const n = t.__vccOpts || t;
      for (const [r, o] of e) n[r] = o;
      return n;
    };
  function u4(t, e, n, r, o, i) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        {
          ref: "reference",
          class: u.normalizeClass([
            "v-popper",
            { "v-popper--shown": t.slotData.isShown },
          ]),
        },
        [
          u.renderSlot(
            t.$slots,
            "default",
            u.normalizeProps(u.guardReactiveProps(t.slotData))
          ),
        ],
        2
      )
    );
  }
  const d4 = rl(c4, [["render", u4]]);
  function f4() {
    var t = window.navigator.userAgent,
      e = t.indexOf("MSIE ");
    if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
    var n = t.indexOf("Trident/");
    if (n > 0) {
      var r = t.indexOf("rv:");
      return parseInt(t.substring(r + 3, t.indexOf(".", r)), 10);
    }
    var o = t.indexOf("Edge/");
    return o > 0 ? parseInt(t.substring(o + 5, t.indexOf(".", o)), 10) : -1;
  }
  let ol;
  function Dd() {
    Dd.init || ((Dd.init = !0), (ol = f4() !== -1));
  }
  var il = {
    name: "ResizeObserver",
    props: {
      emitOnMount: { type: Boolean, default: !1 },
      ignoreWidth: { type: Boolean, default: !1 },
      ignoreHeight: { type: Boolean, default: !1 },
    },
    emits: ["notify"],
    mounted() {
      Dd(),
        u.nextTick(() => {
          (this._w = this.$el.offsetWidth),
            (this._h = this.$el.offsetHeight),
            this.emitOnMount && this.emitSize();
        });
      const t = document.createElement("object");
      (this._resizeObject = t),
        t.setAttribute("aria-hidden", "true"),
        t.setAttribute("tabindex", -1),
        (t.onload = this.addResizeHandlers),
        (t.type = "text/html"),
        ol && this.$el.appendChild(t),
        (t.data = "about:blank"),
        ol || this.$el.appendChild(t);
    },
    beforeUnmount() {
      this.removeResizeHandlers();
    },
    methods: {
      compareAndNotify() {
        ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) ||
          (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) &&
          ((this._w = this.$el.offsetWidth),
          (this._h = this.$el.offsetHeight),
          this.emitSize());
      },
      emitSize() {
        this.$emit("notify", { width: this._w, height: this._h });
      },
      addResizeHandlers() {
        this._resizeObject.contentDocument.defaultView.addEventListener(
          "resize",
          this.compareAndNotify
        ),
          this.compareAndNotify();
      },
      removeResizeHandlers() {
        this._resizeObject &&
          this._resizeObject.onload &&
          (!ol &&
            this._resizeObject.contentDocument &&
            this._resizeObject.contentDocument.defaultView.removeEventListener(
              "resize",
              this.compareAndNotify
            ),
          this.$el.removeChild(this._resizeObject),
          (this._resizeObject.onload = null),
          (this._resizeObject = null));
      },
    },
  };
  const p4 = u.withScopeId("data-v-b329ee4c");
  u.pushScopeId("data-v-b329ee4c");
  const h4 = { class: "resize-observer", tabindex: "-1" };
  u.popScopeId();
  const m4 = p4(
    (t, e, n, r, o, i) => (u.openBlock(), u.createBlock("div", h4))
  );
  (il.render = m4),
    (il.__scopeId = "data-v-b329ee4c"),
    (il.__file = "src/components/ResizeObserver.vue");
  const Em = (t = "theme") => ({
      computed: {
        themeClass() {
          return i4(this[t]);
        },
      },
    }),
    g4 = u.defineComponent({
      name: "VPopperContent",
      components: { ResizeObserver: il },
      mixins: [Em()],
      props: {
        popperId: String,
        theme: String,
        shown: Boolean,
        mounted: Boolean,
        skipTransition: Boolean,
        autoHide: Boolean,
        handleResize: Boolean,
        classes: Object,
        result: Object,
      },
      emits: ["hide", "resize"],
      methods: {
        toPx(t) {
          return t != null && !isNaN(t) ? `${t}px` : null;
        },
      },
    }),
    b4 = ["id", "aria-hidden", "tabindex", "data-popper-placement"],
    y4 = { ref: "inner", class: "v-popper__inner" },
    _4 = u.createElementVNode(
      "div",
      { class: "v-popper__arrow-outer" },
      null,
      -1
    ),
    k4 = u.createElementVNode(
      "div",
      { class: "v-popper__arrow-inner" },
      null,
      -1
    ),
    w4 = [_4, k4];
  function x4(t, e, n, r, o, i) {
    const s = u.resolveComponent("ResizeObserver");
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        {
          id: t.popperId,
          ref: "popover",
          class: u.normalizeClass([
            "v-popper__popper",
            [
              t.themeClass,
              t.classes.popperClass,
              {
                "v-popper__popper--shown": t.shown,
                "v-popper__popper--hidden": !t.shown,
                "v-popper__popper--show-from": t.classes.showFrom,
                "v-popper__popper--show-to": t.classes.showTo,
                "v-popper__popper--hide-from": t.classes.hideFrom,
                "v-popper__popper--hide-to": t.classes.hideTo,
                "v-popper__popper--skip-transition": t.skipTransition,
                "v-popper__popper--arrow-overflow":
                  t.result && t.result.arrow.overflow,
                "v-popper__popper--no-positioning": !t.result,
              },
            ],
          ]),
          style: u.normalizeStyle(
            t.result
              ? {
                  position: t.result.strategy,
                  transform: `translate3d(${Math.round(
                    t.result.x
                  )}px,${Math.round(t.result.y)}px,0)`,
                }
              : void 0
          ),
          "aria-hidden": t.shown ? "false" : "true",
          tabindex: t.autoHide ? 0 : void 0,
          "data-popper-placement": t.result ? t.result.placement : void 0,
          onKeyup:
            e[2] ||
            (e[2] = u.withKeys((a) => t.autoHide && t.$emit("hide"), ["esc"])),
        },
        [
          u.createElementVNode("div", {
            class: "v-popper__backdrop",
            onClick: e[0] || (e[0] = (a) => t.autoHide && t.$emit("hide")),
          }),
          u.createElementVNode(
            "div",
            {
              class: "v-popper__wrapper",
              style: u.normalizeStyle(
                t.result
                  ? { transformOrigin: t.result.transformOrigin }
                  : void 0
              ),
            },
            [
              u.createElementVNode(
                "div",
                y4,
                [
                  t.mounted
                    ? (u.openBlock(),
                      u.createElementBlock(
                        u.Fragment,
                        { key: 0 },
                        [
                          u.createElementVNode("div", null, [
                            u.renderSlot(t.$slots, "default"),
                          ]),
                          t.handleResize
                            ? (u.openBlock(),
                              u.createBlock(s, {
                                key: 0,
                                onNotify:
                                  e[1] || (e[1] = (a) => t.$emit("resize", a)),
                              }))
                            : u.createCommentVNode("", !0),
                        ],
                        64
                      ))
                    : u.createCommentVNode("", !0),
                ],
                512
              ),
              u.createElementVNode(
                "div",
                {
                  ref: "arrow",
                  class: "v-popper__arrow-container",
                  style: u.normalizeStyle(
                    t.result
                      ? {
                          left: t.toPx(t.result.arrow.x),
                          top: t.toPx(t.result.arrow.y),
                        }
                      : void 0
                  ),
                },
                w4,
                4
              ),
            ],
            4
          ),
        ],
        46,
        b4
      )
    );
  }
  const Am = rl(g4, [["render", x4]]),
    Sm = {
      methods: {
        show(...t) {
          return this.$refs.popper.show(...t);
        },
        hide(...t) {
          return this.$refs.popper.hide(...t);
        },
        dispose(...t) {
          return this.$refs.popper.dispose(...t);
        },
        onResize(...t) {
          return this.$refs.popper.onResize(...t);
        },
      },
    };
  let Ld = function () {};
  typeof window < "u" && (Ld = window.Element);
  const C4 = u.defineComponent({
    name: "VPopperWrapper",
    components: { Popper: d4, PopperContent: Am },
    mixins: [Sm, Em("finalTheme")],
    props: {
      theme: { type: String, default: null },
      referenceNode: { type: Function, default: null },
      shown: { type: Boolean, default: !1 },
      showGroup: { type: String, default: null },
      ariaId: { default: null },
      disabled: { type: Boolean, default: void 0 },
      positioningDisabled: { type: Boolean, default: void 0 },
      placement: { type: String, default: void 0 },
      delay: { type: [String, Number, Object], default: void 0 },
      distance: { type: [Number, String], default: void 0 },
      skidding: { type: [Number, String], default: void 0 },
      triggers: { type: Array, default: void 0 },
      showTriggers: { type: [Array, Function], default: void 0 },
      hideTriggers: { type: [Array, Function], default: void 0 },
      popperTriggers: { type: Array, default: void 0 },
      popperShowTriggers: { type: [Array, Function], default: void 0 },
      popperHideTriggers: { type: [Array, Function], default: void 0 },
      container: { type: [String, Object, Ld, Boolean], default: void 0 },
      boundary: { type: [String, Ld], default: void 0 },
      strategy: { type: String, default: void 0 },
      autoHide: { type: [Boolean, Function], default: void 0 },
      handleResize: { type: Boolean, default: void 0 },
      instantMove: { type: Boolean, default: void 0 },
      eagerMount: { type: Boolean, default: void 0 },
      popperClass: { type: [String, Array, Object], default: void 0 },
      computeTransformOrigin: { type: Boolean, default: void 0 },
      autoMinSize: { type: Boolean, default: void 0 },
      autoSize: { type: [Boolean, String], default: void 0 },
      autoMaxSize: { type: Boolean, default: void 0 },
      autoBoundaryMaxSize: { type: Boolean, default: void 0 },
      preventOverflow: { type: Boolean, default: void 0 },
      overflowPadding: { type: [Number, String], default: void 0 },
      arrowPadding: { type: [Number, String], default: void 0 },
      arrowOverflow: { type: Boolean, default: void 0 },
      flip: { type: Boolean, default: void 0 },
      shift: { type: Boolean, default: void 0 },
      shiftCrossAxis: { type: Boolean, default: void 0 },
      noAutoFocus: { type: Boolean, default: void 0 },
      disposeTimeout: { type: Number, default: void 0 },
    },
    emits: {
      show: () => !0,
      hide: () => !0,
      "update:shown": (t) => !0,
      "apply-show": () => !0,
      "apply-hide": () => !0,
      "close-group": () => !0,
      "close-directive": () => !0,
      "auto-hide": () => !0,
      resize: () => !0,
    },
    computed: {
      finalTheme() {
        return this.theme ?? this.$options.vPopperTheme;
      },
    },
    methods: {
      getTargetNodes() {
        return Array.from(this.$el.children).filter(
          (t) => t !== this.$refs.popperContent.$el
        );
      },
    },
  });
  function v4(t, e, n, r, o, i) {
    const s = u.resolveComponent("PopperContent"),
      a = u.resolveComponent("Popper");
    return (
      u.openBlock(),
      u.createBlock(
        a,
        u.mergeProps({ ref: "popper" }, t.$props, {
          theme: t.finalTheme,
          "target-nodes": t.getTargetNodes,
          "popper-node": () => t.$refs.popperContent.$el,
          class: [t.themeClass],
          onShow: e[0] || (e[0] = () => t.$emit("show")),
          onHide: e[1] || (e[1] = () => t.$emit("hide")),
          "onUpdate:shown": e[2] || (e[2] = (l) => t.$emit("update:shown", l)),
          onApplyShow: e[3] || (e[3] = () => t.$emit("apply-show")),
          onApplyHide: e[4] || (e[4] = () => t.$emit("apply-hide")),
          onCloseGroup: e[5] || (e[5] = () => t.$emit("close-group")),
          onCloseDirective: e[6] || (e[6] = () => t.$emit("close-directive")),
          onAutoHide: e[7] || (e[7] = () => t.$emit("auto-hide")),
          onResize: e[8] || (e[8] = () => t.$emit("resize")),
        }),
        {
          default: u.withCtx(
            ({
              popperId: l,
              isShown: c,
              shouldMountContent: d,
              skipTransition: f,
              autoHide: p,
              show: h,
              hide: m,
              handleResize: g,
              onResize: b,
              classes: y,
              result: x,
            }) => [
              u.renderSlot(t.$slots, "default", { shown: c, show: h, hide: m }),
              u.createVNode(
                s,
                {
                  ref: "popperContent",
                  "popper-id": l,
                  theme: t.finalTheme,
                  shown: c,
                  mounted: d,
                  "skip-transition": f,
                  "auto-hide": p,
                  "handle-resize": g,
                  classes: y,
                  result: x,
                  onHide: m,
                  onResize: b,
                },
                {
                  default: u.withCtx(() => [
                    u.renderSlot(t.$slots, "popper", { shown: c, hide: m }),
                  ]),
                  _: 2,
                },
                1032,
                [
                  "popper-id",
                  "theme",
                  "shown",
                  "mounted",
                  "skip-transition",
                  "auto-hide",
                  "handle-resize",
                  "classes",
                  "result",
                  "onHide",
                  "onResize",
                ]
              ),
            ]
          ),
          _: 3,
        },
        16,
        ["theme", "target-nodes", "popper-node", "class"]
      )
    );
  }
  const Id = rl(C4, [["render", v4]]),
    E4 = { ...Id, name: "VDropdown", vPopperTheme: "dropdown" };
  ({ ...Id });
  const A4 = { ...Id, name: "VTooltip", vPopperTheme: "tooltip" },
    S4 = u.defineComponent({
      name: "VTooltipDirective",
      components: { Popper: wm(), PopperContent: Am },
      mixins: [Sm],
      inheritAttrs: !1,
      props: {
        theme: { type: String, default: "tooltip" },
        html: { type: Boolean, default: (t) => is(t.theme, "html") },
        content: { type: [String, Number, Function], default: null },
        loadingContent: {
          type: String,
          default: (t) => is(t.theme, "loadingContent"),
        },
        targetNodes: { type: Function, required: !0 },
      },
      data() {
        return { asyncContent: null };
      },
      computed: {
        isContentAsync() {
          return typeof this.content == "function";
        },
        loading() {
          return this.isContentAsync && this.asyncContent == null;
        },
        finalContent() {
          return this.isContentAsync
            ? this.loading
              ? this.loadingContent
              : this.asyncContent
            : this.content;
        },
      },
      watch: {
        content: {
          handler() {
            this.fetchContent(!0);
          },
          immediate: !0,
        },
        async finalContent() {
          await this.$nextTick(), this.$refs.popper.onResize();
        },
      },
      created() {
        this.$_fetchId = 0;
      },
      methods: {
        fetchContent(t) {
          if (
            typeof this.content == "function" &&
            this.$_isShown &&
            (t || (!this.$_loading && this.asyncContent == null))
          ) {
            (this.asyncContent = null), (this.$_loading = !0);
            const e = ++this.$_fetchId,
              n = this.content(this);
            n.then ? n.then((r) => this.onResult(e, r)) : this.onResult(e, n);
          }
        },
        onResult(t, e) {
          t === this.$_fetchId &&
            ((this.$_loading = !1), (this.asyncContent = e));
        },
        onShow() {
          (this.$_isShown = !0), this.fetchContent();
        },
        onHide() {
          this.$_isShown = !1;
        },
      },
    }),
    M4 = ["innerHTML"],
    T4 = ["textContent"];
  function N4(t, e, n, r, o, i) {
    const s = u.resolveComponent("PopperContent"),
      a = u.resolveComponent("Popper");
    return (
      u.openBlock(),
      u.createBlock(
        a,
        u.mergeProps({ ref: "popper" }, t.$attrs, {
          theme: t.theme,
          "target-nodes": t.targetNodes,
          "popper-node": () => t.$refs.popperContent.$el,
          onApplyShow: t.onShow,
          onApplyHide: t.onHide,
        }),
        {
          default: u.withCtx(
            ({
              popperId: l,
              isShown: c,
              shouldMountContent: d,
              skipTransition: f,
              autoHide: p,
              hide: h,
              handleResize: m,
              onResize: g,
              classes: b,
              result: y,
            }) => [
              u.createVNode(
                s,
                {
                  ref: "popperContent",
                  class: u.normalizeClass({
                    "v-popper--tooltip-loading": t.loading,
                  }),
                  "popper-id": l,
                  theme: t.theme,
                  shown: c,
                  mounted: d,
                  "skip-transition": f,
                  "auto-hide": p,
                  "handle-resize": m,
                  classes: b,
                  result: y,
                  onHide: h,
                  onResize: g,
                },
                {
                  default: u.withCtx(() => [
                    t.html
                      ? (u.openBlock(),
                        u.createElementBlock(
                          "div",
                          { key: 0, innerHTML: t.finalContent },
                          null,
                          8,
                          M4
                        ))
                      : (u.openBlock(),
                        u.createElementBlock(
                          "div",
                          {
                            key: 1,
                            textContent: u.toDisplayString(t.finalContent),
                          },
                          null,
                          8,
                          T4
                        )),
                  ]),
                  _: 2,
                },
                1032,
                [
                  "class",
                  "popper-id",
                  "theme",
                  "shown",
                  "mounted",
                  "skip-transition",
                  "auto-hide",
                  "handle-resize",
                  "classes",
                  "result",
                  "onHide",
                  "onResize",
                ]
              ),
            ]
          ),
          _: 1,
        },
        16,
        ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]
      )
    );
  }
  const O4 = rl(S4, [["render", N4]]),
    Mm = "v-popper--has-tooltip";
  function R4(t, e) {
    let n = t.placement;
    if (!n && e) for (const r of mm) e[r] && (n = r);
    return n || (n = is(t.theme || "tooltip", "placement")), n;
  }
  function Tm(t, e, n) {
    let r;
    const o = typeof e;
    return (
      o === "string"
        ? (r = { content: e })
        : e && o === "object"
        ? (r = e)
        : (r = { content: !1 }),
      (r.placement = R4(r, n)),
      (r.targetNodes = () => [t]),
      (r.referenceNode = () => t),
      r
    );
  }
  let Bd,
    cs,
    D4 = 0;
  function L4() {
    if (Bd) return;
    (cs = u.ref([])),
      (Bd = u.createApp({
        name: "VTooltipDirectiveApp",
        setup() {
          return { directives: cs };
        },
        render() {
          return this.directives.map((e) =>
            u.h(O4, {
              ...e.options,
              shown: e.shown || e.options.shown,
              key: e.id,
            })
          );
        },
        devtools: { hide: !0 },
      }));
    const t = document.createElement("div");
    document.body.appendChild(t), Bd.mount(t);
  }
  function I4(t, e, n) {
    L4();
    const r = u.ref(Tm(t, e, n)),
      o = u.ref(!1),
      i = { id: D4++, options: r, shown: o };
    return (
      cs.value.push(i),
      t.classList && t.classList.add(Mm),
      (t.$_popper = {
        options: r,
        item: i,
        show() {
          o.value = !0;
        },
        hide() {
          o.value = !1;
        },
      })
    );
  }
  function Nm(t) {
    if (t.$_popper) {
      const e = cs.value.indexOf(t.$_popper.item);
      e !== -1 && cs.value.splice(e, 1),
        delete t.$_popper,
        delete t.$_popperOldShown,
        delete t.$_popperMountTarget;
    }
    t.classList && t.classList.remove(Mm);
  }
  function Om(t, { value: e, modifiers: n }) {
    const r = Tm(t, e, n);
    if (!r.content || is(r.theme || "tooltip", "disabled")) Nm(t);
    else {
      let o;
      t.$_popper
        ? ((o = t.$_popper), (o.options.value = r))
        : (o = I4(t, e, n)),
        typeof e.shown < "u" &&
          e.shown !== t.$_popperOldShown &&
          ((t.$_popperOldShown = e.shown), e.shown ? o.show() : o.hide());
    }
  }
  const us = {
      beforeMount: Om,
      updated: Om,
      beforeUnmount(t) {
        Nm(t);
      },
    },
    vo = E4,
    Rm = A4,
    Eo = u.defineComponent({
      __name: "BlockActionButton",
      props: {
        tooltip: { default: void 0 },
        selected: { type: Boolean, default: !1 },
      },
      setup(t) {
        return (e, n) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "div",
              {
                class: u.normalizeClass([
                  "editor-block__actions-button",
                  { "editor-block__actions-button--selected": e.selected },
                ]),
              },
              [u.renderSlot(e.$slots, "icon")],
              2
            )),
            [[u.unref(us), e.tooltip]]
          );
      },
    }),
    Ao = u.defineComponent({
      __name: "BlockActionInput",
      props: { tooltip: { default: void 0 }, modelValue: { default: "" } },
      emits: ["update:modelValue"],
      setup(t, { emit: e }) {
        const n = t,
          r = e,
          o = u.computed({
            get: () => n.modelValue || "",
            set: (i) => r("update:modelValue", i),
          });
        return (i, s) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": s[0] || (s[0] = (a) => (o.value = a)),
                class: "editor-block__actions-input",
              },
              null,
              512
            )),
            [
              [u.vModelText, o.value, void 0, { lazy: !0, trim: !0 }],
              [u.unref(us), i.tooltip],
            ]
          );
      },
    }),
    Pd = (t, e) => {
      const n = t.__vccOpts || t;
      for (const [r, o] of e) n[r] = o;
      return n;
    },
    B4 = {},
    P4 = { class: "editor-block__actions-separator" };
  function $4(t, e) {
    return u.openBlock(), u.createElementBlock("div", P4);
  }
  const Ve = Pd(B4, [["render", $4]]),
    F4 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function H4(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        F4,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M14.12 10.47L12 12.59l-2.13-2.12l-1.41 1.41L10.59 14l-2.12 2.12l1.41 1.41L12 15.41l2.12 2.12l1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6zM8 9h8v10H8z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const z4 = u.markRaw({ name: "mdi-delete-forever-outline", render: H4 }),
    So = u.defineComponent({
      __name: "MdiDeleteForeverOutline",
      setup(t) {
        return (e, n) => (
          u.openBlock(), u.createBlock(u.unref(z4), { class: "text-red-600" })
        );
      },
    });
  /*!
   * shared v9.14.2
   * (c) 2024 kazuya kawaguchi
   * Released under the MIT License.
   */ const sl = typeof window < "u",
    Rr = (t, e = !1) => (e ? Symbol.for(t) : Symbol(t)),
    V4 = (t, e, n) => U4({ l: t, k: e, s: n }),
    U4 = (t) =>
      JSON.stringify(t)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029")
        .replace(/\u0027/g, "\\u0027"),
    Ye = (t) => typeof t == "number" && isFinite(t),
    j4 = (t) => Bm(t) === "[object Date]",
    al = (t) => Bm(t) === "[object RegExp]",
    ll = (t) => he(t) && Object.keys(t).length === 0,
    ht = Object.assign,
    W4 = Object.create,
    Me = (t = null) => W4(t);
  let Dm;
  const $d = () =>
    Dm ||
    (Dm =
      typeof globalThis < "u"
        ? globalThis
        : typeof self < "u"
        ? self
        : typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : Me());
  function Lm(t) {
    return t
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }
  const q4 = Object.prototype.hasOwnProperty;
  function xn(t, e) {
    return q4.call(t, e);
  }
  const Xe = Array.isArray,
    Ue = (t) => typeof t == "function",
    q = (t) => typeof t == "string",
    Fe = (t) => typeof t == "boolean",
    be = (t) => t !== null && typeof t == "object",
    K4 = (t) => be(t) && Ue(t.then) && Ue(t.catch),
    Im = Object.prototype.toString,
    Bm = (t) => Im.call(t),
    he = (t) => {
      if (!be(t)) return !1;
      const e = Object.getPrototypeOf(t);
      return e === null || e.constructor === Object;
    },
    G4 = (t) =>
      t == null
        ? ""
        : Xe(t) || (he(t) && t.toString === Im)
        ? JSON.stringify(t, null, 2)
        : String(t);
  function J4(t, e = "") {
    return t.reduce((n, r, o) => (o === 0 ? n + r : n + e + r), "");
  }
  function cl(t) {
    let e = t;
    return () => ++e;
  }
  function Y4(t, e) {
    typeof console < "u" &&
      (console.warn("[intlify] " + t), e && console.warn(e.stack));
  }
  const ul = (t) => !be(t) || Xe(t);
  function dl(t, e) {
    if (ul(t) || ul(e)) throw new Error("Invalid value");
    const n = [{ src: t, des: e }];
    for (; n.length; ) {
      const { src: r, des: o } = n.pop();
      Object.keys(r).forEach((i) => {
        i !== "__proto__" &&
          (be(r[i]) && !be(o[i]) && (o[i] = Array.isArray(r[i]) ? [] : Me()),
          ul(o[i]) || ul(r[i])
            ? (o[i] = r[i])
            : n.push({ src: r[i], des: o[i] }));
      });
    }
  }
  /*!
   * message-compiler v9.14.2
   * (c) 2024 kazuya kawaguchi
   * Released under the MIT License.
   */ function X4(t, e, n) {
    return { line: t, column: e, offset: n };
  }
  function fl(t, e, n) {
    return { start: t, end: e };
  }
  const Z4 = /\{([0-9a-zA-Z]+)\}/g;
  function Pm(t, ...e) {
    return (
      e.length === 1 && Q4(e[0]) && (e = e[0]),
      (!e || !e.hasOwnProperty) && (e = {}),
      t.replace(Z4, (n, r) => (e.hasOwnProperty(r) ? e[r] : ""))
    );
  }
  const $m = Object.assign,
    Fm = (t) => typeof t == "string",
    Q4 = (t) => t !== null && typeof t == "object";
  function Hm(t, e = "") {
    return t.reduce((n, r, o) => (o === 0 ? n + r : n + e + r), "");
  }
  const Fd = { USE_MODULO_SYNTAX: 1, __EXTEND_POINT__: 2 },
    eC = { [Fd.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'." };
  function tC(t, e, ...n) {
    const r = Pm(eC[t], ...(n || [])),
      o = { message: String(r), code: t };
    return e && (o.location = e), o;
  }
  const ee = {
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14,
      UNHANDLED_CODEGEN_NODE_TYPE: 15,
      UNHANDLED_MINIFIER_NODE_TYPE: 16,
      __EXTEND_POINT__: 17,
    },
    nC = {
      [ee.EXPECTED_TOKEN]: "Expected token: '{0}'",
      [ee.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
      [ee.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]:
        "Unterminated single quote in placeholder",
      [ee.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
      [ee.INVALID_UNICODE_ESCAPE_SEQUENCE]:
        "Invalid unicode escape sequence: {0}",
      [ee.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
      [ee.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
      [ee.EMPTY_PLACEHOLDER]: "Empty placeholder",
      [ee.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
      [ee.INVALID_LINKED_FORMAT]: "Invalid linked format",
      [ee.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
      [ee.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
      [ee.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
      [ee.UNEXPECTED_LEXICAL_ANALYSIS]:
        "Unexpected lexical analysis in token: '{0}'",
      [ee.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
      [ee.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'",
    };
  function ii(t, e, n = {}) {
    const { domain: r, messages: o, args: i } = n,
      s = Pm((o || nC)[t] || "", ...(i || [])),
      a = new SyntaxError(String(s));
    return (a.code = t), e && (a.location = e), (a.domain = r), a;
  }
  function rC(t) {
    throw t;
  }
  const ir = " ",
    oC = "\r",
    _t = `
`,
    iC = "\u2028",
    sC = "\u2029";
  function aC(t) {
    const e = t;
    let n = 0,
      r = 1,
      o = 1,
      i = 0;
    const s = (S) => e[S] === oC && e[S + 1] === _t,
      a = (S) => e[S] === _t,
      l = (S) => e[S] === sC,
      c = (S) => e[S] === iC,
      d = (S) => s(S) || a(S) || l(S) || c(S),
      f = () => n,
      p = () => r,
      h = () => o,
      m = () => i,
      g = (S) => (s(S) || l(S) || c(S) ? _t : e[S]),
      b = () => g(n),
      y = () => g(n + i);
    function x() {
      return (i = 0), d(n) && (r++, (o = 0)), s(n) && n++, n++, o++, e[n];
    }
    function w() {
      return s(n + i) && i++, i++, e[n + i];
    }
    function _() {
      (n = 0), (r = 1), (o = 1), (i = 0);
    }
    function v(S = 0) {
      i = S;
    }
    function C() {
      const S = n + i;
      for (; S !== n; ) x();
      i = 0;
    }
    return {
      index: f,
      line: p,
      column: h,
      peekOffset: m,
      charAt: g,
      currentChar: b,
      currentPeek: y,
      next: x,
      peek: w,
      reset: _,
      resetPeek: v,
      skipToPeek: C,
    };
  }
  const Dr = void 0,
    lC = ".",
    zm = "'",
    cC = "tokenizer";
  function uC(t, e = {}) {
    const n = e.location !== !1,
      r = aC(t),
      o = () => r.index(),
      i = () => X4(r.line(), r.column(), r.index()),
      s = i(),
      a = o(),
      l = {
        currentType: 14,
        offset: a,
        startLoc: s,
        endLoc: s,
        lastType: 14,
        lastOffset: a,
        lastStartLoc: s,
        lastEndLoc: s,
        braceNest: 0,
        inLinked: !1,
        text: "",
      },
      c = () => l,
      { onError: d } = e;
    function f(E, A, I, ...W) {
      const ve = c();
      if (((A.column += I), (A.offset += I), d)) {
        const te = n ? fl(ve.startLoc, A) : null,
          O = ii(E, te, { domain: cC, args: W });
        d(O);
      }
    }
    function p(E, A, I) {
      (E.endLoc = i()), (E.currentType = A);
      const W = { type: A };
      return (
        n && (W.loc = fl(E.startLoc, E.endLoc)), I != null && (W.value = I), W
      );
    }
    const h = (E) => p(E, 14);
    function m(E, A) {
      return E.currentChar() === A
        ? (E.next(), A)
        : (f(ee.EXPECTED_TOKEN, i(), 0, A), "");
    }
    function g(E) {
      let A = "";
      for (; E.currentPeek() === ir || E.currentPeek() === _t; )
        (A += E.currentPeek()), E.peek();
      return A;
    }
    function b(E) {
      const A = g(E);
      return E.skipToPeek(), A;
    }
    function y(E) {
      if (E === Dr) return !1;
      const A = E.charCodeAt(0);
      return (A >= 97 && A <= 122) || (A >= 65 && A <= 90) || A === 95;
    }
    function x(E) {
      if (E === Dr) return !1;
      const A = E.charCodeAt(0);
      return A >= 48 && A <= 57;
    }
    function w(E, A) {
      const { currentType: I } = A;
      if (I !== 2) return !1;
      g(E);
      const W = y(E.currentPeek());
      return E.resetPeek(), W;
    }
    function _(E, A) {
      const { currentType: I } = A;
      if (I !== 2) return !1;
      g(E);
      const W = E.currentPeek() === "-" ? E.peek() : E.currentPeek(),
        ve = x(W);
      return E.resetPeek(), ve;
    }
    function v(E, A) {
      const { currentType: I } = A;
      if (I !== 2) return !1;
      g(E);
      const W = E.currentPeek() === zm;
      return E.resetPeek(), W;
    }
    function C(E, A) {
      const { currentType: I } = A;
      if (I !== 8) return !1;
      g(E);
      const W = E.currentPeek() === ".";
      return E.resetPeek(), W;
    }
    function S(E, A) {
      const { currentType: I } = A;
      if (I !== 9) return !1;
      g(E);
      const W = y(E.currentPeek());
      return E.resetPeek(), W;
    }
    function N(E, A) {
      const { currentType: I } = A;
      if (!(I === 8 || I === 12)) return !1;
      g(E);
      const W = E.currentPeek() === ":";
      return E.resetPeek(), W;
    }
    function M(E, A) {
      const { currentType: I } = A;
      if (I !== 10) return !1;
      const W = () => {
          const te = E.currentPeek();
          return te === "{"
            ? y(E.peek())
            : te === "@" ||
              te === "%" ||
              te === "|" ||
              te === ":" ||
              te === "." ||
              te === ir ||
              !te
            ? !1
            : te === _t
            ? (E.peek(), W())
            : B(E, !1);
        },
        ve = W();
      return E.resetPeek(), ve;
    }
    function L(E) {
      g(E);
      const A = E.currentPeek() === "|";
      return E.resetPeek(), A;
    }
    function $(E) {
      const A = g(E),
        I = E.currentPeek() === "%" && E.peek() === "{";
      return E.resetPeek(), { isModulo: I, hasSpace: A.length > 0 };
    }
    function B(E, A = !0) {
      const I = (ve = !1, te = "", O = !1) => {
          const P = E.currentPeek();
          return P === "{"
            ? te === "%"
              ? !1
              : ve
            : P === "@" || !P
            ? te === "%"
              ? !0
              : ve
            : P === "%"
            ? (E.peek(), I(ve, "%", !0))
            : P === "|"
            ? te === "%" || O
              ? !0
              : !(te === ir || te === _t)
            : P === ir
            ? (E.peek(), I(!0, ir, O))
            : P === _t
            ? (E.peek(), I(!0, _t, O))
            : !0;
        },
        W = I();
      return A && E.resetPeek(), W;
    }
    function H(E, A) {
      const I = E.currentChar();
      return I === Dr ? Dr : A(I) ? (E.next(), I) : null;
    }
    function Q(E) {
      const A = E.charCodeAt(0);
      return (
        (A >= 97 && A <= 122) ||
        (A >= 65 && A <= 90) ||
        (A >= 48 && A <= 57) ||
        A === 95 ||
        A === 36
      );
    }
    function X(E) {
      return H(E, Q);
    }
    function Y(E) {
      const A = E.charCodeAt(0);
      return (
        (A >= 97 && A <= 122) ||
        (A >= 65 && A <= 90) ||
        (A >= 48 && A <= 57) ||
        A === 95 ||
        A === 36 ||
        A === 45
      );
    }
    function Z(E) {
      return H(E, Y);
    }
    function ce(E) {
      const A = E.charCodeAt(0);
      return A >= 48 && A <= 57;
    }
    function Ae(E) {
      return H(E, ce);
    }
    function Ie(E) {
      const A = E.charCodeAt(0);
      return (
        (A >= 48 && A <= 57) || (A >= 65 && A <= 70) || (A >= 97 && A <= 102)
      );
    }
    function xe(E) {
      return H(E, Ie);
    }
    function De(E) {
      let A = "",
        I = "";
      for (; (A = Ae(E)); ) I += A;
      return I;
    }
    function He(E) {
      b(E);
      const A = E.currentChar();
      return A !== "%" && f(ee.EXPECTED_TOKEN, i(), 0, A), E.next(), "%";
    }
    function We(E) {
      let A = "";
      for (;;) {
        const I = E.currentChar();
        if (I === "{" || I === "}" || I === "@" || I === "|" || !I) break;
        if (I === "%")
          if (B(E)) (A += I), E.next();
          else break;
        else if (I === ir || I === _t)
          if (B(E)) (A += I), E.next();
          else {
            if (L(E)) break;
            (A += I), E.next();
          }
        else (A += I), E.next();
      }
      return A;
    }
    function Oe(E) {
      b(E);
      let A = "",
        I = "";
      for (; (A = Z(E)); ) I += A;
      return (
        E.currentChar() === Dr && f(ee.UNTERMINATED_CLOSING_BRACE, i(), 0), I
      );
    }
    function Be(E) {
      b(E);
      let A = "";
      return (
        E.currentChar() === "-" ? (E.next(), (A += `-${De(E)}`)) : (A += De(E)),
        E.currentChar() === Dr && f(ee.UNTERMINATED_CLOSING_BRACE, i(), 0),
        A
      );
    }
    function pt(E) {
      return E !== zm && E !== _t;
    }
    function Je(E) {
      b(E), m(E, "'");
      let A = "",
        I = "";
      for (; (A = H(E, pt)); ) A === "\\" ? (I += yt(E)) : (I += A);
      const W = E.currentChar();
      return W === _t || W === Dr
        ? (f(ee.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0),
          W === _t && (E.next(), m(E, "'")),
          I)
        : (m(E, "'"), I);
    }
    function yt(E) {
      const A = E.currentChar();
      switch (A) {
        case "\\":
        case "'":
          return E.next(), `\\${A}`;
        case "u":
          return tt(E, A, 4);
        case "U":
          return tt(E, A, 6);
        default:
          return f(ee.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, A), "";
      }
    }
    function tt(E, A, I) {
      m(E, A);
      let W = "";
      for (let ve = 0; ve < I; ve++) {
        const te = xe(E);
        if (!te) {
          f(
            ee.INVALID_UNICODE_ESCAPE_SEQUENCE,
            i(),
            0,
            `\\${A}${W}${E.currentChar()}`
          );
          break;
        }
        W += te;
      }
      return `\\${A}${W}`;
    }
    function Gt(E) {
      return E !== "{" && E !== "}" && E !== ir && E !== _t;
    }
    function Rn(E) {
      b(E);
      let A = "",
        I = "";
      for (; (A = H(E, Gt)); ) I += A;
      return I;
    }
    function Er(E) {
      let A = "",
        I = "";
      for (; (A = X(E)); ) I += A;
      return I;
    }
    function go(E) {
      const A = (I) => {
        const W = E.currentChar();
        return W === "{" ||
          W === "%" ||
          W === "@" ||
          W === "|" ||
          W === "(" ||
          W === ")" ||
          !W ||
          W === ir
          ? I
          : ((I += W), E.next(), A(I));
      };
      return A("");
    }
    function nr(E) {
      b(E);
      const A = m(E, "|");
      return b(E), A;
    }
    function bn(E, A) {
      let I = null;
      switch (E.currentChar()) {
        case "{":
          return (
            A.braceNest >= 1 && f(ee.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0),
            E.next(),
            (I = p(A, 2, "{")),
            b(E),
            A.braceNest++,
            I
          );
        case "}":
          return (
            A.braceNest > 0 &&
              A.currentType === 2 &&
              f(ee.EMPTY_PLACEHOLDER, i(), 0),
            E.next(),
            (I = p(A, 3, "}")),
            A.braceNest--,
            A.braceNest > 0 && b(E),
            A.inLinked && A.braceNest === 0 && (A.inLinked = !1),
            I
          );
        case "@":
          return (
            A.braceNest > 0 && f(ee.UNTERMINATED_CLOSING_BRACE, i(), 0),
            (I = yn(E, A) || h(A)),
            (A.braceNest = 0),
            I
          );
        default: {
          let ve = !0,
            te = !0,
            O = !0;
          if (L(E))
            return (
              A.braceNest > 0 && f(ee.UNTERMINATED_CLOSING_BRACE, i(), 0),
              (I = p(A, 1, nr(E))),
              (A.braceNest = 0),
              (A.inLinked = !1),
              I
            );
          if (
            A.braceNest > 0 &&
            (A.currentType === 5 || A.currentType === 6 || A.currentType === 7)
          )
            return (
              f(ee.UNTERMINATED_CLOSING_BRACE, i(), 0),
              (A.braceNest = 0),
              rr(E, A)
            );
          if ((ve = w(E, A))) return (I = p(A, 5, Oe(E))), b(E), I;
          if ((te = _(E, A))) return (I = p(A, 6, Be(E))), b(E), I;
          if ((O = v(E, A))) return (I = p(A, 7, Je(E))), b(E), I;
          if (!ve && !te && !O)
            return (
              (I = p(A, 13, Rn(E))),
              f(ee.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, I.value),
              b(E),
              I
            );
          break;
        }
      }
      return I;
    }
    function yn(E, A) {
      const { currentType: I } = A;
      let W = null;
      const ve = E.currentChar();
      switch (
        ((I === 8 || I === 9 || I === 12 || I === 10) &&
          (ve === _t || ve === ir) &&
          f(ee.INVALID_LINKED_FORMAT, i(), 0),
        ve)
      ) {
        case "@":
          return E.next(), (W = p(A, 8, "@")), (A.inLinked = !0), W;
        case ".":
          return b(E), E.next(), p(A, 9, ".");
        case ":":
          return b(E), E.next(), p(A, 10, ":");
        default:
          return L(E)
            ? ((W = p(A, 1, nr(E))), (A.braceNest = 0), (A.inLinked = !1), W)
            : C(E, A) || N(E, A)
            ? (b(E), yn(E, A))
            : S(E, A)
            ? (b(E), p(A, 12, Er(E)))
            : M(E, A)
            ? (b(E), ve === "{" ? bn(E, A) || W : p(A, 11, go(E)))
            : (I === 8 && f(ee.INVALID_LINKED_FORMAT, i(), 0),
              (A.braceNest = 0),
              (A.inLinked = !1),
              rr(E, A));
      }
    }
    function rr(E, A) {
      let I = { type: 14 };
      if (A.braceNest > 0) return bn(E, A) || h(A);
      if (A.inLinked) return yn(E, A) || h(A);
      switch (E.currentChar()) {
        case "{":
          return bn(E, A) || h(A);
        case "}":
          return f(ee.UNBALANCED_CLOSING_BRACE, i(), 0), E.next(), p(A, 3, "}");
        case "@":
          return yn(E, A) || h(A);
        default: {
          if (L(E))
            return (
              (I = p(A, 1, nr(E))), (A.braceNest = 0), (A.inLinked = !1), I
            );
          const { isModulo: ve, hasSpace: te } = $(E);
          if (ve) return te ? p(A, 0, We(E)) : p(A, 4, He(E));
          if (B(E)) return p(A, 0, We(E));
          break;
        }
      }
      return I;
    }
    function bo() {
      const { currentType: E, offset: A, startLoc: I, endLoc: W } = l;
      return (
        (l.lastType = E),
        (l.lastOffset = A),
        (l.lastStartLoc = I),
        (l.lastEndLoc = W),
        (l.offset = o()),
        (l.startLoc = i()),
        r.currentChar() === Dr ? p(l, 14) : rr(r, l)
      );
    }
    return { nextToken: bo, currentOffset: o, currentPosition: i, context: c };
  }
  const dC = "parser",
    fC = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function pC(t, e, n) {
    switch (t) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const r = parseInt(e || n, 16);
        return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�";
      }
    }
  }
  function hC(t = {}) {
    const e = t.location !== !1,
      { onError: n, onWarn: r } = t;
    function o(w, _, v, C, ...S) {
      const N = w.currentPosition();
      if (((N.offset += C), (N.column += C), n)) {
        const M = e ? fl(v, N) : null,
          L = ii(_, M, { domain: dC, args: S });
        n(L);
      }
    }
    function i(w, _, v, C, ...S) {
      const N = w.currentPosition();
      if (((N.offset += C), (N.column += C), r)) {
        const M = e ? fl(v, N) : null;
        r(tC(_, M, S));
      }
    }
    function s(w, _, v) {
      const C = { type: w };
      return (
        e && ((C.start = _), (C.end = _), (C.loc = { start: v, end: v })), C
      );
    }
    function a(w, _, v, C) {
      e && ((w.end = _), w.loc && (w.loc.end = v));
    }
    function l(w, _) {
      const v = w.context(),
        C = s(3, v.offset, v.startLoc);
      return (C.value = _), a(C, w.currentOffset(), w.currentPosition()), C;
    }
    function c(w, _) {
      const v = w.context(),
        { lastOffset: C, lastStartLoc: S } = v,
        N = s(5, C, S);
      return (
        (N.index = parseInt(_, 10)),
        w.nextToken(),
        a(N, w.currentOffset(), w.currentPosition()),
        N
      );
    }
    function d(w, _, v) {
      const C = w.context(),
        { lastOffset: S, lastStartLoc: N } = C,
        M = s(4, S, N);
      return (
        (M.key = _),
        v === !0 && (M.modulo = !0),
        w.nextToken(),
        a(M, w.currentOffset(), w.currentPosition()),
        M
      );
    }
    function f(w, _) {
      const v = w.context(),
        { lastOffset: C, lastStartLoc: S } = v,
        N = s(9, C, S);
      return (
        (N.value = _.replace(fC, pC)),
        w.nextToken(),
        a(N, w.currentOffset(), w.currentPosition()),
        N
      );
    }
    function p(w) {
      const _ = w.nextToken(),
        v = w.context(),
        { lastOffset: C, lastStartLoc: S } = v,
        N = s(8, C, S);
      return _.type !== 12
        ? (o(w, ee.UNEXPECTED_EMPTY_LINKED_MODIFIER, v.lastStartLoc, 0),
          (N.value = ""),
          a(N, C, S),
          { nextConsumeToken: _, node: N })
        : (_.value == null &&
            o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Cn(_)),
          (N.value = _.value || ""),
          a(N, w.currentOffset(), w.currentPosition()),
          { node: N });
    }
    function h(w, _) {
      const v = w.context(),
        C = s(7, v.offset, v.startLoc);
      return (C.value = _), a(C, w.currentOffset(), w.currentPosition()), C;
    }
    function m(w) {
      const _ = w.context(),
        v = s(6, _.offset, _.startLoc);
      let C = w.nextToken();
      if (C.type === 9) {
        const S = p(w);
        (v.modifier = S.node), (C = S.nextConsumeToken || w.nextToken());
      }
      switch (
        (C.type !== 10 &&
          o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(C)),
        (C = w.nextToken()),
        C.type === 2 && (C = w.nextToken()),
        C.type)
      ) {
        case 11:
          C.value == null &&
            o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(C)),
            (v.key = h(w, C.value || ""));
          break;
        case 5:
          C.value == null &&
            o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(C)),
            (v.key = d(w, C.value || ""));
          break;
        case 6:
          C.value == null &&
            o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(C)),
            (v.key = c(w, C.value || ""));
          break;
        case 7:
          C.value == null &&
            o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(C)),
            (v.key = f(w, C.value || ""));
          break;
        default: {
          o(w, ee.UNEXPECTED_EMPTY_LINKED_KEY, _.lastStartLoc, 0);
          const S = w.context(),
            N = s(7, S.offset, S.startLoc);
          return (
            (N.value = ""),
            a(N, S.offset, S.startLoc),
            (v.key = N),
            a(v, S.offset, S.startLoc),
            { nextConsumeToken: C, node: v }
          );
        }
      }
      return a(v, w.currentOffset(), w.currentPosition()), { node: v };
    }
    function g(w) {
      const _ = w.context(),
        v = _.currentType === 1 ? w.currentOffset() : _.offset,
        C = _.currentType === 1 ? _.endLoc : _.startLoc,
        S = s(2, v, C);
      S.items = [];
      let N = null,
        M = null;
      do {
        const B = N || w.nextToken();
        switch (((N = null), B.type)) {
          case 0:
            B.value == null &&
              o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(B)),
              S.items.push(l(w, B.value || ""));
            break;
          case 6:
            B.value == null &&
              o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(B)),
              S.items.push(c(w, B.value || ""));
            break;
          case 4:
            M = !0;
            break;
          case 5:
            B.value == null &&
              o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(B)),
              S.items.push(d(w, B.value || "", !!M)),
              M &&
                (i(w, Fd.USE_MODULO_SYNTAX, _.lastStartLoc, 0, Cn(B)),
                (M = null));
            break;
          case 7:
            B.value == null &&
              o(w, ee.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Cn(B)),
              S.items.push(f(w, B.value || ""));
            break;
          case 8: {
            const H = m(w);
            S.items.push(H.node), (N = H.nextConsumeToken || null);
            break;
          }
        }
      } while (_.currentType !== 14 && _.currentType !== 1);
      const L = _.currentType === 1 ? _.lastOffset : w.currentOffset(),
        $ = _.currentType === 1 ? _.lastEndLoc : w.currentPosition();
      return a(S, L, $), S;
    }
    function b(w, _, v, C) {
      const S = w.context();
      let N = C.items.length === 0;
      const M = s(1, _, v);
      (M.cases = []), M.cases.push(C);
      do {
        const L = g(w);
        N || (N = L.items.length === 0), M.cases.push(L);
      } while (S.currentType !== 14);
      return (
        N && o(w, ee.MUST_HAVE_MESSAGES_IN_PLURAL, v, 0),
        a(M, w.currentOffset(), w.currentPosition()),
        M
      );
    }
    function y(w) {
      const _ = w.context(),
        { offset: v, startLoc: C } = _,
        S = g(w);
      return _.currentType === 14 ? S : b(w, v, C, S);
    }
    function x(w) {
      const _ = uC(w, $m({}, t)),
        v = _.context(),
        C = s(0, v.offset, v.startLoc);
      return (
        e && C.loc && (C.loc.source = w),
        (C.body = y(_)),
        t.onCacheKey && (C.cacheKey = t.onCacheKey(w)),
        v.currentType !== 14 &&
          o(
            _,
            ee.UNEXPECTED_LEXICAL_ANALYSIS,
            v.lastStartLoc,
            0,
            w[v.offset] || ""
          ),
        a(C, _.currentOffset(), _.currentPosition()),
        C
      );
    }
    return { parse: x };
  }
  function Cn(t) {
    if (t.type === 14) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "…" : e;
  }
  function mC(t, e = {}) {
    const n = { ast: t, helpers: new Set() };
    return { context: () => n, helper: (i) => (n.helpers.add(i), i) };
  }
  function Vm(t, e) {
    for (let n = 0; n < t.length; n++) Hd(t[n], e);
  }
  function Hd(t, e) {
    switch (t.type) {
      case 1:
        Vm(t.cases, e), e.helper("plural");
        break;
      case 2:
        Vm(t.items, e);
        break;
      case 6: {
        Hd(t.key, e), e.helper("linked"), e.helper("type");
        break;
      }
      case 5:
        e.helper("interpolate"), e.helper("list");
        break;
      case 4:
        e.helper("interpolate"), e.helper("named");
        break;
    }
  }
  function gC(t, e = {}) {
    const n = mC(t);
    n.helper("normalize"), t.body && Hd(t.body, n);
    const r = n.context();
    t.helpers = Array.from(r.helpers);
  }
  function bC(t) {
    const e = t.body;
    return e.type === 2 ? Um(e) : e.cases.forEach((n) => Um(n)), t;
  }
  function Um(t) {
    if (t.items.length === 1) {
      const e = t.items[0];
      (e.type === 3 || e.type === 9) && ((t.static = e.value), delete e.value);
    } else {
      const e = [];
      for (let n = 0; n < t.items.length; n++) {
        const r = t.items[n];
        if (!(r.type === 3 || r.type === 9) || r.value == null) break;
        e.push(r.value);
      }
      if (e.length === t.items.length) {
        t.static = Hm(e);
        for (let n = 0; n < t.items.length; n++) {
          const r = t.items[n];
          (r.type === 3 || r.type === 9) && delete r.value;
        }
      }
    }
  }
  const yC = "minifier";
  function si(t) {
    switch (((t.t = t.type), t.type)) {
      case 0: {
        const e = t;
        si(e.body), (e.b = e.body), delete e.body;
        break;
      }
      case 1: {
        const e = t,
          n = e.cases;
        for (let r = 0; r < n.length; r++) si(n[r]);
        (e.c = n), delete e.cases;
        break;
      }
      case 2: {
        const e = t,
          n = e.items;
        for (let r = 0; r < n.length; r++) si(n[r]);
        (e.i = n),
          delete e.items,
          e.static && ((e.s = e.static), delete e.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const e = t;
        e.value && ((e.v = e.value), delete e.value);
        break;
      }
      case 6: {
        const e = t;
        si(e.key),
          (e.k = e.key),
          delete e.key,
          e.modifier && (si(e.modifier), (e.m = e.modifier), delete e.modifier);
        break;
      }
      case 5: {
        const e = t;
        (e.i = e.index), delete e.index;
        break;
      }
      case 4: {
        const e = t;
        (e.k = e.key), delete e.key;
        break;
      }
      default:
        throw ii(ee.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: yC,
          args: [t.type],
        });
    }
    delete t.type;
  }
  const _C = "parser";
  function kC(t, e) {
    const { sourceMap: n, filename: r, breakLineCode: o, needIndent: i } = e,
      s = e.location !== !1,
      a = {
        filename: r,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: o,
        needIndent: i,
        indentLevel: 0,
      };
    s && t.loc && (a.source = t.loc.source);
    const l = () => a;
    function c(b, y) {
      a.code += b;
    }
    function d(b, y = !0) {
      const x = y ? o : "";
      c(i ? x + "  ".repeat(b) : x);
    }
    function f(b = !0) {
      const y = ++a.indentLevel;
      b && d(y);
    }
    function p(b = !0) {
      const y = --a.indentLevel;
      b && d(y);
    }
    function h() {
      d(a.indentLevel);
    }
    return {
      context: l,
      push: c,
      indent: f,
      deindent: p,
      newline: h,
      helper: (b) => `_${b}`,
      needIndent: () => a.needIndent,
    };
  }
  function wC(t, e) {
    const { helper: n } = t;
    t.push(`${n("linked")}(`),
      ai(t, e.key),
      e.modifier
        ? (t.push(", "), ai(t, e.modifier), t.push(", _type"))
        : t.push(", undefined, _type"),
      t.push(")");
  }
  function xC(t, e) {
    const { helper: n, needIndent: r } = t;
    t.push(`${n("normalize")}([`), t.indent(r());
    const o = e.items.length;
    for (let i = 0; i < o && (ai(t, e.items[i]), i !== o - 1); i++)
      t.push(", ");
    t.deindent(r()), t.push("])");
  }
  function CC(t, e) {
    const { helper: n, needIndent: r } = t;
    if (e.cases.length > 1) {
      t.push(`${n("plural")}([`), t.indent(r());
      const o = e.cases.length;
      for (let i = 0; i < o && (ai(t, e.cases[i]), i !== o - 1); i++)
        t.push(", ");
      t.deindent(r()), t.push("])");
    }
  }
  function vC(t, e) {
    e.body ? ai(t, e.body) : t.push("null");
  }
  function ai(t, e) {
    const { helper: n } = t;
    switch (e.type) {
      case 0:
        vC(t, e);
        break;
      case 1:
        CC(t, e);
        break;
      case 2:
        xC(t, e);
        break;
      case 6:
        wC(t, e);
        break;
      case 8:
        t.push(JSON.stringify(e.value), e);
        break;
      case 7:
        t.push(JSON.stringify(e.value), e);
        break;
      case 5:
        t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
        break;
      case 4:
        t.push(
          `${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`,
          e
        );
        break;
      case 9:
        t.push(JSON.stringify(e.value), e);
        break;
      case 3:
        t.push(JSON.stringify(e.value), e);
        break;
      default:
        throw ii(ee.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: _C,
          args: [e.type],
        });
    }
  }
  const EC = (t, e = {}) => {
    const n = Fm(e.mode) ? e.mode : "normal",
      r = Fm(e.filename) ? e.filename : "message.intl",
      o = !!e.sourceMap,
      i =
        e.breakLineCode != null
          ? e.breakLineCode
          : n === "arrow"
          ? ";"
          : `
`,
      s = e.needIndent ? e.needIndent : n !== "arrow",
      a = t.helpers || [],
      l = kC(t, {
        mode: n,
        filename: r,
        sourceMap: o,
        breakLineCode: i,
        needIndent: s,
      });
    l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"),
      l.indent(s),
      a.length > 0 &&
        (l.push(
          `const { ${Hm(
            a.map((f) => `${f}: _${f}`),
            ", "
          )} } = ctx`
        ),
        l.newline()),
      l.push("return "),
      ai(l, t),
      l.deindent(s),
      l.push("}"),
      delete t.helpers;
    const { code: c, map: d } = l.context();
    return { ast: t, code: c, map: d ? d.toJSON() : void 0 };
  };
  function AC(t, e = {}) {
    const n = $m({}, e),
      r = !!n.jit,
      o = !!n.minify,
      i = n.optimize == null ? !0 : n.optimize,
      a = hC(n).parse(t);
    return r
      ? (i && bC(a), o && si(a), { ast: a, code: "" })
      : (gC(a, n), EC(a, n));
  }
  var SC = {
    LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
    COREPACK_ROOT:
      "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
    WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
    npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
    TERM_PROGRAM: "vscode",
    npm_package_scripts_prettier:
      "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
    npm_package_dependencies__tiptap_extension_link: "^2.11.2",
    npm_package_scripts_test_unit_coverage:
      "vitest run --environment jsdom --coverage",
    NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
    ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
    WASMER_DIR: "/Users/ryanwang/.wasmer",
    _P9K_TTY: "/dev/ttys005",
    npm_package_homepage:
      "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
    npm_package_dependencies__tiptap_vue_3: "^2.11.2",
    INIT_CWD:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    SHELL: "/bin/zsh",
    TERM: "xterm-256color",
    npm_package_unpkg: "./dist/rich-text-editor.iife.js",
    npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
    npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
    TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
    CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
    npm_package_dependencies_linkifyjs: "^4.1.3",
    npm_package_scripts_lint:
      "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
    npm_package_scripts_release: "release-it",
    TERM_PROGRAM_VERSION: "0.48.7",
    npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
    npm_package_dependencies_floating_vue: "^5.2.2",
    npm_package_scripts_dev: "vite",
    MallocNanoZone: "0",
    ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
    CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
    ZDOTDIR: "/Users/ryanwang",
    npm_package_dependencies__tiptap_extension_document: "^2.11.2",
    npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
    SDKMAN_PLATFORM: "darwinarm64",
    npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
    npm_config_registry: "https://registry.npmjs.org/",
    ZSH: "/Users/ryanwang/.oh-my-zsh",
    PNPM_HOME: "/Users/ryanwang/Library/pnpm",
    npm_package_repository_url: "https://github.com/halo-dev/halo.git",
    npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
    npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
    npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
    npm_package_scripts_test_unit_ui: "vitest --environment jsdom --watch --ui",
    npm_package_dependencies__tiptap_pm: "^2.11.2",
    USER: "ryanwang",
    DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
    npm_package_description: "Default editor for Halo",
    LS_COLORS:
      "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
    npm_package_license: "GPL-3.0",
    COMMAND_MODE: "unix2003",
    npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
    SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
    npm_package_exports___import: "./dist/rich-text-editor.es.js",
    PNPM_SCRIPT_SRC_DIR:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    npm_package_repository_directory: "ui/packages/editor",
    npm_package_dependencies__tiptap_extension_history: "^2.11.2",
    npm_config_strict_peer_dependencies: "",
    SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
    __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
    npm_execpath:
      "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
    PAGER: "less",
    npm_package_module: "./dist/rich-text-editor.es.js",
    npm_package_dependencies__tiptap_extension_text: "^2.11.2",
    LSCOLORS: "Gxfxcxdxbxegedabagacad",
    npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
    npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
    npm_config_frozen_lockfile: "",
    npm_package_dependencies__tiptap_extension_horizontal_rule: "^2.11.2",
    npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
    npm_package_devDependencies__types_linkifyjs: "^2.1.7",
    PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
    MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
    npm_package_devDependencies_release_it: "^16.1.5",
    npm_package_scripts_typecheck:
      "vue-tsc --noEmit -p tsconfig.app.json --composite false",
    npm_package_peerDependencies_vue: "^3.5.13",
    __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
    USER_ZDOTDIR: "/Users/ryanwang",
    COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
    npm_package_author: "@halo-dev",
    npm_package_dependencies__ckpack_vue_color: "^1.5.0",
    npm_config_auto_install_peers: "true",
    PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    npm_command: "run-script",
    JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
    VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
    npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
    npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
    EDITOR: "nvim",
    P9K_SSH: "0",
    npm_lifecycle_event: "build",
    LANG: "en_US.UTF-8",
    P9K_TTY: "old",
    npm_package_name: "@halo-dev/richtext-editor",
    npm_package_repository_type: "git",
    npm_package_types: "./dist/index.d.ts",
    npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
    npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
    npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
    npm_package_dependencies__tiptap_suggestion: "^2.11.2",
    NODE_PATH:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
    npm_package_exports___types: "./dist/index.d.ts",
    npm_package_scripts_build: "vite build --config ./vite.lib.config.ts",
    XPC_FLAGS: "0x0",
    VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
    npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
    npm_package_dependencies_tippy_js: "^6.3.7",
    npm_package_main: "./dist/rich-text-editor.iife.js",
    npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
    npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
    npm_config_node_gyp:
      "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
    XPC_SERVICE_NAME: "0",
    npm_package_version: "2.20.0",
    npm_package_devDependencies__iconify_json: "^2.2.117",
    VSCODE_INJECTION: "1",
    npm_package_dependencies__tiptap_core: "^2.11.2",
    npm_package_dependencies__tiptap_extension_code: "^2.11.2",
    HOME: "/Users/ryanwang",
    SHLVL: "2",
    npm_package_exports___dist_style_css: "./dist/style.css",
    VSCODE_GIT_ASKPASS_MAIN:
      "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
    npm_package_dependencies__tiptap_extension_image: "^2.11.2",
    npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
    npm_package_dependencies_github_markdown_css: "^5.2.0",
    npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
    npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
    LOGNAME: "ryanwang",
    LESS: "-R",
    SDKMAN_DIR: "/Users/ryanwang/.sdkman",
    npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
    VSCODE_GIT_IPC_HANDLE:
      "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
    npm_package_dependencies__tiptap_extension_table: "^2.11.2",
    npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
    BUN_INSTALL: "/Users/ryanwang/.bun",
    npm_package_scripts_test_unit_watch: "vitest --environment jsdom --watch",
    npm_package_dependencies__tiptap_extension_color: "^2.11.2",
    npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
    npm_config_user_agent: "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
    SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
    GIT_ASKPASS:
      "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
    VSCODE_GIT_ASKPASS_NODE:
      "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
    _P9K_SSH_TTY: "/dev/ttys005",
    npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
    npm_package_files_0: "dist",
    npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
    OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
    COLORTERM: "truecolor",
    npm_node_execpath: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
    NODE_ENV: "production",
  };
  function MC() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" &&
      ($d().__INTLIFY_PROD_DEVTOOLS__ = !1);
  }
  const Lr = [];
  (Lr[0] = { w: [0], i: [3, 0], "[": [4], o: [7] }),
    (Lr[1] = { w: [1], ".": [2], "[": [4], o: [7] }),
    (Lr[2] = { w: [2], i: [3, 0], 0: [3, 0] }),
    (Lr[3] = {
      i: [3, 0],
      0: [3, 0],
      w: [1, 1],
      ".": [2, 1],
      "[": [4, 1],
      o: [7, 1],
    }),
    (Lr[4] = {
      "'": [5, 0],
      '"': [6, 0],
      "[": [4, 2],
      "]": [1, 3],
      o: 8,
      l: [4, 0],
    }),
    (Lr[5] = { "'": [4, 0], o: 8, l: [5, 0] }),
    (Lr[6] = { '"': [4, 0], o: 8, l: [6, 0] });
  const TC = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function NC(t) {
    return TC.test(t);
  }
  function OC(t) {
    const e = t.charCodeAt(0),
      n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
  }
  function RC(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return t;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function DC(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t))
      ? !1
      : NC(e)
      ? OC(e)
      : "*" + e;
  }
  function LC(t) {
    const e = [];
    let n = -1,
      r = 0,
      o = 0,
      i,
      s,
      a,
      l,
      c,
      d,
      f;
    const p = [];
    (p[0] = () => {
      s === void 0 ? (s = a) : (s += a);
    }),
      (p[1] = () => {
        s !== void 0 && (e.push(s), (s = void 0));
      }),
      (p[2] = () => {
        p[0](), o++;
      }),
      (p[3] = () => {
        if (o > 0) o--, (r = 4), p[0]();
        else {
          if (((o = 0), s === void 0 || ((s = DC(s)), s === !1))) return !1;
          p[1]();
        }
      });
    function h() {
      const m = t[n + 1];
      if ((r === 5 && m === "'") || (r === 6 && m === '"'))
        return n++, (a = "\\" + m), p[0](), !0;
    }
    for (; r !== null; )
      if ((n++, (i = t[n]), !(i === "\\" && h()))) {
        if (
          ((l = RC(i)),
          (f = Lr[r]),
          (c = f[l] || f.l || 8),
          c === 8 ||
            ((r = c[0]),
            c[1] !== void 0 && ((d = p[c[1]]), d && ((a = i), d() === !1))))
        )
          return;
        if (r === 7) return e;
      }
  }
  const jm = new Map();
  function IC(t, e) {
    return be(t) ? t[e] : null;
  }
  function BC(t, e) {
    if (!be(t)) return null;
    let n = jm.get(e);
    if ((n || ((n = LC(e)), n && jm.set(e, n)), !n)) return null;
    const r = n.length;
    let o = t,
      i = 0;
    for (; i < r; ) {
      const s = o[n[i]];
      if (s === void 0 || Ue(o)) return null;
      (o = s), i++;
    }
    return o;
  }
  const PC = (t) => t,
    $C = (t) => "",
    FC = "text",
    HC = (t) => (t.length === 0 ? "" : J4(t)),
    zC = G4;
  function Wm(t, e) {
    return (
      (t = Math.abs(t)),
      e === 2 ? (t ? (t > 1 ? 1 : 0) : 1) : t ? Math.min(t, 2) : 0
    );
  }
  function VC(t) {
    const e = Ye(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (Ye(t.named.count) || Ye(t.named.n))
      ? Ye(t.named.count)
        ? t.named.count
        : Ye(t.named.n)
        ? t.named.n
        : e
      : e;
  }
  function UC(t, e) {
    e.count || (e.count = t), e.n || (e.n = t);
  }
  function jC(t = {}) {
    const e = t.locale,
      n = VC(t),
      r =
        be(t.pluralRules) && q(e) && Ue(t.pluralRules[e])
          ? t.pluralRules[e]
          : Wm,
      o = be(t.pluralRules) && q(e) && Ue(t.pluralRules[e]) ? Wm : void 0,
      i = (y) => y[r(n, y.length, o)],
      s = t.list || [],
      a = (y) => s[y],
      l = t.named || Me();
    Ye(t.pluralIndex) && UC(n, l);
    const c = (y) => l[y];
    function d(y) {
      const x = Ue(t.messages)
        ? t.messages(y)
        : be(t.messages)
        ? t.messages[y]
        : !1;
      return x || (t.parent ? t.parent.message(y) : $C);
    }
    const f = (y) => (t.modifiers ? t.modifiers[y] : PC),
      p =
        he(t.processor) && Ue(t.processor.normalize)
          ? t.processor.normalize
          : HC,
      h =
        he(t.processor) && Ue(t.processor.interpolate)
          ? t.processor.interpolate
          : zC,
      m = he(t.processor) && q(t.processor.type) ? t.processor.type : FC,
      b = {
        list: a,
        named: c,
        plural: i,
        linked: (y, ...x) => {
          const [w, _] = x;
          let v = "text",
            C = "";
          x.length === 1
            ? be(w)
              ? ((C = w.modifier || C), (v = w.type || v))
              : q(w) && (C = w || C)
            : x.length === 2 && (q(w) && (C = w || C), q(_) && (v = _ || v));
          const S = d(y)(b),
            N = v === "vnode" && Xe(S) && C ? S[0] : S;
          return C ? f(C)(N, v) : N;
        },
        message: d,
        type: m,
        interpolate: h,
        normalize: p,
        values: ht(Me(), s, l),
      };
    return b;
  }
  let ds = null;
  function WC(t) {
    ds = t;
  }
  function qC(t, e, n) {
    ds &&
      ds.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: t,
        version: e,
        meta: n,
      });
  }
  const KC = GC("function:translate");
  function GC(t) {
    return (e) => ds && ds.emit(t, e);
  }
  const qm = Fd.__EXTEND_POINT__,
    Mo = cl(qm),
    JC = {
      NOT_FOUND_KEY: qm,
      FALLBACK_TO_TRANSLATE: Mo(),
      CANNOT_FORMAT_NUMBER: Mo(),
      FALLBACK_TO_NUMBER_FORMAT: Mo(),
      CANNOT_FORMAT_DATE: Mo(),
      FALLBACK_TO_DATE_FORMAT: Mo(),
      EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Mo(),
      __EXTEND_POINT__: Mo(),
    },
    Km = ee.__EXTEND_POINT__,
    To = cl(Km),
    Bn = {
      INVALID_ARGUMENT: Km,
      INVALID_DATE_ARGUMENT: To(),
      INVALID_ISO_DATE_ARGUMENT: To(),
      NOT_SUPPORT_NON_STRING_MESSAGE: To(),
      NOT_SUPPORT_LOCALE_PROMISE_VALUE: To(),
      NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: To(),
      NOT_SUPPORT_LOCALE_TYPE: To(),
      __EXTEND_POINT__: To(),
    };
  function sr(t) {
    return ii(t, null, void 0);
  }
  function zd(t, e) {
    return e.locale != null ? Gm(e.locale) : Gm(t.locale);
  }
  let Vd;
  function Gm(t) {
    if (q(t)) return t;
    if (Ue(t)) {
      if (t.resolvedOnce && Vd != null) return Vd;
      if (t.constructor.name === "Function") {
        const e = t();
        if (K4(e)) throw sr(Bn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return (Vd = e);
      } else throw sr(Bn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw sr(Bn.NOT_SUPPORT_LOCALE_TYPE);
  }
  function YC(t, e, n) {
    return [
      ...new Set([
        n,
        ...(Xe(e) ? e : be(e) ? Object.keys(e) : q(e) ? [e] : [n]),
      ]),
    ];
  }
  function Jm(t, e, n) {
    const r = q(n) ? n : hl,
      o = t;
    o.__localeChainCache || (o.__localeChainCache = new Map());
    let i = o.__localeChainCache.get(r);
    if (!i) {
      i = [];
      let s = [n];
      for (; Xe(s); ) s = Ym(i, s, e);
      const a = Xe(e) || !he(e) ? e : e.default ? e.default : null;
      (s = q(a) ? [a] : a),
        Xe(s) && Ym(i, s, !1),
        o.__localeChainCache.set(r, i);
    }
    return i;
  }
  function Ym(t, e, n) {
    let r = !0;
    for (let o = 0; o < e.length && Fe(r); o++) {
      const i = e[o];
      q(i) && (r = XC(t, e[o], n));
    }
    return r;
  }
  function XC(t, e, n) {
    let r;
    const o = e.split("-");
    do {
      const i = o.join("-");
      (r = ZC(t, i, n)), o.splice(-1, 1);
    } while (o.length && r === !0);
    return r;
  }
  function ZC(t, e, n) {
    let r = !1;
    if (!t.includes(e) && ((r = !0), e)) {
      r = e[e.length - 1] !== "!";
      const o = e.replace(/!/g, "");
      t.push(o), (Xe(n) || he(n)) && n[o] && (r = n[o]);
    }
    return r;
  }
  const QC = "9.14.2",
    pl = -1,
    hl = "en-US",
    Xm = "",
    Zm = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
  function e5() {
    return {
      upper: (t, e) =>
        e === "text" && q(t)
          ? t.toUpperCase()
          : e === "vnode" && be(t) && "__v_isVNode" in t
          ? t.children.toUpperCase()
          : t,
      lower: (t, e) =>
        e === "text" && q(t)
          ? t.toLowerCase()
          : e === "vnode" && be(t) && "__v_isVNode" in t
          ? t.children.toLowerCase()
          : t,
      capitalize: (t, e) =>
        e === "text" && q(t)
          ? Zm(t)
          : e === "vnode" && be(t) && "__v_isVNode" in t
          ? Zm(t.children)
          : t,
    };
  }
  let Qm;
  function t5(t) {
    Qm = t;
  }
  let e1;
  function n5(t) {
    e1 = t;
  }
  let t1;
  function r5(t) {
    t1 = t;
  }
  let n1 = null;
  const o5 = (t) => {
      n1 = t;
    },
    i5 = () => n1;
  let r1 = null;
  const o1 = (t) => {
      r1 = t;
    },
    s5 = () => r1;
  let i1 = 0;
  function a5(t = {}) {
    const e = Ue(t.onWarn) ? t.onWarn : Y4,
      n = q(t.version) ? t.version : QC,
      r = q(t.locale) || Ue(t.locale) ? t.locale : hl,
      o = Ue(r) ? hl : r,
      i =
        Xe(t.fallbackLocale) ||
        he(t.fallbackLocale) ||
        q(t.fallbackLocale) ||
        t.fallbackLocale === !1
          ? t.fallbackLocale
          : o,
      s = he(t.messages) ? t.messages : Ud(o),
      a = he(t.datetimeFormats) ? t.datetimeFormats : Ud(o),
      l = he(t.numberFormats) ? t.numberFormats : Ud(o),
      c = ht(Me(), t.modifiers, e5()),
      d = t.pluralRules || Me(),
      f = Ue(t.missing) ? t.missing : null,
      p = Fe(t.missingWarn) || al(t.missingWarn) ? t.missingWarn : !0,
      h = Fe(t.fallbackWarn) || al(t.fallbackWarn) ? t.fallbackWarn : !0,
      m = !!t.fallbackFormat,
      g = !!t.unresolving,
      b = Ue(t.postTranslation) ? t.postTranslation : null,
      y = he(t.processor) ? t.processor : null,
      x = Fe(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
      w = !!t.escapeParameter,
      _ = Ue(t.messageCompiler) ? t.messageCompiler : Qm,
      v = Ue(t.messageResolver) ? t.messageResolver : e1 || IC,
      C = Ue(t.localeFallbacker) ? t.localeFallbacker : t1 || YC,
      S = be(t.fallbackContext) ? t.fallbackContext : void 0,
      N = t,
      M = be(N.__datetimeFormatters) ? N.__datetimeFormatters : new Map(),
      L = be(N.__numberFormatters) ? N.__numberFormatters : new Map(),
      $ = be(N.__meta) ? N.__meta : {};
    i1++;
    const B = {
      version: n,
      cid: i1,
      locale: r,
      fallbackLocale: i,
      messages: s,
      modifiers: c,
      pluralRules: d,
      missing: f,
      missingWarn: p,
      fallbackWarn: h,
      fallbackFormat: m,
      unresolving: g,
      postTranslation: b,
      processor: y,
      warnHtmlMessage: x,
      escapeParameter: w,
      messageCompiler: _,
      messageResolver: v,
      localeFallbacker: C,
      fallbackContext: S,
      onWarn: e,
      __meta: $,
    };
    return (
      (B.datetimeFormats = a),
      (B.numberFormats = l),
      (B.__datetimeFormatters = M),
      (B.__numberFormatters = L),
      __INTLIFY_PROD_DEVTOOLS__ && qC(B, n, $),
      B
    );
  }
  const Ud = (t) => ({ [t]: Me() });
  function jd(t, e, n, r, o) {
    const { missing: i, onWarn: s } = t;
    if (i !== null) {
      const a = i(t, n, e, o);
      return q(a) ? a : e;
    } else return e;
  }
  function fs(t, e, n) {
    const r = t;
    (r.__localeChainCache = new Map()), t.localeFallbacker(t, n, e);
  }
  function l5(t, e) {
    return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
  }
  function c5(t, e) {
    const n = e.indexOf(t);
    if (n === -1) return !1;
    for (let r = n + 1; r < e.length; r++) if (l5(t, e[r])) return !0;
    return !1;
  }
  function Wd(t) {
    return (n) => u5(n, t);
  }
  function u5(t, e) {
    const n = f5(e);
    if (n == null) throw ps(0);
    if (Kd(n) === 1) {
      const i = h5(n);
      return t.plural(i.reduce((s, a) => [...s, s1(t, a)], []));
    } else return s1(t, n);
  }
  const d5 = ["b", "body"];
  function f5(t) {
    return Ir(t, d5);
  }
  const p5 = ["c", "cases"];
  function h5(t) {
    return Ir(t, p5, []);
  }
  function s1(t, e) {
    const n = g5(e);
    if (n != null) return t.type === "text" ? n : t.normalize([n]);
    {
      const r = y5(e).reduce((o, i) => [...o, qd(t, i)], []);
      return t.normalize(r);
    }
  }
  const m5 = ["s", "static"];
  function g5(t) {
    return Ir(t, m5);
  }
  const b5 = ["i", "items"];
  function y5(t) {
    return Ir(t, b5, []);
  }
  function qd(t, e) {
    const n = Kd(e);
    switch (n) {
      case 3:
        return ml(e, n);
      case 9:
        return ml(e, n);
      case 4: {
        const r = e;
        if (xn(r, "k") && r.k) return t.interpolate(t.named(r.k));
        if (xn(r, "key") && r.key) return t.interpolate(t.named(r.key));
        throw ps(n);
      }
      case 5: {
        const r = e;
        if (xn(r, "i") && Ye(r.i)) return t.interpolate(t.list(r.i));
        if (xn(r, "index") && Ye(r.index))
          return t.interpolate(t.list(r.index));
        throw ps(n);
      }
      case 6: {
        const r = e,
          o = x5(r),
          i = v5(r);
        return t.linked(qd(t, i), o ? qd(t, o) : void 0, t.type);
      }
      case 7:
        return ml(e, n);
      case 8:
        return ml(e, n);
      default:
        throw new Error(`unhandled node on format message part: ${n}`);
    }
  }
  const _5 = ["t", "type"];
  function Kd(t) {
    return Ir(t, _5);
  }
  const k5 = ["v", "value"];
  function ml(t, e) {
    const n = Ir(t, k5);
    if (n) return n;
    throw ps(e);
  }
  const w5 = ["m", "modifier"];
  function x5(t) {
    return Ir(t, w5);
  }
  const C5 = ["k", "key"];
  function v5(t) {
    const e = Ir(t, C5);
    if (e) return e;
    throw ps(6);
  }
  function Ir(t, e, n) {
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      if (xn(t, o) && t[o] != null) return t[o];
    }
    return n;
  }
  function ps(t) {
    return new Error(`unhandled node type: ${t}`);
  }
  const E5 = (t) => t;
  let gl = Me();
  function li(t) {
    return be(t) && Kd(t) === 0 && (xn(t, "b") || xn(t, "body"));
  }
  function A5(t, e = {}) {
    let n = !1;
    const r = e.onError || rC;
    return (
      (e.onError = (o) => {
        (n = !0), r(o);
      }),
      { ...AC(t, e), detectError: n }
    );
  }
  function S5(t, e) {
    if (q(t)) {
      Fe(e.warnHtmlMessage) && e.warnHtmlMessage;
      const r = (e.onCacheKey || E5)(t),
        o = gl[r];
      if (o) return o;
      const { ast: i, detectError: s } = A5(t, {
          ...e,
          location: SC.NODE_ENV !== "production",
          jit: !0,
        }),
        a = Wd(i);
      return s ? a : (gl[r] = a);
    } else {
      const n = t.cacheKey;
      if (n) {
        const r = gl[n];
        return r || (gl[n] = Wd(t));
      } else return Wd(t);
    }
  }
  const a1 = () => "",
    Yt = (t) => Ue(t);
  function l1(t, ...e) {
    const {
        fallbackFormat: n,
        postTranslation: r,
        unresolving: o,
        messageCompiler: i,
        fallbackLocale: s,
        messages: a,
      } = t,
      [l, c] = Gd(...e),
      d = Fe(c.missingWarn) ? c.missingWarn : t.missingWarn,
      f = Fe(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn,
      p = Fe(c.escapeParameter) ? c.escapeParameter : t.escapeParameter,
      h = !!c.resolvedMessage,
      m =
        q(c.default) || Fe(c.default)
          ? Fe(c.default)
            ? i
              ? l
              : () => l
            : c.default
          : n
          ? i
            ? l
            : () => l
          : "",
      g = n || m !== "",
      b = zd(t, c);
    p && M5(c);
    let [y, x, w] = h ? [l, b, a[b] || Me()] : c1(t, l, b, s, f, d),
      _ = y,
      v = l;
    if (
      (!h && !(q(_) || li(_) || Yt(_)) && g && ((_ = m), (v = _)),
      !h && (!(q(_) || li(_) || Yt(_)) || !q(x)))
    )
      return o ? pl : l;
    let C = !1;
    const S = () => {
        C = !0;
      },
      N = Yt(_) ? _ : u1(t, l, x, _, v, S);
    if (C) return _;
    const M = O5(t, x, w, c),
      L = jC(M),
      $ = T5(t, N, L),
      B = r ? r($, l) : $;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const H = {
        timestamp: Date.now(),
        key: q(l) ? l : Yt(_) ? _.key : "",
        locale: x || (Yt(_) ? _.locale : ""),
        format: q(_) ? _ : Yt(_) ? _.source : "",
        message: B,
      };
      (H.meta = ht({}, t.__meta, i5() || {})), KC(H);
    }
    return B;
  }
  function M5(t) {
    Xe(t.list)
      ? (t.list = t.list.map((e) => (q(e) ? Lm(e) : e)))
      : be(t.named) &&
        Object.keys(t.named).forEach((e) => {
          q(t.named[e]) && (t.named[e] = Lm(t.named[e]));
        });
  }
  function c1(t, e, n, r, o, i) {
    const {
        messages: s,
        onWarn: a,
        messageResolver: l,
        localeFallbacker: c,
      } = t,
      d = c(t, r, n);
    let f = Me(),
      p,
      h = null;
    const m = "translate";
    for (
      let g = 0;
      g < d.length &&
      ((p = d[g]),
      (f = s[p] || Me()),
      (h = l(f, e)) === null && (h = f[e]),
      !(q(h) || li(h) || Yt(h)));
      g++
    )
      if (!c5(p, d)) {
        const b = jd(t, e, p, i, m);
        b !== e && (h = b);
      }
    return [h, p, f];
  }
  function u1(t, e, n, r, o, i) {
    const { messageCompiler: s, warnHtmlMessage: a } = t;
    if (Yt(r)) {
      const c = r;
      return (c.locale = c.locale || n), (c.key = c.key || e), c;
    }
    if (s == null) {
      const c = () => r;
      return (c.locale = n), (c.key = e), c;
    }
    const l = s(r, N5(t, n, o, r, a, i));
    return (l.locale = n), (l.key = e), (l.source = r), l;
  }
  function T5(t, e, n) {
    return e(n);
  }
  function Gd(...t) {
    const [e, n, r] = t,
      o = Me();
    if (!q(e) && !Ye(e) && !Yt(e) && !li(e)) throw sr(Bn.INVALID_ARGUMENT);
    const i = Ye(e) ? String(e) : (Yt(e), e);
    return (
      Ye(n)
        ? (o.plural = n)
        : q(n)
        ? (o.default = n)
        : he(n) && !ll(n)
        ? (o.named = n)
        : Xe(n) && (o.list = n),
      Ye(r) ? (o.plural = r) : q(r) ? (o.default = r) : he(r) && ht(o, r),
      [i, o]
    );
  }
  function N5(t, e, n, r, o, i) {
    return {
      locale: e,
      key: n,
      warnHtmlMessage: o,
      onError: (s) => {
        throw (i && i(s), s);
      },
      onCacheKey: (s) => V4(e, n, s),
    };
  }
  function O5(t, e, n, r) {
    const {
        modifiers: o,
        pluralRules: i,
        messageResolver: s,
        fallbackLocale: a,
        fallbackWarn: l,
        missingWarn: c,
        fallbackContext: d,
      } = t,
      p = {
        locale: e,
        modifiers: o,
        pluralRules: i,
        messages: (h) => {
          let m = s(n, h);
          if (m == null && d) {
            const [, , g] = c1(d, h, e, a, l, c);
            m = s(g, h);
          }
          if (q(m) || li(m)) {
            let g = !1;
            const y = u1(t, h, e, m, h, () => {
              g = !0;
            });
            return g ? a1 : y;
          } else return Yt(m) ? m : a1;
        },
      };
    return (
      t.processor && (p.processor = t.processor),
      r.list && (p.list = r.list),
      r.named && (p.named = r.named),
      Ye(r.plural) && (p.pluralIndex = r.plural),
      p
    );
  }
  function d1(t, ...e) {
    const {
        datetimeFormats: n,
        unresolving: r,
        fallbackLocale: o,
        onWarn: i,
        localeFallbacker: s,
      } = t,
      { __datetimeFormatters: a } = t,
      [l, c, d, f] = Jd(...e),
      p = Fe(d.missingWarn) ? d.missingWarn : t.missingWarn;
    Fe(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
    const h = !!d.part,
      m = zd(t, d),
      g = s(t, o, m);
    if (!q(l) || l === "") return new Intl.DateTimeFormat(m, f).format(c);
    let b = {},
      y,
      x = null;
    const w = "datetime format";
    for (
      let C = 0;
      C < g.length && ((y = g[C]), (b = n[y] || {}), (x = b[l]), !he(x));
      C++
    )
      jd(t, l, y, p, w);
    if (!he(x) || !q(y)) return r ? pl : l;
    let _ = `${y}__${l}`;
    ll(f) || (_ = `${_}__${JSON.stringify(f)}`);
    let v = a.get(_);
    return (
      v || ((v = new Intl.DateTimeFormat(y, ht({}, x, f))), a.set(_, v)),
      h ? v.formatToParts(c) : v.format(c)
    );
  }
  const f1 = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits",
  ];
  function Jd(...t) {
    const [e, n, r, o] = t,
      i = Me();
    let s = Me(),
      a;
    if (q(e)) {
      const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw sr(Bn.INVALID_ISO_DATE_ARGUMENT);
      const c = l[3]
        ? l[3].trim().startsWith("T")
          ? `${l[1].trim()}${l[3].trim()}`
          : `${l[1].trim()}T${l[3].trim()}`
        : l[1].trim();
      a = new Date(c);
      try {
        a.toISOString();
      } catch {
        throw sr(Bn.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (j4(e)) {
      if (isNaN(e.getTime())) throw sr(Bn.INVALID_DATE_ARGUMENT);
      a = e;
    } else if (Ye(e)) a = e;
    else throw sr(Bn.INVALID_ARGUMENT);
    return (
      q(n)
        ? (i.key = n)
        : he(n) &&
          Object.keys(n).forEach((l) => {
            f1.includes(l) ? (s[l] = n[l]) : (i[l] = n[l]);
          }),
      q(r) ? (i.locale = r) : he(r) && (s = r),
      he(o) && (s = o),
      [i.key || "", a, i, s]
    );
  }
  function p1(t, e, n) {
    const r = t;
    for (const o in n) {
      const i = `${e}__${o}`;
      r.__datetimeFormatters.has(i) && r.__datetimeFormatters.delete(i);
    }
  }
  function h1(t, ...e) {
    const {
        numberFormats: n,
        unresolving: r,
        fallbackLocale: o,
        onWarn: i,
        localeFallbacker: s,
      } = t,
      { __numberFormatters: a } = t,
      [l, c, d, f] = Yd(...e),
      p = Fe(d.missingWarn) ? d.missingWarn : t.missingWarn;
    Fe(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
    const h = !!d.part,
      m = zd(t, d),
      g = s(t, o, m);
    if (!q(l) || l === "") return new Intl.NumberFormat(m, f).format(c);
    let b = {},
      y,
      x = null;
    const w = "number format";
    for (
      let C = 0;
      C < g.length && ((y = g[C]), (b = n[y] || {}), (x = b[l]), !he(x));
      C++
    )
      jd(t, l, y, p, w);
    if (!he(x) || !q(y)) return r ? pl : l;
    let _ = `${y}__${l}`;
    ll(f) || (_ = `${_}__${JSON.stringify(f)}`);
    let v = a.get(_);
    return (
      v || ((v = new Intl.NumberFormat(y, ht({}, x, f))), a.set(_, v)),
      h ? v.formatToParts(c) : v.format(c)
    );
  }
  const m1 = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay",
  ];
  function Yd(...t) {
    const [e, n, r, o] = t,
      i = Me();
    let s = Me();
    if (!Ye(e)) throw sr(Bn.INVALID_ARGUMENT);
    const a = e;
    return (
      q(n)
        ? (i.key = n)
        : he(n) &&
          Object.keys(n).forEach((l) => {
            m1.includes(l) ? (s[l] = n[l]) : (i[l] = n[l]);
          }),
      q(r) ? (i.locale = r) : he(r) && (s = r),
      he(o) && (s = o),
      [i.key || "", a, i, s]
    );
  }
  function g1(t, e, n) {
    const r = t;
    for (const o in n) {
      const i = `${e}__${o}`;
      r.__numberFormatters.has(i) && r.__numberFormatters.delete(i);
    }
  }
  MC();
  var R5 = {
    LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
    COREPACK_ROOT:
      "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
    WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
    npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
    TERM_PROGRAM: "vscode",
    npm_package_scripts_prettier:
      "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
    npm_package_dependencies__tiptap_extension_link: "^2.11.2",
    npm_package_scripts_test_unit_coverage:
      "vitest run --environment jsdom --coverage",
    NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
    ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
    WASMER_DIR: "/Users/ryanwang/.wasmer",
    _P9K_TTY: "/dev/ttys005",
    npm_package_homepage:
      "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
    npm_package_dependencies__tiptap_vue_3: "^2.11.2",
    INIT_CWD:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    SHELL: "/bin/zsh",
    TERM: "xterm-256color",
    npm_package_unpkg: "./dist/rich-text-editor.iife.js",
    npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
    npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
    TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
    CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
    npm_package_dependencies_linkifyjs: "^4.1.3",
    npm_package_scripts_lint:
      "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
    npm_package_scripts_release: "release-it",
    TERM_PROGRAM_VERSION: "0.48.7",
    npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
    npm_package_dependencies_floating_vue: "^5.2.2",
    npm_package_scripts_dev: "vite",
    MallocNanoZone: "0",
    ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
    CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
    ZDOTDIR: "/Users/ryanwang",
    npm_package_dependencies__tiptap_extension_document: "^2.11.2",
    npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
    SDKMAN_PLATFORM: "darwinarm64",
    npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
    npm_config_registry: "https://registry.npmjs.org/",
    ZSH: "/Users/ryanwang/.oh-my-zsh",
    PNPM_HOME: "/Users/ryanwang/Library/pnpm",
    npm_package_repository_url: "https://github.com/halo-dev/halo.git",
    npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
    npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
    npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
    npm_package_scripts_test_unit_ui: "vitest --environment jsdom --watch --ui",
    npm_package_dependencies__tiptap_pm: "^2.11.2",
    USER: "ryanwang",
    DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
    npm_package_description: "Default editor for Halo",
    LS_COLORS:
      "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
    npm_package_license: "GPL-3.0",
    COMMAND_MODE: "unix2003",
    npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
    SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
    npm_package_exports___import: "./dist/rich-text-editor.es.js",
    PNPM_SCRIPT_SRC_DIR:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    npm_package_repository_directory: "ui/packages/editor",
    npm_package_dependencies__tiptap_extension_history: "^2.11.2",
    npm_config_strict_peer_dependencies: "",
    SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
    __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
    npm_execpath:
      "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
    PAGER: "less",
    npm_package_module: "./dist/rich-text-editor.es.js",
    npm_package_dependencies__tiptap_extension_text: "^2.11.2",
    LSCOLORS: "Gxfxcxdxbxegedabagacad",
    npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
    npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
    npm_config_frozen_lockfile: "",
    npm_package_dependencies__tiptap_extension_horizontal_rule: "^2.11.2",
    npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
    npm_package_devDependencies__types_linkifyjs: "^2.1.7",
    PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
    MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
    npm_package_devDependencies_release_it: "^16.1.5",
    npm_package_scripts_typecheck:
      "vue-tsc --noEmit -p tsconfig.app.json --composite false",
    npm_package_peerDependencies_vue: "^3.5.13",
    __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
    USER_ZDOTDIR: "/Users/ryanwang",
    COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
    npm_package_author: "@halo-dev",
    npm_package_dependencies__ckpack_vue_color: "^1.5.0",
    npm_config_auto_install_peers: "true",
    PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
    npm_command: "run-script",
    JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
    VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
    npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
    npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
    EDITOR: "nvim",
    P9K_SSH: "0",
    npm_lifecycle_event: "build",
    LANG: "en_US.UTF-8",
    P9K_TTY: "old",
    npm_package_name: "@halo-dev/richtext-editor",
    npm_package_repository_type: "git",
    npm_package_types: "./dist/index.d.ts",
    npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
    npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
    npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
    npm_package_dependencies__tiptap_suggestion: "^2.11.2",
    NODE_PATH:
      "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
    npm_package_exports___types: "./dist/index.d.ts",
    npm_package_scripts_build: "vite build --config ./vite.lib.config.ts",
    XPC_FLAGS: "0x0",
    VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
    npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
    npm_package_dependencies_tippy_js: "^6.3.7",
    npm_package_main: "./dist/rich-text-editor.iife.js",
    npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
    npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
    npm_config_node_gyp:
      "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
    XPC_SERVICE_NAME: "0",
    npm_package_version: "2.20.0",
    npm_package_devDependencies__iconify_json: "^2.2.117",
    VSCODE_INJECTION: "1",
    npm_package_dependencies__tiptap_core: "^2.11.2",
    npm_package_dependencies__tiptap_extension_code: "^2.11.2",
    HOME: "/Users/ryanwang",
    SHLVL: "2",
    npm_package_exports___dist_style_css: "./dist/style.css",
    VSCODE_GIT_ASKPASS_MAIN:
      "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
    npm_package_dependencies__tiptap_extension_image: "^2.11.2",
    npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
    npm_package_dependencies_github_markdown_css: "^5.2.0",
    npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
    npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
    LOGNAME: "ryanwang",
    LESS: "-R",
    SDKMAN_DIR: "/Users/ryanwang/.sdkman",
    npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
    VSCODE_GIT_IPC_HANDLE:
      "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
    npm_package_dependencies__tiptap_extension_table: "^2.11.2",
    npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
    BUN_INSTALL: "/Users/ryanwang/.bun",
    npm_package_scripts_test_unit_watch: "vitest --environment jsdom --watch",
    npm_package_dependencies__tiptap_extension_color: "^2.11.2",
    npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
    npm_config_user_agent: "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
    SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
    GIT_ASKPASS:
      "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
    VSCODE_GIT_ASKPASS_NODE:
      "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
    _P9K_SSH_TTY: "/dev/ttys005",
    npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
    npm_package_files_0: "dist",
    npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
    OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
    COLORTERM: "truecolor",
    npm_node_execpath: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
    NODE_ENV: "production",
  };
  const D5 = "9.14.2";
  function L5() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" &&
      ($d().__INTLIFY_PROD_DEVTOOLS__ = !1);
  }
  const b1 = JC.__EXTEND_POINT__,
    ar = cl(b1);
  ar(), ar(), ar(), ar(), ar(), ar(), ar(), ar(), ar();
  const y1 = Bn.__EXTEND_POINT__,
    Ot = cl(y1),
    Xt = {
      UNEXPECTED_RETURN_TYPE: y1,
      INVALID_ARGUMENT: Ot(),
      MUST_BE_CALL_SETUP_TOP: Ot(),
      NOT_INSTALLED: Ot(),
      NOT_AVAILABLE_IN_LEGACY_MODE: Ot(),
      REQUIRED_VALUE: Ot(),
      INVALID_VALUE: Ot(),
      CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Ot(),
      NOT_INSTALLED_WITH_PROVIDE: Ot(),
      UNEXPECTED_ERROR: Ot(),
      NOT_COMPATIBLE_LEGACY_VUE_I18N: Ot(),
      BRIDGE_SUPPORT_VUE_2_ONLY: Ot(),
      MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Ot(),
      NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Ot(),
      __EXTEND_POINT__: Ot(),
    };
  function vn(t, ...e) {
    return ii(t, null, void 0);
  }
  const Xd = Rr("__translateVNode"),
    Zd = Rr("__datetimeParts"),
    Qd = Rr("__numberParts"),
    I5 = Rr("__setPluralRules"),
    B5 = Rr("__injectWithOption"),
    ef = Rr("__dispose");
  function hs(t) {
    if (!be(t)) return t;
    for (const e in t)
      if (xn(t, e))
        if (!e.includes(".")) be(t[e]) && hs(t[e]);
        else {
          const n = e.split("."),
            r = n.length - 1;
          let o = t,
            i = !1;
          for (let s = 0; s < r; s++) {
            if ((n[s] in o || (o[n[s]] = Me()), !be(o[n[s]]))) {
              i = !0;
              break;
            }
            o = o[n[s]];
          }
          i || ((o[n[r]] = t[e]), delete t[e]), be(o[n[r]]) && hs(o[n[r]]);
        }
    return t;
  }
  function _1(t, e) {
    const { messages: n, __i18n: r, messageResolver: o, flatJson: i } = e,
      s = he(n) ? n : Xe(r) ? Me() : { [t]: Me() };
    if (
      (Xe(r) &&
        r.forEach((a) => {
          if ("locale" in a && "resource" in a) {
            const { locale: l, resource: c } = a;
            l ? ((s[l] = s[l] || Me()), dl(c, s[l])) : dl(c, s);
          } else q(a) && dl(JSON.parse(a), s);
        }),
      o == null && i)
    )
      for (const a in s) xn(s, a) && hs(s[a]);
    return s;
  }
  function k1(t) {
    return t.type;
  }
  function P5(t, e, n) {
    let r = be(e.messages) ? e.messages : Me();
    "__i18nGlobal" in n &&
      (r = _1(t.locale.value, { messages: r, __i18n: n.__i18nGlobal }));
    const o = Object.keys(r);
    o.length &&
      o.forEach((i) => {
        t.mergeLocaleMessage(i, r[i]);
      });
    {
      if (be(e.datetimeFormats)) {
        const i = Object.keys(e.datetimeFormats);
        i.length &&
          i.forEach((s) => {
            t.mergeDateTimeFormat(s, e.datetimeFormats[s]);
          });
      }
      if (be(e.numberFormats)) {
        const i = Object.keys(e.numberFormats);
        i.length &&
          i.forEach((s) => {
            t.mergeNumberFormat(s, e.numberFormats[s]);
          });
      }
    }
  }
  function w1(t) {
    return u.createVNode(u.Text, null, t, 0);
  }
  const x1 = "__INTLIFY_META__",
    C1 = () => [],
    $5 = () => !1;
  let v1 = 0;
  function E1(t) {
    return (e, n, r, o) => t(n, r, u.getCurrentInstance() || void 0, o);
  }
  const F5 = () => {
    const t = u.getCurrentInstance();
    let e = null;
    return t && (e = k1(t)[x1]) ? { [x1]: e } : null;
  };
  function A1(t = {}, e) {
    const { __root: n, __injectWithOption: r } = t,
      o = n === void 0,
      i = t.flatJson,
      s = sl ? u.ref : u.shallowRef,
      a = !!t.translateExistCompatible;
    let l = Fe(t.inheritLocale) ? t.inheritLocale : !0;
    const c = s(n && l ? n.locale.value : q(t.locale) ? t.locale : hl),
      d = s(
        n && l
          ? n.fallbackLocale.value
          : q(t.fallbackLocale) ||
            Xe(t.fallbackLocale) ||
            he(t.fallbackLocale) ||
            t.fallbackLocale === !1
          ? t.fallbackLocale
          : c.value
      ),
      f = s(_1(c.value, t)),
      p = s(he(t.datetimeFormats) ? t.datetimeFormats : { [c.value]: {} }),
      h = s(he(t.numberFormats) ? t.numberFormats : { [c.value]: {} });
    let m = n
        ? n.missingWarn
        : Fe(t.missingWarn) || al(t.missingWarn)
        ? t.missingWarn
        : !0,
      g = n
        ? n.fallbackWarn
        : Fe(t.fallbackWarn) || al(t.fallbackWarn)
        ? t.fallbackWarn
        : !0,
      b = n ? n.fallbackRoot : Fe(t.fallbackRoot) ? t.fallbackRoot : !0,
      y = !!t.fallbackFormat,
      x = Ue(t.missing) ? t.missing : null,
      w = Ue(t.missing) ? E1(t.missing) : null,
      _ = Ue(t.postTranslation) ? t.postTranslation : null,
      v = n
        ? n.warnHtmlMessage
        : Fe(t.warnHtmlMessage)
        ? t.warnHtmlMessage
        : !0,
      C = !!t.escapeParameter;
    const S = n ? n.modifiers : he(t.modifiers) ? t.modifiers : {};
    let N = t.pluralRules || (n && n.pluralRules),
      M;
    (M = (() => {
      o && o1(null);
      const O = {
        version: D5,
        locale: c.value,
        fallbackLocale: d.value,
        messages: f.value,
        modifiers: S,
        pluralRules: N,
        missing: w === null ? void 0 : w,
        missingWarn: m,
        fallbackWarn: g,
        fallbackFormat: y,
        unresolving: !0,
        postTranslation: _ === null ? void 0 : _,
        warnHtmlMessage: v,
        escapeParameter: C,
        messageResolver: t.messageResolver,
        messageCompiler: t.messageCompiler,
        __meta: { framework: "vue" },
      };
      (O.datetimeFormats = p.value),
        (O.numberFormats = h.value),
        (O.__datetimeFormatters = he(M) ? M.__datetimeFormatters : void 0),
        (O.__numberFormatters = he(M) ? M.__numberFormatters : void 0);
      const P = a5(O);
      return o && o1(P), P;
    })()),
      fs(M, c.value, d.value);
    function $() {
      return [c.value, d.value, f.value, p.value, h.value];
    }
    const B = u.computed({
        get: () => c.value,
        set: (O) => {
          (c.value = O), (M.locale = c.value);
        },
      }),
      H = u.computed({
        get: () => d.value,
        set: (O) => {
          (d.value = O), (M.fallbackLocale = d.value), fs(M, c.value, O);
        },
      }),
      Q = u.computed(() => f.value),
      X = u.computed(() => p.value),
      Y = u.computed(() => h.value);
    function Z() {
      return Ue(_) ? _ : null;
    }
    function ce(O) {
      (_ = O), (M.postTranslation = O);
    }
    function Ae() {
      return x;
    }
    function Ie(O) {
      O !== null && (w = E1(O)), (x = O), (M.missing = w);
    }
    const xe = (O, P, ye, ze, or, Ji) => {
      $();
      let yo;
      try {
        R5.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__,
          o || (M.fallbackContext = n ? s5() : void 0),
          (yo = O(M));
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, o || (M.fallbackContext = void 0);
      }
      if (
        (ye !== "translate exists" && Ye(yo) && yo === pl) ||
        (ye === "translate exists" && !yo)
      ) {
        const [V0, R] = P();
        return n && b ? ze(n) : or(V0);
      } else {
        if (Ji(yo)) return yo;
        throw vn(Xt.UNEXPECTED_RETURN_TYPE);
      }
    };
    function De(...O) {
      return xe(
        (P) => Reflect.apply(l1, null, [P, ...O]),
        () => Gd(...O),
        "translate",
        (P) => Reflect.apply(P.t, P, [...O]),
        (P) => P,
        (P) => q(P)
      );
    }
    function He(...O) {
      const [P, ye, ze] = O;
      if (ze && !be(ze)) throw vn(Xt.INVALID_ARGUMENT);
      return De(P, ye, ht({ resolvedMessage: !0 }, ze || {}));
    }
    function We(...O) {
      return xe(
        (P) => Reflect.apply(d1, null, [P, ...O]),
        () => Jd(...O),
        "datetime format",
        (P) => Reflect.apply(P.d, P, [...O]),
        () => Xm,
        (P) => q(P)
      );
    }
    function Oe(...O) {
      return xe(
        (P) => Reflect.apply(h1, null, [P, ...O]),
        () => Yd(...O),
        "number format",
        (P) => Reflect.apply(P.n, P, [...O]),
        () => Xm,
        (P) => q(P)
      );
    }
    function Be(O) {
      return O.map((P) => (q(P) || Ye(P) || Fe(P) ? w1(String(P)) : P));
    }
    const Je = { normalize: Be, interpolate: (O) => O, type: "vnode" };
    function yt(...O) {
      return xe(
        (P) => {
          let ye;
          const ze = P;
          try {
            (ze.processor = Je), (ye = Reflect.apply(l1, null, [ze, ...O]));
          } finally {
            ze.processor = null;
          }
          return ye;
        },
        () => Gd(...O),
        "translate",
        (P) => P[Xd](...O),
        (P) => [w1(P)],
        (P) => Xe(P)
      );
    }
    function tt(...O) {
      return xe(
        (P) => Reflect.apply(h1, null, [P, ...O]),
        () => Yd(...O),
        "number format",
        (P) => P[Qd](...O),
        C1,
        (P) => q(P) || Xe(P)
      );
    }
    function Gt(...O) {
      return xe(
        (P) => Reflect.apply(d1, null, [P, ...O]),
        () => Jd(...O),
        "datetime format",
        (P) => P[Zd](...O),
        C1,
        (P) => q(P) || Xe(P)
      );
    }
    function Rn(O) {
      (N = O), (M.pluralRules = N);
    }
    function Er(O, P) {
      return xe(
        () => {
          if (!O) return !1;
          const ye = q(P) ? P : c.value,
            ze = bn(ye),
            or = M.messageResolver(ze, O);
          return a ? or != null : li(or) || Yt(or) || q(or);
        },
        () => [O],
        "translate exists",
        (ye) => Reflect.apply(ye.te, ye, [O, P]),
        $5,
        (ye) => Fe(ye)
      );
    }
    function go(O) {
      let P = null;
      const ye = Jm(M, d.value, c.value);
      for (let ze = 0; ze < ye.length; ze++) {
        const or = f.value[ye[ze]] || {},
          Ji = M.messageResolver(or, O);
        if (Ji != null) {
          P = Ji;
          break;
        }
      }
      return P;
    }
    function nr(O) {
      const P = go(O);
      return P ?? (n ? n.tm(O) || {} : {});
    }
    function bn(O) {
      return f.value[O] || {};
    }
    function yn(O, P) {
      if (i) {
        const ye = { [O]: P };
        for (const ze in ye) xn(ye, ze) && hs(ye[ze]);
        P = ye[O];
      }
      (f.value[O] = P), (M.messages = f.value);
    }
    function rr(O, P) {
      f.value[O] = f.value[O] || {};
      const ye = { [O]: P };
      if (i) for (const ze in ye) xn(ye, ze) && hs(ye[ze]);
      (P = ye[O]), dl(P, f.value[O]), (M.messages = f.value);
    }
    function bo(O) {
      return p.value[O] || {};
    }
    function E(O, P) {
      (p.value[O] = P), (M.datetimeFormats = p.value), p1(M, O, P);
    }
    function A(O, P) {
      (p.value[O] = ht(p.value[O] || {}, P)),
        (M.datetimeFormats = p.value),
        p1(M, O, P);
    }
    function I(O) {
      return h.value[O] || {};
    }
    function W(O, P) {
      (h.value[O] = P), (M.numberFormats = h.value), g1(M, O, P);
    }
    function ve(O, P) {
      (h.value[O] = ht(h.value[O] || {}, P)),
        (M.numberFormats = h.value),
        g1(M, O, P);
    }
    v1++,
      n &&
        sl &&
        (u.watch(n.locale, (O) => {
          l && ((c.value = O), (M.locale = O), fs(M, c.value, d.value));
        }),
        u.watch(n.fallbackLocale, (O) => {
          l && ((d.value = O), (M.fallbackLocale = O), fs(M, c.value, d.value));
        }));
    const te = {
      id: v1,
      locale: B,
      fallbackLocale: H,
      get inheritLocale() {
        return l;
      },
      set inheritLocale(O) {
        (l = O),
          O &&
            n &&
            ((c.value = n.locale.value),
            (d.value = n.fallbackLocale.value),
            fs(M, c.value, d.value));
      },
      get availableLocales() {
        return Object.keys(f.value).sort();
      },
      messages: Q,
      get modifiers() {
        return S;
      },
      get pluralRules() {
        return N || {};
      },
      get isGlobal() {
        return o;
      },
      get missingWarn() {
        return m;
      },
      set missingWarn(O) {
        (m = O), (M.missingWarn = m);
      },
      get fallbackWarn() {
        return g;
      },
      set fallbackWarn(O) {
        (g = O), (M.fallbackWarn = g);
      },
      get fallbackRoot() {
        return b;
      },
      set fallbackRoot(O) {
        b = O;
      },
      get fallbackFormat() {
        return y;
      },
      set fallbackFormat(O) {
        (y = O), (M.fallbackFormat = y);
      },
      get warnHtmlMessage() {
        return v;
      },
      set warnHtmlMessage(O) {
        (v = O), (M.warnHtmlMessage = O);
      },
      get escapeParameter() {
        return C;
      },
      set escapeParameter(O) {
        (C = O), (M.escapeParameter = O);
      },
      t: De,
      getLocaleMessage: bn,
      setLocaleMessage: yn,
      mergeLocaleMessage: rr,
      getPostTranslationHandler: Z,
      setPostTranslationHandler: ce,
      getMissingHandler: Ae,
      setMissingHandler: Ie,
      [I5]: Rn,
    };
    return (
      (te.datetimeFormats = X),
      (te.numberFormats = Y),
      (te.rt = He),
      (te.te = Er),
      (te.tm = nr),
      (te.d = We),
      (te.n = Oe),
      (te.getDateTimeFormat = bo),
      (te.setDateTimeFormat = E),
      (te.mergeDateTimeFormat = A),
      (te.getNumberFormat = I),
      (te.setNumberFormat = W),
      (te.mergeNumberFormat = ve),
      (te[B5] = r),
      (te[Xd] = yt),
      (te[Zd] = Gt),
      (te[Qd] = tt),
      te
    );
  }
  const tf = {
    tag: { type: [String, Object] },
    locale: { type: String },
    scope: {
      type: String,
      validator: (t) => t === "parent" || t === "global",
      default: "parent",
    },
    i18n: { type: Object },
  };
  function H5({ slots: t }, e) {
    return e.length === 1 && e[0] === "default"
      ? (t.default ? t.default() : []).reduce(
          (r, o) => [...r, ...(o.type === u.Fragment ? o.children : [o])],
          []
        )
      : e.reduce((n, r) => {
          const o = t[r];
          return o && (n[r] = o()), n;
        }, Me());
  }
  function S1(t) {
    return u.Fragment;
  }
  const M1 = u.defineComponent({
    name: "i18n-t",
    props: ht(
      {
        keypath: { type: String, required: !0 },
        plural: {
          type: [Number, String],
          validator: (t) => Ye(t) || !isNaN(t),
        },
      },
      tf
    ),
    setup(t, e) {
      const { slots: n, attrs: r } = e,
        o = t.i18n || nf({ useScope: t.scope, __useComponent: !0 });
      return () => {
        const i = Object.keys(n).filter((f) => f !== "_"),
          s = Me();
        t.locale && (s.locale = t.locale),
          t.plural !== void 0 &&
            (s.plural = q(t.plural) ? +t.plural : t.plural);
        const a = H5(e, i),
          l = o[Xd](t.keypath, a, s),
          c = ht(Me(), r),
          d = q(t.tag) || be(t.tag) ? t.tag : S1();
        return u.h(d, c, l);
      };
    },
  });
  function z5(t) {
    return Xe(t) && !q(t[0]);
  }
  function T1(t, e, n, r) {
    const { slots: o, attrs: i } = e;
    return () => {
      const s = { part: !0 };
      let a = Me();
      t.locale && (s.locale = t.locale),
        q(t.format)
          ? (s.key = t.format)
          : be(t.format) &&
            (q(t.format.key) && (s.key = t.format.key),
            (a = Object.keys(t.format).reduce(
              (p, h) => (n.includes(h) ? ht(Me(), p, { [h]: t.format[h] }) : p),
              Me()
            )));
      const l = r(t.value, s, a);
      let c = [s.key];
      Xe(l)
        ? (c = l.map((p, h) => {
            const m = o[p.type],
              g = m ? m({ [p.type]: p.value, index: h, parts: l }) : [p.value];
            return z5(g) && (g[0].key = `${p.type}-${h}`), g;
          }))
        : q(l) && (c = [l]);
      const d = ht(Me(), i),
        f = q(t.tag) || be(t.tag) ? t.tag : S1();
      return u.h(f, d, c);
    };
  }
  const N1 = u.defineComponent({
      name: "i18n-n",
      props: ht(
        {
          value: { type: Number, required: !0 },
          format: { type: [String, Object] },
        },
        tf
      ),
      setup(t, e) {
        const n = t.i18n || nf({ useScope: t.scope, __useComponent: !0 });
        return T1(t, e, m1, (...r) => n[Qd](...r));
      },
    }),
    O1 = u.defineComponent({
      name: "i18n-d",
      props: ht(
        {
          value: { type: [Number, Date], required: !0 },
          format: { type: [String, Object] },
        },
        tf
      ),
      setup(t, e) {
        const n = t.i18n || nf({ useScope: t.scope, __useComponent: !0 });
        return T1(t, e, f1, (...r) => n[Zd](...r));
      },
    });
  function V5(t, e) {
    const n = t;
    if (t.mode === "composition") return n.__getInstance(e) || t.global;
    {
      const r = n.__getInstance(e);
      return r != null ? r.__composer : t.global.__composer;
    }
  }
  function U5(t) {
    const e = (s) => {
      const { instance: a, modifiers: l, value: c } = s;
      if (!a || !a.$) throw vn(Xt.UNEXPECTED_ERROR);
      const d = V5(t, a.$),
        f = R1(c);
      return [Reflect.apply(d.t, d, [...D1(f)]), d];
    };
    return {
      created: (s, a) => {
        const [l, c] = e(a);
        sl &&
          t.global === c &&
          (s.__i18nWatcher = u.watch(c.locale, () => {
            a.instance && a.instance.$forceUpdate();
          })),
          (s.__composer = c),
          (s.textContent = l);
      },
      unmounted: (s) => {
        sl &&
          s.__i18nWatcher &&
          (s.__i18nWatcher(),
          (s.__i18nWatcher = void 0),
          delete s.__i18nWatcher),
          s.__composer && ((s.__composer = void 0), delete s.__composer);
      },
      beforeUpdate: (s, { value: a }) => {
        if (s.__composer) {
          const l = s.__composer,
            c = R1(a);
          s.textContent = Reflect.apply(l.t, l, [...D1(c)]);
        }
      },
      getSSRProps: (s) => {
        const [a] = e(s);
        return { textContent: a };
      },
    };
  }
  function R1(t) {
    if (q(t)) return { path: t };
    if (he(t)) {
      if (!("path" in t)) throw vn(Xt.REQUIRED_VALUE, "path");
      return t;
    } else throw vn(Xt.INVALID_VALUE);
  }
  function D1(t) {
    const { path: e, locale: n, args: r, choice: o, plural: i } = t,
      s = {},
      a = r || {};
    return (
      q(n) && (s.locale = n),
      Ye(o) && (s.plural = o),
      Ye(i) && (s.plural = i),
      [e, a, s]
    );
  }
  function j5(t, e, ...n) {
    const r = he(n[0]) ? n[0] : {},
      o = !!r.useI18nComponentName;
    (Fe(r.globalInstall) ? r.globalInstall : !0) &&
      ([o ? "i18n" : M1.name, "I18nT"].forEach((s) => t.component(s, M1)),
      [N1.name, "I18nN"].forEach((s) => t.component(s, N1)),
      [O1.name, "I18nD"].forEach((s) => t.component(s, O1))),
      t.directive("t", U5(e));
  }
  const W5 = Rr("global-vue-i18n");
  function q5(t = {}, e) {
    const n = Fe(t.globalInjection) ? t.globalInjection : !0,
      r = !0,
      o = new Map(),
      [i, s] = K5(t),
      a = Rr("");
    function l(f) {
      return o.get(f) || null;
    }
    function c(f, p) {
      o.set(f, p);
    }
    function d(f) {
      o.delete(f);
    }
    {
      const f = {
        get mode() {
          return "composition";
        },
        get allowComposition() {
          return r;
        },
        async install(p, ...h) {
          if (
            ((p.__VUE_I18N_SYMBOL__ = a),
            p.provide(p.__VUE_I18N_SYMBOL__, f),
            he(h[0]))
          ) {
            const b = h[0];
            (f.__composerExtend = b.__composerExtend),
              (f.__vueI18nExtend = b.__vueI18nExtend);
          }
          let m = null;
          n && (m = tv(p, f.global)), j5(p, f, ...h);
          const g = p.unmount;
          p.unmount = () => {
            m && m(), f.dispose(), g();
          };
        },
        get global() {
          return s;
        },
        dispose() {
          i.stop();
        },
        __instances: o,
        __getInstance: l,
        __setInstance: c,
        __deleteInstance: d,
      };
      return f;
    }
  }
  function nf(t = {}) {
    const e = u.getCurrentInstance();
    if (e == null) throw vn(Xt.MUST_BE_CALL_SETUP_TOP);
    if (
      !e.isCE &&
      e.appContext.app != null &&
      !e.appContext.app.__VUE_I18N_SYMBOL__
    )
      throw vn(Xt.NOT_INSTALLED);
    const n = G5(e),
      r = Y5(n),
      o = k1(e),
      i = J5(t, o);
    if (i === "global") return P5(r, t, o), r;
    if (i === "parent") {
      let l = X5(n, e, t.__useComponent);
      return l == null && (l = r), l;
    }
    const s = n;
    let a = s.__getInstance(e);
    if (a == null) {
      const l = ht({}, t);
      "__i18n" in o && (l.__i18n = o.__i18n),
        r && (l.__root = r),
        (a = A1(l)),
        s.__composerExtend && (a[ef] = s.__composerExtend(a)),
        Q5(s, e, a),
        s.__setInstance(e, a);
    }
    return a;
  }
  function K5(t, e, n) {
    const r = u.effectScope();
    {
      const o = r.run(() => A1(t));
      if (o == null) throw vn(Xt.UNEXPECTED_ERROR);
      return [r, o];
    }
  }
  function G5(t) {
    {
      const e = u.inject(t.isCE ? W5 : t.appContext.app.__VUE_I18N_SYMBOL__);
      if (!e)
        throw vn(t.isCE ? Xt.NOT_INSTALLED_WITH_PROVIDE : Xt.UNEXPECTED_ERROR);
      return e;
    }
  }
  function J5(t, e) {
    return ll(t)
      ? "__i18n" in e
        ? "local"
        : "global"
      : t.useScope
      ? t.useScope
      : "local";
  }
  function Y5(t) {
    return t.mode === "composition" ? t.global : t.global.__composer;
  }
  function X5(t, e, n = !1) {
    let r = null;
    const o = e.root;
    let i = Z5(e, n);
    for (; i != null; ) {
      const s = t;
      if (
        (t.mode === "composition" && (r = s.__getInstance(i)),
        r != null || o === i)
      )
        break;
      i = i.parent;
    }
    return r;
  }
  function Z5(t, e = !1) {
    return t == null ? null : (e && t.vnode.ctx) || t.parent;
  }
  function Q5(t, e, n) {
    u.onMounted(() => {}, e),
      u.onUnmounted(() => {
        const r = n;
        t.__deleteInstance(e);
        const o = r[ef];
        o && (o(), delete r[ef]);
      }, e);
  }
  const ev = ["locale", "fallbackLocale", "availableLocales"],
    L1 = ["t", "rt", "d", "n", "tm", "te"];
  function tv(t, e) {
    const n = Object.create(null);
    return (
      ev.forEach((o) => {
        const i = Object.getOwnPropertyDescriptor(e, o);
        if (!i) throw vn(Xt.UNEXPECTED_ERROR);
        const s = u.isRef(i.value)
          ? {
              get() {
                return i.value.value;
              },
              set(a) {
                i.value.value = a;
              },
            }
          : {
              get() {
                return i.get && i.get();
              },
            };
        Object.defineProperty(n, o, s);
      }),
      (t.config.globalProperties.$i18n = n),
      L1.forEach((o) => {
        const i = Object.getOwnPropertyDescriptor(e, o);
        if (!i || !i.value) throw vn(Xt.UNEXPECTED_ERROR);
        Object.defineProperty(t.config.globalProperties, `$${o}`, i);
      }),
      () => {
        delete t.config.globalProperties.$i18n,
          L1.forEach((o) => {
            delete t.config.globalProperties[`$${o}`];
          });
      }
    );
  }
  if ((L5(), t5(S5), n5(BC), r5(Jm), __INTLIFY_PROD_DEVTOOLS__)) {
    const t = $d();
    (t.__INTLIFY__ = !0), WC(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const I1 = {
      editor: {
        menus: {
          undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Undo" } },
          redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Redo" } },
          table: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
            add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add table" } },
            add_column_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add column before" },
            },
            add_column_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add column after" },
            },
            delete_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Delete column" },
            },
            add_row_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add row before" },
            },
            add_row_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add row after" },
            },
            toggle_header_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Column Header" },
            },
            toggle_header_row: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Row Header" },
            },
            toggle_header_cell: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Set/Unset Current Cell as Header" },
            },
            delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete row" } },
            merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Merge cells" } },
            split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Split cell" } },
            delete_table: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Delete table" },
            },
          },
        },
        extensions: {
          commands_menu: {
            columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Column Card" } },
            iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Iframe" } },
            image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "image" } },
            video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Video" } },
            audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Audio" } },
            table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
            no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No results" } },
            placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Enter / to select input type" },
            },
          },
          link: {
            add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add link" } },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
            placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Link address" },
            },
            open_in_new_window: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Open in new window" },
            },
            cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cancel link" } },
          },
          audio: {
            disable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" },
            },
            enable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" },
            },
            disable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Disable loop" },
            },
            enable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Disable loop" },
            },
          },
          iframe: {
            disable_frameborder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Hide frameborder" },
            },
            enable_frameborder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Show frameborder" },
            },
            phone_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Mobile phone size" },
            },
            tablet_vertical_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Tablet portrait size" },
            },
            tablet_horizontal_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Tablet landscape size" },
            },
            desktop_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Desktop size" },
            },
          },
          image: {
            small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
            medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
            large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } },
            restore_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Restore original size" },
            },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
            edit_alt: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit alt" } },
            edit_href: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Edit the image hyperlink" },
            },
          },
          video: {
            disable_controls: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Hide controls" },
            },
            enable_controls: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Show controls" },
            },
            disable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" },
            },
            enable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" },
            },
            disable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Disable loop" },
            },
            enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enable loop" } },
            small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
            medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
            large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } },
          },
          highlight: {
            unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Unset" } },
          },
          columns: {
            add_column_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add column before" },
            },
            add_column_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Add column after" },
            },
            delete_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Delete column" },
            },
          },
          search_and_replace: {
            title: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Search and Replace" },
            },
            search_placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Search" },
            },
            not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Not Found" } },
            occurrence_found: {
              t: 0,
              b: {
                t: 2,
                i: [
                  { t: 4, k: "index" },
                  { t: 3, v: " of " },
                  { t: 4, k: "total" },
                  { t: 3, v: " occurrences" },
                ],
              },
            },
            find_previous: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Find Previous" },
            },
            find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Find Next" } },
            replace_placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Replace" },
            },
            replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace" } },
            replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace All" } },
            case_sensitive: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Case Sensitive" },
            },
            match_word: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Match Whole Word" },
            },
            use_regex: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Use Regular Expression" },
            },
            close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Close" } },
          },
          format_brush: {
            toolbar_item: {
              title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Format Brush" } },
              cancel: {
                t: 0,
                b: { t: 2, i: [{ t: 3 }], s: "Cancel Format Brush" },
              },
            },
          },
        },
        components: {
          color_picker: {
            more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "More" } },
          },
        },
        common: {
          align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align method" } },
          align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align left" } },
          align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align center" } },
          align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align right" } },
          align_justify: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Align justify" },
          },
          bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bold" } },
          italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Italic" } },
          underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Underline" } },
          strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Strike" } },
          quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quote" } },
          code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code" } },
          superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Super Script" } },
          subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sub Script" } },
          codeblock: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code block" } },
            copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Copy code" } },
            copy_code_success: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Copy success" },
            },
          },
          image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image" } },
          heading: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Text type" } },
            paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Paragraph" } },
            header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 1" } },
            header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 2" } },
            header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 3" } },
            header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 4" } },
            header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 5" } },
            header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 6" } },
          },
          bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bullet list" } },
          ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ordered list" } },
          task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Task list" } },
          highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Highlight" } },
          color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Color" } },
          tooltip: {
            custom_width_input: {
              t: 0,
              b: {
                t: 2,
                i: [{ t: 3 }],
                s: "Custom width, press Enter to take effect",
              },
            },
            custom_height_input: {
              t: 0,
              b: {
                t: 2,
                i: [{ t: 3 }],
                s: "Customize height, press Enter to take effect",
              },
            },
            open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Open link" } },
          },
          placeholder: {
            link_input: {
              t: 0,
              b: {
                t: 2,
                i: [{ t: 3 }],
                s: "Enter the link and press enter to confirm.",
              },
            },
            alt_input: {
              t: 0,
              b: {
                t: 2,
                i: [{ t: 3 }],
                s: "Enter the image alt and press enter to confirm.",
              },
            },
            alt_href: {
              t: 0,
              b: {
                t: 2,
                i: [{ t: 3 }],
                s: "Enter the image hyperlink and press enter to confirm.",
              },
            },
          },
          button: {
            new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "New line" } },
            delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
            refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Refresh" } },
            restore_default: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Restore default" },
            },
          },
          text: { default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Default" } } },
          line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Line height" } },
          clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear format" } },
        },
      },
    },
    B1 = {
      editor: {
        menus: {
          undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "撤销" } },
          redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "恢复" } },
          table: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "表格" } },
            add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "插入表格" } },
            add_column_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向前插入列" },
            },
            add_column_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向后插入列" },
            },
            delete_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "删除当前列" },
            },
            add_row_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向上插入行" },
            },
            add_row_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向下插入行" },
            },
            toggle_header_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "设置/取消首列表头" },
            },
            toggle_header_row: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "设置/取消首行表头" },
            },
            toggle_header_cell: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "设置/取消当前单元格为表头" },
            },
            delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "删除当前行" } },
            merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "合并单元格" } },
            split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "分割单元格" } },
            delete_table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "删除表格" } },
          },
        },
        extensions: {
          commands_menu: {
            columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "分栏卡片" } },
            iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "嵌入网页" } },
            image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "图片" } },
            video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "视频" } },
            audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "音频" } },
            table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "表格" } },
            no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "没有搜索结果" } },
            placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "输入 / 以选择输入类型" },
            },
          },
          link: {
            add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "添加链接" } },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "修改链接" } },
            placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "链接地址" } },
            open_in_new_window: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "在新窗口中打开" },
            },
            cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "取消链接" } },
          },
          audio: {
            disable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "关闭自动播放" },
            },
            enable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "开启自动播放" },
            },
            disable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "关闭循环播放" },
            },
            enable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "开启循环播放" },
            },
          },
          iframe: {
            disable_frameborder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "取消边框" },
            },
            enable_frameborder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "设置边框" },
            },
            phone_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "手机尺寸" } },
            tablet_vertical_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "平板电脑纵向尺寸" },
            },
            tablet_horizontal_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "平板电脑横向尺寸" },
            },
            desktop_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "桌面电脑尺寸" },
            },
          },
          image: {
            small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "小尺寸" } },
            medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "中尺寸" } },
            large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "大尺寸" } },
            restore_size: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "恢复原始尺寸" },
            },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "修改链接" } },
            edit_alt: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "修改图片 alt 属性" },
            },
            edit_href: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "修改图片跳转链接" },
            },
          },
          video: {
            disable_controls: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "隐藏控制面板" },
            },
            enable_controls: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "显示控制面板" },
            },
            disable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "关闭自动播放" },
            },
            enable_autoplay: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "开启自动播放" },
            },
            disable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "关闭循环播放" },
            },
            enable_loop: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "开启循环播放" },
            },
            small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "小尺寸" } },
            medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "中尺寸" } },
            large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "大尺寸" } },
          },
          highlight: {
            unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "移除高亮颜色" } },
          },
          columns: {
            add_column_before: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向前插入列" },
            },
            add_column_after: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "向后插入列" },
            },
            delete_column: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "删除当前列" },
            },
          },
          search_and_replace: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "查找替换" } },
            search_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "查找" } },
            not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "无结果" } },
            occurrence_found: {
              t: 0,
              b: {
                t: 2,
                i: [
                  { t: 3, v: "第 " },
                  { t: 4, k: "index" },
                  { t: 3, v: " 项，共 " },
                  { t: 4, k: "total" },
                  { t: 3, v: " 项" },
                ],
              },
            },
            find_previous: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "上一个匹配项" },
            },
            find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "下一个匹配项" } },
            replace_placeholder: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "替换" },
            },
            replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "替换" } },
            replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "全部替换" } },
            case_sensitive: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "区分大小写" },
            },
            match_word: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "全字匹配" } },
            use_regex: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "使用正则表达式" },
            },
            close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "关闭" } },
          },
          format_brush: {
            toolbar_item: {
              title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "格式刷" } },
              cancel: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "取消格式刷" } },
            },
          },
        },
        components: {
          color_picker: {
            more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "更多颜色" } },
          },
        },
        common: {
          align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "对齐方式" } },
          align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "左对齐" } },
          align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "居中" } },
          align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "右对齐" } },
          align_justify: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "两端对齐" } },
          bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "粗体" } },
          italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "斜体" } },
          underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "下划线" } },
          strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "删除线" } },
          quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "引用" } },
          code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "行内代码" } },
          superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "上角标" } },
          subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "下角标" } },
          codeblock: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "代码块" } },
            copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "复制代码" } },
            copy_code_success: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "复制成功" },
            },
          },
          image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "图片" } },
          heading: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "文本类型" } },
            paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "普通文本" } },
            header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "一级标题" } },
            header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "二级标题" } },
            header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "三级标题" } },
            header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "四级标题" } },
            header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "五级标题" } },
            header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "六级标题" } },
          },
          bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "无序列表" } },
          ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "有序列表" } },
          task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "任务列表" } },
          highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "高亮" } },
          color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "字体颜色" } },
          tooltip: {
            custom_width_input: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "自定义宽度，按回车键生效" },
            },
            custom_height_input: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "自定义高度，按回车键生效" },
            },
            open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "打开链接" } },
          },
          placeholder: {
            link_input: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "输入链接，按回车确定" },
            },
            alt_input: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "输入图片 alt 属性值，按回车确认" },
            },
            alt_href: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "输入图片跳转链接，按回车确认" },
            },
          },
          button: {
            new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "换行" } },
            delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "删除" } },
            edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "修改链接" } },
            refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "刷新" } },
            restore_default: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "恢复为默认" },
            },
          },
          text: { default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "默认" } } },
          line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "行高" } },
          clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "清除格式" } },
        },
      },
    },
    T = q5({
      legacy: !1,
      locale: "en",
      fallbackLocale: "zh-CN",
      messages: { en: I1, zh: B1, "en-US": I1, "zh-CN": B1 },
    }),
    nv = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function rv(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        nv,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M20 10.5a6.5 6.5 0 0 1-6.5 6.5H7.83l3.09 3.09L9.5 21.5L4 16l5.5-5.5l1.41 1.41L7.83 15h5.67c2.5 0 4.5-2 4.5-4.5S16 6 13.5 6H6V4h7.5a6.5 6.5 0 0 1 6.5 6.5",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const ov = u.markRaw({ name: "mdi-arrow-u-left-bottom", render: rv }),
    iv = { class: "editor-block__content" },
    sv = { class: "editor-block__actions" },
    av = u.defineComponent({
      __name: "BlockCard",
      props: {
        selected: { type: Boolean, default: !1 },
        editor: {},
        getPos: {},
        deleteNode: {},
      },
      setup(t) {
        const e = t;
        function n() {
          e.editor.commands.insertContentAt(
            e.getPos() + 1,
            [{ type: "paragraph", content: "" }],
            { updateSelection: !0 }
          ),
            e.editor.commands.focus(e.getPos() + 2, { scrollIntoView: !0 });
        }
        return (r, o) => (
          u.openBlock(),
          u.createElementBlock(
            "section",
            {
              class: u.normalizeClass([
                "editor-block group",
                { "editor-block--selected": r.selected },
              ]),
            },
            [
              u.createElementVNode("div", iv, [
                u.renderSlot(r.$slots, "content"),
              ]),
              u.createElementVNode(
                "div",
                {
                  class: u.normalizeClass([
                    "invisible group-hover:visible pb-2 absolute -top-12 right-0",
                    { "!visible": r.selected },
                  ]),
                },
                [
                  u.createElementVNode("div", sv, [
                    u.renderSlot(r.$slots, "actions"),
                    u.createVNode(
                      Eo,
                      {
                        tooltip: u
                          .unref(T)
                          .global.t("editor.common.button.new_line"),
                        onClick: n,
                      },
                      {
                        icon: u.withCtx(() => [u.createVNode(u.unref(ov))]),
                        _: 1,
                      },
                      8,
                      ["tooltip"]
                    ),
                    u.createVNode(Ve),
                    u.createVNode(
                      Eo,
                      {
                        tooltip: u
                          .unref(T)
                          .global.t("editor.common.button.delete"),
                        onClick: r.deleteNode,
                      },
                      { icon: u.withCtx(() => [u.createVNode(So)]), _: 1 },
                      8,
                      ["tooltip", "onClick"]
                    ),
                  ]),
                ],
                2
              ),
            ],
            2
          )
        );
      },
    }),
    lv = ["title"],
    cv = {
      class:
        "relative rounded-md bg-white overflow-hidden shadow w-96 p-1 max-h-72 overflow-y-auto",
    },
    bl = u.defineComponent({
      __name: "BubbleItem",
      props: {
        editor: {},
        isActive: { type: Function, default: () => !1 },
        visible: { type: Function, default: () => !0 },
        icon: { default: void 0 },
        iconStyle: { default: void 0 },
        title: { default: void 0 },
        action: { type: Function, default: void 0 },
      },
      setup(t) {
        const e = t,
          n = u.ref(),
          r = (o) => {
            var s;
            if (!e.action) return;
            const i =
              (s = e.action) == null ? void 0 : s.call(e, { editor: o });
            typeof i == "object" && (n.value = i);
          };
        return (o, i) => (
          u.openBlock(),
          u.createBlock(
            u.unref(vo),
            {
              class: "inline-flex",
              triggers: [],
              "auto-hide": !0,
              shown: !!n.value,
              distance: 10,
              onHide: i[1] || (i[1] = (s) => (n.value = void 0)),
            },
            {
              popper: u.withCtx(() => [
                u.createElementVNode("div", cv, [
                  (u.openBlock(),
                  u.createBlock(
                    u.KeepAlive,
                    null,
                    [
                      (u.openBlock(),
                      u.createBlock(
                        u.resolveDynamicComponent(n.value),
                        u.normalizeProps(u.guardReactiveProps(e)),
                        null,
                        16
                      )),
                    ],
                    1024
                  )),
                ]),
              ]),
              default: u.withCtx(() => [
                o.visible({ editor: o.editor })
                  ? u.withDirectives(
                      (u.openBlock(),
                      u.createElementBlock(
                        "button",
                        {
                          key: 0,
                          class: u.normalizeClass([
                            {
                              "bg-gray-200 !text-black": o.isActive({
                                editor: o.editor,
                              }),
                            },
                            "text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md",
                          ]),
                          title: o.title,
                          onClick: i[0] || (i[0] = (s) => r(o.editor)),
                        },
                        [
                          (u.openBlock(),
                          u.createBlock(
                            u.resolveDynamicComponent(o.icon),
                            {
                              style: u.normalizeStyle(o.iconStyle),
                              class: "w-5 h-5",
                            },
                            null,
                            8,
                            ["style"]
                          )),
                        ],
                        10,
                        lv
                      )),
                      [
                        [
                          u.unref(us),
                          { content: o.title, distance: 8, delay: { show: 0 } },
                        ],
                      ]
                    )
                  : u.createCommentVNode("", !0),
              ]),
              _: 1,
            },
            8,
            ["shown"]
          )
        );
      },
    });
  function rf(t, e, n, r) {
    for (let o = 0, i = 0; o < t.childCount; o++) {
      let s = t.child(o),
        a = i + s.nodeSize,
        l = Math.max(i, e),
        c = Math.min(a, n);
      if (l < c)
        if (s.isText)
          for (let d = l; d < c; d++) r.push(s.text.charCodeAt(d - i));
        else
          s.isLeaf
            ? r.push(s.type.name)
            : (l == i && r.push(s.type.name),
              rf(
                s.content,
                Math.max(i + 1, l) - i - 1,
                Math.min(a - 1, c) - i - 1,
                r
              ),
              c == a && r.push(-1));
      i = a;
    }
    return r;
  }
  const uv = 5e3;
  function dv(t, e) {
    return Math.min(15, Math.max(2, Math.floor(Math.max(t, e) / 10)));
  }
  function P1(t, e, n) {
    let r = rf(t, n.fromA, n.toA, []),
      o = rf(e, n.fromB, n.toB, []),
      i = 0,
      s = r.length,
      a = o.length;
    for (; i < r.length && i < o.length && r[i] === o[i]; ) i++;
    if (i == r.length && i == o.length) return [];
    for (; s > i && a > i && r[s - 1] === o[a - 1]; ) s--, a--;
    if (s == i || a == i || (s == a && s == i + 1))
      return [n.slice(i, s, i, a)];
    let l = s - i,
      c = a - i,
      d = Math.min(uv, l + c),
      f = d + 1,
      p = [],
      h = [];
    for (let m = f * 2, g = 0; g < m; g++) h[g] = -1;
    for (let m = 0; m <= d; m++) {
      for (let g = -m; g <= m; g += 2) {
        let b = h[g + 1 + d],
          y = h[g - 1 + d],
          x = b < y ? y : b + 1,
          w = x + g;
        for (; x < l && w < c && r[i + x] === o[i + w]; ) x++, w++;
        if (((h[g + d] = x), x >= l && w >= c)) {
          let _ = [],
            v = dv(s - i, a - i),
            C = -1,
            S = -1,
            N = -1,
            M = -1,
            L = ($, B, H, Q) => {
              C > -1 && C < B + v
                ? ((C = $), (N = H))
                : (C > -1 && _.push(n.slice(C, S, N, M)),
                  (C = $),
                  (S = B),
                  (N = H),
                  (M = Q));
            };
          for (let $ = m - 1; $ >= 0; $--) {
            let B = h[g + 1 + d],
              H = h[g - 1 + d];
            B < H
              ? (g--, (x = H + i), (w = x + g), L(x, x, w, w + 1))
              : (g++, (x = B + i), (w = x + g), L(x, x + 1, w, w)),
              (h = p[$ >> 1]);
          }
          return C > -1 && _.push(n.slice(C, S, N, M)), _.reverse();
        }
      }
      m % 2 == 0 && p.push(h.slice());
    }
    return [n.slice(i, s, i, a)];
  }
  class Ce {
    constructor(e, n) {
      (this.length = e), (this.data = n);
    }
    cut(e) {
      return e == this.length ? this : new Ce(e, this.data);
    }
    static slice(e, n, r) {
      if (n == r) return Ce.none;
      if (n == 0 && r == Ce.len(e)) return e;
      let o = [];
      for (let i = 0, s = 0; s < r; i++) {
        let a = e[i],
          l = s + a.length,
          c = Math.min(r, l) - Math.max(n, s);
        c > 0 && o.push(a.cut(c)), (s = l);
      }
      return o;
    }
    static join(e, n, r) {
      if (e.length == 0) return n;
      if (n.length == 0) return e;
      let o = r(e[e.length - 1].data, n[0].data);
      if (o == null) return e.concat(n);
      let i = e.slice(0, e.length - 1);
      i.push(new Ce(e[e.length - 1].length + n[0].length, o));
      for (let s = 1; s < n.length; s++) i.push(n[s]);
      return i;
    }
    static len(e) {
      let n = 0;
      for (let r = 0; r < e.length; r++) n += e[r].length;
      return n;
    }
  }
  Ce.none = [];
  class Zt {
    constructor(e, n, r, o, i, s) {
      (this.fromA = e),
        (this.toA = n),
        (this.fromB = r),
        (this.toB = o),
        (this.deleted = i),
        (this.inserted = s);
    }
    get lenA() {
      return this.toA - this.fromA;
    }
    get lenB() {
      return this.toB - this.fromB;
    }
    slice(e, n, r, o) {
      return e == 0 &&
        r == 0 &&
        n == this.toA - this.fromA &&
        o == this.toB - this.fromB
        ? this
        : new Zt(
            this.fromA + e,
            this.fromA + n,
            this.fromB + r,
            this.fromB + o,
            Ce.slice(this.deleted, e, n),
            Ce.slice(this.inserted, r, o)
          );
    }
    static merge(e, n, r) {
      if (e.length == 0) return n;
      if (n.length == 0) return e;
      let o = [];
      for (let i = 0, s = 0, a = e[0], l = n[0]; ; ) {
        if (!a && !l) return o;
        if (a && (!l || a.toB < l.fromA)) {
          let c = s ? n[s - 1].toB - n[s - 1].toA : 0;
          o.push(
            c == 0
              ? a
              : new Zt(
                  a.fromA,
                  a.toA,
                  a.fromB + c,
                  a.toB + c,
                  a.deleted,
                  a.inserted
                )
          ),
            (a = i++ == e.length ? null : e[i]);
        } else if (l && (!a || l.toA < a.fromB)) {
          let c = i ? e[i - 1].toB - e[i - 1].toA : 0;
          o.push(
            c == 0
              ? l
              : new Zt(
                  l.fromA - c,
                  l.toA - c,
                  l.fromB,
                  l.toB,
                  l.deleted,
                  l.inserted
                )
          ),
            (l = s++ == n.length ? null : n[s]);
        } else {
          let c = Math.min(a.fromB, l.fromA),
            d = Math.min(
              a.fromA,
              l.fromA - (i ? e[i - 1].toB - e[i - 1].toA : 0)
            ),
            f = d,
            p = Math.min(
              l.fromB,
              a.fromB + (s ? n[s - 1].toB - n[s - 1].toA : 0)
            ),
            h = p,
            m = Ce.none,
            g = Ce.none,
            b = !1,
            y = !1;
          for (;;) {
            let x = a ? (c >= a.fromB ? a.toB : a.fromB) : 2e8,
              w = l ? (c >= l.fromA ? l.toA : l.fromA) : 2e8,
              _ = Math.min(x, w),
              v = a && c >= a.fromB,
              C = l && c >= l.fromA;
            if (!v && !C) break;
            v &&
              c == a.fromB &&
              !b &&
              ((m = Ce.join(m, a.deleted, r)), (f += a.lenA), (b = !0)),
              v &&
                !C &&
                ((g = Ce.join(
                  g,
                  Ce.slice(a.inserted, c - a.fromB, _ - a.fromB),
                  r
                )),
                (h += _ - c)),
              C &&
                c == l.fromA &&
                !y &&
                ((g = Ce.join(g, l.inserted, r)), (h += l.lenB), (y = !0)),
              C &&
                !v &&
                ((m = Ce.join(
                  m,
                  Ce.slice(l.deleted, c - l.fromA, _ - l.fromA),
                  r
                )),
                (f += _ - c)),
              v &&
                _ == a.toB &&
                ((a = i++ == e.length ? null : e[i]), (b = !1)),
              C &&
                _ == l.toA &&
                ((l = s++ == n.length ? null : n[s]), (y = !1)),
              (c = _);
          }
          (d < f || p < h) && o.push(new Zt(d, f, p, h, m, g));
        }
      }
    }
  }
  let of;
  try {
    of = new RegExp("[\\p{Alphabetic}_]", "u");
  } catch {}
  const fv =
    /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function ci(t) {
    if (t < 128)
      return (
        (t >= 48 && t <= 57) || (t >= 65 && t <= 90) || (t >= 79 && t <= 122)
      );
    let e = String.fromCharCode(t);
    return of ? of.test(e) : e.toUpperCase() != e.toLowerCase() || fv.test(e);
  }
  function pv(t, e, n) {
    let r = "";
    function o(i, s, a) {
      for (let l = 0, c = 0; l < i.childCount; l++) {
        let d = i.child(l),
          f = c + d.nodeSize,
          p = Math.max(c, s),
          h = Math.min(f, a);
        p < h &&
          (d.isText
            ? (r += d.text.slice(
                Math.max(0, s - c),
                Math.min(d.text.length, a - c)
              ))
            : d.isLeaf
            ? (r += " ")
            : (p == c && (r += " "),
              o(
                d.content,
                Math.max(0, p - c - 1),
                Math.min(d.content.size, a - c)
              ),
              h == f && (r += " "))),
          (c = f);
      }
    }
    return o(t, e, n), r;
  }
  const sf = 30;
  function hv(t, e) {
    let n = [];
    for (let r = 0; r < t.length; r++) {
      let o = t[r].toB,
        i = r;
      for (; r < t.length - 1 && t[r + 1].fromB <= o + sf; ) o = t[++r].toB;
      mv(t, i, r + 1, e, n);
    }
    return n;
  }
  function mv(t, e, n, r, o) {
    let i = Math.max(0, t[e].fromB - sf),
      s = Math.min(r.content.size, t[n - 1].toB + sf),
      a = pv(r.content, i, s);
    for (let l = e; l < n; l++) {
      let c = l,
        d = t[l],
        f = d.lenA,
        p = d.lenB;
      for (; l < n - 1; ) {
        let h = t[l + 1],
          m = !1,
          g = d.toB == s ? !1 : ci(a.charCodeAt(d.toB - 1 - i));
        for (let b = d.toB; !m && b < h.fromB; b++) {
          let y = b == s ? !1 : ci(a.charCodeAt(b - i));
          (!g || !y) && b != t[c].fromB && (m = !0), (g = y);
        }
        if (m) break;
        (f += h.lenA), (p += h.lenB), (d = h), l++;
      }
      if (p > 0 && f > 0 && !(p == 1 && f == 1)) {
        let h = t[c].fromB,
          m = t[l].toB;
        if (h < s && ci(a.charCodeAt(h - i)))
          for (; h > i && ci(a.charCodeAt(h - 1 - i)); ) h--;
        if (m > i && ci(a.charCodeAt(m - 1 - i)))
          for (; m < s && ci(a.charCodeAt(m - i)); ) m++;
        let g = gv(t.slice(c, l + 1), h, m),
          b = o.length ? o[o.length - 1] : null;
        b && b.toA == g.fromA
          ? (o[o.length - 1] = new Zt(
              b.fromA,
              g.toA,
              b.fromB,
              g.toB,
              b.deleted.concat(g.deleted),
              b.inserted.concat(g.inserted)
            ))
          : o.push(g);
      } else for (let h = c; h <= l; h++) o.push(t[h]);
    }
    return t;
  }
  function yl(t, e) {
    return t === e ? t : null;
  }
  function gv(t, e, n) {
    let r = t[0].fromA - (t[0].fromB - e),
      o = t[t.length - 1],
      i = o.toA + (n - o.toB),
      s = Ce.none,
      a = Ce.none,
      l = (t[0].deleted.length ? t[0].deleted : t[0].inserted)[0].data,
      c = (t[0].inserted.length ? t[0].inserted : t[0].deleted)[0].data;
    for (let d = r, f = e, p = 0; ; p++) {
      let h = p == t.length ? null : t[p],
        m = h ? h.fromA : i,
        g = h ? h.fromB : n;
      if (
        (m > d && (s = Ce.join(s, [new Ce(m - d, l)], yl)),
        g > f && (a = Ce.join(a, [new Ce(g - f, c)], yl)),
        !h)
      )
        break;
      (s = Ce.join(s, h.deleted, yl)),
        (a = Ce.join(a, h.inserted, yl)),
        s.length && (l = s[s.length - 1].data),
        a.length && (c = a[a.length - 1].data),
        (d = h.toA),
        (f = h.toB);
    }
    return new Zt(r, i, e, n, s, a);
  }
  class ui {
    constructor(e, n) {
      (this.config = e), (this.changes = n);
    }
    addSteps(e, n, r) {
      let o = [];
      for (let l = 0; l < n.length; l++) {
        let c = Array.isArray(r) ? r[l] : r,
          d = 0;
        n[l].forEach((f, p, h, m) => {
          o.push(
            new Zt(
              f + d,
              p + d,
              h,
              m,
              f == p ? Ce.none : [new Ce(p - f, c)],
              h == m ? Ce.none : [new Ce(m - h, c)]
            )
          ),
            (d = m - h - (p - f));
        });
      }
      if (o.length == 0) return this;
      let i = af(o, this.config.combine),
        s = Zt.merge(this.changes, i, this.config.combine),
        a = s;
      for (let l = 0; l < a.length; l++) {
        let c = a[l];
        if (
          c.fromA == c.toA ||
          c.fromB == c.toB ||
          !i.some((f) => f.toB > c.fromB && f.fromB < c.toB)
        )
          continue;
        let d = P1(this.config.doc.content, e.content, c);
        (d.length == 1 && d[0].fromB == 0 && d[0].toB == c.toB - c.fromB) ||
          (a == s && (a = s.slice()),
          d.length == 1
            ? (a[l] = d[0])
            : (a.splice(l, 1, ...d), (l += d.length - 1)));
      }
      return new ui(this.config, a);
    }
    get startDoc() {
      return this.config.doc;
    }
    map(e) {
      let n = (r) => {
        let o = e(r);
        return o === r.data ? r : new Ce(r.length, o);
      };
      return new ui(
        this.config,
        this.changes.map(
          (r) =>
            new Zt(
              r.fromA,
              r.toA,
              r.fromB,
              r.toB,
              r.deleted.map(n),
              r.inserted.map(n)
            )
        )
      );
    }
    changedRange(e, n) {
      if (e == this) return null;
      let r = n && bv(n),
        o = r ? r.toB - r.fromB - (r.toA - r.fromA) : 0;
      function i(f) {
        return !r || f <= r.fromA ? f : f + o;
      }
      let s = r ? r.fromB : 2e8,
        a = r ? r.toB : -2e8;
      function l(f, p = f) {
        (s = Math.min(f, s)), (a = Math.max(p, a));
      }
      let c = this.changes,
        d = e.changes;
      for (let f = 0, p = 0; f < c.length && p < d.length; ) {
        let h = c[f],
          m = d[p];
        h && m && yv(h, m, i)
          ? (f++, p++)
          : m && (!h || i(h.fromB) >= m.fromB)
          ? (l(m.fromB, m.toB), p++)
          : (l(i(h.fromB), i(h.toB)), f++);
      }
      return s <= a ? { from: s, to: a } : null;
    }
    static create(e, n = (r, o) => (r === o ? r : null)) {
      return new ui({ combine: n, doc: e }, []);
    }
  }
  ui.computeDiff = P1;
  function af(t, e, n = 0, r = t.length) {
    if (r == n + 1) return [t[n]];
    let o = (n + r) >> 1;
    return Zt.merge(af(t, e, n, o), af(t, e, o, r), e);
  }
  function $1(t) {
    let e = 2e8,
      n = -2e8;
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      e != 2e8 && ((e = o.map(e, -1)), (n = o.map(n, 1))),
        o.forEach((i, s, a, l) => {
          (e = Math.min(e, a)), (n = Math.max(n, l));
        });
    }
    return e == 2e8 ? null : { from: e, to: n };
  }
  function bv(t) {
    let e = $1(t);
    if (!e) return null;
    let n = $1(t.map((r) => r.invert()).reverse());
    return { fromA: n.from, toA: n.to, fromB: e.from, toB: e.to };
  }
  function yv(t, e, n) {
    return (
      n(t.fromB) == e.fromB &&
      n(t.toB) == e.toB &&
      F1(t.deleted, e.deleted) &&
      F1(t.inserted, e.inserted)
    );
  }
  function F1(t, e) {
    if (t.length != e.length) return !1;
    for (let n = 0; n < t.length; n++)
      if (t[n].length != e[n].length || t[n].data !== e[n].data) return !1;
    return !0;
  }
  function ot(t) {
    this.content = t;
  }
  (ot.prototype = {
    constructor: ot,
    find: function (t) {
      for (var e = 0; e < this.content.length; e += 2)
        if (this.content[e] === t) return e;
      return -1;
    },
    get: function (t) {
      var e = this.find(t);
      return e == -1 ? void 0 : this.content[e + 1];
    },
    update: function (t, e, n) {
      var r = n && n != t ? this.remove(n) : this,
        o = r.find(t),
        i = r.content.slice();
      return (
        o == -1 ? i.push(n || t, e) : ((i[o + 1] = e), n && (i[o] = n)),
        new ot(i)
      );
    },
    remove: function (t) {
      var e = this.find(t);
      if (e == -1) return this;
      var n = this.content.slice();
      return n.splice(e, 2), new ot(n);
    },
    addToStart: function (t, e) {
      return new ot([t, e].concat(this.remove(t).content));
    },
    addToEnd: function (t, e) {
      var n = this.remove(t).content.slice();
      return n.push(t, e), new ot(n);
    },
    addBefore: function (t, e, n) {
      var r = this.remove(e),
        o = r.content.slice(),
        i = r.find(t);
      return o.splice(i == -1 ? o.length : i, 0, e, n), new ot(o);
    },
    forEach: function (t) {
      for (var e = 0; e < this.content.length; e += 2)
        t(this.content[e], this.content[e + 1]);
    },
    prepend: function (t) {
      return (
        (t = ot.from(t)),
        t.size ? new ot(t.content.concat(this.subtract(t).content)) : this
      );
    },
    append: function (t) {
      return (
        (t = ot.from(t)),
        t.size ? new ot(this.subtract(t).content.concat(t.content)) : this
      );
    },
    subtract: function (t) {
      var e = this;
      t = ot.from(t);
      for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n]);
      return e;
    },
    toObject: function () {
      var t = {};
      return (
        this.forEach(function (e, n) {
          t[e] = n;
        }),
        t
      );
    },
    get size() {
      return this.content.length >> 1;
    },
  }),
    (ot.from = function (t) {
      if (t instanceof ot) return t;
      var e = [];
      if (t) for (var n in t) e.push(n, t[n]);
      return new ot(e);
    });
  function H1(t, e, n) {
    for (let r = 0; ; r++) {
      if (r == t.childCount || r == e.childCount)
        return t.childCount == e.childCount ? null : n;
      let o = t.child(r),
        i = e.child(r);
      if (o == i) {
        n += o.nodeSize;
        continue;
      }
      if (!o.sameMarkup(i)) return n;
      if (o.isText && o.text != i.text) {
        for (let s = 0; o.text[s] == i.text[s]; s++) n++;
        return n;
      }
      if (o.content.size || i.content.size) {
        let s = H1(o.content, i.content, n + 1);
        if (s != null) return s;
      }
      n += o.nodeSize;
    }
  }
  function z1(t, e, n, r) {
    for (let o = t.childCount, i = e.childCount; ; ) {
      if (o == 0 || i == 0) return o == i ? null : { a: n, b: r };
      let s = t.child(--o),
        a = e.child(--i),
        l = s.nodeSize;
      if (s == a) {
        (n -= l), (r -= l);
        continue;
      }
      if (!s.sameMarkup(a)) return { a: n, b: r };
      if (s.isText && s.text != a.text) {
        let c = 0,
          d = Math.min(s.text.length, a.text.length);
        for (
          ;
          c < d &&
          s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1];

        )
          c++, n--, r--;
        return { a: n, b: r };
      }
      if (s.content.size || a.content.size) {
        let c = z1(s.content, a.content, n - 1, r - 1);
        if (c) return c;
      }
      (n -= l), (r -= l);
    }
  }
  class D {
    constructor(e, n) {
      if (((this.content = e), (this.size = n || 0), n == null))
        for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
    }
    nodesBetween(e, n, r, o = 0, i) {
      for (let s = 0, a = 0; a < n; s++) {
        let l = this.content[s],
          c = a + l.nodeSize;
        if (c > e && r(l, o + a, i || null, s) !== !1 && l.content.size) {
          let d = a + 1;
          l.nodesBetween(
            Math.max(0, e - d),
            Math.min(l.content.size, n - d),
            r,
            o + d
          );
        }
        a = c;
      }
    }
    descendants(e) {
      this.nodesBetween(0, this.size, e);
    }
    textBetween(e, n, r, o) {
      let i = "",
        s = !0;
      return (
        this.nodesBetween(
          e,
          n,
          (a, l) => {
            let c = a.isText
              ? a.text.slice(Math.max(e, l) - l, n - l)
              : a.isLeaf
              ? o
                ? typeof o == "function"
                  ? o(a)
                  : o
                : a.type.spec.leafText
                ? a.type.spec.leafText(a)
                : ""
              : "";
            a.isBlock &&
              ((a.isLeaf && c) || a.isTextblock) &&
              r &&
              (s ? (s = !1) : (i += r)),
              (i += c);
          },
          0
        ),
        i
      );
    }
    append(e) {
      if (!e.size) return this;
      if (!this.size) return e;
      let n = this.lastChild,
        r = e.firstChild,
        o = this.content.slice(),
        i = 0;
      for (
        n.isText &&
        n.sameMarkup(r) &&
        ((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
        i < e.content.length;
        i++
      )
        o.push(e.content[i]);
      return new D(o, this.size + e.size);
    }
    cut(e, n = this.size) {
      if (e == 0 && n == this.size) return this;
      let r = [],
        o = 0;
      if (n > e)
        for (let i = 0, s = 0; s < n; i++) {
          let a = this.content[i],
            l = s + a.nodeSize;
          l > e &&
            ((s < e || l > n) &&
              (a.isText
                ? (a = a.cut(
                    Math.max(0, e - s),
                    Math.min(a.text.length, n - s)
                  ))
                : (a = a.cut(
                    Math.max(0, e - s - 1),
                    Math.min(a.content.size, n - s - 1)
                  ))),
            r.push(a),
            (o += a.nodeSize)),
            (s = l);
        }
      return new D(r, o);
    }
    cutByIndex(e, n) {
      return e == n
        ? D.empty
        : e == 0 && n == this.content.length
        ? this
        : new D(this.content.slice(e, n));
    }
    replaceChild(e, n) {
      let r = this.content[e];
      if (r == n) return this;
      let o = this.content.slice(),
        i = this.size + n.nodeSize - r.nodeSize;
      return (o[e] = n), new D(o, i);
    }
    addToStart(e) {
      return new D([e].concat(this.content), this.size + e.nodeSize);
    }
    addToEnd(e) {
      return new D(this.content.concat(e), this.size + e.nodeSize);
    }
    eq(e) {
      if (this.content.length != e.content.length) return !1;
      for (let n = 0; n < this.content.length; n++)
        if (!this.content[n].eq(e.content[n])) return !1;
      return !0;
    }
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    get childCount() {
      return this.content.length;
    }
    child(e) {
      let n = this.content[e];
      if (!n) throw new RangeError("Index " + e + " out of range for " + this);
      return n;
    }
    maybeChild(e) {
      return this.content[e] || null;
    }
    forEach(e) {
      for (let n = 0, r = 0; n < this.content.length; n++) {
        let o = this.content[n];
        e(o, r, n), (r += o.nodeSize);
      }
    }
    findDiffStart(e, n = 0) {
      return H1(this, e, n);
    }
    findDiffEnd(e, n = this.size, r = e.size) {
      return z1(this, e, n, r);
    }
    findIndex(e, n = -1) {
      if (e == 0) return _l(0, e);
      if (e == this.size) return _l(this.content.length, e);
      if (e > this.size || e < 0)
        throw new RangeError(`Position ${e} outside of fragment (${this})`);
      for (let r = 0, o = 0; ; r++) {
        let i = this.child(r),
          s = o + i.nodeSize;
        if (s >= e) return s == e || n > 0 ? _l(r + 1, s) : _l(r, o);
        o = s;
      }
    }
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    toStringInner() {
      return this.content.join(", ");
    }
    toJSON() {
      return this.content.length ? this.content.map((e) => e.toJSON()) : null;
    }
    static fromJSON(e, n) {
      if (!n) return D.empty;
      if (!Array.isArray(n))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new D(n.map(e.nodeFromJSON));
    }
    static fromArray(e) {
      if (!e.length) return D.empty;
      let n,
        r = 0;
      for (let o = 0; o < e.length; o++) {
        let i = e[o];
        (r += i.nodeSize),
          o && i.isText && e[o - 1].sameMarkup(i)
            ? (n || (n = e.slice(0, o)),
              (n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)))
            : n && n.push(i);
      }
      return new D(n || e, r);
    }
    static from(e) {
      if (!e) return D.empty;
      if (e instanceof D) return e;
      if (Array.isArray(e)) return this.fromArray(e);
      if (e.attrs) return new D([e], e.nodeSize);
      throw new RangeError(
        "Can not convert " +
          e +
          " to a Fragment" +
          (e.nodesBetween
            ? " (looks like multiple versions of prosemirror-model were loaded)"
            : "")
      );
    }
  }
  D.empty = new D([], 0);
  const lf = { index: 0, offset: 0 };
  function _l(t, e) {
    return (lf.index = t), (lf.offset = e), lf;
  }
  function kl(t, e) {
    if (t === e) return !0;
    if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
    let n = Array.isArray(t);
    if (Array.isArray(e) != n) return !1;
    if (n) {
      if (t.length != e.length) return !1;
      for (let r = 0; r < t.length; r++) if (!kl(t[r], e[r])) return !1;
    } else {
      for (let r in t) if (!(r in e) || !kl(t[r], e[r])) return !1;
      for (let r in e) if (!(r in t)) return !1;
    }
    return !0;
  }
  let _e = class W0 {
    constructor(e, n) {
      (this.type = e), (this.attrs = n);
    }
    addToSet(e) {
      let n,
        r = !1;
      for (let o = 0; o < e.length; o++) {
        let i = e[o];
        if (this.eq(i)) return e;
        if (this.type.excludes(i.type)) n || (n = e.slice(0, o));
        else {
          if (i.type.excludes(this.type)) return e;
          !r &&
            i.type.rank > this.type.rank &&
            (n || (n = e.slice(0, o)), n.push(this), (r = !0)),
            n && n.push(i);
        }
      }
      return n || (n = e.slice()), r || n.push(this), n;
    }
    removeFromSet(e) {
      for (let n = 0; n < e.length; n++)
        if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
      return e;
    }
    isInSet(e) {
      for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
      return !1;
    }
    eq(e) {
      return this == e || (this.type == e.type && kl(this.attrs, e.attrs));
    }
    toJSON() {
      let e = { type: this.type.name };
      for (let n in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return e;
    }
    static fromJSON(e, n) {
      if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
      let r = e.marks[n.type];
      if (!r)
        throw new RangeError(`There is no mark type ${n.type} in this schema`);
      let o = r.create(n.attrs);
      return r.checkAttrs(o.attrs), o;
    }
    static sameSet(e, n) {
      if (e == n) return !0;
      if (e.length != n.length) return !1;
      for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
      return !0;
    }
    static setFrom(e) {
      if (!e || (Array.isArray(e) && e.length == 0)) return W0.none;
      if (e instanceof W0) return [e];
      let n = e.slice();
      return n.sort((r, o) => r.type.rank - o.type.rank), n;
    }
  };
  _e.none = [];
  class ms extends Error {}
  class z {
    constructor(e, n, r) {
      (this.content = e), (this.openStart = n), (this.openEnd = r);
    }
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    insertAt(e, n) {
      let r = U1(this.content, e + this.openStart, n);
      return r && new z(r, this.openStart, this.openEnd);
    }
    removeBetween(e, n) {
      return new z(
        V1(this.content, e + this.openStart, n + this.openStart),
        this.openStart,
        this.openEnd
      );
    }
    eq(e) {
      return (
        this.content.eq(e.content) &&
        this.openStart == e.openStart &&
        this.openEnd == e.openEnd
      );
    }
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    toJSON() {
      if (!this.content.size) return null;
      let e = { content: this.content.toJSON() };
      return (
        this.openStart > 0 && (e.openStart = this.openStart),
        this.openEnd > 0 && (e.openEnd = this.openEnd),
        e
      );
    }
    static fromJSON(e, n) {
      if (!n) return z.empty;
      let r = n.openStart || 0,
        o = n.openEnd || 0;
      if (typeof r != "number" || typeof o != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new z(D.fromJSON(e, n.content), r, o);
    }
    static maxOpen(e, n = !0) {
      let r = 0,
        o = 0;
      for (
        let i = e.firstChild;
        i && !i.isLeaf && (n || !i.type.spec.isolating);
        i = i.firstChild
      )
        r++;
      for (
        let i = e.lastChild;
        i && !i.isLeaf && (n || !i.type.spec.isolating);
        i = i.lastChild
      )
        o++;
      return new z(e, r, o);
    }
  }
  z.empty = new z(D.empty, 0, 0);
  function V1(t, e, n) {
    let { index: r, offset: o } = t.findIndex(e),
      i = t.maybeChild(r),
      { index: s, offset: a } = t.findIndex(n);
    if (o == e || i.isText) {
      if (a != n && !t.child(s).isText)
        throw new RangeError("Removing non-flat range");
      return t.cut(0, e).append(t.cut(n));
    }
    if (r != s) throw new RangeError("Removing non-flat range");
    return t.replaceChild(r, i.copy(V1(i.content, e - o - 1, n - o - 1)));
  }
  function U1(t, e, n, r) {
    let { index: o, offset: i } = t.findIndex(e),
      s = t.maybeChild(o);
    if (i == e || s.isText) return t.cut(0, e).append(n).append(t.cut(e));
    let a = U1(s.content, e - i - 1, n);
    return a && t.replaceChild(o, s.copy(a));
  }
  function _v(t, e, n) {
    if (n.openStart > t.depth)
      throw new ms("Inserted content deeper than insertion position");
    if (t.depth - n.openStart != e.depth - n.openEnd)
      throw new ms("Inconsistent open depths");
    return j1(t, e, n, 0);
  }
  function j1(t, e, n, r) {
    let o = t.index(r),
      i = t.node(r);
    if (o == e.index(r) && r < t.depth - n.openStart) {
      let s = j1(t, e, n, r + 1);
      return i.copy(i.content.replaceChild(o, s));
    } else if (n.content.size)
      if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
        let s = t.parent,
          a = s.content;
        return Oo(
          s,
          a
            .cut(0, t.parentOffset)
            .append(n.content)
            .append(a.cut(e.parentOffset))
        );
      } else {
        let { start: s, end: a } = kv(n, t);
        return Oo(i, q1(t, s, a, e, r));
      }
    else return Oo(i, wl(t, e, r));
  }
  function W1(t, e) {
    if (!e.type.compatibleContent(t.type))
      throw new ms("Cannot join " + e.type.name + " onto " + t.type.name);
  }
  function cf(t, e, n) {
    let r = t.node(n);
    return W1(r, e.node(n)), r;
  }
  function No(t, e) {
    let n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n])
      ? (e[n] = t.withText(e[n].text + t.text))
      : e.push(t);
  }
  function gs(t, e, n, r) {
    let o = (e || t).node(n),
      i = 0,
      s = e ? e.index(n) : o.childCount;
    t &&
      ((i = t.index(n)),
      t.depth > n ? i++ : t.textOffset && (No(t.nodeAfter, r), i++));
    for (let a = i; a < s; a++) No(o.child(a), r);
    e && e.depth == n && e.textOffset && No(e.nodeBefore, r);
  }
  function Oo(t, e) {
    return t.type.checkContent(e), t.copy(e);
  }
  function q1(t, e, n, r, o) {
    let i = t.depth > o && cf(t, e, o + 1),
      s = r.depth > o && cf(n, r, o + 1),
      a = [];
    return (
      gs(null, t, o, a),
      i && s && e.index(o) == n.index(o)
        ? (W1(i, s), No(Oo(i, q1(t, e, n, r, o + 1)), a))
        : (i && No(Oo(i, wl(t, e, o + 1)), a),
          gs(e, n, o, a),
          s && No(Oo(s, wl(n, r, o + 1)), a)),
      gs(r, null, o, a),
      new D(a)
    );
  }
  function wl(t, e, n) {
    let r = [];
    if ((gs(null, t, n, r), t.depth > n)) {
      let o = cf(t, e, n + 1);
      No(Oo(o, wl(t, e, n + 1)), r);
    }
    return gs(e, null, n, r), new D(r);
  }
  function kv(t, e) {
    let n = e.depth - t.openStart,
      o = e.node(n).copy(t.content);
    for (let i = n - 1; i >= 0; i--) o = e.node(i).copy(D.from(o));
    return {
      start: o.resolveNoCache(t.openStart + n),
      end: o.resolveNoCache(o.content.size - t.openEnd - n),
    };
  }
  class di {
    constructor(e, n, r) {
      (this.pos = e),
        (this.path = n),
        (this.parentOffset = r),
        (this.depth = n.length / 3 - 1);
    }
    resolveDepth(e) {
      return e == null ? this.depth : e < 0 ? this.depth + e : e;
    }
    get parent() {
      return this.node(this.depth);
    }
    get doc() {
      return this.node(0);
    }
    node(e) {
      return this.path[this.resolveDepth(e) * 3];
    }
    index(e) {
      return this.path[this.resolveDepth(e) * 3 + 1];
    }
    indexAfter(e) {
      return (
        (e = this.resolveDepth(e)),
        this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
      );
    }
    start(e) {
      return (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
    }
    end(e) {
      return (
        (e = this.resolveDepth(e)), this.start(e) + this.node(e).content.size
      );
    }
    before(e) {
      if (((e = this.resolveDepth(e)), !e))
        throw new RangeError("There is no position before the top-level node");
      return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
    }
    after(e) {
      if (((e = this.resolveDepth(e)), !e))
        throw new RangeError("There is no position after the top-level node");
      return e == this.depth + 1
        ? this.pos
        : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
    }
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    get nodeAfter() {
      let e = this.parent,
        n = this.index(this.depth);
      if (n == e.childCount) return null;
      let r = this.pos - this.path[this.path.length - 1],
        o = e.child(n);
      return r ? e.child(n).cut(r) : o;
    }
    get nodeBefore() {
      let e = this.index(this.depth),
        n = this.pos - this.path[this.path.length - 1];
      return n
        ? this.parent.child(e).cut(0, n)
        : e == 0
        ? null
        : this.parent.child(e - 1);
    }
    posAtIndex(e, n) {
      n = this.resolveDepth(n);
      let r = this.path[n * 3],
        o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
      for (let i = 0; i < e; i++) o += r.child(i).nodeSize;
      return o;
    }
    marks() {
      let e = this.parent,
        n = this.index();
      if (e.content.size == 0) return _e.none;
      if (this.textOffset) return e.child(n).marks;
      let r = e.maybeChild(n - 1),
        o = e.maybeChild(n);
      if (!r) {
        let a = r;
        (r = o), (o = a);
      }
      let i = r.marks;
      for (var s = 0; s < i.length; s++)
        i[s].type.spec.inclusive === !1 &&
          (!o || !i[s].isInSet(o.marks)) &&
          (i = i[s--].removeFromSet(i));
      return i;
    }
    marksAcross(e) {
      let n = this.parent.maybeChild(this.index());
      if (!n || !n.isInline) return null;
      let r = n.marks,
        o = e.parent.maybeChild(e.index());
      for (var i = 0; i < r.length; i++)
        r[i].type.spec.inclusive === !1 &&
          (!o || !r[i].isInSet(o.marks)) &&
          (r = r[i--].removeFromSet(r));
      return r;
    }
    sharedDepth(e) {
      for (let n = this.depth; n > 0; n--)
        if (this.start(n) <= e && this.end(n) >= e) return n;
      return 0;
    }
    blockRange(e = this, n) {
      if (e.pos < this.pos) return e.blockRange(this);
      for (
        let r =
          this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
        r >= 0;
        r--
      )
        if (e.pos <= this.end(r) && (!n || n(this.node(r))))
          return new bs(this, e, r);
      return null;
    }
    sameParent(e) {
      return this.pos - this.parentOffset == e.pos - e.parentOffset;
    }
    max(e) {
      return e.pos > this.pos ? e : this;
    }
    min(e) {
      return e.pos < this.pos ? e : this;
    }
    toString() {
      let e = "";
      for (let n = 1; n <= this.depth; n++)
        e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
      return e + ":" + this.parentOffset;
    }
    static resolve(e, n) {
      if (!(n >= 0 && n <= e.content.size))
        throw new RangeError("Position " + n + " out of range");
      let r = [],
        o = 0,
        i = n;
      for (let s = e; ; ) {
        let { index: a, offset: l } = s.content.findIndex(i),
          c = i - l;
        if ((r.push(s, a, o + l), !c || ((s = s.child(a)), s.isText))) break;
        (i = c - 1), (o += l + 1);
      }
      return new di(n, r, i);
    }
    static resolveCached(e, n) {
      let r = K1.get(e);
      if (r)
        for (let i = 0; i < r.elts.length; i++) {
          let s = r.elts[i];
          if (s.pos == n) return s;
        }
      else K1.set(e, (r = new wv()));
      let o = (r.elts[r.i] = di.resolve(e, n));
      return (r.i = (r.i + 1) % xv), o;
    }
  }
  class wv {
    constructor() {
      (this.elts = []), (this.i = 0);
    }
  }
  const xv = 12,
    K1 = new WeakMap();
  class bs {
    constructor(e, n, r) {
      (this.$from = e), (this.$to = n), (this.depth = r);
    }
    get start() {
      return this.$from.before(this.depth + 1);
    }
    get end() {
      return this.$to.after(this.depth + 1);
    }
    get parent() {
      return this.$from.node(this.depth);
    }
    get startIndex() {
      return this.$from.index(this.depth);
    }
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  }
  const Cv = Object.create(null);
  let Qt = class q0 {
    constructor(e, n, r, o = _e.none) {
      (this.type = e),
        (this.attrs = n),
        (this.marks = o),
        (this.content = r || D.empty);
    }
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    get childCount() {
      return this.content.childCount;
    }
    child(e) {
      return this.content.child(e);
    }
    maybeChild(e) {
      return this.content.maybeChild(e);
    }
    forEach(e) {
      this.content.forEach(e);
    }
    nodesBetween(e, n, r, o = 0) {
      this.content.nodesBetween(e, n, r, o, this);
    }
    descendants(e) {
      this.nodesBetween(0, this.content.size, e);
    }
    get textContent() {
      return this.isLeaf && this.type.spec.leafText
        ? this.type.spec.leafText(this)
        : this.textBetween(0, this.content.size, "");
    }
    textBetween(e, n, r, o) {
      return this.content.textBetween(e, n, r, o);
    }
    get firstChild() {
      return this.content.firstChild;
    }
    get lastChild() {
      return this.content.lastChild;
    }
    eq(e) {
      return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
    }
    sameMarkup(e) {
      return this.hasMarkup(e.type, e.attrs, e.marks);
    }
    hasMarkup(e, n, r) {
      return (
        this.type == e &&
        kl(this.attrs, n || e.defaultAttrs || Cv) &&
        _e.sameSet(this.marks, r || _e.none)
      );
    }
    copy(e = null) {
      return e == this.content
        ? this
        : new q0(this.type, this.attrs, e, this.marks);
    }
    mark(e) {
      return e == this.marks
        ? this
        : new q0(this.type, this.attrs, this.content, e);
    }
    cut(e, n = this.content.size) {
      return e == 0 && n == this.content.size
        ? this
        : this.copy(this.content.cut(e, n));
    }
    slice(e, n = this.content.size, r = !1) {
      if (e == n) return z.empty;
      let o = this.resolve(e),
        i = this.resolve(n),
        s = r ? 0 : o.sharedDepth(n),
        a = o.start(s),
        c = o.node(s).content.cut(o.pos - a, i.pos - a);
      return new z(c, o.depth - s, i.depth - s);
    }
    replace(e, n, r) {
      return _v(this.resolve(e), this.resolve(n), r);
    }
    nodeAt(e) {
      for (let n = this; ; ) {
        let { index: r, offset: o } = n.content.findIndex(e);
        if (((n = n.maybeChild(r)), !n)) return null;
        if (o == e || n.isText) return n;
        e -= o + 1;
      }
    }
    childAfter(e) {
      let { index: n, offset: r } = this.content.findIndex(e);
      return { node: this.content.maybeChild(n), index: n, offset: r };
    }
    childBefore(e) {
      if (e == 0) return { node: null, index: 0, offset: 0 };
      let { index: n, offset: r } = this.content.findIndex(e);
      if (r < e) return { node: this.content.child(n), index: n, offset: r };
      let o = this.content.child(n - 1);
      return { node: o, index: n - 1, offset: r - o.nodeSize };
    }
    resolve(e) {
      return di.resolveCached(this, e);
    }
    resolveNoCache(e) {
      return di.resolve(this, e);
    }
    rangeHasMark(e, n, r) {
      let o = !1;
      return (
        n > e &&
          this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)),
        o
      );
    }
    get isBlock() {
      return this.type.isBlock;
    }
    get isTextblock() {
      return this.type.isTextblock;
    }
    get inlineContent() {
      return this.type.inlineContent;
    }
    get isInline() {
      return this.type.isInline;
    }
    get isText() {
      return this.type.isText;
    }
    get isLeaf() {
      return this.type.isLeaf;
    }
    get isAtom() {
      return this.type.isAtom;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let e = this.type.name;
      return (
        this.content.size && (e += "(" + this.content.toStringInner() + ")"),
        G1(this.marks, e)
      );
    }
    contentMatchAt(e) {
      let n = this.type.contentMatch.matchFragment(this.content, 0, e);
      if (!n)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return n;
    }
    canReplace(e, n, r = D.empty, o = 0, i = r.childCount) {
      let s = this.contentMatchAt(e).matchFragment(r, o, i),
        a = s && s.matchFragment(this.content, n);
      if (!a || !a.validEnd) return !1;
      for (let l = o; l < i; l++)
        if (!this.type.allowsMarks(r.child(l).marks)) return !1;
      return !0;
    }
    canReplaceWith(e, n, r, o) {
      if (o && !this.type.allowsMarks(o)) return !1;
      let i = this.contentMatchAt(e).matchType(r),
        s = i && i.matchFragment(this.content, n);
      return s ? s.validEnd : !1;
    }
    canAppend(e) {
      return e.content.size
        ? this.canReplace(this.childCount, this.childCount, e.content)
        : this.type.compatibleContent(e.type);
    }
    check() {
      this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
      let e = _e.none;
      for (let n = 0; n < this.marks.length; n++) {
        let r = this.marks[n];
        r.type.checkAttrs(r.attrs), (e = r.addToSet(e));
      }
      if (!_e.sameSet(e, this.marks))
        throw new RangeError(
          `Invalid collection of marks for node ${
            this.type.name
          }: ${this.marks.map((n) => n.type.name)}`
        );
      this.content.forEach((n) => n.check());
    }
    toJSON() {
      let e = { type: this.type.name };
      for (let n in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return (
        this.content.size && (e.content = this.content.toJSON()),
        this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
        e
      );
    }
    static fromJSON(e, n) {
      if (!n) throw new RangeError("Invalid input for Node.fromJSON");
      let r;
      if (n.marks) {
        if (!Array.isArray(n.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        r = n.marks.map(e.markFromJSON);
      }
      if (n.type == "text") {
        if (typeof n.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return e.text(n.text, r);
      }
      let o = D.fromJSON(e, n.content),
        i = e.nodeType(n.type).create(n.attrs, o, r);
      return i.type.checkAttrs(i.attrs), i;
    }
  };
  Qt.prototype.text = void 0;
  class xl extends Qt {
    constructor(e, n, r, o) {
      if ((super(e, n, null, o), !r))
        throw new RangeError("Empty text nodes are not allowed");
      this.text = r;
    }
    toString() {
      return this.type.spec.toDebugString
        ? this.type.spec.toDebugString(this)
        : G1(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(e, n) {
      return this.text.slice(e, n);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(e) {
      return e == this.marks
        ? this
        : new xl(this.type, this.attrs, this.text, e);
    }
    withText(e) {
      return e == this.text
        ? this
        : new xl(this.type, this.attrs, e, this.marks);
    }
    cut(e = 0, n = this.text.length) {
      return e == 0 && n == this.text.length
        ? this
        : this.withText(this.text.slice(e, n));
    }
    eq(e) {
      return this.sameMarkup(e) && this.text == e.text;
    }
    toJSON() {
      let e = super.toJSON();
      return (e.text = this.text), e;
    }
  }
  function G1(t, e) {
    for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
    return e;
  }
  class Br {
    constructor(e) {
      (this.validEnd = e), (this.next = []), (this.wrapCache = []);
    }
    static parse(e, n) {
      let r = new vv(e, n);
      if (r.next == null) return Br.empty;
      let o = J1(r);
      r.next && r.err("Unexpected trailing text");
      let i = Ov(Nv(o));
      return Rv(i, r), i;
    }
    matchType(e) {
      for (let n = 0; n < this.next.length; n++)
        if (this.next[n].type == e) return this.next[n].next;
      return null;
    }
    matchFragment(e, n = 0, r = e.childCount) {
      let o = this;
      for (let i = n; o && i < r; i++) o = o.matchType(e.child(i).type);
      return o;
    }
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    get defaultType() {
      for (let e = 0; e < this.next.length; e++) {
        let { type: n } = this.next[e];
        if (!(n.isText || n.hasRequiredAttrs())) return n;
      }
      return null;
    }
    compatible(e) {
      for (let n = 0; n < this.next.length; n++)
        for (let r = 0; r < e.next.length; r++)
          if (this.next[n].type == e.next[r].type) return !0;
      return !1;
    }
    fillBefore(e, n = !1, r = 0) {
      let o = [this];
      function i(s, a) {
        let l = s.matchFragment(e, r);
        if (l && (!n || l.validEnd))
          return D.from(a.map((c) => c.createAndFill()));
        for (let c = 0; c < s.next.length; c++) {
          let { type: d, next: f } = s.next[c];
          if (!(d.isText || d.hasRequiredAttrs()) && o.indexOf(f) == -1) {
            o.push(f);
            let p = i(f, a.concat(d));
            if (p) return p;
          }
        }
        return null;
      }
      return i(this, []);
    }
    findWrapping(e) {
      for (let r = 0; r < this.wrapCache.length; r += 2)
        if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
      let n = this.computeWrapping(e);
      return this.wrapCache.push(e, n), n;
    }
    computeWrapping(e) {
      let n = Object.create(null),
        r = [{ match: this, type: null, via: null }];
      for (; r.length; ) {
        let o = r.shift(),
          i = o.match;
        if (i.matchType(e)) {
          let s = [];
          for (let a = o; a.type; a = a.via) s.push(a.type);
          return s.reverse();
        }
        for (let s = 0; s < i.next.length; s++) {
          let { type: a, next: l } = i.next[s];
          !a.isLeaf &&
            !a.hasRequiredAttrs() &&
            !(a.name in n) &&
            (!o.type || l.validEnd) &&
            (r.push({ match: a.contentMatch, type: a, via: o }),
            (n[a.name] = !0));
        }
      }
      return null;
    }
    get edgeCount() {
      return this.next.length;
    }
    edge(e) {
      if (e >= this.next.length)
        throw new RangeError(`There's no ${e}th edge in this content match`);
      return this.next[e];
    }
    toString() {
      let e = [];
      function n(r) {
        e.push(r);
        for (let o = 0; o < r.next.length; o++)
          e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
      }
      return (
        n(this),
        e.map((r, o) => {
          let i = o + (r.validEnd ? "*" : " ") + " ";
          for (let s = 0; s < r.next.length; s++)
            i +=
              (s ? ", " : "") +
              r.next[s].type.name +
              "->" +
              e.indexOf(r.next[s].next);
          return i;
        }).join(`
`)
      );
    }
  }
  Br.empty = new Br(!0);
  class vv {
    constructor(e, n) {
      (this.string = e),
        (this.nodeTypes = n),
        (this.inline = null),
        (this.pos = 0),
        (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
        this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
        this.tokens[0] == "" && this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(e) {
      return this.next == e && (this.pos++ || !0);
    }
    err(e) {
      throw new SyntaxError(
        e + " (in content expression '" + this.string + "')"
      );
    }
  }
  function J1(t) {
    let e = [];
    do e.push(Ev(t));
    while (t.eat("|"));
    return e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
  function Ev(t) {
    let e = [];
    do e.push(Av(t));
    while (t.next && t.next != ")" && t.next != "|");
    return e.length == 1 ? e[0] : { type: "seq", exprs: e };
  }
  function Av(t) {
    let e = Tv(t);
    for (;;)
      if (t.eat("+")) e = { type: "plus", expr: e };
      else if (t.eat("*")) e = { type: "star", expr: e };
      else if (t.eat("?")) e = { type: "opt", expr: e };
      else if (t.eat("{")) e = Sv(t, e);
      else break;
    return e;
  }
  function Y1(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    let e = Number(t.next);
    return t.pos++, e;
  }
  function Sv(t, e) {
    let n = Y1(t),
      r = n;
    return (
      t.eat(",") && (t.next != "}" ? (r = Y1(t)) : (r = -1)),
      t.eat("}") || t.err("Unclosed braced range"),
      { type: "range", min: n, max: r, expr: e }
    );
  }
  function Mv(t, e) {
    let n = t.nodeTypes,
      r = n[e];
    if (r) return [r];
    let o = [];
    for (let i in n) {
      let s = n[i];
      s.isInGroup(e) && o.push(s);
    }
    return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
  }
  function Tv(t) {
    if (t.eat("(")) {
      let e = J1(t);
      return t.eat(")") || t.err("Missing closing paren"), e;
    } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
    else {
      let e = Mv(t, t.next).map(
        (n) => (
          t.inline == null
            ? (t.inline = n.isInline)
            : t.inline != n.isInline &&
              t.err("Mixing inline and block content"),
          { type: "name", value: n }
        )
      );
      return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
    }
  }
  function Nv(t) {
    let e = [[]];
    return o(i(t, 0), n()), e;
    function n() {
      return e.push([]) - 1;
    }
    function r(s, a, l) {
      let c = { term: l, to: a };
      return e[s].push(c), c;
    }
    function o(s, a) {
      s.forEach((l) => (l.to = a));
    }
    function i(s, a) {
      if (s.type == "choice")
        return s.exprs.reduce((l, c) => l.concat(i(c, a)), []);
      if (s.type == "seq")
        for (let l = 0; ; l++) {
          let c = i(s.exprs[l], a);
          if (l == s.exprs.length - 1) return c;
          o(c, (a = n()));
        }
      else if (s.type == "star") {
        let l = n();
        return r(a, l), o(i(s.expr, l), l), [r(l)];
      } else if (s.type == "plus") {
        let l = n();
        return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)];
      } else {
        if (s.type == "opt") return [r(a)].concat(i(s.expr, a));
        if (s.type == "range") {
          let l = a;
          for (let c = 0; c < s.min; c++) {
            let d = n();
            o(i(s.expr, l), d), (l = d);
          }
          if (s.max == -1) o(i(s.expr, l), l);
          else
            for (let c = s.min; c < s.max; c++) {
              let d = n();
              r(l, d), o(i(s.expr, l), d), (l = d);
            }
          return [r(l)];
        } else {
          if (s.type == "name") return [r(a, void 0, s.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function X1(t, e) {
    return e - t;
  }
  function Z1(t, e) {
    let n = [];
    return r(e), n.sort(X1);
    function r(o) {
      let i = t[o];
      if (i.length == 1 && !i[0].term) return r(i[0].to);
      n.push(o);
      for (let s = 0; s < i.length; s++) {
        let { term: a, to: l } = i[s];
        !a && n.indexOf(l) == -1 && r(l);
      }
    }
  }
  function Ov(t) {
    let e = Object.create(null);
    return n(Z1(t, 0));
    function n(r) {
      let o = [];
      r.forEach((s) => {
        t[s].forEach(({ term: a, to: l }) => {
          if (!a) return;
          let c;
          for (let d = 0; d < o.length; d++) o[d][0] == a && (c = o[d][1]);
          Z1(t, l).forEach((d) => {
            c || o.push([a, (c = [])]), c.indexOf(d) == -1 && c.push(d);
          });
        });
      });
      let i = (e[r.join(",")] = new Br(r.indexOf(t.length - 1) > -1));
      for (let s = 0; s < o.length; s++) {
        let a = o[s][1].sort(X1);
        i.next.push({ type: o[s][0], next: e[a.join(",")] || n(a) });
      }
      return i;
    }
  }
  function Rv(t, e) {
    for (let n = 0, r = [t]; n < r.length; n++) {
      let o = r[n],
        i = !o.validEnd,
        s = [];
      for (let a = 0; a < o.next.length; a++) {
        let { type: l, next: c } = o.next[a];
        s.push(l.name),
          i && !(l.isText || l.hasRequiredAttrs()) && (i = !1),
          r.indexOf(c) == -1 && r.push(c);
      }
      i &&
        e.err(
          "Only non-generatable nodes (" +
            s.join(", ") +
            ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
        );
    }
  }
  function Q1(t) {
    let e = Object.create(null);
    for (let n in t) {
      let r = t[n];
      if (!r.hasDefault) return null;
      e[n] = r.default;
    }
    return e;
  }
  function eg(t, e) {
    let n = Object.create(null);
    for (let r in t) {
      let o = e && e[r];
      if (o === void 0) {
        let i = t[r];
        if (i.hasDefault) o = i.default;
        else throw new RangeError("No value supplied for attribute " + r);
      }
      n[r] = o;
    }
    return n;
  }
  function tg(t, e, n, r) {
    for (let o in e)
      if (!(o in t))
        throw new RangeError(
          `Unsupported attribute ${o} for ${n} of type ${o}`
        );
    for (let o in t) {
      let i = t[o];
      i.validate && i.validate(e[o]);
    }
  }
  function ng(t, e) {
    let n = Object.create(null);
    if (e) for (let r in e) n[r] = new Lv(t, r, e[r]);
    return n;
  }
  let uf = class Px {
    constructor(e, n, r) {
      (this.name = e),
        (this.schema = n),
        (this.spec = r),
        (this.markSet = null),
        (this.groups = r.group ? r.group.split(" ") : []),
        (this.attrs = ng(e, r.attrs)),
        (this.defaultAttrs = Q1(this.attrs)),
        (this.contentMatch = null),
        (this.inlineContent = null),
        (this.isBlock = !(r.inline || e == "text")),
        (this.isText = e == "text");
    }
    get isInline() {
      return !this.isBlock;
    }
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    get isLeaf() {
      return this.contentMatch == Br.empty;
    }
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    isInGroup(e) {
      return this.groups.indexOf(e) > -1;
    }
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    hasRequiredAttrs() {
      for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
      return !1;
    }
    compatibleContent(e) {
      return this == e || this.contentMatch.compatible(e.contentMatch);
    }
    computeAttrs(e) {
      return !e && this.defaultAttrs ? this.defaultAttrs : eg(this.attrs, e);
    }
    create(e = null, n, r) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Qt(this, this.computeAttrs(e), D.from(n), _e.setFrom(r));
    }
    createChecked(e = null, n, r) {
      return (
        (n = D.from(n)),
        this.checkContent(n),
        new Qt(this, this.computeAttrs(e), n, _e.setFrom(r))
      );
    }
    createAndFill(e = null, n, r) {
      if (((e = this.computeAttrs(e)), (n = D.from(n)), n.size)) {
        let s = this.contentMatch.fillBefore(n);
        if (!s) return null;
        n = s.append(n);
      }
      let o = this.contentMatch.matchFragment(n),
        i = o && o.fillBefore(D.empty, !0);
      return i ? new Qt(this, e, n.append(i), _e.setFrom(r)) : null;
    }
    validContent(e) {
      let n = this.contentMatch.matchFragment(e);
      if (!n || !n.validEnd) return !1;
      for (let r = 0; r < e.childCount; r++)
        if (!this.allowsMarks(e.child(r).marks)) return !1;
      return !0;
    }
    checkContent(e) {
      if (!this.validContent(e))
        throw new RangeError(
          `Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`
        );
    }
    checkAttrs(e) {
      tg(this.attrs, e, "node", this.name);
    }
    allowsMarkType(e) {
      return this.markSet == null || this.markSet.indexOf(e) > -1;
    }
    allowsMarks(e) {
      if (this.markSet == null) return !0;
      for (let n = 0; n < e.length; n++)
        if (!this.allowsMarkType(e[n].type)) return !1;
      return !0;
    }
    allowedMarks(e) {
      if (this.markSet == null) return e;
      let n;
      for (let r = 0; r < e.length; r++)
        this.allowsMarkType(e[r].type)
          ? n && n.push(e[r])
          : n || (n = e.slice(0, r));
      return n ? (n.length ? n : _e.none) : e;
    }
    static compile(e, n) {
      let r = Object.create(null);
      e.forEach((i, s) => (r[i] = new Px(i, n, s)));
      let o = n.spec.topNode || "doc";
      if (!r[o])
        throw new RangeError(
          "Schema is missing its top node type ('" + o + "')"
        );
      if (!r.text) throw new RangeError("Every schema needs a 'text' type");
      for (let i in r.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return r;
    }
  };
  function Dv(t, e, n) {
    let r = n.split("|");
    return (o) => {
      let i = o === null ? "null" : typeof o;
      if (r.indexOf(i) < 0)
        throw new RangeError(
          `Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`
        );
    };
  }
  class Lv {
    constructor(e, n, r) {
      (this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default")),
        (this.default = r.default),
        (this.validate =
          typeof r.validate == "string" ? Dv(e, n, r.validate) : r.validate);
    }
    get isRequired() {
      return !this.hasDefault;
    }
  }
  class ys {
    constructor(e, n, r, o) {
      (this.name = e),
        (this.rank = n),
        (this.schema = r),
        (this.spec = o),
        (this.attrs = ng(e, o.attrs)),
        (this.excluded = null);
      let i = Q1(this.attrs);
      this.instance = i ? new _e(this, i) : null;
    }
    create(e = null) {
      return !e && this.instance
        ? this.instance
        : new _e(this, eg(this.attrs, e));
    }
    static compile(e, n) {
      let r = Object.create(null),
        o = 0;
      return e.forEach((i, s) => (r[i] = new ys(i, o++, n, s))), r;
    }
    removeFromSet(e) {
      for (var n = 0; n < e.length; n++)
        e[n].type == this && ((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
      return e;
    }
    isInSet(e) {
      for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
    }
    checkAttrs(e) {
      tg(this.attrs, e, "mark", this.name);
    }
    excludes(e) {
      return this.excluded.indexOf(e) > -1;
    }
  }
  class _s {
    constructor(e) {
      (this.linebreakReplacement = null), (this.cached = Object.create(null));
      let n = (this.spec = {});
      for (let o in e) n[o] = e[o];
      (n.nodes = ot.from(e.nodes)),
        (n.marks = ot.from(e.marks || {})),
        (this.nodes = uf.compile(this.spec.nodes, this)),
        (this.marks = ys.compile(this.spec.marks, this));
      let r = Object.create(null);
      for (let o in this.nodes) {
        if (o in this.marks)
          throw new RangeError(o + " can not be both a node and a mark");
        let i = this.nodes[o],
          s = i.spec.content || "",
          a = i.spec.marks;
        if (
          ((i.contentMatch = r[s] || (r[s] = Br.parse(s, this.nodes))),
          (i.inlineContent = i.contentMatch.inlineContent),
          i.spec.linebreakReplacement)
        ) {
          if (this.linebreakReplacement)
            throw new RangeError("Multiple linebreak nodes defined");
          if (!i.isInline || !i.isLeaf)
            throw new RangeError(
              "Linebreak replacement nodes must be inline leaf nodes"
            );
          this.linebreakReplacement = i;
        }
        i.markSet =
          a == "_"
            ? null
            : a
            ? rg(this, a.split(" "))
            : a == "" || !i.inlineContent
            ? []
            : null;
      }
      for (let o in this.marks) {
        let i = this.marks[o],
          s = i.spec.excludes;
        i.excluded = s == null ? [i] : s == "" ? [] : rg(this, s.split(" "));
      }
      (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
        (this.markFromJSON = this.markFromJSON.bind(this)),
        (this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
        (this.cached.wrappings = Object.create(null));
    }
    node(e, n = null, r, o) {
      if (typeof e == "string") e = this.nodeType(e);
      else if (e instanceof uf) {
        if (e.schema != this)
          throw new RangeError(
            "Node type from different schema used (" + e.name + ")"
          );
      } else throw new RangeError("Invalid node type: " + e);
      return e.createChecked(n, r, o);
    }
    text(e, n) {
      let r = this.nodes.text;
      return new xl(r, r.defaultAttrs, e, _e.setFrom(n));
    }
    mark(e, n) {
      return typeof e == "string" && (e = this.marks[e]), e.create(n);
    }
    nodeFromJSON(e) {
      return Qt.fromJSON(this, e);
    }
    markFromJSON(e) {
      return _e.fromJSON(this, e);
    }
    nodeType(e) {
      let n = this.nodes[e];
      if (!n) throw new RangeError("Unknown node type: " + e);
      return n;
    }
  }
  function rg(t, e) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
      let o = e[r],
        i = t.marks[o],
        s = i;
      if (i) n.push(i);
      else
        for (let a in t.marks) {
          let l = t.marks[a];
          (o == "_" ||
            (l.spec.group && l.spec.group.split(" ").indexOf(o) > -1)) &&
            n.push((s = l));
        }
      if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
    }
    return n;
  }
  function Iv(t) {
    return t.tag != null;
  }
  function Bv(t) {
    return t.style != null;
  }
  class Pn {
    constructor(e, n) {
      (this.schema = e), (this.rules = n), (this.tags = []), (this.styles = []);
      let r = (this.matchedStyles = []);
      n.forEach((o) => {
        if (Iv(o)) this.tags.push(o);
        else if (Bv(o)) {
          let i = /[^=]*/.exec(o.style)[0];
          r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
        }
      }),
        (this.normalizeLists = !this.tags.some((o) => {
          if (!/^(ul|ol)\b/.test(o.tag) || !o.node) return !1;
          let i = e.nodes[o.node];
          return i.contentMatch.matchType(i);
        }));
    }
    parse(e, n = {}) {
      let r = new ag(this, n, !1);
      return r.addAll(e, _e.none, n.from, n.to), r.finish();
    }
    parseSlice(e, n = {}) {
      let r = new ag(this, n, !0);
      return r.addAll(e, _e.none, n.from, n.to), z.maxOpen(r.finish());
    }
    matchTag(e, n, r) {
      for (
        let o = r ? this.tags.indexOf(r) + 1 : 0;
        o < this.tags.length;
        o++
      ) {
        let i = this.tags[o];
        if (
          Fv(e, i.tag) &&
          (i.namespace === void 0 || e.namespaceURI == i.namespace) &&
          (!i.context || n.matchesContext(i.context))
        ) {
          if (i.getAttrs) {
            let s = i.getAttrs(e);
            if (s === !1) continue;
            i.attrs = s || void 0;
          }
          return i;
        }
      }
    }
    matchStyle(e, n, r, o) {
      for (
        let i = o ? this.styles.indexOf(o) + 1 : 0;
        i < this.styles.length;
        i++
      ) {
        let s = this.styles[i],
          a = s.style;
        if (
          !(
            a.indexOf(e) != 0 ||
            (s.context && !r.matchesContext(s.context)) ||
            (a.length > e.length &&
              (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))
          )
        ) {
          if (s.getAttrs) {
            let l = s.getAttrs(n);
            if (l === !1) continue;
            s.attrs = l || void 0;
          }
          return s;
        }
      }
    }
    static schemaRules(e) {
      let n = [];
      function r(o) {
        let i = o.priority == null ? 50 : o.priority,
          s = 0;
        for (; s < n.length; s++) {
          let a = n[s];
          if ((a.priority == null ? 50 : a.priority) < i) break;
        }
        n.splice(s, 0, o);
      }
      for (let o in e.marks) {
        let i = e.marks[o].spec.parseDOM;
        i &&
          i.forEach((s) => {
            r((s = lg(s))), s.mark || s.ignore || s.clearMark || (s.mark = o);
          });
      }
      for (let o in e.nodes) {
        let i = e.nodes[o].spec.parseDOM;
        i &&
          i.forEach((s) => {
            r((s = lg(s))), s.node || s.ignore || s.mark || (s.node = o);
          });
      }
      return n;
    }
    static fromSchema(e) {
      return (
        e.cached.domParser ||
        (e.cached.domParser = new Pn(e, Pn.schemaRules(e)))
      );
    }
  }
  const og = {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      canvas: !0,
      dd: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      figcaption: !0,
      figure: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      li: !0,
      noscript: !0,
      ol: !0,
      output: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      tfoot: !0,
      ul: !0,
    },
    Pv = {
      head: !0,
      noscript: !0,
      object: !0,
      script: !0,
      style: !0,
      title: !0,
    },
    ig = { ol: !0, ul: !0 },
    Cl = 1,
    vl = 2,
    ks = 4;
  function sg(t, e, n) {
    return e != null
      ? (e ? Cl : 0) | (e === "full" ? vl : 0)
      : t && t.whitespace == "pre"
      ? Cl | vl
      : n & ~ks;
  }
  class El {
    constructor(e, n, r, o, i, s) {
      (this.type = e),
        (this.attrs = n),
        (this.marks = r),
        (this.solid = o),
        (this.options = s),
        (this.content = []),
        (this.activeMarks = _e.none),
        (this.match = i || (s & ks ? null : e.contentMatch));
    }
    findWrapping(e) {
      if (!this.match) {
        if (!this.type) return [];
        let n = this.type.contentMatch.fillBefore(D.from(e));
        if (n) this.match = this.type.contentMatch.matchFragment(n);
        else {
          let r = this.type.contentMatch,
            o;
          return (o = r.findWrapping(e.type)) ? ((this.match = r), o) : null;
        }
      }
      return this.match.findWrapping(e.type);
    }
    finish(e) {
      if (!(this.options & Cl)) {
        let r = this.content[this.content.length - 1],
          o;
        if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
          let i = r;
          r.text.length == o[0].length
            ? this.content.pop()
            : (this.content[this.content.length - 1] = i.withText(
                i.text.slice(0, i.text.length - o[0].length)
              ));
        }
      }
      let n = D.from(this.content);
      return (
        !e && this.match && (n = n.append(this.match.fillBefore(D.empty, !0))),
        this.type ? this.type.create(this.attrs, n, this.marks) : n
      );
    }
    inlineContext(e) {
      return this.type
        ? this.type.inlineContent
        : this.content.length
        ? this.content[0].isInline
        : e.parentNode &&
          !og.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
    }
  }
  class ag {
    constructor(e, n, r) {
      (this.parser = e), (this.options = n), (this.isOpen = r), (this.open = 0);
      let o = n.topNode,
        i,
        s = sg(null, n.preserveWhitespace, 0) | (r ? ks : 0);
      o
        ? (i = new El(
            o.type,
            o.attrs,
            _e.none,
            !0,
            n.topMatch || o.type.contentMatch,
            s
          ))
        : r
        ? (i = new El(null, null, _e.none, !0, null, s))
        : (i = new El(e.schema.topNodeType, null, _e.none, !0, null, s)),
        (this.nodes = [i]),
        (this.find = n.findPositions),
        (this.needsBlock = !1);
    }
    get top() {
      return this.nodes[this.open];
    }
    addDOM(e, n) {
      e.nodeType == 3
        ? this.addTextNode(e, n)
        : e.nodeType == 1 && this.addElement(e, n);
    }
    addTextNode(e, n) {
      let r = e.nodeValue,
        o = this.top;
      if (o.options & vl || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
        if (o.options & Cl)
          o.options & vl
            ? (r = r.replace(
                /\r\n?/g,
                `
`
              ))
            : (r = r.replace(/\r?\n|\r/g, " "));
        else if (
          ((r = r.replace(/[ \t\r\n\u000c]+/g, " ")),
          /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1)
        ) {
          let i = o.content[o.content.length - 1],
            s = e.previousSibling;
          (!i ||
            (s && s.nodeName == "BR") ||
            (i.isText && /[ \t\r\n\u000c]$/.test(i.text))) &&
            (r = r.slice(1));
        }
        r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
      } else this.findInside(e);
    }
    addElement(e, n, r) {
      let o = e.nodeName.toLowerCase(),
        i;
      ig.hasOwnProperty(o) && this.parser.normalizeLists && $v(e);
      let s =
        (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
        (i = this.parser.matchTag(e, this, r));
      if (s ? s.ignore : Pv.hasOwnProperty(o))
        this.findInside(e), this.ignoreFallback(e, n);
      else if (!s || s.skip || s.closeParent) {
        s && s.closeParent
          ? (this.open = Math.max(0, this.open - 1))
          : s && s.skip.nodeType && (e = s.skip);
        let a,
          l = this.top,
          c = this.needsBlock;
        if (og.hasOwnProperty(o))
          l.content.length &&
            l.content[0].isInline &&
            this.open &&
            (this.open--, (l = this.top)),
            (a = !0),
            l.type || (this.needsBlock = !0);
        else if (!e.firstChild) {
          this.leafFallback(e, n);
          return;
        }
        let d = s && s.skip ? n : this.readStyles(e, n);
        d && this.addAll(e, d), a && this.sync(l), (this.needsBlock = c);
      } else {
        let a = this.readStyles(e, n);
        a && this.addElementByRule(e, s, a, s.consuming === !1 ? i : void 0);
      }
    }
    leafFallback(e, n) {
      e.nodeName == "BR" &&
        this.top.type &&
        this.top.type.inlineContent &&
        this.addTextNode(
          e.ownerDocument.createTextNode(`
`),
          n
        );
    }
    ignoreFallback(e, n) {
      e.nodeName == "BR" &&
        (!this.top.type || !this.top.type.inlineContent) &&
        this.findPlace(this.parser.schema.text("-"), n);
    }
    readStyles(e, n) {
      let r = e.style;
      if (r && r.length)
        for (let o = 0; o < this.parser.matchedStyles.length; o++) {
          let i = this.parser.matchedStyles[o],
            s = r.getPropertyValue(i);
          if (s)
            for (let a = void 0; ; ) {
              let l = this.parser.matchStyle(i, s, this, a);
              if (!l) break;
              if (l.ignore) return null;
              if (
                (l.clearMark
                  ? (n = n.filter((c) => !l.clearMark(c)))
                  : (n = n.concat(
                      this.parser.schema.marks[l.mark].create(l.attrs)
                    )),
                l.consuming === !1)
              )
                a = l;
              else break;
            }
        }
      return n;
    }
    addElementByRule(e, n, r, o) {
      let i, s;
      if (n.node)
        if (((s = this.parser.schema.nodes[n.node]), s.isLeaf))
          this.insertNode(s.create(n.attrs), r) || this.leafFallback(e, r);
        else {
          let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
          l && ((i = !0), (r = l));
        }
      else {
        let l = this.parser.schema.marks[n.mark];
        r = r.concat(l.create(n.attrs));
      }
      let a = this.top;
      if (s && s.isLeaf) this.findInside(e);
      else if (o) this.addElement(e, r, o);
      else if (n.getContent)
        this.findInside(e),
          n
            .getContent(e, this.parser.schema)
            .forEach((l) => this.insertNode(l, r));
      else {
        let l = e;
        typeof n.contentElement == "string"
          ? (l = e.querySelector(n.contentElement))
          : typeof n.contentElement == "function"
          ? (l = n.contentElement(e))
          : n.contentElement && (l = n.contentElement),
          this.findAround(e, l, !0),
          this.addAll(l, r),
          this.findAround(e, l, !1);
      }
      i && this.sync(a) && this.open--;
    }
    addAll(e, n, r, o) {
      let i = r || 0;
      for (
        let s = r ? e.childNodes[r] : e.firstChild,
          a = o == null ? null : e.childNodes[o];
        s != a;
        s = s.nextSibling, ++i
      )
        this.findAtPoint(e, i), this.addDOM(s, n);
      this.findAtPoint(e, i);
    }
    findPlace(e, n) {
      let r, o;
      for (let i = this.open; i >= 0; i--) {
        let s = this.nodes[i],
          a = s.findWrapping(e);
        if (
          (a && (!r || r.length > a.length) && ((r = a), (o = s), !a.length)) ||
          s.solid
        )
          break;
      }
      if (!r) return null;
      this.sync(o);
      for (let i = 0; i < r.length; i++) n = this.enterInner(r[i], null, n, !1);
      return n;
    }
    insertNode(e, n) {
      if (e.isInline && this.needsBlock && !this.top.type) {
        let o = this.textblockFromContext();
        o && (n = this.enterInner(o, null, n));
      }
      let r = this.findPlace(e, n);
      if (r) {
        this.closeExtra();
        let o = this.top;
        o.match && (o.match = o.match.matchType(e.type));
        let i = _e.none;
        for (let s of r.concat(e.marks))
          (o.type ? o.type.allowsMarkType(s.type) : cg(s.type, e.type)) &&
            (i = s.addToSet(i));
        return o.content.push(e.mark(i)), !0;
      }
      return !1;
    }
    enter(e, n, r, o) {
      let i = this.findPlace(e.create(n), r);
      return i && (i = this.enterInner(e, n, r, !0, o)), i;
    }
    enterInner(e, n, r, o = !1, i) {
      this.closeExtra();
      let s = this.top;
      s.match = s.match && s.match.matchType(e);
      let a = sg(e, i, s.options);
      s.options & ks && s.content.length == 0 && (a |= ks);
      let l = _e.none;
      return (
        (r = r.filter((c) =>
          (s.type ? s.type.allowsMarkType(c.type) : cg(c.type, e))
            ? ((l = c.addToSet(l)), !1)
            : !0
        )),
        this.nodes.push(new El(e, n, l, o, null, a)),
        this.open++,
        r
      );
    }
    closeExtra(e = !1) {
      let n = this.nodes.length - 1;
      if (n > this.open) {
        for (; n > this.open; n--)
          this.nodes[n - 1].content.push(this.nodes[n].finish(e));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      return (
        (this.open = 0),
        this.closeExtra(this.isOpen),
        this.nodes[0].finish(this.isOpen || this.options.topOpen)
      );
    }
    sync(e) {
      for (let n = this.open; n >= 0; n--)
        if (this.nodes[n] == e) return (this.open = n), !0;
      return !1;
    }
    get currentPos() {
      this.closeExtra();
      let e = 0;
      for (let n = this.open; n >= 0; n--) {
        let r = this.nodes[n].content;
        for (let o = r.length - 1; o >= 0; o--) e += r[o].nodeSize;
        n && e++;
      }
      return e;
    }
    findAtPoint(e, n) {
      if (this.find)
        for (let r = 0; r < this.find.length; r++)
          this.find[r].node == e &&
            this.find[r].offset == n &&
            (this.find[r].pos = this.currentPos);
    }
    findInside(e) {
      if (this.find)
        for (let n = 0; n < this.find.length; n++)
          this.find[n].pos == null &&
            e.nodeType == 1 &&
            e.contains(this.find[n].node) &&
            (this.find[n].pos = this.currentPos);
    }
    findAround(e, n, r) {
      if (e != n && this.find)
        for (let o = 0; o < this.find.length; o++)
          this.find[o].pos == null &&
            e.nodeType == 1 &&
            e.contains(this.find[o].node) &&
            n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) &&
            (this.find[o].pos = this.currentPos);
    }
    findInText(e) {
      if (this.find)
        for (let n = 0; n < this.find.length; n++)
          this.find[n].node == e &&
            (this.find[n].pos =
              this.currentPos - (e.nodeValue.length - this.find[n].offset));
    }
    matchesContext(e) {
      if (e.indexOf("|") > -1)
        return e.split(/\s*\|\s*/).some(this.matchesContext, this);
      let n = e.split("/"),
        r = this.options.context,
        o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
        i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
        s = (a, l) => {
          for (; a >= 0; a--) {
            let c = n[a];
            if (c == "") {
              if (a == n.length - 1 || a == 0) continue;
              for (; l >= i; l--) if (s(a - 1, l)) return !0;
              return !1;
            } else {
              let d =
                l > 0 || (l == 0 && o)
                  ? this.nodes[l].type
                  : r && l >= i
                  ? r.node(l - i).type
                  : null;
              if (!d || (d.name != c && !d.isInGroup(c))) return !1;
              l--;
            }
          }
          return !0;
        };
      return s(n.length - 1, this.open);
    }
    textblockFromContext() {
      let e = this.options.context;
      if (e)
        for (let n = e.depth; n >= 0; n--) {
          let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
          if (r && r.isTextblock && r.defaultAttrs) return r;
        }
      for (let n in this.parser.schema.nodes) {
        let r = this.parser.schema.nodes[n];
        if (r.isTextblock && r.defaultAttrs) return r;
      }
    }
  }
  function $v(t) {
    for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
      let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
      r && ig.hasOwnProperty(r) && n
        ? (n.appendChild(e), (e = n))
        : r == "li"
        ? (n = e)
        : r && (n = null);
    }
  }
  function Fv(t, e) {
    return (
      t.matches ||
      t.msMatchesSelector ||
      t.webkitMatchesSelector ||
      t.mozMatchesSelector
    ).call(t, e);
  }
  function lg(t) {
    let e = {};
    for (let n in t) e[n] = t[n];
    return e;
  }
  function cg(t, e) {
    let n = e.schema.nodes;
    for (let r in n) {
      let o = n[r];
      if (!o.allowsMarkType(t)) continue;
      let i = [],
        s = (a) => {
          i.push(a);
          for (let l = 0; l < a.edgeCount; l++) {
            let { type: c, next: d } = a.edge(l);
            if (c == e || (i.indexOf(d) < 0 && s(d))) return !0;
          }
        };
      if (s(o.contentMatch)) return !0;
    }
  }
  class Pr {
    constructor(e, n) {
      (this.nodes = e), (this.marks = n);
    }
    serializeFragment(e, n = {}, r) {
      r || (r = df(n).createDocumentFragment());
      let o = r,
        i = [];
      return (
        e.forEach((s) => {
          if (i.length || s.marks.length) {
            let a = 0,
              l = 0;
            for (; a < i.length && l < s.marks.length; ) {
              let c = s.marks[l];
              if (!this.marks[c.type.name]) {
                l++;
                continue;
              }
              if (!c.eq(i[a][0]) || c.type.spec.spanning === !1) break;
              a++, l++;
            }
            for (; a < i.length; ) o = i.pop()[1];
            for (; l < s.marks.length; ) {
              let c = s.marks[l++],
                d = this.serializeMark(c, s.isInline, n);
              d &&
                (i.push([c, o]),
                o.appendChild(d.dom),
                (o = d.contentDOM || d.dom));
            }
          }
          o.appendChild(this.serializeNodeInner(s, n));
        }),
        r
      );
    }
    serializeNodeInner(e, n) {
      let { dom: r, contentDOM: o } = Al(
        df(n),
        this.nodes[e.type.name](e),
        null,
        e.attrs
      );
      if (o) {
        if (e.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(e.content, n, o);
      }
      return r;
    }
    serializeNode(e, n = {}) {
      let r = this.serializeNodeInner(e, n);
      for (let o = e.marks.length - 1; o >= 0; o--) {
        let i = this.serializeMark(e.marks[o], e.isInline, n);
        i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom));
      }
      return r;
    }
    serializeMark(e, n, r = {}) {
      let o = this.marks[e.type.name];
      return o && Al(df(r), o(e, n), null, e.attrs);
    }
    static renderSpec(e, n, r = null, o) {
      return Al(e, n, r, o);
    }
    static fromSchema(e) {
      return (
        e.cached.domSerializer ||
        (e.cached.domSerializer = new Pr(
          this.nodesFromSchema(e),
          this.marksFromSchema(e)
        ))
      );
    }
    static nodesFromSchema(e) {
      let n = ug(e.nodes);
      return n.text || (n.text = (r) => r.text), n;
    }
    static marksFromSchema(e) {
      return ug(e.marks);
    }
  }
  function ug(t) {
    let e = {};
    for (let n in t) {
      let r = t[n].spec.toDOM;
      r && (e[n] = r);
    }
    return e;
  }
  function df(t) {
    return t.document || window.document;
  }
  const dg = new WeakMap();
  function Hv(t) {
    let e = dg.get(t);
    return e === void 0 && dg.set(t, (e = zv(t))), e;
  }
  function zv(t) {
    let e = null;
    function n(r) {
      if (r && typeof r == "object")
        if (Array.isArray(r))
          if (typeof r[0] == "string") e || (e = []), e.push(r);
          else for (let o = 0; o < r.length; o++) n(r[o]);
        else for (let o in r) n(r[o]);
    }
    return n(t), e;
  }
  function Al(t, e, n, r) {
    if (typeof e == "string") return { dom: t.createTextNode(e) };
    if (e.nodeType != null) return { dom: e };
    if (e.dom && e.dom.nodeType != null) return e;
    let o = e[0],
      i;
    if (typeof o != "string")
      throw new RangeError("Invalid array passed to renderSpec");
    if (r && (i = Hv(r)) && i.indexOf(e) > -1)
      throw new RangeError(
        "Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."
      );
    let s = o.indexOf(" ");
    s > 0 && ((n = o.slice(0, s)), (o = o.slice(s + 1)));
    let a,
      l = n ? t.createElementNS(n, o) : t.createElement(o),
      c = e[1],
      d = 1;
    if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
      d = 2;
      for (let f in c)
        if (c[f] != null) {
          let p = f.indexOf(" ");
          p > 0
            ? l.setAttributeNS(f.slice(0, p), f.slice(p + 1), c[f])
            : l.setAttribute(f, c[f]);
        }
    }
    for (let f = d; f < e.length; f++) {
      let p = e[f];
      if (p === 0) {
        if (f < e.length - 1 || f > d)
          throw new RangeError(
            "Content hole must be the only child of its parent node"
          );
        return { dom: l, contentDOM: l };
      } else {
        let { dom: h, contentDOM: m } = Al(t, p, n, r);
        if ((l.appendChild(h), m)) {
          if (a) throw new RangeError("Multiple content holes");
          a = m;
        }
      }
    }
    return { dom: l, contentDOM: a };
  }
  const fg = 65535,
    pg = Math.pow(2, 16);
  function Vv(t, e) {
    return t + e * pg;
  }
  function hg(t) {
    return t & fg;
  }
  function Uv(t) {
    return (t - (t & fg)) / pg;
  }
  const mg = 1,
    gg = 2,
    Sl = 4,
    bg = 8;
  class Ml {
    constructor(e, n, r) {
      (this.pos = e), (this.delInfo = n), (this.recover = r);
    }
    get deleted() {
      return (this.delInfo & bg) > 0;
    }
    get deletedBefore() {
      return (this.delInfo & (mg | Sl)) > 0;
    }
    get deletedAfter() {
      return (this.delInfo & (gg | Sl)) > 0;
    }
    get deletedAcross() {
      return (this.delInfo & Sl) > 0;
    }
  }
  class Rt {
    constructor(e, n = !1) {
      if (((this.ranges = e), (this.inverted = n), !e.length && Rt.empty))
        return Rt.empty;
    }
    recover(e) {
      let n = 0,
        r = hg(e);
      if (!this.inverted)
        for (let o = 0; o < r; o++)
          n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
      return this.ranges[r * 3] + n + Uv(e);
    }
    mapResult(e, n = 1) {
      return this._map(e, n, !1);
    }
    map(e, n = 1) {
      return this._map(e, n, !0);
    }
    _map(e, n, r) {
      let o = 0,
        i = this.inverted ? 2 : 1,
        s = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let l = this.ranges[a] - (this.inverted ? o : 0);
        if (l > e) break;
        let c = this.ranges[a + i],
          d = this.ranges[a + s],
          f = l + c;
        if (e <= f) {
          let p = c ? (e == l ? -1 : e == f ? 1 : n) : n,
            h = l + o + (p < 0 ? 0 : d);
          if (r) return h;
          let m = e == (n < 0 ? l : f) ? null : Vv(a / 3, e - l),
            g = e == l ? gg : e == f ? mg : Sl;
          return (n < 0 ? e != l : e != f) && (g |= bg), new Ml(h, g, m);
        }
        o += d - c;
      }
      return r ? e + o : new Ml(e + o, 0, null);
    }
    touches(e, n) {
      let r = 0,
        o = hg(n),
        i = this.inverted ? 2 : 1,
        s = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let l = this.ranges[a] - (this.inverted ? r : 0);
        if (l > e) break;
        let c = this.ranges[a + i],
          d = l + c;
        if (e <= d && a == o * 3) return !0;
        r += this.ranges[a + s] - c;
      }
      return !1;
    }
    forEach(e) {
      let n = this.inverted ? 2 : 1,
        r = this.inverted ? 1 : 2;
      for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
        let s = this.ranges[o],
          a = s - (this.inverted ? i : 0),
          l = s + (this.inverted ? 0 : i),
          c = this.ranges[o + n],
          d = this.ranges[o + r];
        e(a, a + c, l, l + d), (i += d - c);
      }
    }
    invert() {
      return new Rt(this.ranges, !this.inverted);
    }
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    static offset(e) {
      return e == 0 ? Rt.empty : new Rt(e < 0 ? [0, -e, 0] : [0, 0, e]);
    }
  }
  Rt.empty = new Rt([]);
  class Ro {
    constructor(e = [], n, r = 0, o = e.length) {
      (this.maps = e), (this.mirror = n), (this.from = r), (this.to = o);
    }
    slice(e = 0, n = this.maps.length) {
      return new Ro(this.maps, this.mirror, e, n);
    }
    copy() {
      return new Ro(
        this.maps.slice(),
        this.mirror && this.mirror.slice(),
        this.from,
        this.to
      );
    }
    appendMap(e, n) {
      (this.to = this.maps.push(e)),
        n != null && this.setMirror(this.maps.length - 1, n);
    }
    appendMapping(e) {
      for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
        let o = e.getMirror(n);
        this.appendMap(e.maps[n], o != null && o < n ? r + o : void 0);
      }
    }
    getMirror(e) {
      if (this.mirror) {
        for (let n = 0; n < this.mirror.length; n++)
          if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)];
      }
    }
    setMirror(e, n) {
      this.mirror || (this.mirror = []), this.mirror.push(e, n);
    }
    appendMappingInverted(e) {
      for (
        let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
        n >= 0;
        n--
      ) {
        let o = e.getMirror(n);
        this.appendMap(
          e.maps[n].invert(),
          o != null && o > n ? r - o - 1 : void 0
        );
      }
    }
    invert() {
      let e = new Ro();
      return e.appendMappingInverted(this), e;
    }
    map(e, n = 1) {
      if (this.mirror) return this._map(e, n, !0);
      for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
      return e;
    }
    mapResult(e, n = 1) {
      return this._map(e, n, !1);
    }
    _map(e, n, r) {
      let o = 0;
      for (let i = this.from; i < this.to; i++) {
        let s = this.maps[i],
          a = s.mapResult(e, n);
        if (a.recover != null) {
          let l = this.getMirror(i);
          if (l != null && l > i && l < this.to) {
            (i = l), (e = this.maps[l].recover(a.recover));
            continue;
          }
        }
        (o |= a.delInfo), (e = a.pos);
      }
      return r ? e : new Ml(e, o, null);
    }
  }
  const ff = Object.create(null);
  class it {
    getMap() {
      return Rt.empty;
    }
    merge(e) {
      return null;
    }
    static fromJSON(e, n) {
      if (!n || !n.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let r = ff[n.stepType];
      if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
      return r.fromJSON(e, n);
    }
    static jsonID(e, n) {
      if (e in ff) throw new RangeError("Duplicate use of step JSON ID " + e);
      return (ff[e] = n), (n.prototype.jsonID = e), n;
    }
  }
  class qe {
    constructor(e, n) {
      (this.doc = e), (this.failed = n);
    }
    static ok(e) {
      return new qe(e, null);
    }
    static fail(e) {
      return new qe(null, e);
    }
    static fromReplace(e, n, r, o) {
      try {
        return qe.ok(e.replace(n, r, o));
      } catch (i) {
        if (i instanceof ms) return qe.fail(i.message);
        throw i;
      }
    }
  }
  function pf(t, e, n) {
    let r = [];
    for (let o = 0; o < t.childCount; o++) {
      let i = t.child(o);
      i.content.size && (i = i.copy(pf(i.content, e, i))),
        i.isInline && (i = e(i, n, o)),
        r.push(i);
    }
    return D.fromArray(r);
  }
  class $n extends it {
    constructor(e, n, r) {
      super(), (this.from = e), (this.to = n), (this.mark = r);
    }
    apply(e) {
      let n = e.slice(this.from, this.to),
        r = e.resolve(this.from),
        o = r.node(r.sharedDepth(this.to)),
        i = new z(
          pf(
            n.content,
            (s, a) =>
              !s.isAtom || !a.type.allowsMarkType(this.mark.type)
                ? s
                : s.mark(this.mark.addToSet(s.marks)),
            o
          ),
          n.openStart,
          n.openEnd
        );
      return qe.fromReplace(e, this.from, this.to, i);
    }
    invert() {
      return new en(this.from, this.to, this.mark);
    }
    map(e) {
      let n = e.mapResult(this.from, 1),
        r = e.mapResult(this.to, -1);
      return (n.deleted && r.deleted) || n.pos >= r.pos
        ? null
        : new $n(n.pos, r.pos, this.mark);
    }
    merge(e) {
      return e instanceof $n &&
        e.mark.eq(this.mark) &&
        this.from <= e.to &&
        this.to >= e.from
        ? new $n(
            Math.min(this.from, e.from),
            Math.max(this.to, e.to),
            this.mark
          )
        : null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to,
      };
    }
    static fromJSON(e, n) {
      if (typeof n.from != "number" || typeof n.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new $n(n.from, n.to, e.markFromJSON(n.mark));
    }
  }
  it.jsonID("addMark", $n);
  class en extends it {
    constructor(e, n, r) {
      super(), (this.from = e), (this.to = n), (this.mark = r);
    }
    apply(e) {
      let n = e.slice(this.from, this.to),
        r = new z(
          pf(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e),
          n.openStart,
          n.openEnd
        );
      return qe.fromReplace(e, this.from, this.to, r);
    }
    invert() {
      return new $n(this.from, this.to, this.mark);
    }
    map(e) {
      let n = e.mapResult(this.from, 1),
        r = e.mapResult(this.to, -1);
      return (n.deleted && r.deleted) || n.pos >= r.pos
        ? null
        : new en(n.pos, r.pos, this.mark);
    }
    merge(e) {
      return e instanceof en &&
        e.mark.eq(this.mark) &&
        this.from <= e.to &&
        this.to >= e.from
        ? new en(
            Math.min(this.from, e.from),
            Math.max(this.to, e.to),
            this.mark
          )
        : null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to,
      };
    }
    static fromJSON(e, n) {
      if (typeof n.from != "number" || typeof n.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new en(n.from, n.to, e.markFromJSON(n.mark));
    }
  }
  it.jsonID("removeMark", en);
  class lr extends it {
    constructor(e, n) {
      super(), (this.pos = e), (this.mark = n);
    }
    apply(e) {
      let n = e.nodeAt(this.pos);
      if (!n) return qe.fail("No node at mark step's position");
      let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
      return qe.fromReplace(
        e,
        this.pos,
        this.pos + 1,
        new z(D.from(r), 0, n.isLeaf ? 0 : 1)
      );
    }
    invert(e) {
      let n = e.nodeAt(this.pos);
      if (n) {
        let r = this.mark.addToSet(n.marks);
        if (r.length == n.marks.length) {
          for (let o = 0; o < n.marks.length; o++)
            if (!n.marks[o].isInSet(r)) return new lr(this.pos, n.marks[o]);
          return new lr(this.pos, this.mark);
        }
      }
      return new Do(this.pos, this.mark);
    }
    map(e) {
      let n = e.mapResult(this.pos, 1);
      return n.deletedAfter ? null : new lr(n.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON(),
      };
    }
    static fromJSON(e, n) {
      if (typeof n.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new lr(n.pos, e.markFromJSON(n.mark));
    }
  }
  it.jsonID("addNodeMark", lr);
  class Do extends it {
    constructor(e, n) {
      super(), (this.pos = e), (this.mark = n);
    }
    apply(e) {
      let n = e.nodeAt(this.pos);
      if (!n) return qe.fail("No node at mark step's position");
      let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
      return qe.fromReplace(
        e,
        this.pos,
        this.pos + 1,
        new z(D.from(r), 0, n.isLeaf ? 0 : 1)
      );
    }
    invert(e) {
      let n = e.nodeAt(this.pos);
      return !n || !this.mark.isInSet(n.marks)
        ? this
        : new lr(this.pos, this.mark);
    }
    map(e) {
      let n = e.mapResult(this.pos, 1);
      return n.deletedAfter ? null : new Do(n.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON(),
      };
    }
    static fromJSON(e, n) {
      if (typeof n.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new Do(n.pos, e.markFromJSON(n.mark));
    }
  }
  it.jsonID("removeNodeMark", Do);
  class Ze extends it {
    constructor(e, n, r, o = !1) {
      super(),
        (this.from = e),
        (this.to = n),
        (this.slice = r),
        (this.structure = o);
    }
    apply(e) {
      return this.structure && hf(e, this.from, this.to)
        ? qe.fail("Structure replace would overwrite content")
        : qe.fromReplace(e, this.from, this.to, this.slice);
    }
    getMap() {
      return new Rt([this.from, this.to - this.from, this.slice.size]);
    }
    invert(e) {
      return new Ze(
        this.from,
        this.from + this.slice.size,
        e.slice(this.from, this.to)
      );
    }
    map(e) {
      let n = e.mapResult(this.from, 1),
        r = e.mapResult(this.to, -1);
      return n.deletedAcross && r.deletedAcross
        ? null
        : new Ze(n.pos, Math.max(n.pos, r.pos), this.slice);
    }
    merge(e) {
      if (!(e instanceof Ze) || e.structure || this.structure) return null;
      if (
        this.from + this.slice.size == e.from &&
        !this.slice.openEnd &&
        !e.slice.openStart
      ) {
        let n =
          this.slice.size + e.slice.size == 0
            ? z.empty
            : new z(
                this.slice.content.append(e.slice.content),
                this.slice.openStart,
                e.slice.openEnd
              );
        return new Ze(this.from, this.to + (e.to - e.from), n, this.structure);
      } else if (
        e.to == this.from &&
        !this.slice.openStart &&
        !e.slice.openEnd
      ) {
        let n =
          this.slice.size + e.slice.size == 0
            ? z.empty
            : new z(
                e.slice.content.append(this.slice.content),
                e.slice.openStart,
                this.slice.openEnd
              );
        return new Ze(e.from, this.to, n, this.structure);
      } else return null;
    }
    toJSON() {
      let e = { stepType: "replace", from: this.from, to: this.to };
      return (
        this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
      );
    }
    static fromJSON(e, n) {
      if (typeof n.from != "number" || typeof n.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new Ze(n.from, n.to, z.fromJSON(e, n.slice), !!n.structure);
    }
  }
  it.jsonID("replace", Ze);
  class Qe extends it {
    constructor(e, n, r, o, i, s, a = !1) {
      super(),
        (this.from = e),
        (this.to = n),
        (this.gapFrom = r),
        (this.gapTo = o),
        (this.slice = i),
        (this.insert = s),
        (this.structure = a);
    }
    apply(e) {
      if (
        this.structure &&
        (hf(e, this.from, this.gapFrom) || hf(e, this.gapTo, this.to))
      )
        return qe.fail("Structure gap-replace would overwrite content");
      let n = e.slice(this.gapFrom, this.gapTo);
      if (n.openStart || n.openEnd) return qe.fail("Gap is not a flat range");
      let r = this.slice.insertAt(this.insert, n.content);
      return r
        ? qe.fromReplace(e, this.from, this.to, r)
        : qe.fail("Content does not fit in gap");
    }
    getMap() {
      return new Rt([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert,
      ]);
    }
    invert(e) {
      let n = this.gapTo - this.gapFrom;
      return new Qe(
        this.from,
        this.from + this.slice.size + n,
        this.from + this.insert,
        this.from + this.insert + n,
        e
          .slice(this.from, this.to)
          .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
        this.gapFrom - this.from,
        this.structure
      );
    }
    map(e) {
      let n = e.mapResult(this.from, 1),
        r = e.mapResult(this.to, -1),
        o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1),
        i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
      return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
        ? null
        : new Qe(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let e = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert,
      };
      return (
        this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
      );
    }
    static fromJSON(e, n) {
      if (
        typeof n.from != "number" ||
        typeof n.to != "number" ||
        typeof n.gapFrom != "number" ||
        typeof n.gapTo != "number" ||
        typeof n.insert != "number"
      )
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new Qe(
        n.from,
        n.to,
        n.gapFrom,
        n.gapTo,
        z.fromJSON(e, n.slice),
        n.insert,
        !!n.structure
      );
    }
  }
  it.jsonID("replaceAround", Qe);
  function hf(t, e, n) {
    let r = t.resolve(e),
      o = n - e,
      i = r.depth;
    for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
      i--, o--;
    if (o > 0) {
      let s = r.node(i).maybeChild(r.indexAfter(i));
      for (; o > 0; ) {
        if (!s || s.isLeaf) return !0;
        (s = s.firstChild), o--;
      }
    }
    return !1;
  }
  function jv(t, e, n, r) {
    let o = [],
      i = [],
      s,
      a;
    t.doc.nodesBetween(e, n, (l, c, d) => {
      if (!l.isInline) return;
      let f = l.marks;
      if (!r.isInSet(f) && d.type.allowsMarkType(r.type)) {
        let p = Math.max(c, e),
          h = Math.min(c + l.nodeSize, n),
          m = r.addToSet(f);
        for (let g = 0; g < f.length; g++)
          f[g].isInSet(m) ||
            (s && s.to == p && s.mark.eq(f[g])
              ? (s.to = h)
              : o.push((s = new en(p, h, f[g]))));
        a && a.to == p ? (a.to = h) : i.push((a = new $n(p, h, r)));
      }
    }),
      o.forEach((l) => t.step(l)),
      i.forEach((l) => t.step(l));
  }
  function Wv(t, e, n, r) {
    let o = [],
      i = 0;
    t.doc.nodesBetween(e, n, (s, a) => {
      if (!s.isInline) return;
      i++;
      let l = null;
      if (r instanceof ys) {
        let c = s.marks,
          d;
        for (; (d = r.isInSet(c)); )
          (l || (l = [])).push(d), (c = d.removeFromSet(c));
      } else r ? r.isInSet(s.marks) && (l = [r]) : (l = s.marks);
      if (l && l.length) {
        let c = Math.min(a + s.nodeSize, n);
        for (let d = 0; d < l.length; d++) {
          let f = l[d],
            p;
          for (let h = 0; h < o.length; h++) {
            let m = o[h];
            m.step == i - 1 && f.eq(o[h].style) && (p = m);
          }
          p
            ? ((p.to = c), (p.step = i))
            : o.push({ style: f, from: Math.max(a, e), to: c, step: i });
        }
      }
    }),
      o.forEach((s) => t.step(new en(s.from, s.to, s.style)));
  }
  function mf(t, e, n, r = n.contentMatch, o = !0) {
    let i = t.doc.nodeAt(e),
      s = [],
      a = e + 1;
    for (let l = 0; l < i.childCount; l++) {
      let c = i.child(l),
        d = a + c.nodeSize,
        f = r.matchType(c.type);
      if (!f) s.push(new Ze(a, d, z.empty));
      else {
        r = f;
        for (let p = 0; p < c.marks.length; p++)
          n.allowsMarkType(c.marks[p].type) || t.step(new en(a, d, c.marks[p]));
        if (o && c.isText && n.whitespace != "pre") {
          let p,
            h = /\r?\n|\r/g,
            m;
          for (; (p = h.exec(c.text)); )
            m ||
              (m = new z(
                D.from(n.schema.text(" ", n.allowedMarks(c.marks))),
                0,
                0
              )),
              s.push(new Ze(a + p.index, a + p.index + p[0].length, m));
        }
      }
      a = d;
    }
    if (!r.validEnd) {
      let l = r.fillBefore(D.empty, !0);
      t.replace(a, a, new z(l, 0, 0));
    }
    for (let l = s.length - 1; l >= 0; l--) t.step(s[l]);
  }
  function qv(t, e, n) {
    return (
      (e == 0 || t.canReplace(e, t.childCount)) &&
      (n == t.childCount || t.canReplace(0, n))
    );
  }
  function Lo(t) {
    let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
    for (let r = t.depth; ; --r) {
      let o = t.$from.node(r),
        i = t.$from.index(r),
        s = t.$to.indexAfter(r);
      if (r < t.depth && o.canReplace(i, s, n)) return r;
      if (r == 0 || o.type.spec.isolating || !qv(o, i, s)) break;
    }
    return null;
  }
  function Kv(t, e, n) {
    let { $from: r, $to: o, depth: i } = e,
      s = r.before(i + 1),
      a = o.after(i + 1),
      l = s,
      c = a,
      d = D.empty,
      f = 0;
    for (let m = i, g = !1; m > n; m--)
      g || r.index(m) > 0
        ? ((g = !0), (d = D.from(r.node(m).copy(d))), f++)
        : l--;
    let p = D.empty,
      h = 0;
    for (let m = i, g = !1; m > n; m--)
      g || o.after(m + 1) < o.end(m)
        ? ((g = !0), (p = D.from(o.node(m).copy(p))), h++)
        : c++;
    t.step(new Qe(l, c, s, a, new z(d.append(p), f, h), d.size - f, !0));
  }
  function ws(t, e, n = null, r = t) {
    let o = Gv(t, e),
      i = o && Jv(r, e);
    return i ? o.map(yg).concat({ type: e, attrs: n }).concat(i.map(yg)) : null;
  }
  function yg(t) {
    return { type: t, attrs: null };
  }
  function Gv(t, e) {
    let { parent: n, startIndex: r, endIndex: o } = t,
      i = n.contentMatchAt(r).findWrapping(e);
    if (!i) return null;
    let s = i.length ? i[0] : e;
    return n.canReplaceWith(r, o, s) ? i : null;
  }
  function Jv(t, e) {
    let { parent: n, startIndex: r, endIndex: o } = t,
      i = n.child(r),
      s = e.contentMatch.findWrapping(i.type);
    if (!s) return null;
    let l = (s.length ? s[s.length - 1] : e).contentMatch;
    for (let c = r; l && c < o; c++) l = l.matchType(n.child(c).type);
    return !l || !l.validEnd ? null : s;
  }
  function Yv(t, e, n) {
    let r = D.empty;
    for (let s = n.length - 1; s >= 0; s--) {
      if (r.size) {
        let a = n[s].type.contentMatch.matchFragment(r);
        if (!a || !a.validEnd)
          throw new RangeError(
            "Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
          );
      }
      r = D.from(n[s].type.create(n[s].attrs, r));
    }
    let o = e.start,
      i = e.end;
    t.step(new Qe(o, i, o, i, new z(r, 0, 0), n.length, !0));
  }
  function Xv(t, e, n, r, o) {
    if (!r.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let i = t.steps.length;
    t.doc.nodesBetween(e, n, (s, a) => {
      let l = typeof o == "function" ? o(s) : o;
      if (
        s.isTextblock &&
        !s.hasMarkup(r, l) &&
        Zv(t.doc, t.mapping.slice(i).map(a), r)
      ) {
        let c = null;
        if (r.schema.linebreakReplacement) {
          let h = r.whitespace == "pre",
            m = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
          h && !m ? (c = !1) : !h && m && (c = !0);
        }
        c === !1 && kg(t, s, a, i),
          mf(t, t.mapping.slice(i).map(a, 1), r, void 0, c === null);
        let d = t.mapping.slice(i),
          f = d.map(a, 1),
          p = d.map(a + s.nodeSize, 1);
        return (
          t.step(
            new Qe(
              f,
              p,
              f + 1,
              p - 1,
              new z(D.from(r.create(l, null, s.marks)), 0, 0),
              1,
              !0
            )
          ),
          c === !0 && _g(t, s, a, i),
          !1
        );
      }
    });
  }
  function _g(t, e, n, r) {
    e.forEach((o, i) => {
      if (o.isText) {
        let s,
          a = /\r?\n|\r/g;
        for (; (s = a.exec(o.text)); ) {
          let l = t.mapping.slice(r).map(n + 1 + i + s.index);
          t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function kg(t, e, n, r) {
    e.forEach((o, i) => {
      if (o.type == o.type.schema.linebreakReplacement) {
        let s = t.mapping.slice(r).map(n + 1 + i);
        t.replaceWith(
          s,
          s + 1,
          e.type.schema.text(`
`)
        );
      }
    });
  }
  function Zv(t, e, n) {
    let r = t.resolve(e),
      o = r.index();
    return r.parent.canReplaceWith(o, o + 1, n);
  }
  function Qv(t, e, n, r, o) {
    let i = t.doc.nodeAt(e);
    if (!i) throw new RangeError("No node at given position");
    n || (n = i.type);
    let s = n.create(r, null, o || i.marks);
    if (i.isLeaf) return t.replaceWith(e, e + i.nodeSize, s);
    if (!n.validContent(i.content))
      throw new RangeError("Invalid content for node type " + n.name);
    t.step(
      new Qe(
        e,
        e + i.nodeSize,
        e + 1,
        e + i.nodeSize - 1,
        new z(D.from(s), 0, 0),
        1,
        !0
      )
    );
  }
  function En(t, e, n = 1, r) {
    let o = t.resolve(e),
      i = o.depth - n,
      s = (r && r[r.length - 1]) || o.parent;
    if (
      i < 0 ||
      o.parent.type.spec.isolating ||
      !o.parent.canReplace(o.index(), o.parent.childCount) ||
      !s.type.validContent(
        o.parent.content.cutByIndex(o.index(), o.parent.childCount)
      )
    )
      return !1;
    for (let c = o.depth - 1, d = n - 2; c > i; c--, d--) {
      let f = o.node(c),
        p = o.index(c);
      if (f.type.spec.isolating) return !1;
      let h = f.content.cutByIndex(p, f.childCount),
        m = r && r[d + 1];
      m && (h = h.replaceChild(0, m.type.create(m.attrs)));
      let g = (r && r[d]) || f;
      if (!f.canReplace(p + 1, f.childCount) || !g.type.validContent(h))
        return !1;
    }
    let a = o.indexAfter(i),
      l = r && r[0];
    return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
  }
  function eE(t, e, n = 1, r) {
    let o = t.doc.resolve(e),
      i = D.empty,
      s = D.empty;
    for (let a = o.depth, l = o.depth - n, c = n - 1; a > l; a--, c--) {
      i = D.from(o.node(a).copy(i));
      let d = r && r[c];
      s = D.from(d ? d.type.create(d.attrs, s) : o.node(a).copy(s));
    }
    t.step(new Ze(e, e, new z(i.append(s), n, n), !0));
  }
  function An(t, e) {
    let n = t.resolve(e),
      r = n.index();
    return wg(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
  }
  function tE(t, e) {
    e.content.size || t.type.compatibleContent(e.type);
    let n = t.contentMatchAt(t.childCount),
      { linebreakReplacement: r } = t.type.schema;
    for (let o = 0; o < e.childCount; o++) {
      let i = e.child(o),
        s = i.type == r ? t.type.schema.nodes.text : i.type;
      if (((n = n.matchType(s)), !n || !t.type.allowsMarks(i.marks))) return !1;
    }
    return n.validEnd;
  }
  function wg(t, e) {
    return !!(t && e && !t.isLeaf && tE(t, e));
  }
  function xs(t, e, n = -1) {
    let r = t.resolve(e);
    for (let o = r.depth; ; o--) {
      let i,
        s,
        a = r.index(o);
      if (
        (o == r.depth
          ? ((i = r.nodeBefore), (s = r.nodeAfter))
          : n > 0
          ? ((i = r.node(o + 1)), a++, (s = r.node(o).maybeChild(a)))
          : ((i = r.node(o).maybeChild(a - 1)), (s = r.node(o + 1))),
        i && !i.isTextblock && wg(i, s) && r.node(o).canReplace(a, a + 1))
      )
        return e;
      if (o == 0) break;
      e = n < 0 ? r.before(o) : r.after(o);
    }
  }
  function nE(t, e, n) {
    let r = null,
      { linebreakReplacement: o } = t.doc.type.schema,
      i = t.doc.resolve(e - n),
      s = i.node().type;
    if (o && s.inlineContent) {
      let d = s.whitespace == "pre",
        f = !!s.contentMatch.matchType(o);
      d && !f ? (r = !1) : !d && f && (r = !0);
    }
    let a = t.steps.length;
    if (r === !1) {
      let d = t.doc.resolve(e + n);
      kg(t, d.node(), d.before(), a);
    }
    s.inlineContent &&
      mf(t, e + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
    let l = t.mapping.slice(a),
      c = l.map(e - n);
    if ((t.step(new Ze(c, l.map(e + n, -1), z.empty, !0)), r === !0)) {
      let d = t.doc.resolve(c);
      _g(t, d.node(), d.before(), t.steps.length);
    }
    return t;
  }
  function xg(t, e, n) {
    let r = t.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
    if (r.parentOffset == 0)
      for (let o = r.depth - 1; o >= 0; o--) {
        let i = r.index(o);
        if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1);
        if (i > 0) return null;
      }
    if (r.parentOffset == r.parent.content.size)
      for (let o = r.depth - 1; o >= 0; o--) {
        let i = r.indexAfter(o);
        if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1);
        if (i < r.node(o).childCount) return null;
      }
    return null;
  }
  function gf(t, e, n) {
    let r = t.resolve(e);
    if (!n.content.size) return e;
    let o = n.content;
    for (let i = 0; i < n.openStart; i++) o = o.firstChild.content;
    for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
      for (let s = r.depth; s >= 0; s--) {
        let a =
            s == r.depth
              ? 0
              : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
              ? -1
              : 1,
          l = r.index(s) + (a > 0 ? 1 : 0),
          c = r.node(s),
          d = !1;
        if (i == 1) d = c.canReplace(l, l, o);
        else {
          let f = c.contentMatchAt(l).findWrapping(o.firstChild.type);
          d = f && c.canReplaceWith(l, l, f[0]);
        }
        if (d) return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
      }
    return null;
  }
  function Cs(t, e, n = e, r = z.empty) {
    if (e == n && !r.size) return null;
    let o = t.resolve(e),
      i = t.resolve(n);
    return Cg(o, i, r) ? new Ze(e, n, r) : new rE(o, i, r).fit();
  }
  function Cg(t, e, n) {
    return (
      !n.openStart &&
      !n.openEnd &&
      t.start() == e.start() &&
      t.parent.canReplace(t.index(), e.index(), n.content)
    );
  }
  class rE {
    constructor(e, n, r) {
      (this.$from = e),
        (this.$to = n),
        (this.unplaced = r),
        (this.frontier = []),
        (this.placed = D.empty);
      for (let o = 0; o <= e.depth; o++) {
        let i = e.node(o);
        this.frontier.push({
          type: i.type,
          match: i.contentMatchAt(e.indexAfter(o)),
        });
      }
      for (let o = e.depth; o > 0; o--)
        this.placed = D.from(e.node(o).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      for (; this.unplaced.size; ) {
        let c = this.findFittable();
        c ? this.placeNodes(c) : this.openMore() || this.dropNode();
      }
      let e = this.mustMoveInline(),
        n = this.placed.size - this.depth - this.$from.depth,
        r = this.$from,
        o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
      if (!o) return null;
      let i = this.placed,
        s = r.depth,
        a = o.depth;
      for (; s && a && i.childCount == 1; )
        (i = i.firstChild.content), s--, a--;
      let l = new z(i, s, a);
      return e > -1
        ? new Qe(r.pos, e, this.$to.pos, this.$to.end(), l, n)
        : l.size || r.pos != this.$to.pos
        ? new Ze(r.pos, o.pos, l)
        : null;
    }
    findFittable() {
      let e = this.unplaced.openStart;
      for (
        let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
        r < e;
        r++
      ) {
        let i = n.firstChild;
        if ((n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)) {
          e = r;
          break;
        }
        n = i.content;
      }
      for (let n = 1; n <= 2; n++)
        for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
          let o,
            i = null;
          r
            ? ((i = bf(this.unplaced.content, r - 1).firstChild),
              (o = i.content))
            : (o = this.unplaced.content);
          let s = o.firstChild;
          for (let a = this.depth; a >= 0; a--) {
            let { type: l, match: c } = this.frontier[a],
              d,
              f = null;
            if (
              n == 1 &&
              (s
                ? c.matchType(s.type) || (f = c.fillBefore(D.from(s), !1))
                : i && l.compatibleContent(i.type))
            )
              return { sliceDepth: r, frontierDepth: a, parent: i, inject: f };
            if (n == 2 && s && (d = c.findWrapping(s.type)))
              return { sliceDepth: r, frontierDepth: a, parent: i, wrap: d };
            if (i && c.matchType(i.type)) break;
          }
        }
    }
    openMore() {
      let { content: e, openStart: n, openEnd: r } = this.unplaced,
        o = bf(e, n);
      return !o.childCount || o.firstChild.isLeaf
        ? !1
        : ((this.unplaced = new z(
            e,
            n + 1,
            Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)
          )),
          !0);
    }
    dropNode() {
      let { content: e, openStart: n, openEnd: r } = this.unplaced,
        o = bf(e, n);
      if (o.childCount <= 1 && n > 0) {
        let i = e.size - n <= n + o.size;
        this.unplaced = new z(vs(e, n - 1, 1), n - 1, i ? n - 1 : r);
      } else this.unplaced = new z(vs(e, n, 1), n, r);
    }
    placeNodes({
      sliceDepth: e,
      frontierDepth: n,
      parent: r,
      inject: o,
      wrap: i,
    }) {
      for (; this.depth > n; ) this.closeFrontierNode();
      if (i) for (let g = 0; g < i.length; g++) this.openFrontierNode(i[g]);
      let s = this.unplaced,
        a = r ? r.content : s.content,
        l = s.openStart - e,
        c = 0,
        d = [],
        { match: f, type: p } = this.frontier[n];
      if (o) {
        for (let g = 0; g < o.childCount; g++) d.push(o.child(g));
        f = f.matchFragment(o);
      }
      let h = a.size + e - (s.content.size - s.openEnd);
      for (; c < a.childCount; ) {
        let g = a.child(c),
          b = f.matchType(g.type);
        if (!b) break;
        c++,
          (c > 1 || l == 0 || g.content.size) &&
            ((f = b),
            d.push(
              vg(
                g.mark(p.allowedMarks(g.marks)),
                c == 1 ? l : 0,
                c == a.childCount ? h : -1
              )
            ));
      }
      let m = c == a.childCount;
      m || (h = -1),
        (this.placed = Es(this.placed, n, D.from(d))),
        (this.frontier[n].match = f),
        m &&
          h < 0 &&
          r &&
          r.type == this.frontier[this.depth].type &&
          this.frontier.length > 1 &&
          this.closeFrontierNode();
      for (let g = 0, b = a; g < h; g++) {
        let y = b.lastChild;
        this.frontier.push({
          type: y.type,
          match: y.contentMatchAt(y.childCount),
        }),
          (b = y.content);
      }
      this.unplaced = m
        ? e == 0
          ? z.empty
          : new z(vs(s.content, e - 1, 1), e - 1, h < 0 ? s.openEnd : e - 1)
        : new z(vs(s.content, e, c), s.openStart, s.openEnd);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      let e = this.frontier[this.depth],
        n;
      if (
        !e.type.isTextblock ||
        !yf(this.$to, this.$to.depth, e.type, e.match, !1) ||
        (this.$to.depth == this.depth &&
          (n = this.findCloseLevel(this.$to)) &&
          n.depth == this.depth)
      )
        return -1;
      let { depth: r } = this.$to,
        o = this.$to.after(r);
      for (; r > 1 && o == this.$to.end(--r); ) ++o;
      return o;
    }
    findCloseLevel(e) {
      e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: r, type: o } = this.frontier[n],
          i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
          s = yf(e, n, o, r, i);
        if (s) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: c } = this.frontier[a],
              d = yf(e, a, c, l, !0);
            if (!d || d.childCount) continue e;
          }
          return {
            depth: n,
            fit: s,
            move: i ? e.doc.resolve(e.after(n + 1)) : e,
          };
        }
      }
    }
    close(e) {
      let n = this.findCloseLevel(e);
      if (!n) return null;
      for (; this.depth > n.depth; ) this.closeFrontierNode();
      n.fit.childCount && (this.placed = Es(this.placed, n.depth, n.fit)),
        (e = n.move);
      for (let r = n.depth + 1; r <= e.depth; r++) {
        let o = e.node(r),
          i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
        this.openFrontierNode(o.type, o.attrs, i);
      }
      return e;
    }
    openFrontierNode(e, n = null, r) {
      let o = this.frontier[this.depth];
      (o.match = o.match.matchType(e)),
        (this.placed = Es(this.placed, this.depth, D.from(e.create(n, r)))),
        this.frontier.push({ type: e, match: e.contentMatch });
    }
    closeFrontierNode() {
      let n = this.frontier.pop().match.fillBefore(D.empty, !0);
      n.childCount && (this.placed = Es(this.placed, this.frontier.length, n));
    }
  }
  function vs(t, e, n) {
    return e == 0
      ? t.cutByIndex(n, t.childCount)
      : t.replaceChild(
          0,
          t.firstChild.copy(vs(t.firstChild.content, e - 1, n))
        );
  }
  function Es(t, e, n) {
    return e == 0
      ? t.append(n)
      : t.replaceChild(
          t.childCount - 1,
          t.lastChild.copy(Es(t.lastChild.content, e - 1, n))
        );
  }
  function bf(t, e) {
    for (let n = 0; n < e; n++) t = t.firstChild.content;
    return t;
  }
  function vg(t, e, n) {
    if (e <= 0) return t;
    let r = t.content;
    return (
      e > 1 &&
        (r = r.replaceChild(
          0,
          vg(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
        )),
      e > 0 &&
        ((r = t.type.contentMatch.fillBefore(r).append(r)),
        n <= 0 &&
          (r = r.append(
            t.type.contentMatch.matchFragment(r).fillBefore(D.empty, !0)
          ))),
      t.copy(r)
    );
  }
  function yf(t, e, n, r, o) {
    let i = t.node(e),
      s = o ? t.indexAfter(e) : t.index(e);
    if (s == i.childCount && !n.compatibleContent(i.type)) return null;
    let a = r.fillBefore(i.content, !0, s);
    return a && !oE(n, i.content, s) ? a : null;
  }
  function oE(t, e, n) {
    for (let r = n; r < e.childCount; r++)
      if (!t.allowsMarks(e.child(r).marks)) return !0;
    return !1;
  }
  function iE(t) {
    return t.spec.defining || t.spec.definingForContent;
  }
  function sE(t, e, n, r) {
    if (!r.size) return t.deleteRange(e, n);
    let o = t.doc.resolve(e),
      i = t.doc.resolve(n);
    if (Cg(o, i, r)) return t.step(new Ze(e, n, r));
    let s = Ag(o, t.doc.resolve(n));
    s[s.length - 1] == 0 && s.pop();
    let a = -(o.depth + 1);
    s.unshift(a);
    for (let p = o.depth, h = o.pos - 1; p > 0; p--, h--) {
      let m = o.node(p).type.spec;
      if (m.defining || m.definingAsContext || m.isolating) break;
      s.indexOf(p) > -1 ? (a = p) : o.before(p) == h && s.splice(1, 0, -p);
    }
    let l = s.indexOf(a),
      c = [],
      d = r.openStart;
    for (let p = r.content, h = 0; ; h++) {
      let m = p.firstChild;
      if ((c.push(m), h == r.openStart)) break;
      p = m.content;
    }
    for (let p = d - 1; p >= 0; p--) {
      let h = c[p],
        m = iE(h.type);
      if (m && !h.sameMarkup(o.node(Math.abs(a) - 1))) d = p;
      else if (m || !h.type.isTextblock) break;
    }
    for (let p = r.openStart; p >= 0; p--) {
      let h = (p + d + 1) % (r.openStart + 1),
        m = c[h];
      if (m)
        for (let g = 0; g < s.length; g++) {
          let b = s[(g + l) % s.length],
            y = !0;
          b < 0 && ((y = !1), (b = -b));
          let x = o.node(b - 1),
            w = o.index(b - 1);
          if (x.canReplaceWith(w, w, m.type, m.marks))
            return t.replace(
              o.before(b),
              y ? i.after(b) : n,
              new z(Eg(r.content, 0, r.openStart, h), h, r.openEnd)
            );
        }
    }
    let f = t.steps.length;
    for (
      let p = s.length - 1;
      p >= 0 && (t.replace(e, n, r), !(t.steps.length > f));
      p--
    ) {
      let h = s[p];
      h < 0 || ((e = o.before(h)), (n = i.after(h)));
    }
  }
  function Eg(t, e, n, r, o) {
    if (e < n) {
      let i = t.firstChild;
      t = t.replaceChild(0, i.copy(Eg(i.content, e + 1, n, r, i)));
    }
    if (e > r) {
      let i = o.contentMatchAt(0),
        s = i.fillBefore(t).append(t);
      t = s.append(i.matchFragment(s).fillBefore(D.empty, !0));
    }
    return t;
  }
  function aE(t, e, n, r) {
    if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
      let o = xg(t.doc, e, r.type);
      o != null && (e = n = o);
    }
    t.replaceRange(e, n, new z(D.from(r), 0, 0));
  }
  function lE(t, e, n) {
    let r = t.doc.resolve(e),
      o = t.doc.resolve(n),
      i = Ag(r, o);
    for (let s = 0; s < i.length; s++) {
      let a = i[s],
        l = s == i.length - 1;
      if ((l && a == 0) || r.node(a).type.contentMatch.validEnd)
        return t.delete(r.start(a), o.end(a));
      if (
        a > 0 &&
        (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1)))
      )
        return t.delete(r.before(a), o.after(a));
    }
    for (let s = 1; s <= r.depth && s <= o.depth; s++)
      if (
        e - r.start(s) == r.depth - s &&
        n > r.end(s) &&
        o.end(s) - n != o.depth - s &&
        r.start(s - 1) == o.start(s - 1) &&
        r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1))
      )
        return t.delete(r.before(s), n);
    t.delete(e, n);
  }
  function Ag(t, e) {
    let n = [],
      r = Math.min(t.depth, e.depth);
    for (let o = r; o >= 0; o--) {
      let i = t.start(o);
      if (
        i < t.pos - (t.depth - o) ||
        e.end(o) > e.pos + (e.depth - o) ||
        t.node(o).type.spec.isolating ||
        e.node(o).type.spec.isolating
      )
        break;
      (i == e.start(o) ||
        (o == t.depth &&
          o == e.depth &&
          t.parent.inlineContent &&
          e.parent.inlineContent &&
          o &&
          e.start(o - 1) == i - 1)) &&
        n.push(o);
    }
    return n;
  }
  class $r extends it {
    constructor(e, n, r) {
      super(), (this.pos = e), (this.attr = n), (this.value = r);
    }
    apply(e) {
      let n = e.nodeAt(this.pos);
      if (!n) return qe.fail("No node at attribute step's position");
      let r = Object.create(null);
      for (let i in n.attrs) r[i] = n.attrs[i];
      r[this.attr] = this.value;
      let o = n.type.create(r, null, n.marks);
      return qe.fromReplace(
        e,
        this.pos,
        this.pos + 1,
        new z(D.from(o), 0, n.isLeaf ? 0 : 1)
      );
    }
    getMap() {
      return Rt.empty;
    }
    invert(e) {
      return new $r(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
    }
    map(e) {
      let n = e.mapResult(this.pos, 1);
      return n.deletedAfter ? null : new $r(n.pos, this.attr, this.value);
    }
    toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value,
      };
    }
    static fromJSON(e, n) {
      if (typeof n.pos != "number" || typeof n.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new $r(n.pos, n.attr, n.value);
    }
  }
  it.jsonID("attr", $r);
  class fi extends it {
    constructor(e, n) {
      super(), (this.attr = e), (this.value = n);
    }
    apply(e) {
      let n = Object.create(null);
      for (let o in e.attrs) n[o] = e.attrs[o];
      n[this.attr] = this.value;
      let r = e.type.create(n, e.content, e.marks);
      return qe.ok(r);
    }
    getMap() {
      return Rt.empty;
    }
    invert(e) {
      return new fi(this.attr, e.attrs[this.attr]);
    }
    map(e) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(e, n) {
      if (typeof n.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new fi(n.attr, n.value);
    }
  }
  it.jsonID("docAttr", fi),
    (k.TransformError = class extends Error {}),
    (k.TransformError = function t(e) {
      let n = Error.call(this, e);
      return (n.__proto__ = t.prototype), n;
    }),
    (k.TransformError.prototype = Object.create(Error.prototype)),
    (k.TransformError.prototype.constructor = k.TransformError),
    (k.TransformError.prototype.name = "TransformError");
  class Tl {
    constructor(e) {
      (this.doc = e),
        (this.steps = []),
        (this.docs = []),
        (this.mapping = new Ro());
    }
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    step(e) {
      let n = this.maybeStep(e);
      if (n.failed) throw new k.TransformError(n.failed);
      return this;
    }
    maybeStep(e) {
      let n = e.apply(this.doc);
      return n.failed || this.addStep(e, n.doc), n;
    }
    get docChanged() {
      return this.steps.length > 0;
    }
    addStep(e, n) {
      this.docs.push(this.doc),
        this.steps.push(e),
        this.mapping.appendMap(e.getMap()),
        (this.doc = n);
    }
    replace(e, n = e, r = z.empty) {
      let o = Cs(this.doc, e, n, r);
      return o && this.step(o), this;
    }
    replaceWith(e, n, r) {
      return this.replace(e, n, new z(D.from(r), 0, 0));
    }
    delete(e, n) {
      return this.replace(e, n, z.empty);
    }
    insert(e, n) {
      return this.replaceWith(e, e, n);
    }
    replaceRange(e, n, r) {
      return sE(this, e, n, r), this;
    }
    replaceRangeWith(e, n, r) {
      return aE(this, e, n, r), this;
    }
    deleteRange(e, n) {
      return lE(this, e, n), this;
    }
    lift(e, n) {
      return Kv(this, e, n), this;
    }
    join(e, n = 1) {
      return nE(this, e, n), this;
    }
    wrap(e, n) {
      return Yv(this, e, n), this;
    }
    setBlockType(e, n = e, r, o = null) {
      return Xv(this, e, n, r, o), this;
    }
    setNodeMarkup(e, n, r = null, o) {
      return Qv(this, e, n, r, o), this;
    }
    setNodeAttribute(e, n, r) {
      return this.step(new $r(e, n, r)), this;
    }
    setDocAttribute(e, n) {
      return this.step(new fi(e, n)), this;
    }
    addNodeMark(e, n) {
      return this.step(new lr(e, n)), this;
    }
    removeNodeMark(e, n) {
      if (!(n instanceof _e)) {
        let r = this.doc.nodeAt(e);
        if (!r) throw new RangeError("No node at position " + e);
        if (((n = n.isInSet(r.marks)), !n)) return this;
      }
      return this.step(new Do(e, n)), this;
    }
    split(e, n = 1, r) {
      return eE(this, e, n, r), this;
    }
    addMark(e, n, r) {
      return jv(this, e, n, r), this;
    }
    removeMark(e, n, r) {
      return Wv(this, e, n, r), this;
    }
    clearIncompatible(e, n, r) {
      return mf(this, e, n, r), this;
    }
  }
  const _f = Object.create(null);
  class J {
    constructor(e, n, r) {
      (this.$anchor = e),
        (this.$head = n),
        (this.ranges = r || [new As(e.min(n), e.max(n))]);
    }
    get anchor() {
      return this.$anchor.pos;
    }
    get head() {
      return this.$head.pos;
    }
    get from() {
      return this.$from.pos;
    }
    get to() {
      return this.$to.pos;
    }
    get $from() {
      return this.ranges[0].$from;
    }
    get $to() {
      return this.ranges[0].$to;
    }
    get empty() {
      let e = this.ranges;
      for (let n = 0; n < e.length; n++)
        if (e[n].$from.pos != e[n].$to.pos) return !1;
      return !0;
    }
    content() {
      return this.$from.doc.slice(this.from, this.to, !0);
    }
    replace(e, n = z.empty) {
      let r = n.content.lastChild,
        o = null;
      for (let a = 0; a < n.openEnd; a++) (o = r), (r = r.lastChild);
      let i = e.steps.length,
        s = this.ranges;
      for (let a = 0; a < s.length; a++) {
        let { $from: l, $to: c } = s[a],
          d = e.mapping.slice(i);
        e.replaceRange(d.map(l.pos), d.map(c.pos), a ? z.empty : n),
          a == 0 && Tg(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
      }
    }
    replaceWith(e, n) {
      let r = e.steps.length,
        o = this.ranges;
      for (let i = 0; i < o.length; i++) {
        let { $from: s, $to: a } = o[i],
          l = e.mapping.slice(r),
          c = l.map(s.pos),
          d = l.map(a.pos);
        i
          ? e.deleteRange(c, d)
          : (e.replaceRangeWith(c, d, n), Tg(e, r, n.isInline ? -1 : 1));
      }
    }
    static findFrom(e, n, r = !1) {
      let o = e.parent.inlineContent
        ? new U(e)
        : pi(e.node(0), e.parent, e.pos, e.index(), n, r);
      if (o) return o;
      for (let i = e.depth - 1; i >= 0; i--) {
        let s =
          n < 0
            ? pi(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r)
            : pi(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
        if (s) return s;
      }
      return null;
    }
    static near(e, n = 1) {
      return this.findFrom(e, n) || this.findFrom(e, -n) || new mt(e.node(0));
    }
    static atStart(e) {
      return pi(e, e, 0, 0, 1) || new mt(e);
    }
    static atEnd(e) {
      return pi(e, e, e.content.size, e.childCount, -1) || new mt(e);
    }
    static fromJSON(e, n) {
      if (!n || !n.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let r = _f[n.type];
      if (!r) throw new RangeError(`No selection type ${n.type} defined`);
      return r.fromJSON(e, n);
    }
    static jsonID(e, n) {
      if (e in _f)
        throw new RangeError("Duplicate use of selection JSON ID " + e);
      return (_f[e] = n), (n.prototype.jsonID = e), n;
    }
    getBookmark() {
      return U.between(this.$anchor, this.$head).getBookmark();
    }
  }
  J.prototype.visible = !0;
  class As {
    constructor(e, n) {
      (this.$from = e), (this.$to = n);
    }
  }
  let Sg = !1;
  function Mg(t) {
    !Sg &&
      !t.parent.inlineContent &&
      ((Sg = !0),
      console.warn(
        "TextSelection endpoint not pointing into a node with inline content (" +
          t.parent.type.name +
          ")"
      ));
  }
  class U extends J {
    constructor(e, n = e) {
      Mg(e), Mg(n), super(e, n);
    }
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(e, n) {
      let r = e.resolve(n.map(this.head));
      if (!r.parent.inlineContent) return J.near(r);
      let o = e.resolve(n.map(this.anchor));
      return new U(o.parent.inlineContent ? o : r, r);
    }
    replace(e, n = z.empty) {
      if ((super.replace(e, n), n == z.empty)) {
        let r = this.$from.marksAcross(this.$to);
        r && e.ensureMarks(r);
      }
    }
    eq(e) {
      return e instanceof U && e.anchor == this.anchor && e.head == this.head;
    }
    getBookmark() {
      return new Nl(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    static fromJSON(e, n) {
      if (typeof n.anchor != "number" || typeof n.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new U(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r = n) {
      let o = e.resolve(n);
      return new this(o, r == n ? o : e.resolve(r));
    }
    static between(e, n, r) {
      let o = e.pos - n.pos;
      if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
        let i = J.findFrom(n, r, !0) || J.findFrom(n, -r, !0);
        if (i) n = i.$head;
        else return J.near(n, r);
      }
      return (
        e.parent.inlineContent ||
          (o == 0
            ? (e = n)
            : ((e = (J.findFrom(e, -r, !0) || J.findFrom(e, r, !0)).$anchor),
              e.pos < n.pos != o < 0 && (e = n))),
        new U(e, n)
      );
    }
  }
  J.jsonID("text", U);
  class Nl {
    constructor(e, n) {
      (this.anchor = e), (this.head = n);
    }
    map(e) {
      return new Nl(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      return U.between(e.resolve(this.anchor), e.resolve(this.head));
    }
  }
  class K extends J {
    constructor(e) {
      let n = e.nodeAfter,
        r = e.node(0).resolve(e.pos + n.nodeSize);
      super(e, r), (this.node = n);
    }
    map(e, n) {
      let { deleted: r, pos: o } = n.mapResult(this.anchor),
        i = e.resolve(o);
      return r ? J.near(i) : new K(i);
    }
    content() {
      return new z(D.from(this.node), 0, 0);
    }
    eq(e) {
      return e instanceof K && e.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new kf(this.anchor);
    }
    static fromJSON(e, n) {
      if (typeof n.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new K(e.resolve(n.anchor));
    }
    static create(e, n) {
      return new K(e.resolve(n));
    }
    static isSelectable(e) {
      return !e.isText && e.type.spec.selectable !== !1;
    }
  }
  (K.prototype.visible = !1), J.jsonID("node", K);
  class kf {
    constructor(e) {
      this.anchor = e;
    }
    map(e) {
      let { deleted: n, pos: r } = e.mapResult(this.anchor);
      return n ? new Nl(r, r) : new kf(r);
    }
    resolve(e) {
      let n = e.resolve(this.anchor),
        r = n.nodeAfter;
      return r && K.isSelectable(r) ? new K(n) : J.near(n);
    }
  }
  class mt extends J {
    constructor(e) {
      super(e.resolve(0), e.resolve(e.content.size));
    }
    replace(e, n = z.empty) {
      if (n == z.empty) {
        e.delete(0, e.doc.content.size);
        let r = J.atStart(e.doc);
        r.eq(e.selection) || e.setSelection(r);
      } else super.replace(e, n);
    }
    toJSON() {
      return { type: "all" };
    }
    static fromJSON(e) {
      return new mt(e);
    }
    map(e) {
      return new mt(e);
    }
    eq(e) {
      return e instanceof mt;
    }
    getBookmark() {
      return cE;
    }
  }
  J.jsonID("all", mt);
  const cE = {
    map() {
      return this;
    },
    resolve(t) {
      return new mt(t);
    },
  };
  function pi(t, e, n, r, o, i = !1) {
    if (e.inlineContent) return U.create(t, n);
    for (
      let s = r - (o > 0 ? 0 : 1);
      o > 0 ? s < e.childCount : s >= 0;
      s += o
    ) {
      let a = e.child(s);
      if (a.isAtom) {
        if (!i && K.isSelectable(a))
          return K.create(t, n - (o < 0 ? a.nodeSize : 0));
      } else {
        let l = pi(t, a, n + o, o < 0 ? a.childCount : 0, o, i);
        if (l) return l;
      }
      n += a.nodeSize * o;
    }
    return null;
  }
  function Tg(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e) return;
    let o = t.steps[r];
    if (!(o instanceof Ze || o instanceof Qe)) return;
    let i = t.mapping.maps[r],
      s;
    i.forEach((a, l, c, d) => {
      s == null && (s = d);
    }),
      t.setSelection(J.near(t.doc.resolve(s), n));
  }
  const Ng = 1,
    Ol = 2,
    Og = 4;
  class Rg extends Tl {
    constructor(e) {
      super(e.doc),
        (this.curSelectionFor = 0),
        (this.updated = 0),
        (this.meta = Object.create(null)),
        (this.time = Date.now()),
        (this.curSelection = e.selection),
        (this.storedMarks = e.storedMarks);
    }
    get selection() {
      return (
        this.curSelectionFor < this.steps.length &&
          ((this.curSelection = this.curSelection.map(
            this.doc,
            this.mapping.slice(this.curSelectionFor)
          )),
          (this.curSelectionFor = this.steps.length)),
        this.curSelection
      );
    }
    setSelection(e) {
      if (e.$from.doc != this.doc)
        throw new RangeError(
          "Selection passed to setSelection must point at the current document"
        );
      return (
        (this.curSelection = e),
        (this.curSelectionFor = this.steps.length),
        (this.updated = (this.updated | Ng) & ~Ol),
        (this.storedMarks = null),
        this
      );
    }
    get selectionSet() {
      return (this.updated & Ng) > 0;
    }
    setStoredMarks(e) {
      return (this.storedMarks = e), (this.updated |= Ol), this;
    }
    ensureMarks(e) {
      return (
        _e.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
          this.setStoredMarks(e),
        this
      );
    }
    addStoredMark(e) {
      return this.ensureMarks(
        e.addToSet(this.storedMarks || this.selection.$head.marks())
      );
    }
    removeStoredMark(e) {
      return this.ensureMarks(
        e.removeFromSet(this.storedMarks || this.selection.$head.marks())
      );
    }
    get storedMarksSet() {
      return (this.updated & Ol) > 0;
    }
    addStep(e, n) {
      super.addStep(e, n),
        (this.updated = this.updated & ~Ol),
        (this.storedMarks = null);
    }
    setTime(e) {
      return (this.time = e), this;
    }
    replaceSelection(e) {
      return this.selection.replace(this, e), this;
    }
    replaceSelectionWith(e, n = !0) {
      let r = this.selection;
      return (
        n &&
          (e = e.mark(
            this.storedMarks ||
              (r.empty
                ? r.$from.marks()
                : r.$from.marksAcross(r.$to) || _e.none)
          )),
        r.replaceWith(this, e),
        this
      );
    }
    deleteSelection() {
      return this.selection.replace(this), this;
    }
    insertText(e, n, r) {
      let o = this.doc.type.schema;
      if (n == null)
        return e
          ? this.replaceSelectionWith(o.text(e), !0)
          : this.deleteSelection();
      {
        if ((r == null && (r = n), (r = r ?? n), !e))
          return this.deleteRange(n, r);
        let i = this.storedMarks;
        if (!i) {
          let s = this.doc.resolve(n);
          i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
        }
        return (
          this.replaceRangeWith(n, r, o.text(e, i)),
          this.selection.empty || this.setSelection(J.near(this.selection.$to)),
          this
        );
      }
    }
    setMeta(e, n) {
      return (this.meta[typeof e == "string" ? e : e.key] = n), this;
    }
    getMeta(e) {
      return this.meta[typeof e == "string" ? e : e.key];
    }
    get isGeneric() {
      for (let e in this.meta) return !1;
      return !0;
    }
    scrollIntoView() {
      return (this.updated |= Og), this;
    }
    get scrolledIntoView() {
      return (this.updated & Og) > 0;
    }
  }
  function Dg(t, e) {
    return !e || !t ? t : t.bind(e);
  }
  class Ss {
    constructor(e, n, r) {
      (this.name = e),
        (this.init = Dg(n.init, r)),
        (this.apply = Dg(n.apply, r));
    }
  }
  const uE = [
    new Ss("doc", {
      init(t) {
        return t.doc || t.schema.topNodeType.createAndFill();
      },
      apply(t) {
        return t.doc;
      },
    }),
    new Ss("selection", {
      init(t, e) {
        return t.selection || J.atStart(e.doc);
      },
      apply(t) {
        return t.selection;
      },
    }),
    new Ss("storedMarks", {
      init(t) {
        return t.storedMarks || null;
      },
      apply(t, e, n, r) {
        return r.selection.$cursor ? t.storedMarks : null;
      },
    }),
    new Ss("scrollToSelection", {
      init() {
        return 0;
      },
      apply(t, e) {
        return t.scrolledIntoView ? e + 1 : e;
      },
    }),
  ];
  class wf {
    constructor(e, n) {
      (this.schema = e),
        (this.plugins = []),
        (this.pluginsByKey = Object.create(null)),
        (this.fields = uE.slice()),
        n &&
          n.forEach((r) => {
            if (this.pluginsByKey[r.key])
              throw new RangeError(
                "Adding different instances of a keyed plugin (" + r.key + ")"
              );
            this.plugins.push(r),
              (this.pluginsByKey[r.key] = r),
              r.spec.state && this.fields.push(new Ss(r.key, r.spec.state, r));
          });
    }
  }
  class Io {
    constructor(e) {
      this.config = e;
    }
    get schema() {
      return this.config.schema;
    }
    get plugins() {
      return this.config.plugins;
    }
    apply(e) {
      return this.applyTransaction(e).state;
    }
    filterTransaction(e, n = -1) {
      for (let r = 0; r < this.config.plugins.length; r++)
        if (r != n) {
          let o = this.config.plugins[r];
          if (
            o.spec.filterTransaction &&
            !o.spec.filterTransaction.call(o, e, this)
          )
            return !1;
        }
      return !0;
    }
    applyTransaction(e) {
      if (!this.filterTransaction(e)) return { state: this, transactions: [] };
      let n = [e],
        r = this.applyInner(e),
        o = null;
      for (;;) {
        let i = !1;
        for (let s = 0; s < this.config.plugins.length; s++) {
          let a = this.config.plugins[s];
          if (a.spec.appendTransaction) {
            let l = o ? o[s].n : 0,
              c = o ? o[s].state : this,
              d =
                l < n.length &&
                a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
            if (d && r.filterTransaction(d, s)) {
              if ((d.setMeta("appendedTransaction", e), !o)) {
                o = [];
                for (let f = 0; f < this.config.plugins.length; f++)
                  o.push(
                    f < s ? { state: r, n: n.length } : { state: this, n: 0 }
                  );
              }
              n.push(d), (r = r.applyInner(d)), (i = !0);
            }
            o && (o[s] = { state: r, n: n.length });
          }
        }
        if (!i) return { state: r, transactions: n };
      }
    }
    applyInner(e) {
      if (!e.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let n = new Io(this.config),
        r = this.config.fields;
      for (let o = 0; o < r.length; o++) {
        let i = r[o];
        n[i.name] = i.apply(e, this[i.name], this, n);
      }
      return n;
    }
    get tr() {
      return new Rg(this);
    }
    static create(e) {
      let n = new wf(e.doc ? e.doc.type.schema : e.schema, e.plugins),
        r = new Io(n);
      for (let o = 0; o < n.fields.length; o++)
        r[n.fields[o].name] = n.fields[o].init(e, r);
      return r;
    }
    reconfigure(e) {
      let n = new wf(this.schema, e.plugins),
        r = n.fields,
        o = new Io(n);
      for (let i = 0; i < r.length; i++) {
        let s = r[i].name;
        o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
      }
      return o;
    }
    toJSON(e) {
      let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (
        (this.storedMarks &&
          (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
        e && typeof e == "object")
      )
        for (let r in e) {
          if (r == "doc" || r == "selection")
            throw new RangeError(
              "The JSON fields `doc` and `selection` are reserved"
            );
          let o = e[r],
            i = o.spec.state;
          i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
        }
      return n;
    }
    static fromJSON(e, n, r) {
      if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!e.schema)
        throw new RangeError("Required config field 'schema' missing");
      let o = new wf(e.schema, e.plugins),
        i = new Io(o);
      return (
        o.fields.forEach((s) => {
          if (s.name == "doc") i.doc = Qt.fromJSON(e.schema, n.doc);
          else if (s.name == "selection")
            i.selection = J.fromJSON(i.doc, n.selection);
          else if (s.name == "storedMarks")
            n.storedMarks &&
              (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
          else {
            if (r)
              for (let a in r) {
                let l = r[a],
                  c = l.spec.state;
                if (
                  l.key == s.name &&
                  c &&
                  c.fromJSON &&
                  Object.prototype.hasOwnProperty.call(n, a)
                ) {
                  i[s.name] = c.fromJSON.call(l, e, n[a], i);
                  return;
                }
              }
            i[s.name] = s.init(e, i);
          }
        }),
        i
      );
    }
  }
  function Lg(t, e, n) {
    for (let r in t) {
      let o = t[r];
      o instanceof Function
        ? (o = o.bind(e))
        : r == "handleDOMEvents" && (o = Lg(o, e, {})),
        (n[r] = o);
    }
    return n;
  }
  class ie {
    constructor(e) {
      (this.spec = e),
        (this.props = {}),
        e.props && Lg(e.props, this, this.props),
        (this.key = e.key ? e.key.key : Ig("plugin"));
    }
    getState(e) {
      return e[this.key];
    }
  }
  const xf = Object.create(null);
  function Ig(t) {
    return t in xf ? t + "$" + ++xf[t] : ((xf[t] = 0), t + "$");
  }
  class de {
    constructor(e = "key") {
      this.key = Ig(e);
    }
    get(e) {
      return e.config.pluginsByKey[this.key];
    }
    getState(e) {
      return e[this.key];
    }
  }
  class Bg {
    constructor(e, n, r) {
      (this.step = e), (this.inverted = n), (this.origin = r);
    }
  }
  function Pg(t, e, n) {
    for (let o = t.length - 1; o >= 0; o--) n.step(t[o].inverted);
    for (let o = 0; o < e.length; o++) n.step(e[o]);
    let r = [];
    for (let o = 0, i = t.length; o < t.length; o++) {
      let s = t[o].step.map(n.mapping.slice(i));
      i--,
        s &&
          !n.maybeStep(s).failed &&
          (n.mapping.setMirror(i, n.steps.length - 1),
          r.push(new Bg(s, s.invert(n.docs[n.docs.length - 1]), t[o].origin)));
    }
    return r;
  }
  class Rl {
    constructor(e, n) {
      (this.version = e), (this.unconfirmed = n);
    }
  }
  function dE(t) {
    let e = [];
    for (let n = 0; n < t.steps.length; n++)
      e.push(new Bg(t.steps[n], t.steps[n].invert(t.docs[n]), t));
    return e;
  }
  const cr = new de("collab");
  function fE(t = {}) {
    let e = {
      version: t.version || 0,
      clientID:
        t.clientID == null
          ? Math.floor(Math.random() * 4294967295)
          : t.clientID,
    };
    return new ie({
      key: cr,
      state: {
        init: () => new Rl(e.version, []),
        apply(n, r) {
          let o = n.getMeta(cr);
          return (
            o ||
            (n.docChanged ? new Rl(r.version, r.unconfirmed.concat(dE(n))) : r)
          );
        },
      },
      config: e,
      historyPreserveItems: !0,
    });
  }
  function pE(t, e, n, r = {}) {
    let o = cr.getState(t),
      i = o.version + e.length,
      s = cr.get(t).spec.config.clientID,
      a = 0;
    for (; a < n.length && n[a] == s; ) ++a;
    let l = o.unconfirmed.slice(a);
    if (((e = a ? e.slice(a) : e), !e.length))
      return t.tr.setMeta(cr, new Rl(i, l));
    let c = l.length,
      d = t.tr;
    if (c) l = Pg(l, e, d);
    else {
      for (let p = 0; p < e.length; p++) d.step(e[p]);
      l = [];
    }
    let f = new Rl(i, l);
    return (
      r &&
        r.mapSelectionBackward &&
        t.selection instanceof U &&
        (d.setSelection(
          U.between(
            d.doc.resolve(d.mapping.map(t.selection.anchor, -1)),
            d.doc.resolve(d.mapping.map(t.selection.head, -1)),
            -1
          )
        ),
        (d.updated &= -2)),
      d.setMeta("rebased", c).setMeta("addToHistory", !1).setMeta(cr, f)
    );
  }
  function hE(t) {
    let e = cr.getState(t);
    return e.unconfirmed.length == 0
      ? null
      : {
          version: e.version,
          steps: e.unconfirmed.map((n) => n.step),
          clientID: cr.get(t).spec.config.clientID,
          get origins() {
            return (
              this._origins ||
              (this._origins = e.unconfirmed.map((n) => n.origin))
            );
          },
        };
  }
  function mE(t) {
    return cr.getState(t).version;
  }
  const Dl = (t, e) =>
    t.selection.empty
      ? !1
      : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
  function $g(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
      ? null
      : n;
  }
  const Cf = (t, e, n) => {
      let r = $g(t, n);
      if (!r) return !1;
      let o = Ef(r);
      if (!o) {
        let s = r.blockRange(),
          a = s && Lo(s);
        return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
      }
      let i = o.nodeBefore;
      if (qg(t, o, e, -1)) return !0;
      if (r.parent.content.size == 0 && (hi(i, "end") || K.isSelectable(i)))
        for (let s = r.depth; ; s--) {
          let a = Cs(t.doc, r.before(s), r.after(s), z.empty);
          if (a && a.slice.size < a.to - a.from) {
            if (e) {
              let l = t.tr.step(a);
              l.setSelection(
                hi(i, "end")
                  ? J.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1)
                  : K.create(l.doc, o.pos - i.nodeSize)
              ),
                e(l.scrollIntoView());
            }
            return !0;
          }
          if (s == 1 || r.node(s - 1).childCount > 1) break;
        }
      return i.isAtom && o.depth == r.depth - 1
        ? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0)
        : !1;
    },
    Fg = (t, e, n) => {
      let r = $g(t, n);
      if (!r) return !1;
      let o = Ef(r);
      return o ? zg(t, o, e) : !1;
    },
    Hg = (t, e, n) => {
      let r = Vg(t, n);
      if (!r) return !1;
      let o = Mf(r);
      return o ? zg(t, o, e) : !1;
    };
  function zg(t, e, n) {
    let r = e.nodeBefore,
      o = r,
      i = e.pos - 1;
    for (; !o.isTextblock; i--) {
      if (o.type.spec.isolating) return !1;
      let d = o.lastChild;
      if (!d) return !1;
      o = d;
    }
    let s = e.nodeAfter,
      a = s,
      l = e.pos + 1;
    for (; !a.isTextblock; l++) {
      if (a.type.spec.isolating) return !1;
      let d = a.firstChild;
      if (!d) return !1;
      a = d;
    }
    let c = Cs(t.doc, i, l, z.empty);
    if (!c || c.from != i || (c instanceof Ze && c.slice.size >= l - i))
      return !1;
    if (n) {
      let d = t.tr.step(c);
      d.setSelection(U.create(d.doc, i)), n(d.scrollIntoView());
    }
    return !0;
  }
  function hi(t, e, n = !1) {
    for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
      if (r.isTextblock) return !0;
      if (n && r.childCount != 1) return !1;
    }
    return !1;
  }
  const vf = (t, e, n) => {
    let { $head: r, empty: o } = t.selection,
      i = r;
    if (!o) return !1;
    if (r.parent.isTextblock) {
      if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0) return !1;
      i = Ef(r);
    }
    let s = i && i.nodeBefore;
    return !s || !K.isSelectable(s)
      ? !1
      : (e &&
          e(
            t.tr
              .setSelection(K.create(t.doc, i.pos - s.nodeSize))
              .scrollIntoView()
          ),
        !0);
  };
  function Ef(t) {
    if (!t.parent.type.spec.isolating)
      for (let e = t.depth - 1; e >= 0; e--) {
        if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
        if (t.node(e).type.spec.isolating) break;
      }
    return null;
  }
  function Vg(t, e) {
    let { $cursor: n } = t.selection;
    return !n ||
      (e
        ? !e.endOfTextblock("forward", t)
        : n.parentOffset < n.parent.content.size)
      ? null
      : n;
  }
  const Af = (t, e, n) => {
      let r = Vg(t, n);
      if (!r) return !1;
      let o = Mf(r);
      if (!o) return !1;
      let i = o.nodeAfter;
      if (qg(t, o, e, 1)) return !0;
      if (r.parent.content.size == 0 && (hi(i, "start") || K.isSelectable(i))) {
        let s = Cs(t.doc, r.before(), r.after(), z.empty);
        if (s && s.slice.size < s.to - s.from) {
          if (e) {
            let a = t.tr.step(s);
            a.setSelection(
              hi(i, "start")
                ? J.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1)
                : K.create(a.doc, a.mapping.map(o.pos))
            ),
              e(a.scrollIntoView());
          }
          return !0;
        }
      }
      return i.isAtom && o.depth == r.depth - 1
        ? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0)
        : !1;
    },
    Sf = (t, e, n) => {
      let { $head: r, empty: o } = t.selection,
        i = r;
      if (!o) return !1;
      if (r.parent.isTextblock) {
        if (
          n
            ? !n.endOfTextblock("forward", t)
            : r.parentOffset < r.parent.content.size
        )
          return !1;
        i = Mf(r);
      }
      let s = i && i.nodeAfter;
      return !s || !K.isSelectable(s)
        ? !1
        : (e && e(t.tr.setSelection(K.create(t.doc, i.pos)).scrollIntoView()),
          !0);
    };
  function Mf(t) {
    if (!t.parent.type.spec.isolating)
      for (let e = t.depth - 1; e >= 0; e--) {
        let n = t.node(e);
        if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
        if (n.type.spec.isolating) break;
      }
    return null;
  }
  const Ll = (t, e) => {
      let n = t.selection,
        r = n instanceof K,
        o;
      if (r) {
        if (n.node.isTextblock || !An(t.doc, n.from)) return !1;
        o = n.from;
      } else if (((o = xs(t.doc, n.from, -1)), o == null)) return !1;
      if (e) {
        let i = t.tr.join(o);
        r &&
          i.setSelection(
            K.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)
          ),
          e(i.scrollIntoView());
      }
      return !0;
    },
    Ug = (t, e) => {
      let n = t.selection,
        r;
      if (n instanceof K) {
        if (n.node.isTextblock || !An(t.doc, n.to)) return !1;
        r = n.to;
      } else if (((r = xs(t.doc, n.to, 1)), r == null)) return !1;
      return e && e(t.tr.join(r).scrollIntoView()), !0;
    },
    Il = (t, e) => {
      let { $from: n, $to: r } = t.selection,
        o = n.blockRange(r),
        i = o && Lo(o);
      return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
    },
    Tf = (t, e) => {
      let { $head: n, $anchor: r } = t.selection;
      return !n.parent.type.spec.code || !n.sameParent(r)
        ? !1
        : (e &&
            e(
              t.tr
                .insertText(
                  `
`
                )
                .scrollIntoView()
            ),
          !0);
    };
  function Nf(t) {
    for (let e = 0; e < t.edgeCount; e++) {
      let { type: n } = t.edge(e);
      if (n.isTextblock && !n.hasRequiredAttrs()) return n;
    }
    return null;
  }
  const Of = (t, e) => {
      let { $head: n, $anchor: r } = t.selection;
      if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
      let o = n.node(-1),
        i = n.indexAfter(-1),
        s = Nf(o.contentMatchAt(i));
      if (!s || !o.canReplaceWith(i, i, s)) return !1;
      if (e) {
        let a = n.after(),
          l = t.tr.replaceWith(a, a, s.createAndFill());
        l.setSelection(J.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
      }
      return !0;
    },
    Rf = (t, e) => {
      let n = t.selection,
        { $from: r, $to: o } = n;
      if (n instanceof mt || r.parent.inlineContent || o.parent.inlineContent)
        return !1;
      let i = Nf(o.parent.contentMatchAt(o.indexAfter()));
      if (!i || !i.isTextblock) return !1;
      if (e) {
        let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o)
            .pos,
          a = t.tr.insert(s, i.createAndFill());
        a.setSelection(U.create(a.doc, s + 1)), e(a.scrollIntoView());
      }
      return !0;
    },
    Df = (t, e) => {
      let { $cursor: n } = t.selection;
      if (!n || n.parent.content.size) return !1;
      if (n.depth > 1 && n.after() != n.end(-1)) {
        let i = n.before();
        if (En(t.doc, i)) return e && e(t.tr.split(i).scrollIntoView()), !0;
      }
      let r = n.blockRange(),
        o = r && Lo(r);
      return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
    };
  function jg(t) {
    return (e, n) => {
      let { $from: r, $to: o } = e.selection;
      if (e.selection instanceof K && e.selection.node.isBlock)
        return !r.parentOffset || !En(e.doc, r.pos)
          ? !1
          : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
      if (!r.depth) return !1;
      let i = [],
        s,
        a,
        l = !1,
        c = !1;
      for (let h = r.depth; ; h--)
        if (r.node(h).isBlock) {
          (l = r.end(h) == r.pos + (r.depth - h)),
            (c = r.start(h) == r.pos - (r.depth - h)),
            (a = Nf(r.node(h - 1).contentMatchAt(r.indexAfter(h - 1))));
          let g = t && t(o.parent, l, r);
          i.unshift(g || (l && a ? { type: a } : null)), (s = h);
          break;
        } else {
          if (h == 1) return !1;
          i.unshift(null);
        }
      let d = e.tr;
      (e.selection instanceof U || e.selection instanceof mt) &&
        d.deleteSelection();
      let f = d.mapping.map(r.pos),
        p = En(d.doc, f, i.length, i);
      if (
        (p ||
          ((i[0] = a ? { type: a } : null), (p = En(d.doc, f, i.length, i))),
        d.split(f, i.length, i),
        !l && c && r.node(s).type != a)
      ) {
        let h = d.mapping.map(r.before(s)),
          m = d.doc.resolve(h);
        a &&
          r.node(s - 1).canReplaceWith(m.index(), m.index() + 1, a) &&
          d.setNodeMarkup(d.mapping.map(r.before(s)), a);
      }
      return n && n(d.scrollIntoView()), !0;
    };
  }
  const Lf = jg(),
    gE = (t, e) =>
      Lf(
        t,
        e &&
          ((n) => {
            let r =
              t.storedMarks ||
              (t.selection.$to.parentOffset && t.selection.$from.marks());
            r && n.ensureMarks(r), e(n);
          })
      ),
    Bl = (t, e) => {
      let { $from: n, to: r } = t.selection,
        o,
        i = n.sharedDepth(r);
      return i == 0
        ? !1
        : ((o = n.before(i)),
          e && e(t.tr.setSelection(K.create(t.doc, o))),
          !0);
    },
    Wg = (t, e) => (e && e(t.tr.setSelection(new mt(t.doc))), !0);
  function bE(t, e, n) {
    let r = e.nodeBefore,
      o = e.nodeAfter,
      i = e.index();
    return !r || !o || !r.type.compatibleContent(o.type)
      ? !1
      : !r.content.size && e.parent.canReplace(i - 1, i)
      ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
      : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || An(t.doc, e.pos))
      ? !1
      : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
  }
  function qg(t, e, n, r) {
    let o = e.nodeBefore,
      i = e.nodeAfter,
      s,
      a,
      l = o.type.spec.isolating || i.type.spec.isolating;
    if (!l && bE(t, e, n)) return !0;
    let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
    if (
      c &&
      (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) &&
      a.matchType(s[0] || i.type).validEnd
    ) {
      if (n) {
        let h = e.pos + i.nodeSize,
          m = D.empty;
        for (let y = s.length - 1; y >= 0; y--)
          m = D.from(s[y].create(null, m));
        m = D.from(o.copy(m));
        let g = t.tr.step(
            new Qe(e.pos - 1, h, e.pos, h, new z(m, 1, 0), s.length, !0)
          ),
          b = g.doc.resolve(h + 2 * s.length);
        b.nodeAfter &&
          b.nodeAfter.type == o.type &&
          An(g.doc, b.pos) &&
          g.join(b.pos),
          n(g.scrollIntoView());
      }
      return !0;
    }
    let d = i.type.spec.isolating || (r > 0 && l) ? null : J.findFrom(e, 1),
      f = d && d.$from.blockRange(d.$to),
      p = f && Lo(f);
    if (p != null && p >= e.depth)
      return n && n(t.tr.lift(f, p).scrollIntoView()), !0;
    if (c && hi(i, "start", !0) && hi(o, "end")) {
      let h = o,
        m = [];
      for (; m.push(h), !h.isTextblock; ) h = h.lastChild;
      let g = i,
        b = 1;
      for (; !g.isTextblock; g = g.firstChild) b++;
      if (h.canReplace(h.childCount, h.childCount, g.content)) {
        if (n) {
          let y = D.empty;
          for (let w = m.length - 1; w >= 0; w--) y = D.from(m[w].copy(y));
          let x = t.tr.step(
            new Qe(
              e.pos - m.length,
              e.pos + i.nodeSize,
              e.pos + b,
              e.pos + i.nodeSize - b,
              new z(y, m.length, 0),
              0,
              !0
            )
          );
          n(x.scrollIntoView());
        }
        return !0;
      }
    }
    return !1;
  }
  function Kg(t) {
    return function (e, n) {
      let r = e.selection,
        o = t < 0 ? r.$from : r.$to,
        i = o.depth;
      for (; o.node(i).isInline; ) {
        if (!i) return !1;
        i--;
      }
      return o.node(i).isTextblock
        ? (n &&
            n(
              e.tr.setSelection(U.create(e.doc, t < 0 ? o.start(i) : o.end(i)))
            ),
          !0)
        : !1;
    };
  }
  const If = Kg(-1),
    Bf = Kg(1);
  function Pl(t, e = null) {
    return function (n, r) {
      let { $from: o, $to: i } = n.selection,
        s = o.blockRange(i),
        a = s && ws(s, t, e);
      return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
    };
  }
  function $l(t, e = null) {
    return function (n, r) {
      let o = !1;
      for (let i = 0; i < n.selection.ranges.length && !o; i++) {
        let {
          $from: { pos: s },
          $to: { pos: a },
        } = n.selection.ranges[i];
        n.doc.nodesBetween(s, a, (l, c) => {
          if (o) return !1;
          if (!(!l.isTextblock || l.hasMarkup(t, e)))
            if (l.type == t) o = !0;
            else {
              let d = n.doc.resolve(c),
                f = d.index();
              o = d.parent.canReplaceWith(f, f + 1, t);
            }
        });
      }
      if (!o) return !1;
      if (r) {
        let i = n.tr;
        for (let s = 0; s < n.selection.ranges.length; s++) {
          let {
            $from: { pos: a },
            $to: { pos: l },
          } = n.selection.ranges[s];
          i.setBlockType(a, l, t, e);
        }
        r(i.scrollIntoView());
      }
      return !0;
    };
  }
  function yE(t, e, n, r) {
    for (let o = 0; o < e.length; o++) {
      let { $from: i, $to: s } = e[o],
        a = i.depth == 0 ? t.inlineContent && t.type.allowsMarkType(n) : !1;
      if (
        (t.nodesBetween(i.pos, s.pos, (l, c) => {
          if (
            a ||
            (!r &&
              l.isAtom &&
              l.isInline &&
              c >= i.pos &&
              c + l.nodeSize <= s.pos)
          )
            return !1;
          a = l.inlineContent && l.type.allowsMarkType(n);
        }),
        a)
      )
        return !0;
    }
    return !1;
  }
  function _E(t) {
    let e = [];
    for (let n = 0; n < t.length; n++) {
      let { $from: r, $to: o } = t[n];
      r.doc.nodesBetween(r.pos, o.pos, (i, s) => {
        if (
          i.isAtom &&
          i.content.size &&
          i.isInline &&
          s >= r.pos &&
          s + i.nodeSize <= o.pos
        )
          return (
            s + 1 > r.pos && e.push(new As(r, r.doc.resolve(s + 1))),
            (r = r.doc.resolve(s + 1 + i.content.size)),
            !1
          );
      }),
        r.pos < o.pos && e.push(new As(r, o));
    }
    return e;
  }
  function kE(t, e = null, n) {
    let r = (n && n.removeWhenPresent) !== !1,
      o = (n && n.enterInlineAtoms) !== !1;
    return function (i, s) {
      let { empty: a, $cursor: l, ranges: c } = i.selection;
      if ((a && !l) || !yE(i.doc, c, t, o)) return !1;
      if (s)
        if (l)
          t.isInSet(i.storedMarks || l.marks())
            ? s(i.tr.removeStoredMark(t))
            : s(i.tr.addStoredMark(t.create(e)));
        else {
          let d,
            f = i.tr;
          o || (c = _E(c)),
            r
              ? (d = !c.some((p) =>
                  i.doc.rangeHasMark(p.$from.pos, p.$to.pos, t)
                ))
              : (d = !c.every((p) => {
                  let h = !1;
                  return (
                    f.doc.nodesBetween(p.$from.pos, p.$to.pos, (m, g, b) => {
                      if (h) return !1;
                      h =
                        !t.isInSet(m.marks) &&
                        !!b &&
                        b.type.allowsMarkType(t) &&
                        !(
                          m.isText &&
                          /^\s*$/.test(
                            m.textBetween(
                              Math.max(0, p.$from.pos - g),
                              Math.min(m.nodeSize, p.$to.pos - g)
                            )
                          )
                        );
                    }),
                    !h
                  );
                }));
          for (let p = 0; p < c.length; p++) {
            let { $from: h, $to: m } = c[p];
            if (!d) f.removeMark(h.pos, m.pos, t);
            else {
              let g = h.pos,
                b = m.pos,
                y = h.nodeAfter,
                x = m.nodeBefore,
                w = y && y.isText ? /^\s*/.exec(y.text)[0].length : 0,
                _ = x && x.isText ? /\s*$/.exec(x.text)[0].length : 0;
              g + w < b && ((g += w), (b -= _)), f.addMark(g, b, t.create(e));
            }
          }
          s(f.scrollIntoView());
        }
      return !0;
    };
  }
  function wE(t, e) {
    return (n) => {
      if (!n.isGeneric) return t(n);
      let r = [];
      for (let i = 0; i < n.mapping.maps.length; i++) {
        let s = n.mapping.maps[i];
        for (let a = 0; a < r.length; a++) r[a] = s.map(r[a]);
        s.forEach((a, l, c, d) => r.push(c, d));
      }
      let o = [];
      for (let i = 0; i < r.length; i += 2) {
        let s = r[i],
          a = r[i + 1],
          l = n.doc.resolve(s),
          c = l.sharedDepth(a),
          d = l.node(c);
        for (let f = l.indexAfter(c), p = l.after(c + 1); p <= a; ++f) {
          let h = d.maybeChild(f);
          if (!h) break;
          if (f && o.indexOf(p) == -1) {
            let m = d.child(f - 1);
            m.type == h.type && e(m, h) && o.push(p);
          }
          p += h.nodeSize;
        }
      }
      o.sort((i, s) => i - s);
      for (let i = o.length - 1; i >= 0; i--) An(n.doc, o[i]) && n.join(o[i]);
      t(n);
    };
  }
  function xE(t, e) {
    let n = Array.isArray(e) ? (r) => e.indexOf(r.type.name) > -1 : e;
    return (r, o, i) => t(r, o && wE(o, n), i);
  }
  function Fl(...t) {
    return function (e, n, r) {
      for (let o = 0; o < t.length; o++) if (t[o](e, n, r)) return !0;
      return !1;
    };
  }
  let Pf = Fl(Dl, Cf, vf),
    Gg = Fl(Dl, Af, Sf);
  const Fn = {
      Enter: Fl(Tf, Rf, Df, Lf),
      "Mod-Enter": Of,
      Backspace: Pf,
      "Mod-Backspace": Pf,
      "Shift-Backspace": Pf,
      Delete: Gg,
      "Mod-Delete": Gg,
      "Mod-a": Wg,
    },
    $f = {
      "Ctrl-h": Fn.Backspace,
      "Alt-Backspace": Fn["Mod-Backspace"],
      "Ctrl-d": Fn.Delete,
      "Ctrl-Alt-Backspace": Fn["Mod-Delete"],
      "Alt-Delete": Fn["Mod-Delete"],
      "Alt-d": Fn["Mod-Delete"],
      "Ctrl-a": If,
      "Ctrl-e": Bf,
    };
  for (let t in Fn) $f[t] = Fn[t];
  const CE = (
    typeof navigator < "u"
      ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
      : typeof os < "u" && os.platform
      ? os.platform() == "darwin"
      : !1
  )
    ? $f
    : Fn;
  function Jg(t = {}) {
    return new ie({
      view(e) {
        return new vE(e, t);
      },
    });
  }
  class vE {
    constructor(e, n) {
      var r;
      (this.editorView = e),
        (this.cursorPos = null),
        (this.element = null),
        (this.timeout = -1),
        (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
        (this.color = n.color === !1 ? void 0 : n.color || "black"),
        (this.class = n.class),
        (this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(
          (o) => {
            let i = (s) => {
              this[o](s);
            };
            return e.dom.addEventListener(o, i), { name: o, handler: i };
          }
        ));
    }
    destroy() {
      this.handlers.forEach(({ name: e, handler: n }) =>
        this.editorView.dom.removeEventListener(e, n)
      );
    }
    update(e, n) {
      this.cursorPos != null &&
        n.doc != e.state.doc &&
        (this.cursorPos > e.state.doc.content.size
          ? this.setCursor(null)
          : this.updateOverlay());
    }
    setCursor(e) {
      e != this.cursorPos &&
        ((this.cursorPos = e),
        e == null
          ? (this.element.parentNode.removeChild(this.element),
            (this.element = null))
          : this.updateOverlay());
    }
    updateOverlay() {
      let e = this.editorView.state.doc.resolve(this.cursorPos),
        n = !e.parent.inlineContent,
        r;
      if (n) {
        let a = e.nodeBefore,
          l = e.nodeAfter;
        if (a || l) {
          let c = this.editorView.nodeDOM(
            this.cursorPos - (a ? a.nodeSize : 0)
          );
          if (c) {
            let d = c.getBoundingClientRect(),
              f = a ? d.bottom : d.top;
            a &&
              l &&
              (f =
                (f +
                  this.editorView
                    .nodeDOM(this.cursorPos)
                    .getBoundingClientRect().top) /
                2),
              (r = {
                left: d.left,
                right: d.right,
                top: f - this.width / 2,
                bottom: f + this.width / 2,
              });
          }
        }
      }
      if (!r) {
        let a = this.editorView.coordsAtPos(this.cursorPos);
        r = {
          left: a.left - this.width / 2,
          right: a.left + this.width / 2,
          top: a.top,
          bottom: a.bottom,
        };
      }
      let o = this.editorView.dom.offsetParent;
      this.element ||
        ((this.element = o.appendChild(document.createElement("div"))),
        this.class && (this.element.className = this.class),
        (this.element.style.cssText =
          "position: absolute; z-index: 50; pointer-events: none;"),
        this.color && (this.element.style.backgroundColor = this.color)),
        this.element.classList.toggle("prosemirror-dropcursor-block", n),
        this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
      let i, s;
      if (
        !o ||
        (o == document.body && getComputedStyle(o).position == "static")
      )
        (i = -pageXOffset), (s = -pageYOffset);
      else {
        let a = o.getBoundingClientRect();
        (i = a.left - o.scrollLeft), (s = a.top - o.scrollTop);
      }
      (this.element.style.left = r.left - i + "px"),
        (this.element.style.top = r.top - s + "px"),
        (this.element.style.width = r.right - r.left + "px"),
        (this.element.style.height = r.bottom - r.top + "px");
    }
    scheduleRemoval(e) {
      clearTimeout(this.timeout),
        (this.timeout = setTimeout(() => this.setCursor(null), e));
    }
    dragover(e) {
      if (!this.editorView.editable) return;
      let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
        r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
        o = r && r.type.spec.disableDropCursor,
        i = typeof o == "function" ? o(this.editorView, n, e) : o;
      if (n && !i) {
        let s = n.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let a = gf(
            this.editorView.state.doc,
            s,
            this.editorView.dragging.slice
          );
          a != null && (s = a);
        }
        this.setCursor(s), this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(e) {
      (e.target == this.editorView.dom ||
        !this.editorView.dom.contains(e.relatedTarget)) &&
        this.setCursor(null);
    }
  }
  for (
    var Fr = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
      },
      Hl = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"',
      },
      Yg = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent),
      EE = typeof navigator < "u" && /Mac/.test(navigator.platform),
      AE =
        typeof navigator < "u" &&
        /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
          navigator.userAgent
        ),
      SE = EE || (Yg && +Yg[1] < 57),
      st = 0;
    st < 10;
    st++
  )
    Fr[48 + st] = Fr[96 + st] = String(st);
  for (var st = 1; st <= 24; st++) Fr[st + 111] = "F" + st;
  for (var st = 65; st <= 90; st++)
    (Fr[st] = String.fromCharCode(st + 32)), (Hl[st] = String.fromCharCode(st));
  for (var Ff in Fr) Hl.hasOwnProperty(Ff) || (Hl[Ff] = Fr[Ff]);
  function ME(t) {
    var e =
        (SE && (t.ctrlKey || t.altKey || t.metaKey)) ||
        (AE && t.shiftKey && t.key && t.key.length == 1) ||
        t.key == "Unidentified",
      n =
        (!e && t.key) ||
        (t.shiftKey ? Hl : Fr)[t.keyCode] ||
        t.key ||
        "Unidentified";
    return (
      n == "Esc" && (n = "Escape"),
      n == "Del" && (n = "Delete"),
      n == "Left" && (n = "ArrowLeft"),
      n == "Up" && (n = "ArrowUp"),
      n == "Right" && (n = "ArrowRight"),
      n == "Down" && (n = "ArrowDown"),
      n
    );
  }
  const TE =
    typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
  function NE(t) {
    let e = t.split(/-(?!$)/),
      n = e[e.length - 1];
    n == "Space" && (n = " ");
    let r, o, i, s;
    for (let a = 0; a < e.length - 1; a++) {
      let l = e[a];
      if (/^(cmd|meta|m)$/i.test(l)) s = !0;
      else if (/^a(lt)?$/i.test(l)) r = !0;
      else if (/^(c|ctrl|control)$/i.test(l)) o = !0;
      else if (/^s(hift)?$/i.test(l)) i = !0;
      else if (/^mod$/i.test(l)) TE ? (s = !0) : (o = !0);
      else throw new Error("Unrecognized modifier name: " + l);
    }
    return (
      r && (n = "Alt-" + n),
      o && (n = "Ctrl-" + n),
      s && (n = "Meta-" + n),
      i && (n = "Shift-" + n),
      n
    );
  }
  function OE(t) {
    let e = Object.create(null);
    for (let n in t) e[NE(n)] = t[n];
    return e;
  }
  function Hf(t, e, n = !0) {
    return (
      e.altKey && (t = "Alt-" + t),
      e.ctrlKey && (t = "Ctrl-" + t),
      e.metaKey && (t = "Meta-" + t),
      n && e.shiftKey && (t = "Shift-" + t),
      t
    );
  }
  function Xg(t) {
    return new ie({ props: { handleKeyDown: Ms(t) } });
  }
  function Ms(t) {
    let e = OE(t);
    return function (n, r) {
      let o = ME(r),
        i,
        s = e[Hf(o, r)];
      if (s && s(n.state, n.dispatch, n)) return !0;
      if (o.length == 1 && o != " ") {
        if (r.shiftKey) {
          let a = e[Hf(o, r, !1)];
          if (a && a(n.state, n.dispatch, n)) return !0;
        }
        if (
          (r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) &&
          (i = Fr[r.keyCode]) &&
          i != o
        ) {
          let a = e[Hf(i, r)];
          if (a && a(n.state, n.dispatch, n)) return !0;
        }
      }
      return !1;
    };
  }
  const at = function (t) {
      for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
    },
    Ts = function (t) {
      let e = t.assignedSlot || t.parentNode;
      return e && e.nodeType == 11 ? e.host : e;
    };
  let zf = null;
  const ur = function (t, e, n) {
      let r = zf || (zf = document.createRange());
      return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
    },
    RE = function () {
      zf = null;
    },
    Bo = function (t, e, n, r) {
      return n && (Zg(t, e, n, r, -1) || Zg(t, e, n, r, 1));
    },
    DE = /^(img|br|input|textarea|hr)$/i;
  function Zg(t, e, n, r, o) {
    for (;;) {
      if (t == n && e == r) return !0;
      if (e == (o < 0 ? 0 : tn(t))) {
        let i = t.parentNode;
        if (
          !i ||
          i.nodeType != 1 ||
          Ns(t) ||
          DE.test(t.nodeName) ||
          t.contentEditable == "false"
        )
          return !1;
        (e = at(t) + (o < 0 ? 0 : 1)), (t = i);
      } else if (t.nodeType == 1) {
        if (
          ((t = t.childNodes[e + (o < 0 ? -1 : 0)]),
          t.contentEditable == "false")
        )
          return !1;
        e = o < 0 ? tn(t) : 0;
      } else return !1;
    }
  }
  function tn(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function LE(t, e) {
    for (;;) {
      if (t.nodeType == 3 && e) return t;
      if (t.nodeType == 1 && e > 0) {
        if (t.contentEditable == "false") return null;
        (t = t.childNodes[e - 1]), (e = tn(t));
      } else if (t.parentNode && !Ns(t)) (e = at(t)), (t = t.parentNode);
      else return null;
    }
  }
  function IE(t, e) {
    for (;;) {
      if (t.nodeType == 3 && e < t.nodeValue.length) return t;
      if (t.nodeType == 1 && e < t.childNodes.length) {
        if (t.contentEditable == "false") return null;
        (t = t.childNodes[e]), (e = 0);
      } else if (t.parentNode && !Ns(t)) (e = at(t) + 1), (t = t.parentNode);
      else return null;
    }
  }
  function BE(t, e, n) {
    for (let r = e == 0, o = e == tn(t); r || o; ) {
      if (t == n) return !0;
      let i = at(t);
      if (((t = t.parentNode), !t)) return !1;
      (r = r && i == 0), (o = o && i == tn(t));
    }
  }
  function Ns(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
  }
  const zl = function (t) {
    return (
      t.focusNode &&
      Bo(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
    );
  };
  function Po(t, e) {
    let n = document.createEvent("Event");
    return (
      n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
    );
  }
  function PE(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
    return e;
  }
  function $E(t, e, n) {
    if (t.caretPositionFromPoint)
      try {
        let r = t.caretPositionFromPoint(e, n);
        if (r)
          return {
            node: r.offsetNode,
            offset: Math.min(tn(r.offsetNode), r.offset),
          };
      } catch {}
    if (t.caretRangeFromPoint) {
      let r = t.caretRangeFromPoint(e, n);
      if (r)
        return {
          node: r.startContainer,
          offset: Math.min(tn(r.startContainer), r.startOffset),
        };
    }
  }
  const Hn = typeof navigator < "u" ? navigator : null,
    Qg = typeof document < "u" ? document : null,
    Hr = (Hn && Hn.userAgent) || "",
    Vf = /Edge\/(\d+)/.exec(Hr),
    e2 = /MSIE \d/.exec(Hr),
    Uf = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Hr),
    Dt = !!(e2 || Uf || Vf),
    zr = e2 ? document.documentMode : Uf ? +Uf[1] : Vf ? +Vf[1] : 0,
    Sn = !Dt && /gecko\/(\d+)/i.test(Hr);
  Sn && +(/Firefox\/(\d+)/.exec(Hr) || [0, 0])[1];
  const jf = !Dt && /Chrome\/(\d+)/.exec(Hr),
    gt = !!jf,
    t2 = jf ? +jf[1] : 0,
    kt = !Dt && !!Hn && /Apple Computer/.test(Hn.vendor),
    mi = kt && (/Mobile\/\w+/.test(Hr) || (!!Hn && Hn.maxTouchPoints > 2)),
    nn = mi || (Hn ? /Mac/.test(Hn.platform) : !1),
    FE = Hn ? /Win/.test(Hn.platform) : !1,
    dr = /Android \d/.test(Hr),
    Os = !!Qg && "webkitFontSmoothing" in Qg.documentElement.style,
    HE = Os
      ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
      : 0;
  function zE(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e
      ? { left: 0, right: e.width, top: 0, bottom: e.height }
      : {
          left: 0,
          right: t.documentElement.clientWidth,
          top: 0,
          bottom: t.documentElement.clientHeight,
        };
  }
  function fr(t, e) {
    return typeof t == "number" ? t : t[e];
  }
  function VE(t) {
    let e = t.getBoundingClientRect(),
      n = e.width / t.offsetWidth || 1,
      r = e.height / t.offsetHeight || 1;
    return {
      left: e.left,
      right: e.left + t.clientWidth * n,
      top: e.top,
      bottom: e.top + t.clientHeight * r,
    };
  }
  function n2(t, e, n) {
    let r = t.someProp("scrollThreshold") || 0,
      o = t.someProp("scrollMargin") || 5,
      i = t.dom.ownerDocument;
    for (let s = n || t.dom; s; s = Ts(s)) {
      if (s.nodeType != 1) continue;
      let a = s,
        l = a == i.body,
        c = l ? zE(i) : VE(a),
        d = 0,
        f = 0;
      if (
        (e.top < c.top + fr(r, "top")
          ? (f = -(c.top - e.top + fr(o, "top")))
          : e.bottom > c.bottom - fr(r, "bottom") &&
            (f =
              e.bottom - e.top > c.bottom - c.top
                ? e.top + fr(o, "top") - c.top
                : e.bottom - c.bottom + fr(o, "bottom")),
        e.left < c.left + fr(r, "left")
          ? (d = -(c.left - e.left + fr(o, "left")))
          : e.right > c.right - fr(r, "right") &&
            (d = e.right - c.right + fr(o, "right")),
        d || f)
      )
        if (l) i.defaultView.scrollBy(d, f);
        else {
          let p = a.scrollLeft,
            h = a.scrollTop;
          f && (a.scrollTop += f), d && (a.scrollLeft += d);
          let m = a.scrollLeft - p,
            g = a.scrollTop - h;
          e = {
            left: e.left - m,
            top: e.top - g,
            right: e.right - m,
            bottom: e.bottom - g,
          };
        }
      if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
    }
  }
  function UE(t) {
    let e = t.dom.getBoundingClientRect(),
      n = Math.max(0, e.top),
      r,
      o;
    for (
      let i = (e.left + e.right) / 2, s = n + 1;
      s < Math.min(innerHeight, e.bottom);
      s += 5
    ) {
      let a = t.root.elementFromPoint(i, s);
      if (!a || a == t.dom || !t.dom.contains(a)) continue;
      let l = a.getBoundingClientRect();
      if (l.top >= n - 20) {
        (r = a), (o = l.top);
        break;
      }
    }
    return { refDOM: r, refTop: o, stack: r2(t.dom) };
  }
  function r2(t) {
    let e = [],
      n = t.ownerDocument;
    for (
      let r = t;
      r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
      r = Ts(r)
    );
    return e;
  }
  function jE({ refDOM: t, refTop: e, stack: n }) {
    let r = t ? t.getBoundingClientRect().top : 0;
    o2(n, r == 0 ? 0 : r - e);
  }
  function o2(t, e) {
    for (let n = 0; n < t.length; n++) {
      let { dom: r, top: o, left: i } = t[n];
      r.scrollTop != o + e && (r.scrollTop = o + e),
        r.scrollLeft != i && (r.scrollLeft = i);
    }
  }
  let gi = null;
  function WE(t) {
    if (t.setActive) return t.setActive();
    if (gi) return t.focus(gi);
    let e = r2(t);
    t.focus(
      gi == null
        ? {
            get preventScroll() {
              return (gi = { preventScroll: !0 }), !0;
            },
          }
        : void 0
    ),
      gi || ((gi = !1), o2(e, 0));
  }
  function i2(t, e) {
    let n,
      r = 2e8,
      o,
      i = 0,
      s = e.top,
      a = e.top,
      l,
      c;
    for (let d = t.firstChild, f = 0; d; d = d.nextSibling, f++) {
      let p;
      if (d.nodeType == 1) p = d.getClientRects();
      else if (d.nodeType == 3) p = ur(d).getClientRects();
      else continue;
      for (let h = 0; h < p.length; h++) {
        let m = p[h];
        if (m.top <= s && m.bottom >= a) {
          (s = Math.max(m.bottom, s)), (a = Math.min(m.top, a));
          let g =
            m.left > e.left
              ? m.left - e.left
              : m.right < e.left
              ? e.left - m.right
              : 0;
          if (g < r) {
            (n = d),
              (r = g),
              (o =
                g && n.nodeType == 3
                  ? { left: m.right < e.left ? m.right : m.left, top: e.top }
                  : e),
              d.nodeType == 1 &&
                g &&
                (i = f + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
            continue;
          }
        } else
          m.top > e.top &&
            !l &&
            m.left <= e.left &&
            m.right >= e.left &&
            ((l = d),
            (c = {
              left: Math.max(m.left, Math.min(m.right, e.left)),
              top: m.top,
            }));
        !n &&
          ((e.left >= m.right && e.top >= m.top) ||
            (e.left >= m.left && e.top >= m.bottom)) &&
          (i = f + 1);
      }
    }
    return (
      !n && l && ((n = l), (o = c), (r = 0)),
      n && n.nodeType == 3
        ? qE(n, o)
        : !n || (r && n.nodeType == 1)
        ? { node: t, offset: i }
        : i2(n, o)
    );
  }
  function qE(t, e) {
    let n = t.nodeValue.length,
      r = document.createRange();
    for (let o = 0; o < n; o++) {
      r.setEnd(t, o + 1), r.setStart(t, o);
      let i = Vr(r, 1);
      if (i.top != i.bottom && Wf(e, i))
        return {
          node: t,
          offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0),
        };
    }
    return { node: t, offset: 0 };
  }
  function Wf(t, e) {
    return (
      t.left >= e.left - 1 &&
      t.left <= e.right + 1 &&
      t.top >= e.top - 1 &&
      t.top <= e.bottom + 1
    );
  }
  function KE(t, e) {
    let n = t.parentNode;
    return n &&
      /^li$/i.test(n.nodeName) &&
      e.left < t.getBoundingClientRect().left
      ? n
      : t;
  }
  function GE(t, e, n) {
    let { node: r, offset: o } = i2(e, n),
      i = -1;
    if (r.nodeType == 1 && !r.firstChild) {
      let s = r.getBoundingClientRect();
      i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
    }
    return t.docView.posFromDOM(r, o, i);
  }
  function JE(t, e, n, r) {
    let o = -1;
    for (let i = e, s = !1; i != t.dom; ) {
      let a = t.docView.nearestDesc(i, !0),
        l;
      if (!a) return null;
      if (
        a.dom.nodeType == 1 &&
        ((a.node.isBlock && a.parent) || !a.contentDOM) &&
        ((l = a.dom.getBoundingClientRect()).width || l.height) &&
        (a.node.isBlock &&
          a.parent &&
          ((!s && l.left > r.left) || l.top > r.top
            ? (o = a.posBefore)
            : ((!s && l.right < r.left) || l.bottom < r.top) &&
              (o = a.posAfter),
          (s = !0)),
        !a.contentDOM && o < 0 && !a.node.isText)
      )
        return (
          a.node.isBlock
            ? r.top < (l.top + l.bottom) / 2
            : r.left < (l.left + l.right) / 2
        )
          ? a.posBefore
          : a.posAfter;
      i = a.dom.parentNode;
    }
    return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
  }
  function s2(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
      for (
        let o = Math.max(
            0,
            Math.min(
              r - 1,
              Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2
            )
          ),
          i = o;
        ;

      ) {
        let s = t.childNodes[i];
        if (s.nodeType == 1) {
          let a = s.getClientRects();
          for (let l = 0; l < a.length; l++) {
            let c = a[l];
            if (Wf(e, c)) return s2(s, e, c);
          }
        }
        if ((i = (i + 1) % r) == o) break;
      }
    return t;
  }
  function YE(t, e) {
    let n = t.dom.ownerDocument,
      r,
      o = 0,
      i = $E(n, e.left, e.top);
    i && ({ node: r, offset: o } = i);
    let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
        e.left,
        e.top
      ),
      a;
    if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
      let c = t.dom.getBoundingClientRect();
      if (!Wf(e, c) || ((s = s2(t.dom, e, c)), !s)) return null;
    }
    if (kt) for (let c = s; r && c; c = Ts(c)) c.draggable && (r = void 0);
    if (((s = KE(s, e)), r)) {
      if (
        Sn &&
        r.nodeType == 1 &&
        ((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
      ) {
        let d = r.childNodes[o],
          f;
        d.nodeName == "IMG" &&
          (f = d.getBoundingClientRect()).right <= e.left &&
          f.bottom > e.top &&
          o++;
      }
      let c;
      Os &&
        o &&
        r.nodeType == 1 &&
        (c = r.childNodes[o - 1]).nodeType == 1 &&
        c.contentEditable == "false" &&
        c.getBoundingClientRect().top >= e.top &&
        o--,
        r == t.dom &&
        o == r.childNodes.length - 1 &&
        r.lastChild.nodeType == 1 &&
        e.top > r.lastChild.getBoundingClientRect().bottom
          ? (a = t.state.doc.content.size)
          : (o == 0 ||
              r.nodeType != 1 ||
              r.childNodes[o - 1].nodeName != "BR") &&
            (a = JE(t, r, o, e));
    }
    a == null && (a = GE(t, s, e));
    let l = t.docView.nearestDesc(s, !0);
    return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
  }
  function a2(t) {
    return t.top < t.bottom || t.left < t.right;
  }
  function Vr(t, e) {
    let n = t.getClientRects();
    if (n.length) {
      let r = n[e < 0 ? 0 : n.length - 1];
      if (a2(r)) return r;
    }
    return Array.prototype.find.call(n, a2) || t.getBoundingClientRect();
  }
  const XE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function l2(t, e, n) {
    let {
        node: r,
        offset: o,
        atom: i,
      } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
      s = Os || Sn;
    if (r.nodeType == 3)
      if (
        s &&
        (XE.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))
      ) {
        let l = Vr(ur(r, o, o), n);
        if (
          Sn &&
          o &&
          /\s/.test(r.nodeValue[o - 1]) &&
          o < r.nodeValue.length
        ) {
          let c = Vr(ur(r, o - 1, o - 1), -1);
          if (c.top == l.top) {
            let d = Vr(ur(r, o, o + 1), -1);
            if (d.top != l.top) return Rs(d, d.left < c.left);
          }
        }
        return l;
      } else {
        let l = o,
          c = o,
          d = n < 0 ? 1 : -1;
        return (
          n < 0 && !o
            ? (c++, (d = -1))
            : n >= 0 && o == r.nodeValue.length
            ? (l--, (d = 1))
            : n < 0
            ? l--
            : c++,
          Rs(Vr(ur(r, l, c), d), d < 0)
        );
      }
    if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
      if (i == null && o && (n < 0 || o == tn(r))) {
        let l = r.childNodes[o - 1];
        if (l.nodeType == 1) return qf(l.getBoundingClientRect(), !1);
      }
      if (i == null && o < tn(r)) {
        let l = r.childNodes[o];
        if (l.nodeType == 1) return qf(l.getBoundingClientRect(), !0);
      }
      return qf(r.getBoundingClientRect(), n >= 0);
    }
    if (i == null && o && (n < 0 || o == tn(r))) {
      let l = r.childNodes[o - 1],
        c =
          l.nodeType == 3
            ? ur(l, tn(l) - (s ? 0 : 1))
            : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling)
            ? l
            : null;
      if (c) return Rs(Vr(c, 1), !1);
    }
    if (i == null && o < tn(r)) {
      let l = r.childNodes[o];
      for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling;
      let c = l
        ? l.nodeType == 3
          ? ur(l, 0, s ? 0 : 1)
          : l.nodeType == 1
          ? l
          : null
        : null;
      if (c) return Rs(Vr(c, -1), !0);
    }
    return Rs(Vr(r.nodeType == 3 ? ur(r) : r, -n), n >= 0);
  }
  function Rs(t, e) {
    if (t.width == 0) return t;
    let n = e ? t.left : t.right;
    return { top: t.top, bottom: t.bottom, left: n, right: n };
  }
  function qf(t, e) {
    if (t.height == 0) return t;
    let n = e ? t.top : t.bottom;
    return { top: n, bottom: n, left: t.left, right: t.right };
  }
  function c2(t, e, n) {
    let r = t.state,
      o = t.root.activeElement;
    r != e && t.updateState(e), o != t.dom && t.focus();
    try {
      return n();
    } finally {
      r != e && t.updateState(r), o != t.dom && o && o.focus();
    }
  }
  function ZE(t, e, n) {
    let r = e.selection,
      o = n == "up" ? r.$from : r.$to;
    return c2(t, e, () => {
      let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
      for (;;) {
        let a = t.docView.nearestDesc(i, !0);
        if (!a) break;
        if (a.node.isBlock) {
          i = a.contentDOM || a.dom;
          break;
        }
        i = a.dom.parentNode;
      }
      let s = l2(t, o.pos, 1);
      for (let a = i.firstChild; a; a = a.nextSibling) {
        let l;
        if (a.nodeType == 1) l = a.getClientRects();
        else if (a.nodeType == 3)
          l = ur(a, 0, a.nodeValue.length).getClientRects();
        else continue;
        for (let c = 0; c < l.length; c++) {
          let d = l[c];
          if (
            d.bottom > d.top + 1 &&
            (n == "up"
              ? s.top - d.top > (d.bottom - s.top) * 2
              : d.bottom - s.bottom > (s.bottom - d.top) * 2)
          )
            return !1;
        }
      }
      return !0;
    });
  }
  const QE = /[\u0590-\u08ac]/;
  function e6(t, e, n) {
    let { $head: r } = e.selection;
    if (!r.parent.isTextblock) return !1;
    let o = r.parentOffset,
      i = !o,
      s = o == r.parent.content.size,
      a = t.domSelection();
    return a
      ? !QE.test(r.parent.textContent) || !a.modify
        ? n == "left" || n == "backward"
          ? i
          : s
        : c2(t, e, () => {
            let {
                focusNode: l,
                focusOffset: c,
                anchorNode: d,
                anchorOffset: f,
              } = t.domSelectionRange(),
              p = a.caretBidiLevel;
            a.modify("move", n, "character");
            let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
              { focusNode: m, focusOffset: g } = t.domSelectionRange(),
              b =
                (m && !h.contains(m.nodeType == 1 ? m : m.parentNode)) ||
                (l == m && c == g);
            try {
              a.collapse(d, f),
                l && (l != d || c != f) && a.extend && a.extend(l, c);
            } catch {}
            return p != null && (a.caretBidiLevel = p), b;
          })
      : r.pos == r.start() || r.pos == r.end();
  }
  let u2 = null,
    d2 = null,
    f2 = !1;
  function t6(t, e, n) {
    return u2 == e && d2 == n
      ? f2
      : ((u2 = e),
        (d2 = n),
        (f2 = n == "up" || n == "down" ? ZE(t, e, n) : e6(t, e, n)));
  }
  const rn = 0,
    p2 = 1,
    $o = 2,
    zn = 3;
  class Ds {
    constructor(e, n, r, o) {
      (this.parent = e),
        (this.children = n),
        (this.dom = r),
        (this.contentDOM = o),
        (this.dirty = rn),
        (r.pmViewDesc = this);
    }
    matchesWidget(e) {
      return !1;
    }
    matchesMark(e) {
      return !1;
    }
    matchesNode(e, n, r) {
      return !1;
    }
    matchesHack(e) {
      return !1;
    }
    parseRule() {
      return null;
    }
    stopEvent(e) {
      return !1;
    }
    get size() {
      let e = 0;
      for (let n = 0; n < this.children.length; n++) e += this.children[n].size;
      return e;
    }
    get border() {
      return 0;
    }
    destroy() {
      (this.parent = void 0),
        this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
      for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
    }
    posBeforeChild(e) {
      for (let n = 0, r = this.posAtStart; ; n++) {
        let o = this.children[n];
        if (o == e) return r;
        r += o.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(e, n, r) {
      if (
        this.contentDOM &&
        this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
      )
        if (r < 0) {
          let i, s;
          if (e == this.contentDOM) i = e.childNodes[n - 1];
          else {
            for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
            i = e.previousSibling;
          }
          for (; i && !((s = i.pmViewDesc) && s.parent == this); )
            i = i.previousSibling;
          return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
        } else {
          let i, s;
          if (e == this.contentDOM) i = e.childNodes[n];
          else {
            for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
            i = e.nextSibling;
          }
          for (; i && !((s = i.pmViewDesc) && s.parent == this); )
            i = i.nextSibling;
          return i ? this.posBeforeChild(s) : this.posAtEnd;
        }
      let o;
      if (e == this.dom && this.contentDOM) o = n > at(this.contentDOM);
      else if (
        this.contentDOM &&
        this.contentDOM != this.dom &&
        this.dom.contains(this.contentDOM)
      )
        o = e.compareDocumentPosition(this.contentDOM) & 2;
      else if (this.dom.firstChild) {
        if (n == 0)
          for (let i = e; ; i = i.parentNode) {
            if (i == this.dom) {
              o = !1;
              break;
            }
            if (i.previousSibling) break;
          }
        if (o == null && n == e.childNodes.length)
          for (let i = e; ; i = i.parentNode) {
            if (i == this.dom) {
              o = !0;
              break;
            }
            if (i.nextSibling) break;
          }
      }
      return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(e, n = !1) {
      for (let r = !0, o = e; o; o = o.parentNode) {
        let i = this.getDesc(o),
          s;
        if (i && (!n || i.node))
          if (
            r &&
            (s = i.nodeDOM) &&
            !(s.nodeType == 1
              ? s.contains(e.nodeType == 1 ? e : e.parentNode)
              : s == e)
          )
            r = !1;
          else return i;
      }
    }
    getDesc(e) {
      let n = e.pmViewDesc;
      for (let r = n; r; r = r.parent) if (r == this) return n;
    }
    posFromDOM(e, n, r) {
      for (let o = e; o; o = o.parentNode) {
        let i = this.getDesc(o);
        if (i) return i.localPosFromDOM(e, n, r);
      }
      return -1;
    }
    descAt(e) {
      for (let n = 0, r = 0; n < this.children.length; n++) {
        let o = this.children[n],
          i = r + o.size;
        if (r == e && i != r) {
          for (; !o.border && o.children.length; ) o = o.children[0];
          return o;
        }
        if (e < i) return o.descAt(e - r - o.border);
        r = i;
      }
    }
    domFromPos(e, n) {
      if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
      let r = 0,
        o = 0;
      for (let i = 0; r < this.children.length; r++) {
        let s = this.children[r],
          a = i + s.size;
        if (a > e || s instanceof g2) {
          o = e - i;
          break;
        }
        i = a;
      }
      if (o) return this.children[r].domFromPos(o - this.children[r].border, n);
      for (
        let i;
        r && !(i = this.children[r - 1]).size && i instanceof h2 && i.side >= 0;
        r--
      );
      if (n <= 0) {
        let i,
          s = !0;
        for (
          ;
          (i = r ? this.children[r - 1] : null),
            !(!i || i.dom.parentNode == this.contentDOM);
          r--, s = !1
        );
        return i && n && s && !i.border && !i.domAtom
          ? i.domFromPos(i.size, n)
          : { node: this.contentDOM, offset: i ? at(i.dom) + 1 : 0 };
      } else {
        let i,
          s = !0;
        for (
          ;
          (i = r < this.children.length ? this.children[r] : null),
            !(!i || i.dom.parentNode == this.contentDOM);
          r++, s = !1
        );
        return i && s && !i.border && !i.domAtom
          ? i.domFromPos(0, n)
          : {
              node: this.contentDOM,
              offset: i ? at(i.dom) : this.contentDOM.childNodes.length,
            };
      }
    }
    parseRange(e, n, r = 0) {
      if (this.children.length == 0)
        return {
          node: this.contentDOM,
          from: e,
          to: n,
          fromOffset: 0,
          toOffset: this.contentDOM.childNodes.length,
        };
      let o = -1,
        i = -1;
      for (let s = r, a = 0; ; a++) {
        let l = this.children[a],
          c = s + l.size;
        if (o == -1 && e <= c) {
          let d = s + l.border;
          if (
            e >= d &&
            n <= c - l.border &&
            l.node &&
            l.contentDOM &&
            this.contentDOM.contains(l.contentDOM)
          )
            return l.parseRange(e, n, d);
          e = s;
          for (let f = a; f > 0; f--) {
            let p = this.children[f - 1];
            if (
              p.size &&
              p.dom.parentNode == this.contentDOM &&
              !p.emptyChildAt(1)
            ) {
              o = at(p.dom) + 1;
              break;
            }
            e -= p.size;
          }
          o == -1 && (o = 0);
        }
        if (o > -1 && (c > n || a == this.children.length - 1)) {
          n = c;
          for (let d = a + 1; d < this.children.length; d++) {
            let f = this.children[d];
            if (
              f.size &&
              f.dom.parentNode == this.contentDOM &&
              !f.emptyChildAt(-1)
            ) {
              i = at(f.dom);
              break;
            }
            n += f.size;
          }
          i == -1 && (i = this.contentDOM.childNodes.length);
          break;
        }
        s = c;
      }
      return {
        node: this.contentDOM,
        from: e,
        to: n,
        fromOffset: o,
        toOffset: i,
      };
    }
    emptyChildAt(e) {
      if (this.border || !this.contentDOM || !this.children.length) return !1;
      let n = this.children[e < 0 ? 0 : this.children.length - 1];
      return n.size == 0 || n.emptyChildAt(e);
    }
    domAfterPos(e) {
      let { node: n, offset: r } = this.domFromPos(e, 0);
      if (n.nodeType != 1 || r == n.childNodes.length)
        throw new RangeError("No node after pos " + e);
      return n.childNodes[r];
    }
    setSelection(e, n, r, o = !1) {
      let i = Math.min(e, n),
        s = Math.max(e, n);
      for (let h = 0, m = 0; h < this.children.length; h++) {
        let g = this.children[h],
          b = m + g.size;
        if (i > m && s < b)
          return g.setSelection(e - m - g.border, n - m - g.border, r, o);
        m = b;
      }
      let a = this.domFromPos(e, e ? -1 : 1),
        l = n == e ? a : this.domFromPos(n, n ? -1 : 1),
        c = r.root.getSelection(),
        d = r.domSelectionRange(),
        f = !1;
      if ((Sn || kt) && e == n) {
        let { node: h, offset: m } = a;
        if (h.nodeType == 3) {
          if (
            ((f = !!(
              m &&
              h.nodeValue[m - 1] ==
                `
`
            )),
            f && m == h.nodeValue.length)
          )
            for (let g = h, b; g; g = g.parentNode) {
              if ((b = g.nextSibling)) {
                b.nodeName == "BR" &&
                  (a = l = { node: b.parentNode, offset: at(b) + 1 });
                break;
              }
              let y = g.pmViewDesc;
              if (y && y.node && y.node.isBlock) break;
            }
        } else {
          let g = h.childNodes[m - 1];
          f = g && (g.nodeName == "BR" || g.contentEditable == "false");
        }
      }
      if (
        Sn &&
        d.focusNode &&
        d.focusNode != l.node &&
        d.focusNode.nodeType == 1
      ) {
        let h = d.focusNode.childNodes[d.focusOffset];
        h && h.contentEditable == "false" && (o = !0);
      }
      if (
        !(o || (f && kt)) &&
        Bo(a.node, a.offset, d.anchorNode, d.anchorOffset) &&
        Bo(l.node, l.offset, d.focusNode, d.focusOffset)
      )
        return;
      let p = !1;
      if ((c.extend || e == n) && !f) {
        c.collapse(a.node, a.offset);
        try {
          e != n && c.extend(l.node, l.offset), (p = !0);
        } catch {}
      }
      if (!p) {
        if (e > n) {
          let m = a;
          (a = l), (l = m);
        }
        let h = document.createRange();
        h.setEnd(l.node, l.offset),
          h.setStart(a.node, a.offset),
          c.removeAllRanges(),
          c.addRange(h);
      }
    }
    ignoreMutation(e) {
      return !this.contentDOM && e.type != "selection";
    }
    get contentLost() {
      return (
        this.contentDOM &&
        this.contentDOM != this.dom &&
        !this.dom.contains(this.contentDOM)
      );
    }
    markDirty(e, n) {
      for (let r = 0, o = 0; o < this.children.length; o++) {
        let i = this.children[o],
          s = r + i.size;
        if (r == s ? e <= s && n >= r : e < s && n > r) {
          let a = r + i.border,
            l = s - i.border;
          if (e >= a && n <= l) {
            (this.dirty = e == r || n == s ? $o : p2),
              e == a &&
              n == l &&
              (i.contentLost || i.dom.parentNode != this.contentDOM)
                ? (i.dirty = zn)
                : i.markDirty(e - a, n - a);
            return;
          } else
            i.dirty =
              i.dom == i.contentDOM &&
              i.dom.parentNode == this.contentDOM &&
              !i.children.length
                ? $o
                : zn;
        }
        r = s;
      }
      this.dirty = $o;
    }
    markParentsDirty() {
      let e = 1;
      for (let n = this.parent; n; n = n.parent, e++) {
        let r = e == 1 ? $o : p2;
        n.dirty < r && (n.dirty = r);
      }
    }
    get domAtom() {
      return !1;
    }
    get ignoreForCoords() {
      return !1;
    }
    isText(e) {
      return !1;
    }
  }
  class h2 extends Ds {
    constructor(e, n, r, o) {
      let i,
        s = n.type.toDOM;
      if (
        (typeof s == "function" &&
          (s = s(r, () => {
            if (!i) return o;
            if (i.parent) return i.parent.posBeforeChild(i);
          })),
        !n.type.spec.raw)
      ) {
        if (s.nodeType != 1) {
          let a = document.createElement("span");
          a.appendChild(s), (s = a);
        }
        (s.contentEditable = "false"), s.classList.add("ProseMirror-widget");
      }
      super(e, [], s, null), (this.widget = n), (this.widget = n), (i = this);
    }
    matchesWidget(e) {
      return this.dirty == rn && e.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: !0 };
    }
    stopEvent(e) {
      let n = this.widget.spec.stopEvent;
      return n ? n(e) : !1;
    }
    ignoreMutation(e) {
      return e.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom), super.destroy();
    }
    get domAtom() {
      return !0;
    }
    get side() {
      return this.widget.type.side;
    }
  }
  class n6 extends Ds {
    constructor(e, n, r, o) {
      super(e, [], n, null), (this.textDOM = r), (this.text = o);
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(e, n) {
      return e != this.textDOM
        ? this.posAtStart + (n ? this.size : 0)
        : this.posAtStart + n;
    }
    domFromPos(e) {
      return { node: this.textDOM, offset: e };
    }
    ignoreMutation(e) {
      return e.type === "characterData" && e.target.nodeValue == e.oldValue;
    }
  }
  class Fo extends Ds {
    constructor(e, n, r, o, i) {
      super(e, [], r, o), (this.mark = n), (this.spec = i);
    }
    static create(e, n, r, o) {
      let i = o.nodeViews[n.type.name],
        s = i && i(n, o, r);
      return (
        (!s || !s.dom) &&
          (s = Pr.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
        new Fo(e, n, s.dom, s.contentDOM || s.dom, s)
      );
    }
    parseRule() {
      return this.dirty & zn || this.mark.type.spec.reparseInView
        ? null
        : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM,
          };
    }
    matchesMark(e) {
      return this.dirty != zn && this.mark.eq(e);
    }
    markDirty(e, n) {
      if ((super.markDirty(e, n), this.dirty != rn)) {
        let r = this.parent;
        for (; !r.node; ) r = r.parent;
        r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = rn);
      }
    }
    slice(e, n, r) {
      let o = Fo.create(this.parent, this.mark, !0, r),
        i = this.children,
        s = this.size;
      n < s && (i = Gf(i, n, s, r)), e > 0 && (i = Gf(i, 0, e, r));
      for (let a = 0; a < i.length; a++) i[a].parent = o;
      return (o.children = i), o;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation
        ? this.spec.ignoreMutation(e)
        : super.ignoreMutation(e);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
  }
  class Ur extends Ds {
    constructor(e, n, r, o, i, s, a, l, c) {
      super(e, [], i, s),
        (this.node = n),
        (this.outerDeco = r),
        (this.innerDeco = o),
        (this.nodeDOM = a);
    }
    static create(e, n, r, o, i, s) {
      let a = i.nodeViews[n.type.name],
        l,
        c =
          a &&
          a(
            n,
            i,
            () => {
              if (!l) return s;
              if (l.parent) return l.parent.posBeforeChild(l);
            },
            r,
            o
          ),
        d = c && c.dom,
        f = c && c.contentDOM;
      if (n.isText) {
        if (!d) d = document.createTextNode(n.text);
        else if (d.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else
        d ||
          ({ dom: d, contentDOM: f } = Pr.renderSpec(
            document,
            n.type.spec.toDOM(n),
            null,
            n.attrs
          ));
      !f &&
        !n.isText &&
        d.nodeName != "BR" &&
        (d.hasAttribute("contenteditable") || (d.contentEditable = "false"),
        n.type.spec.draggable && (d.draggable = !0));
      let p = d;
      return (
        (d = _2(d, r, n)),
        c
          ? (l = new r6(e, n, r, o, d, f || null, p, c, i, s + 1))
          : n.isText
          ? new Vl(e, n, r, o, d, p, i)
          : new Ur(e, n, r, o, d, f || null, p, i, s + 1)
      );
    }
    parseRule() {
      if (this.node.type.spec.reparseInView) return null;
      let e = { node: this.node.type.name, attrs: this.node.attrs };
      if (
        (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
        !this.contentDOM)
      )
        e.getContent = () => this.node.content;
      else if (!this.contentLost) e.contentElement = this.contentDOM;
      else {
        for (let n = this.children.length - 1; n >= 0; n--) {
          let r = this.children[n];
          if (this.dom.contains(r.dom.parentNode)) {
            e.contentElement = r.dom.parentNode;
            break;
          }
        }
        e.contentElement || (e.getContent = () => D.empty);
      }
      return e;
    }
    matchesNode(e, n, r) {
      return (
        this.dirty == rn &&
        e.eq(this.node) &&
        Ul(n, this.outerDeco) &&
        r.eq(this.innerDeco)
      );
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    updateChildren(e, n) {
      let r = this.node.inlineContent,
        o = n,
        i = e.composing ? this.localCompositionInfo(e, n) : null,
        s = i && i.pos > -1 ? i : null,
        a = i && i.pos < 0,
        l = new i6(this, s && s.node, e);
      l6(
        this.node,
        this.innerDeco,
        (c, d, f) => {
          c.spec.marks
            ? l.syncToMarks(c.spec.marks, r, e)
            : c.type.side >= 0 &&
              !f &&
              l.syncToMarks(
                d == this.node.childCount ? _e.none : this.node.child(d).marks,
                r,
                e
              ),
            l.placeWidget(c, e, o);
        },
        (c, d, f, p) => {
          l.syncToMarks(c.marks, r, e);
          let h;
          l.findNodeMatch(c, d, f, p) ||
            (a &&
              e.state.selection.from > o &&
              e.state.selection.to < o + c.nodeSize &&
              (h = l.findIndexWithChild(i.node)) > -1 &&
              l.updateNodeAt(c, d, f, h, e)) ||
            l.updateNextNode(c, d, f, e, p, o) ||
            l.addNode(c, d, f, e, o),
            (o += c.nodeSize);
        }
      ),
        l.syncToMarks([], r, e),
        this.node.isTextblock && l.addTextblockHacks(),
        l.destroyRest(),
        (l.changed || this.dirty == $o) &&
          (s && this.protectLocalComposition(e, s),
          b2(this.contentDOM, this.children, e),
          mi && c6(this.dom));
    }
    localCompositionInfo(e, n) {
      let { from: r, to: o } = e.state.selection;
      if (
        !(e.state.selection instanceof U) ||
        r < n ||
        o > n + this.node.content.size
      )
        return null;
      let i = e.input.compositionNode;
      if (!i || !this.dom.contains(i.parentNode)) return null;
      if (this.node.inlineContent) {
        let s = i.nodeValue,
          a = u6(this.node.content, s, r - n, o - n);
        return a < 0 ? null : { node: i, pos: a, text: s };
      } else return { node: i, pos: -1, text: "" };
    }
    protectLocalComposition(e, { node: n, pos: r, text: o }) {
      if (this.getDesc(n)) return;
      let i = n;
      for (; i.parentNode != this.contentDOM; i = i.parentNode) {
        for (; i.previousSibling; ) i.parentNode.removeChild(i.previousSibling);
        for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling);
        i.pmViewDesc && (i.pmViewDesc = void 0);
      }
      let s = new n6(this, i, n, o);
      e.input.compositionNodes.push(s),
        (this.children = Gf(this.children, r, r + o.length, e, s));
    }
    update(e, n, r, o) {
      return this.dirty == zn || !e.sameMarkup(this.node)
        ? !1
        : (this.updateInner(e, n, r, o), !0);
    }
    updateInner(e, n, r, o) {
      this.updateOuterDeco(n),
        (this.node = e),
        (this.innerDeco = r),
        this.contentDOM && this.updateChildren(o, this.posAtStart),
        (this.dirty = rn);
    }
    updateOuterDeco(e) {
      if (Ul(e, this.outerDeco)) return;
      let n = this.nodeDOM.nodeType != 1,
        r = this.dom;
      (this.dom = y2(
        this.dom,
        this.nodeDOM,
        Kf(this.outerDeco, this.node, n),
        Kf(e, this.node, n)
      )),
        this.dom != r &&
          ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
        (this.outerDeco = e);
    }
    selectNode() {
      this.nodeDOM.nodeType == 1 &&
        this.nodeDOM.classList.add("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) &&
          (this.dom.draggable = !0);
    }
    deselectNode() {
      this.nodeDOM.nodeType == 1 &&
        (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) &&
          this.dom.removeAttribute("draggable"));
    }
    get domAtom() {
      return this.node.isAtom;
    }
  }
  function m2(t, e, n, r, o) {
    _2(r, e, t);
    let i = new Ur(void 0, t, e, n, r, r, r, o, 0);
    return i.contentDOM && i.updateChildren(o, 0), i;
  }
  class Vl extends Ur {
    constructor(e, n, r, o, i, s, a) {
      super(e, n, r, o, i, null, s, a, 0);
    }
    parseRule() {
      let e = this.nodeDOM.parentNode;
      for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
      return { skip: e || !0 };
    }
    update(e, n, r, o) {
      return this.dirty == zn ||
        (this.dirty != rn && !this.inParent()) ||
        !e.sameMarkup(this.node)
        ? !1
        : (this.updateOuterDeco(n),
          (this.dirty != rn || e.text != this.node.text) &&
            e.text != this.nodeDOM.nodeValue &&
            ((this.nodeDOM.nodeValue = e.text),
            o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
          (this.node = e),
          (this.dirty = rn),
          !0);
    }
    inParent() {
      let e = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
      return !1;
    }
    domFromPos(e) {
      return { node: this.nodeDOM, offset: e };
    }
    localPosFromDOM(e, n, r) {
      return e == this.nodeDOM
        ? this.posAtStart + Math.min(n, this.node.text.length)
        : super.localPosFromDOM(e, n, r);
    }
    ignoreMutation(e) {
      return e.type != "characterData" && e.type != "selection";
    }
    slice(e, n, r) {
      let o = this.node.cut(e, n),
        i = document.createTextNode(o.text);
      return new Vl(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
    }
    markDirty(e, n) {
      super.markDirty(e, n),
        this.dom != this.nodeDOM &&
          (e == 0 || n == this.nodeDOM.nodeValue.length) &&
          (this.dirty = zn);
    }
    get domAtom() {
      return !1;
    }
    isText(e) {
      return this.node.text == e;
    }
  }
  class g2 extends Ds {
    parseRule() {
      return { ignore: !0 };
    }
    matchesHack(e) {
      return this.dirty == rn && this.dom.nodeName == e;
    }
    get domAtom() {
      return !0;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  }
  class r6 extends Ur {
    constructor(e, n, r, o, i, s, a, l, c, d) {
      super(e, n, r, o, i, s, a, c, d), (this.spec = l);
    }
    update(e, n, r, o) {
      if (this.dirty == zn) return !1;
      if (
        this.spec.update &&
        (this.node.type == e.type || this.spec.multiType)
      ) {
        let i = this.spec.update(e, n, r);
        return i && this.updateInner(e, n, r, o), i;
      } else
        return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o);
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(e, n, r, o) {
      this.spec.setSelection
        ? this.spec.setSelection(e, n, r.root)
        : super.setSelection(e, n, r, o);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
    stopEvent(e) {
      return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation
        ? this.spec.ignoreMutation(e)
        : super.ignoreMutation(e);
    }
  }
  function b2(t, e, n) {
    let r = t.firstChild,
      o = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i],
        a = s.dom;
      if (a.parentNode == t) {
        for (; a != r; ) (r = k2(r)), (o = !0);
        r = r.nextSibling;
      } else (o = !0), t.insertBefore(a, r);
      if (s instanceof Fo) {
        let l = r ? r.previousSibling : t.lastChild;
        b2(s.contentDOM, s.children, n), (r = l ? l.nextSibling : t.firstChild);
      }
    }
    for (; r; ) (r = k2(r)), (o = !0);
    o && n.trackWrites == t && (n.trackWrites = null);
  }
  const Ls = function (t) {
    t && (this.nodeName = t);
  };
  Ls.prototype = Object.create(null);
  const Ho = [new Ls()];
  function Kf(t, e, n) {
    if (t.length == 0) return Ho;
    let r = n ? Ho[0] : new Ls(),
      o = [r];
    for (let i = 0; i < t.length; i++) {
      let s = t[i].type.attrs;
      if (s) {
        s.nodeName && o.push((r = new Ls(s.nodeName)));
        for (let a in s) {
          let l = s[a];
          l != null &&
            (n &&
              o.length == 1 &&
              o.push((r = new Ls(e.isInline ? "span" : "div"))),
            a == "class"
              ? (r.class = (r.class ? r.class + " " : "") + l)
              : a == "style"
              ? (r.style = (r.style ? r.style + ";" : "") + l)
              : a != "nodeName" && (r[a] = l));
        }
      }
    }
    return o;
  }
  function y2(t, e, n, r) {
    if (n == Ho && r == Ho) return e;
    let o = e;
    for (let i = 0; i < r.length; i++) {
      let s = r[i],
        a = n[i];
      if (i) {
        let l;
        (a &&
          a.nodeName == s.nodeName &&
          o != t &&
          (l = o.parentNode) &&
          l.nodeName.toLowerCase() == s.nodeName) ||
          ((l = document.createElement(s.nodeName)),
          (l.pmIsDeco = !0),
          l.appendChild(o),
          (a = Ho[0])),
          (o = l);
      }
      o6(o, a || Ho[0], s);
    }
    return o;
  }
  function o6(t, e, n) {
    for (let r in e)
      r != "class" &&
        r != "style" &&
        r != "nodeName" &&
        !(r in n) &&
        t.removeAttribute(r);
    for (let r in n)
      r != "class" &&
        r != "style" &&
        r != "nodeName" &&
        n[r] != e[r] &&
        t.setAttribute(r, n[r]);
    if (e.class != n.class) {
      let r = e.class ? e.class.split(" ").filter(Boolean) : [],
        o = n.class ? n.class.split(" ").filter(Boolean) : [];
      for (let i = 0; i < r.length; i++)
        o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
      for (let i = 0; i < o.length; i++)
        r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
      t.classList.length == 0 && t.removeAttribute("class");
    }
    if (e.style != n.style) {
      if (e.style) {
        let r =
            /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
          o;
        for (; (o = r.exec(e.style)); ) t.style.removeProperty(o[1]);
      }
      n.style && (t.style.cssText += n.style);
    }
  }
  function _2(t, e, n) {
    return y2(t, t, Ho, Kf(e, n, t.nodeType != 1));
  }
  function Ul(t, e) {
    if (t.length != e.length) return !1;
    for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
    return !0;
  }
  function k2(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
  }
  class i6 {
    constructor(e, n, r) {
      (this.lock = n),
        (this.view = r),
        (this.index = 0),
        (this.stack = []),
        (this.changed = !1),
        (this.top = e),
        (this.preMatch = s6(e.node.content, e));
    }
    destroyBetween(e, n) {
      if (e != n) {
        for (let r = e; r < n; r++) this.top.children[r].destroy();
        this.top.children.splice(e, n - e), (this.changed = !0);
      }
    }
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    syncToMarks(e, n, r) {
      let o = 0,
        i = this.stack.length >> 1,
        s = Math.min(i, e.length);
      for (
        ;
        o < s &&
        (o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(e[o]) &&
        e[o].type.spec.spanning !== !1;

      )
        o++;
      for (; o < i; )
        this.destroyRest(),
          (this.top.dirty = rn),
          (this.index = this.stack.pop()),
          (this.top = this.stack.pop()),
          i--;
      for (; i < e.length; ) {
        this.stack.push(this.top, this.index + 1);
        let a = -1;
        for (
          let l = this.index;
          l < Math.min(this.index + 3, this.top.children.length);
          l++
        ) {
          let c = this.top.children[l];
          if (c.matchesMark(e[i]) && !this.isLocked(c.dom)) {
            a = l;
            break;
          }
        }
        if (a > -1)
          a > this.index &&
            ((this.changed = !0), this.destroyBetween(this.index, a)),
            (this.top = this.top.children[this.index]);
        else {
          let l = Fo.create(this.top, e[i], n, r);
          this.top.children.splice(this.index, 0, l),
            (this.top = l),
            (this.changed = !0);
        }
        (this.index = 0), i++;
      }
    }
    findNodeMatch(e, n, r, o) {
      let i = -1,
        s;
      if (
        o >= this.preMatch.index &&
        (s = this.preMatch.matches[o - this.preMatch.index]).parent ==
          this.top &&
        s.matchesNode(e, n, r)
      )
        i = this.top.children.indexOf(s, this.index);
      else
        for (
          let a = this.index, l = Math.min(this.top.children.length, a + 5);
          a < l;
          a++
        ) {
          let c = this.top.children[a];
          if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
            i = a;
            break;
          }
        }
      return i < 0
        ? !1
        : (this.destroyBetween(this.index, i), this.index++, !0);
    }
    updateNodeAt(e, n, r, o, i) {
      let s = this.top.children[o];
      return (
        s.dirty == zn && s.dom == s.contentDOM && (s.dirty = $o),
        s.update(e, n, r, i)
          ? (this.destroyBetween(this.index, o), this.index++, !0)
          : !1
      );
    }
    findIndexWithChild(e) {
      for (;;) {
        let n = e.parentNode;
        if (!n) return -1;
        if (n == this.top.contentDOM) {
          let r = e.pmViewDesc;
          if (r) {
            for (let o = this.index; o < this.top.children.length; o++)
              if (this.top.children[o] == r) return o;
          }
          return -1;
        }
        e = n;
      }
    }
    updateNextNode(e, n, r, o, i, s) {
      for (let a = this.index; a < this.top.children.length; a++) {
        let l = this.top.children[a];
        if (l instanceof Ur) {
          let c = this.preMatch.matched.get(l);
          if (c != null && c != i) return !1;
          let d = l.dom,
            f,
            p =
              this.isLocked(d) &&
              !(
                e.isText &&
                l.node &&
                l.node.isText &&
                l.nodeDOM.nodeValue == e.text &&
                l.dirty != zn &&
                Ul(n, l.outerDeco)
              );
          if (!p && l.update(e, n, r, o))
            return (
              this.destroyBetween(this.index, a),
              l.dom != d && (this.changed = !0),
              this.index++,
              !0
            );
          if (!p && (f = this.recreateWrapper(l, e, n, r, o, s)))
            return (
              this.destroyBetween(this.index, a),
              (this.top.children[this.index] = f),
              f.contentDOM &&
                ((f.dirty = $o), f.updateChildren(o, s + 1), (f.dirty = rn)),
              (this.changed = !0),
              this.index++,
              !0
            );
          break;
        }
      }
      return !1;
    }
    recreateWrapper(e, n, r, o, i, s) {
      if (
        e.dirty ||
        n.isAtom ||
        !e.children.length ||
        !e.node.content.eq(n.content) ||
        !Ul(r, e.outerDeco) ||
        !o.eq(e.innerDeco)
      )
        return null;
      let a = Ur.create(this.top, n, r, o, i, s);
      if (a.contentDOM) {
        (a.children = e.children), (e.children = []);
        for (let l of a.children) l.parent = a;
      }
      return e.destroy(), a;
    }
    addNode(e, n, r, o, i) {
      let s = Ur.create(this.top, e, n, r, o, i);
      s.contentDOM && s.updateChildren(o, i + 1),
        this.top.children.splice(this.index++, 0, s),
        (this.changed = !0);
    }
    placeWidget(e, n, r) {
      let o =
        this.index < this.top.children.length
          ? this.top.children[this.index]
          : null;
      if (
        o &&
        o.matchesWidget(e) &&
        (e == o.widget || !o.widget.type.toDOM.parentNode)
      )
        this.index++;
      else {
        let i = new h2(this.top, e, n, r);
        this.top.children.splice(this.index++, 0, i), (this.changed = !0);
      }
    }
    addTextblockHacks() {
      let e = this.top.children[this.index - 1],
        n = this.top;
      for (; e instanceof Fo; )
        (n = e), (e = n.children[n.children.length - 1]);
      (!e ||
        !(e instanceof Vl) ||
        /\n$/.test(e.node.text) ||
        (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
        ((kt || gt) &&
          e &&
          e.dom.contentEditable == "false" &&
          this.addHackNode("IMG", n),
        this.addHackNode("BR", this.top));
    }
    addHackNode(e, n) {
      if (
        n == this.top &&
        this.index < n.children.length &&
        n.children[this.index].matchesHack(e)
      )
        this.index++;
      else {
        let r = document.createElement(e);
        e == "IMG" && ((r.className = "ProseMirror-separator"), (r.alt = "")),
          e == "BR" && (r.className = "ProseMirror-trailingBreak");
        let o = new g2(this.top, [], r, null);
        n != this.top
          ? n.children.push(o)
          : n.children.splice(this.index++, 0, o),
          (this.changed = !0);
      }
    }
    isLocked(e) {
      return (
        this.lock &&
        (e == this.lock ||
          (e.nodeType == 1 && e.contains(this.lock.parentNode)))
      );
    }
  }
  function s6(t, e) {
    let n = e,
      r = n.children.length,
      o = t.childCount,
      i = new Map(),
      s = [];
    e: for (; o > 0; ) {
      let a;
      for (;;)
        if (r) {
          let c = n.children[r - 1];
          if (c instanceof Fo) (n = c), (r = c.children.length);
          else {
            (a = c), r--;
            break;
          }
        } else {
          if (n == e) break e;
          (r = n.parent.children.indexOf(n)), (n = n.parent);
        }
      let l = a.node;
      if (l) {
        if (l != t.child(o - 1)) break;
        --o, i.set(a, o), s.push(a);
      }
    }
    return { index: o, matched: i, matches: s.reverse() };
  }
  function a6(t, e) {
    return t.type.side - e.type.side;
  }
  function l6(t, e, n, r) {
    let o = e.locals(t),
      i = 0;
    if (o.length == 0) {
      for (let c = 0; c < t.childCount; c++) {
        let d = t.child(c);
        r(d, o, e.forChild(i, d), c), (i += d.nodeSize);
      }
      return;
    }
    let s = 0,
      a = [],
      l = null;
    for (let c = 0; ; ) {
      let d, f;
      for (; s < o.length && o[s].to == i; ) {
        let b = o[s++];
        b.widget && (d ? (f || (f = [d])).push(b) : (d = b));
      }
      if (d)
        if (f) {
          f.sort(a6);
          for (let b = 0; b < f.length; b++) n(f[b], c, !!l);
        } else n(d, c, !!l);
      let p, h;
      if (l) (h = -1), (p = l), (l = null);
      else if (c < t.childCount) (h = c), (p = t.child(c++));
      else break;
      for (let b = 0; b < a.length; b++) a[b].to <= i && a.splice(b--, 1);
      for (; s < o.length && o[s].from <= i && o[s].to > i; ) a.push(o[s++]);
      let m = i + p.nodeSize;
      if (p.isText) {
        let b = m;
        s < o.length && o[s].from < b && (b = o[s].from);
        for (let y = 0; y < a.length; y++) a[y].to < b && (b = a[y].to);
        b < m && ((l = p.cut(b - i)), (p = p.cut(0, b - i)), (m = b), (h = -1));
      } else for (; s < o.length && o[s].to < m; ) s++;
      let g = p.isInline && !p.isLeaf ? a.filter((b) => !b.inline) : a.slice();
      r(p, g, e.forChild(i, p), h), (i = m);
    }
  }
  function c6(t) {
    if (t.nodeName == "UL" || t.nodeName == "OL") {
      let e = t.style.cssText;
      (t.style.cssText = e + "; list-style: square !important"),
        window.getComputedStyle(t).listStyle,
        (t.style.cssText = e);
    }
  }
  function u6(t, e, n, r) {
    for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
      let s = t.child(o++),
        a = i;
      if (((i += s.nodeSize), !s.isText)) continue;
      let l = s.text;
      for (; o < t.childCount; ) {
        let c = t.child(o++);
        if (((i += c.nodeSize), !c.isText)) break;
        l += c.text;
      }
      if (i >= n) {
        if (i >= r && l.slice(r - e.length - a, r - a) == e)
          return r - e.length;
        let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
        if (c >= 0 && c + e.length + a >= n) return a + c;
        if (
          n == r &&
          l.length >= r + e.length - a &&
          l.slice(r - a, r - a + e.length) == e
        )
          return r;
      }
    }
    return -1;
  }
  function Gf(t, e, n, r, o) {
    let i = [];
    for (let s = 0, a = 0; s < t.length; s++) {
      let l = t[s],
        c = a,
        d = (a += l.size);
      c >= n || d <= e
        ? i.push(l)
        : (c < e && i.push(l.slice(0, e - c, r)),
          o && (i.push(o), (o = void 0)),
          d > n && i.push(l.slice(n - c, l.size, r)));
    }
    return i;
  }
  function Jf(t, e = null) {
    let n = t.domSelectionRange(),
      r = t.state.doc;
    if (!n.focusNode) return null;
    let o = t.docView.nearestDesc(n.focusNode),
      i = o && o.size == 0,
      s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (s < 0) return null;
    let a = r.resolve(s),
      l,
      c;
    if (zl(n)) {
      for (l = s; o && !o.node; ) o = o.parent;
      let f = o.node;
      if (
        o &&
        f.isAtom &&
        K.isSelectable(f) &&
        o.parent &&
        !(f.isInline && BE(n.focusNode, n.focusOffset, o.dom))
      ) {
        let p = o.posBefore;
        c = new K(s == p ? a : r.resolve(p));
      }
    } else {
      if (
        n instanceof t.dom.ownerDocument.defaultView.Selection &&
        n.rangeCount > 1
      ) {
        let f = s,
          p = s;
        for (let h = 0; h < n.rangeCount; h++) {
          let m = n.getRangeAt(h);
          (f = Math.min(
            f,
            t.docView.posFromDOM(m.startContainer, m.startOffset, 1)
          )),
            (p = Math.max(
              p,
              t.docView.posFromDOM(m.endContainer, m.endOffset, -1)
            ));
        }
        if (f < 0) return null;
        ([l, s] = p == t.state.selection.anchor ? [p, f] : [f, p]),
          (a = r.resolve(s));
      } else l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
      if (l < 0) return null;
    }
    let d = r.resolve(l);
    if (!c) {
      let f = e == "pointer" || (t.state.selection.head < a.pos && !i) ? 1 : -1;
      c = Xf(t, d, a, f);
    }
    return c;
  }
  function w2(t) {
    return t.editable
      ? t.hasFocus()
      : M2(t) &&
          document.activeElement &&
          document.activeElement.contains(t.dom);
  }
  function pr(t, e = !1) {
    let n = t.state.selection;
    if ((E2(t, n), !!w2(t))) {
      if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && gt) {
        let r = t.domSelectionRange(),
          o = t.domObserver.currentSelection;
        if (
          r.anchorNode &&
          o.anchorNode &&
          Bo(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
        ) {
          (t.input.mouseDown.delayedSelectionSync = !0),
            t.domObserver.setCurSelection();
          return;
        }
      }
      if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) f6(t);
      else {
        let { anchor: r, head: o } = n,
          i,
          s;
        x2 &&
          !(n instanceof U) &&
          (n.$from.parent.inlineContent || (i = C2(t, n.from)),
          !n.empty && !n.$from.parent.inlineContent && (s = C2(t, n.to))),
          t.docView.setSelection(r, o, t, e),
          x2 && (i && v2(i), s && v2(s)),
          n.visible
            ? t.dom.classList.remove("ProseMirror-hideselection")
            : (t.dom.classList.add("ProseMirror-hideselection"),
              "onselectionchange" in document && d6(t));
      }
      t.domObserver.setCurSelection(), t.domObserver.connectSelection();
    }
  }
  const x2 = kt || (gt && t2 < 63);
  function C2(t, e) {
    let { node: n, offset: r } = t.docView.domFromPos(e, 0),
      o = r < n.childNodes.length ? n.childNodes[r] : null,
      i = r ? n.childNodes[r - 1] : null;
    if (kt && o && o.contentEditable == "false") return Yf(o);
    if (
      (!o || o.contentEditable == "false") &&
      (!i || i.contentEditable == "false")
    ) {
      if (o) return Yf(o);
      if (i) return Yf(i);
    }
  }
  function Yf(t) {
    return (
      (t.contentEditable = "true"),
      kt && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
      t
    );
  }
  function v2(t) {
    (t.contentEditable = "false"),
      t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
  }
  function d6(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
    let n = t.domSelectionRange(),
      r = n.anchorNode,
      o = n.anchorOffset;
    e.addEventListener(
      "selectionchange",
      (t.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != o) &&
          (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
          setTimeout(() => {
            (!w2(t) || t.state.selection.visible) &&
              t.dom.classList.remove("ProseMirror-hideselection");
          }, 20));
      })
    );
  }
  function f6(t) {
    let e = t.domSelection(),
      n = document.createRange();
    if (!e) return;
    let r = t.cursorWrapper.dom,
      o = r.nodeName == "IMG";
    o ? n.setStart(r.parentNode, at(r) + 1) : n.setStart(r, 0),
      n.collapse(!0),
      e.removeAllRanges(),
      e.addRange(n),
      !o &&
        !t.state.selection.visible &&
        Dt &&
        zr <= 11 &&
        ((r.disabled = !0), (r.disabled = !1));
  }
  function E2(t, e) {
    if (e instanceof K) {
      let n = t.docView.descAt(e.from);
      n != t.lastSelectedViewDesc &&
        (A2(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
    } else A2(t);
  }
  function A2(t) {
    t.lastSelectedViewDesc &&
      (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
      (t.lastSelectedViewDesc = void 0));
  }
  function Xf(t, e, n, r) {
    return (
      t.someProp("createSelectionBetween", (o) => o(t, e, n)) ||
      U.between(e, n, r)
    );
  }
  function S2(t) {
    return t.editable && !t.hasFocus() ? !1 : M2(t);
  }
  function M2(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode) return !1;
    try {
      return (
        t.dom.contains(
          e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode
        ) &&
        (t.editable ||
          t.dom.contains(
            e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode
          ))
      );
    } catch {
      return !1;
    }
  }
  function p6(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0),
      n = t.domSelectionRange();
    return Bo(e.node, e.offset, n.anchorNode, n.anchorOffset);
  }
  function Zf(t, e) {
    let { $anchor: n, $head: r } = t.selection,
      o = e > 0 ? n.max(r) : n.min(r),
      i = o.parent.inlineContent
        ? o.depth
          ? t.doc.resolve(e > 0 ? o.after() : o.before())
          : null
        : o;
    return i && J.findFrom(i, e);
  }
  function jr(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
  }
  function T2(t, e, n) {
    let r = t.state.selection;
    if (r instanceof U)
      if (n.indexOf("s") > -1) {
        let { $head: o } = r,
          i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
        if (!i || i.isText || !i.isLeaf) return !1;
        let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
        return jr(t, new U(r.$anchor, s));
      } else if (r.empty) {
        if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
          let o = Zf(t.state, e);
          return o && o instanceof K ? jr(t, o) : !1;
        } else if (!(nn && n.indexOf("m") > -1)) {
          let o = r.$head,
            i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter,
            s;
          if (!i || i.isText) return !1;
          let a = e < 0 ? o.pos - i.nodeSize : o.pos;
          return i.isAtom || ((s = t.docView.descAt(a)) && !s.contentDOM)
            ? K.isSelectable(i)
              ? jr(
                  t,
                  new K(e < 0 ? t.state.doc.resolve(o.pos - i.nodeSize) : o)
                )
              : Os
              ? jr(t, new U(t.state.doc.resolve(e < 0 ? a : a + i.nodeSize)))
              : !1
            : !1;
        }
      } else return !1;
    else {
      if (r instanceof K && r.node.isInline)
        return jr(t, new U(e > 0 ? r.$to : r.$from));
      {
        let o = Zf(t.state, e);
        return o ? jr(t, o) : !1;
      }
    }
  }
  function jl(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function Is(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
  }
  function bi(t, e) {
    return e < 0 ? h6(t) : m6(t);
  }
  function h6(t) {
    let e = t.domSelectionRange(),
      n = e.focusNode,
      r = e.focusOffset;
    if (!n) return;
    let o,
      i,
      s = !1;
    for (
      Sn && n.nodeType == 1 && r < jl(n) && Is(n.childNodes[r], -1) && (s = !0);
      ;

    )
      if (r > 0) {
        if (n.nodeType != 1) break;
        {
          let a = n.childNodes[r - 1];
          if (Is(a, -1)) (o = n), (i = --r);
          else if (a.nodeType == 3) (n = a), (r = n.nodeValue.length);
          else break;
        }
      } else {
        if (N2(n)) break;
        {
          let a = n.previousSibling;
          for (; a && Is(a, -1); )
            (o = n.parentNode), (i = at(a)), (a = a.previousSibling);
          if (a) (n = a), (r = jl(n));
          else {
            if (((n = n.parentNode), n == t.dom)) break;
            r = 0;
          }
        }
      }
    s ? Qf(t, n, r) : o && Qf(t, o, i);
  }
  function m6(t) {
    let e = t.domSelectionRange(),
      n = e.focusNode,
      r = e.focusOffset;
    if (!n) return;
    let o = jl(n),
      i,
      s;
    for (;;)
      if (r < o) {
        if (n.nodeType != 1) break;
        let a = n.childNodes[r];
        if (Is(a, 1)) (i = n), (s = ++r);
        else break;
      } else {
        if (N2(n)) break;
        {
          let a = n.nextSibling;
          for (; a && Is(a, 1); )
            (i = a.parentNode), (s = at(a) + 1), (a = a.nextSibling);
          if (a) (n = a), (r = 0), (o = jl(n));
          else {
            if (((n = n.parentNode), n == t.dom)) break;
            r = o = 0;
          }
        }
      }
    i && Qf(t, i, s);
  }
  function N2(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock;
  }
  function g6(t, e) {
    for (; t && e == t.childNodes.length && !Ns(t); )
      (e = at(t) + 1), (t = t.parentNode);
    for (; t && e < t.childNodes.length; ) {
      let n = t.childNodes[e];
      if (n.nodeType == 3) return n;
      if (n.nodeType == 1 && n.contentEditable == "false") break;
      (t = n), (e = 0);
    }
  }
  function b6(t, e) {
    for (; t && !e && !Ns(t); ) (e = at(t)), (t = t.parentNode);
    for (; t && e; ) {
      let n = t.childNodes[e - 1];
      if (n.nodeType == 3) return n;
      if (n.nodeType == 1 && n.contentEditable == "false") break;
      (t = n), (e = t.childNodes.length);
    }
  }
  function Qf(t, e, n) {
    if (e.nodeType != 3) {
      let i, s;
      (s = g6(e, n))
        ? ((e = s), (n = 0))
        : (i = b6(e, n)) && ((e = i), (n = i.nodeValue.length));
    }
    let r = t.domSelection();
    if (!r) return;
    if (zl(r)) {
      let i = document.createRange();
      i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
    } else r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let { state: o } = t;
    setTimeout(() => {
      t.state == o && pr(t);
    }, 50);
  }
  function O2(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(gt || FE) && n.parent.inlineContent) {
      let o = t.coordsAtPos(e);
      if (e > n.start()) {
        let i = t.coordsAtPos(e - 1),
          s = (i.top + i.bottom) / 2;
        if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
          return i.left < o.left ? "ltr" : "rtl";
      }
      if (e < n.end()) {
        let i = t.coordsAtPos(e + 1),
          s = (i.top + i.bottom) / 2;
        if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
          return i.left > o.left ? "ltr" : "rtl";
      }
    }
    return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
  }
  function R2(t, e, n) {
    let r = t.state.selection;
    if (
      (r instanceof U && !r.empty) ||
      n.indexOf("s") > -1 ||
      (nn && n.indexOf("m") > -1)
    )
      return !1;
    let { $from: o, $to: i } = r;
    if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
      let s = Zf(t.state, e);
      if (s && s instanceof K) return jr(t, s);
    }
    if (!o.parent.inlineContent) {
      let s = e < 0 ? o : i,
        a = r instanceof mt ? J.near(s, e) : J.findFrom(s, e);
      return a ? jr(t, a) : !1;
    }
    return !1;
  }
  function D2(t, e) {
    if (!(t.state.selection instanceof U)) return !0;
    let { $head: n, $anchor: r, empty: o } = t.state.selection;
    if (!n.sameParent(r)) return !0;
    if (!o) return !1;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
    let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (i && !i.isText) {
      let s = t.state.tr;
      return (
        e < 0
          ? s.delete(n.pos - i.nodeSize, n.pos)
          : s.delete(n.pos, n.pos + i.nodeSize),
        t.dispatch(s),
        !0
      );
    }
    return !1;
  }
  function L2(t, e, n) {
    t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
  }
  function y6(t) {
    if (!kt || t.state.selection.$head.parentOffset > 0) return !1;
    let { focusNode: e, focusOffset: n } = t.domSelectionRange();
    if (
      e &&
      e.nodeType == 1 &&
      n == 0 &&
      e.firstChild &&
      e.firstChild.contentEditable == "false"
    ) {
      let r = e.firstChild;
      L2(t, r, "true"), setTimeout(() => L2(t, r, "false"), 20);
    }
    return !1;
  }
  function _6(t) {
    let e = "";
    return (
      t.ctrlKey && (e += "c"),
      t.metaKey && (e += "m"),
      t.altKey && (e += "a"),
      t.shiftKey && (e += "s"),
      e
    );
  }
  function k6(t, e) {
    let n = e.keyCode,
      r = _6(e);
    if (n == 8 || (nn && n == 72 && r == "c")) return D2(t, -1) || bi(t, -1);
    if ((n == 46 && !e.shiftKey) || (nn && n == 68 && r == "c"))
      return D2(t, 1) || bi(t, 1);
    if (n == 13 || n == 27) return !0;
    if (n == 37 || (nn && n == 66 && r == "c")) {
      let o = n == 37 ? (O2(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
      return T2(t, o, r) || bi(t, o);
    } else if (n == 39 || (nn && n == 70 && r == "c")) {
      let o = n == 39 ? (O2(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
      return T2(t, o, r) || bi(t, o);
    } else {
      if (n == 38 || (nn && n == 80 && r == "c"))
        return R2(t, -1, r) || bi(t, -1);
      if (n == 40 || (nn && n == 78 && r == "c"))
        return y6(t) || R2(t, 1, r) || bi(t, 1);
      if (r == (nn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
        return !0;
    }
    return !1;
  }
  function ep(t, e) {
    t.someProp("transformCopied", (h) => {
      e = h(e, t);
    });
    let n = [],
      { content: r, openStart: o, openEnd: i } = e;
    for (
      ;
      o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

    ) {
      o--, i--;
      let h = r.firstChild;
      n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null),
        (r = h.content);
    }
    let s = t.someProp("clipboardSerializer") || Pr.fromSchema(t.state.schema),
      a = z2(),
      l = a.createElement("div");
    l.appendChild(s.serializeFragment(r, { document: a }));
    let c = l.firstChild,
      d,
      f = 0;
    for (; c && c.nodeType == 1 && (d = F2[c.nodeName.toLowerCase()]); ) {
      for (let h = d.length - 1; h >= 0; h--) {
        let m = a.createElement(d[h]);
        for (; l.firstChild; ) m.appendChild(l.firstChild);
        l.appendChild(m), f++;
      }
      c = l.firstChild;
    }
    c &&
      c.nodeType == 1 &&
      c.setAttribute(
        "data-pm-slice",
        `${o} ${i}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`
      );
    let p =
      t.someProp("clipboardTextSerializer", (h) => h(e, t)) ||
      e.content.textBetween(
        0,
        e.content.size,
        `

`
      );
    return { dom: l, text: p, slice: e };
  }
  function tp(t, e, n, r, o) {
    let i = o.parent.type.spec.code,
      s,
      a;
    if (!n && !e) return null;
    let l = e && (r || i || !n);
    if (l) {
      if (
        (t.someProp("transformPastedText", (p) => {
          e = p(e, i || r, t);
        }),
        i)
      )
        return e
          ? new z(
              D.from(
                t.state.schema.text(
                  e.replace(
                    /\r\n?/g,
                    `
`
                  )
                )
              ),
              0,
              0
            )
          : z.empty;
      let f = t.someProp("clipboardTextParser", (p) => p(e, o, r, t));
      if (f) a = f;
      else {
        let p = o.marks(),
          { schema: h } = t.state,
          m = Pr.fromSchema(h);
        (s = document.createElement("div")),
          e.split(/(?:\r\n?|\n)+/).forEach((g) => {
            let b = s.appendChild(document.createElement("p"));
            g && b.appendChild(m.serializeNode(h.text(g, p)));
          });
      }
    } else
      t.someProp("transformPastedHTML", (f) => {
        n = f(n, t);
      }),
        (s = v6(n)),
        Os && E6(s);
    let c = s && s.querySelector("[data-pm-slice]"),
      d =
        c &&
        /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
          c.getAttribute("data-pm-slice") || ""
        );
    if (d && d[3])
      for (let f = +d[3]; f > 0; f--) {
        let p = s.firstChild;
        for (; p && p.nodeType != 1; ) p = p.nextSibling;
        if (!p) break;
        s = p;
      }
    if (
      (a ||
        (a = (
          t.someProp("clipboardParser") ||
          t.someProp("domParser") ||
          Pn.fromSchema(t.state.schema)
        ).parseSlice(s, {
          preserveWhitespace: !!(l || d),
          context: o,
          ruleFromNode(p) {
            return p.nodeName == "BR" &&
              !p.nextSibling &&
              p.parentNode &&
              !w6.test(p.parentNode.nodeName)
              ? { ignore: !0 }
              : null;
          },
        })),
      d)
    )
      a = A6($2(a, +d[1], +d[2]), d[4]);
    else if (
      ((a = z.maxOpen(x6(a.content, o), !0)), a.openStart || a.openEnd)
    ) {
      let f = 0,
        p = 0;
      for (
        let h = a.content.firstChild;
        f < a.openStart && !h.type.spec.isolating;
        f++, h = h.firstChild
      );
      for (
        let h = a.content.lastChild;
        p < a.openEnd && !h.type.spec.isolating;
        p++, h = h.lastChild
      );
      a = $2(a, f, p);
    }
    return (
      t.someProp("transformPasted", (f) => {
        a = f(a, t);
      }),
      a
    );
  }
  const w6 =
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function x6(t, e) {
    if (t.childCount < 2) return t;
    for (let n = e.depth; n >= 0; n--) {
      let o = e.node(n).contentMatchAt(e.index(n)),
        i,
        s = [];
      if (
        (t.forEach((a) => {
          if (!s) return;
          let l = o.findWrapping(a.type),
            c;
          if (!l) return (s = null);
          if ((c = s.length && i.length && B2(l, i, a, s[s.length - 1], 0)))
            s[s.length - 1] = c;
          else {
            s.length && (s[s.length - 1] = P2(s[s.length - 1], i.length));
            let d = I2(a, l);
            s.push(d), (o = o.matchType(d.type)), (i = l);
          }
        }),
        s)
      )
        return D.from(s);
    }
    return t;
  }
  function I2(t, e, n = 0) {
    for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, D.from(t));
    return t;
  }
  function B2(t, e, n, r, o) {
    if (o < t.length && o < e.length && t[o] == e[o]) {
      let i = B2(t, e, n, r.lastChild, o + 1);
      if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i));
      if (
        r
          .contentMatchAt(r.childCount)
          .matchType(o == t.length - 1 ? n.type : t[o + 1])
      )
        return r.copy(r.content.append(D.from(I2(n, t, o + 1))));
    }
  }
  function P2(t, e) {
    if (e == 0) return t;
    let n = t.content.replaceChild(t.childCount - 1, P2(t.lastChild, e - 1)),
      r = t.contentMatchAt(t.childCount).fillBefore(D.empty, !0);
    return t.copy(n.append(r));
  }
  function np(t, e, n, r, o, i) {
    let s = e < 0 ? t.firstChild : t.lastChild,
      a = s.content;
    return (
      t.childCount > 1 && (i = 0),
      o < r - 1 && (a = np(a, e, n, r, o + 1, i)),
      o >= n &&
        (a =
          e < 0
            ? s
                .contentMatchAt(0)
                .fillBefore(a, i <= o)
                .append(a)
            : a.append(s.contentMatchAt(s.childCount).fillBefore(D.empty, !0))),
      t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a))
    );
  }
  function $2(t, e, n) {
    return (
      e < t.openStart &&
        (t = new z(
          np(t.content, -1, e, t.openStart, 0, t.openEnd),
          e,
          t.openEnd
        )),
      n < t.openEnd &&
        (t = new z(np(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
      t
    );
  }
  const F2 = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"],
  };
  let H2 = null;
  function z2() {
    return H2 || (H2 = document.implementation.createHTMLDocument("title"));
  }
  let rp = null;
  function C6(t) {
    let e = window.trustedTypes;
    return e
      ? (rp ||
          (rp = e.createPolicy("ProseMirrorClipboard", {
            createHTML: (n) => n,
          })),
        rp.createHTML(t))
      : t;
  }
  function v6(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = z2().createElement("div"),
      r = /<([a-z][^>\s]+)/i.exec(t),
      o;
    if (
      ((o = r && F2[r[1].toLowerCase()]) &&
        (t =
          o.map((i) => "<" + i + ">").join("") +
          t +
          o
            .map((i) => "</" + i + ">")
            .reverse()
            .join("")),
      (n.innerHTML = C6(t)),
      o)
    )
      for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n;
    return n;
  }
  function E6(t) {
    let e = t.querySelectorAll(
      gt ? "span:not([class]):not([style])" : "span.Apple-converted-space"
    );
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      r.childNodes.length == 1 &&
        r.textContent == " " &&
        r.parentNode &&
        r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
    }
  }
  function A6(t, e) {
    if (!t.size) return t;
    let n = t.content.firstChild.type.schema,
      r;
    try {
      r = JSON.parse(e);
    } catch {
      return t;
    }
    let { content: o, openStart: i, openEnd: s } = t;
    for (let a = r.length - 2; a >= 0; a -= 2) {
      let l = n.nodes[r[a]];
      if (!l || l.hasRequiredAttrs()) break;
      (o = D.from(l.create(r[a + 1], o))), i++, s++;
    }
    return new z(o, i, s);
  }
  const wt = {},
    xt = {},
    S6 = { touchstart: !0, touchmove: !0 };
  class M6 {
    constructor() {
      (this.shiftKey = !1),
        (this.mouseDown = null),
        (this.lastKeyCode = null),
        (this.lastKeyCodeTime = 0),
        (this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
        (this.lastSelectionOrigin = null),
        (this.lastSelectionTime = 0),
        (this.lastIOSEnter = 0),
        (this.lastIOSEnterFallbackTimeout = -1),
        (this.lastFocus = 0),
        (this.lastTouch = 0),
        (this.lastChromeDelete = 0),
        (this.composing = !1),
        (this.compositionNode = null),
        (this.composingTimeout = -1),
        (this.compositionNodes = []),
        (this.compositionEndedAt = -2e8),
        (this.compositionID = 1),
        (this.compositionPendingChanges = 0),
        (this.domChangeCount = 0),
        (this.eventHandlers = Object.create(null)),
        (this.hideSelectionGuard = null);
    }
  }
  function T6(t) {
    for (let e in wt) {
      let n = wt[e];
      t.dom.addEventListener(
        e,
        (t.input.eventHandlers[e] = (r) => {
          O6(t, r) && !ip(t, r) && (t.editable || !(r.type in xt)) && n(t, r);
        }),
        S6[e] ? { passive: !0 } : void 0
      );
    }
    kt && t.dom.addEventListener("input", () => null), op(t);
  }
  function Wr(t, e) {
    (t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
  }
  function N6(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers)
      t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout),
      clearTimeout(t.input.lastIOSEnterFallbackTimeout);
  }
  function op(t) {
    t.someProp("handleDOMEvents", (e) => {
      for (let n in e)
        t.input.eventHandlers[n] ||
          t.dom.addEventListener(
            n,
            (t.input.eventHandlers[n] = (r) => ip(t, r))
          );
    });
  }
  function ip(t, e) {
    return t.someProp("handleDOMEvents", (n) => {
      let r = n[e.type];
      return r ? r(t, e) || e.defaultPrevented : !1;
    });
  }
  function O6(t, e) {
    if (!e.bubbles) return !0;
    if (e.defaultPrevented) return !1;
    for (let n = e.target; n != t.dom; n = n.parentNode)
      if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e)))
        return !1;
    return !0;
  }
  function R6(t, e) {
    !ip(t, e) &&
      wt[e.type] &&
      (t.editable || !(e.type in xt)) &&
      wt[e.type](t, e);
  }
  (xt.keydown = (t, e) => {
    let n = e;
    if (
      ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
      !U2(t, n) &&
        ((t.input.lastKeyCode = n.keyCode),
        (t.input.lastKeyCodeTime = Date.now()),
        !(dr && gt && n.keyCode == 13)))
    )
      if (
        (n.keyCode != 229 && t.domObserver.forceFlush(),
        mi && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
      ) {
        let r = Date.now();
        (t.input.lastIOSEnter = r),
          (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            t.input.lastIOSEnter == r &&
              (t.someProp("handleKeyDown", (o) => o(t, Po(13, "Enter"))),
              (t.input.lastIOSEnter = 0));
          }, 200));
      } else
        t.someProp("handleKeyDown", (r) => r(t, n)) || k6(t, n)
          ? n.preventDefault()
          : Wr(t, "key");
  }),
    (xt.keyup = (t, e) => {
      e.keyCode == 16 && (t.input.shiftKey = !1);
    }),
    (xt.keypress = (t, e) => {
      let n = e;
      if (
        U2(t, n) ||
        !n.charCode ||
        (n.ctrlKey && !n.altKey) ||
        (nn && n.metaKey)
      )
        return;
      if (t.someProp("handleKeyPress", (o) => o(t, n))) {
        n.preventDefault();
        return;
      }
      let r = t.state.selection;
      if (!(r instanceof U) || !r.$from.sameParent(r.$to)) {
        let o = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(o) &&
          !t.someProp("handleTextInput", (i) =>
            i(t, r.$from.pos, r.$to.pos, o)
          ) &&
          t.dispatch(t.state.tr.insertText(o).scrollIntoView()),
          n.preventDefault();
      }
    });
  function Wl(t) {
    return { left: t.clientX, top: t.clientY };
  }
  function D6(t, e) {
    let n = e.x - t.clientX,
      r = e.y - t.clientY;
    return n * n + r * r < 100;
  }
  function sp(t, e, n, r, o) {
    if (r == -1) return !1;
    let i = t.state.doc.resolve(r);
    for (let s = i.depth + 1; s > 0; s--)
      if (
        t.someProp(e, (a) =>
          s > i.depth
            ? a(t, n, i.nodeAfter, i.before(s), o, !0)
            : a(t, n, i.node(s), i.before(s), o, !1)
        )
      )
        return !0;
    return !1;
  }
  function yi(t, e, n) {
    if ((t.focused || t.focus(), t.state.selection.eq(e))) return;
    let r = t.state.tr.setSelection(e);
    r.setMeta("pointer", !0), t.dispatch(r);
  }
  function L6(t, e) {
    if (e == -1) return !1;
    let n = t.state.doc.resolve(e),
      r = n.nodeAfter;
    return r && r.isAtom && K.isSelectable(r) ? (yi(t, new K(n)), !0) : !1;
  }
  function I6(t, e) {
    if (e == -1) return !1;
    let n = t.state.selection,
      r,
      o;
    n instanceof K && (r = n.node);
    let i = t.state.doc.resolve(e);
    for (let s = i.depth + 1; s > 0; s--) {
      let a = s > i.depth ? i.nodeAfter : i.node(s);
      if (K.isSelectable(a)) {
        r &&
        n.$from.depth > 0 &&
        s >= n.$from.depth &&
        i.before(n.$from.depth + 1) == n.$from.pos
          ? (o = i.before(n.$from.depth))
          : (o = i.before(s));
        break;
      }
    }
    return o != null ? (yi(t, K.create(t.state.doc, o)), !0) : !1;
  }
  function B6(t, e, n, r, o) {
    return (
      sp(t, "handleClickOn", e, n, r) ||
      t.someProp("handleClick", (i) => i(t, e, r)) ||
      (o ? I6(t, n) : L6(t, n))
    );
  }
  function P6(t, e, n, r) {
    return (
      sp(t, "handleDoubleClickOn", e, n, r) ||
      t.someProp("handleDoubleClick", (o) => o(t, e, r))
    );
  }
  function $6(t, e, n, r) {
    return (
      sp(t, "handleTripleClickOn", e, n, r) ||
      t.someProp("handleTripleClick", (o) => o(t, e, r)) ||
      F6(t, n, r)
    );
  }
  function F6(t, e, n) {
    if (n.button != 0) return !1;
    let r = t.state.doc;
    if (e == -1)
      return r.inlineContent ? (yi(t, U.create(r, 0, r.content.size)), !0) : !1;
    let o = r.resolve(e);
    for (let i = o.depth + 1; i > 0; i--) {
      let s = i > o.depth ? o.nodeAfter : o.node(i),
        a = o.before(i);
      if (s.inlineContent) yi(t, U.create(r, a + 1, a + 1 + s.content.size));
      else if (K.isSelectable(s)) yi(t, K.create(r, a));
      else continue;
      return !0;
    }
  }
  function ap(t) {
    return Bs(t);
  }
  const V2 = nn ? "metaKey" : "ctrlKey";
  wt.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = ap(t),
      o = Date.now(),
      i = "singleClick";
    o - t.input.lastClick.time < 500 &&
      D6(n, t.input.lastClick) &&
      !n[V2] &&
      (t.input.lastClick.type == "singleClick"
        ? (i = "doubleClick")
        : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
      (t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i });
    let s = t.posAtCoords(Wl(n));
    s &&
      (i == "singleClick"
        ? (t.input.mouseDown && t.input.mouseDown.done(),
          (t.input.mouseDown = new H6(t, s, n, !!r)))
        : (i == "doubleClick" ? P6 : $6)(t, s.pos, s.inside, n)
        ? n.preventDefault()
        : Wr(t, "pointer"));
  };
  class H6 {
    constructor(e, n, r, o) {
      (this.view = e),
        (this.pos = n),
        (this.event = r),
        (this.flushed = o),
        (this.delayedSelectionSync = !1),
        (this.mightDrag = null),
        (this.startDoc = e.state.doc),
        (this.selectNode = !!r[V2]),
        (this.allowDefault = r.shiftKey);
      let i, s;
      if (n.inside > -1) (i = e.state.doc.nodeAt(n.inside)), (s = n.inside);
      else {
        let d = e.state.doc.resolve(n.pos);
        (i = d.parent), (s = d.depth ? d.before() : 0);
      }
      const a = o ? null : r.target,
        l = a ? e.docView.nearestDesc(a, !0) : null;
      this.target = l && l.dom.nodeType == 1 ? l.dom : null;
      let { selection: c } = e.state;
      ((r.button == 0 &&
        i.type.spec.draggable &&
        i.type.spec.selectable !== !1) ||
        (c instanceof K && c.from <= s && c.to > s)) &&
        (this.mightDrag = {
          node: i,
          pos: s,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(
            this.target &&
            Sn &&
            !this.target.hasAttribute("contentEditable")
          ),
        }),
        this.target &&
          this.mightDrag &&
          (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
          (this.view.domObserver.stop(),
          this.mightDrag.addAttr && (this.target.draggable = !0),
          this.mightDrag.setUneditable &&
            setTimeout(() => {
              this.view.input.mouseDown == this &&
                this.target.setAttribute("contentEditable", "false");
            }, 20),
          this.view.domObserver.start()),
        e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
        e.root.addEventListener(
          "mousemove",
          (this.move = this.move.bind(this))
        ),
        Wr(e, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up),
        this.view.root.removeEventListener("mousemove", this.move),
        this.mightDrag &&
          this.target &&
          (this.view.domObserver.stop(),
          this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
          this.mightDrag.setUneditable &&
            this.target.removeAttribute("contentEditable"),
          this.view.domObserver.start()),
        this.delayedSelectionSync && setTimeout(() => pr(this.view)),
        (this.view.input.mouseDown = null);
    }
    up(e) {
      if ((this.done(), !this.view.dom.contains(e.target))) return;
      let n = this.pos;
      this.view.state.doc != this.startDoc &&
        (n = this.view.posAtCoords(Wl(e))),
        this.updateAllowDefault(e),
        this.allowDefault || !n
          ? Wr(this.view, "pointer")
          : B6(this.view, n.pos, n.inside, e, this.selectNode)
          ? e.preventDefault()
          : e.button == 0 &&
            (this.flushed ||
              (kt && this.mightDrag && !this.mightDrag.node.isAtom) ||
              (gt &&
                !this.view.state.selection.visible &&
                Math.min(
                  Math.abs(n.pos - this.view.state.selection.from),
                  Math.abs(n.pos - this.view.state.selection.to)
                ) <= 2))
          ? (yi(this.view, J.near(this.view.state.doc.resolve(n.pos))),
            e.preventDefault())
          : Wr(this.view, "pointer");
    }
    move(e) {
      this.updateAllowDefault(e),
        Wr(this.view, "pointer"),
        e.buttons == 0 && this.done();
    }
    updateAllowDefault(e) {
      !this.allowDefault &&
        (Math.abs(this.event.x - e.clientX) > 4 ||
          Math.abs(this.event.y - e.clientY) > 4) &&
        (this.allowDefault = !0);
    }
  }
  (wt.touchstart = (t) => {
    (t.input.lastTouch = Date.now()), ap(t), Wr(t, "pointer");
  }),
    (wt.touchmove = (t) => {
      (t.input.lastTouch = Date.now()), Wr(t, "pointer");
    }),
    (wt.contextmenu = (t) => ap(t));
  function U2(t, e) {
    return t.composing
      ? !0
      : kt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
      ? ((t.input.compositionEndedAt = -2e8), !0)
      : !1;
  }
  const z6 = dr ? 5e3 : -1;
  (xt.compositionstart = xt.compositionupdate =
    (t) => {
      if (!t.composing) {
        t.domObserver.flush();
        let { state: e } = t,
          n = e.selection.$to;
        if (
          e.selection instanceof U &&
          (e.storedMarks ||
            (!n.textOffset &&
              n.parentOffset &&
              n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
        )
          (t.markCursor = t.state.storedMarks || n.marks()),
            Bs(t, !0),
            (t.markCursor = null);
        else if (
          (Bs(t, !e.selection.empty),
          Sn &&
            e.selection.empty &&
            n.parentOffset &&
            !n.textOffset &&
            n.nodeBefore.marks.length)
        ) {
          let r = t.domSelectionRange();
          for (
            let o = r.focusNode, i = r.focusOffset;
            o && o.nodeType == 1 && i != 0;

          ) {
            let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
            if (!s) break;
            if (s.nodeType == 3) {
              let a = t.domSelection();
              a && a.collapse(s, s.nodeValue.length);
              break;
            } else (o = s), (i = -1);
          }
        }
        t.input.composing = !0;
      }
      j2(t, z6);
    }),
    (xt.compositionend = (t, e) => {
      t.composing &&
        ((t.input.composing = !1),
        (t.input.compositionEndedAt = e.timeStamp),
        (t.input.compositionPendingChanges = t.domObserver.pendingRecords()
          .length
          ? t.input.compositionID
          : 0),
        (t.input.compositionNode = null),
        t.input.compositionPendingChanges &&
          Promise.resolve().then(() => t.domObserver.flush()),
        t.input.compositionID++,
        j2(t, 20));
    });
  function j2(t, e) {
    clearTimeout(t.input.composingTimeout),
      e > -1 && (t.input.composingTimeout = setTimeout(() => Bs(t), e));
  }
  function W2(t) {
    for (
      t.composing &&
      ((t.input.composing = !1), (t.input.compositionEndedAt = U6()));
      t.input.compositionNodes.length > 0;

    )
      t.input.compositionNodes.pop().markParentsDirty();
  }
  function V6(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode) return null;
    let n = LE(e.focusNode, e.focusOffset),
      r = IE(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
      let o = r.pmViewDesc,
        i = t.domObserver.lastChangedTextNode;
      if (n == i || r == i) return i;
      if (!o || !o.isText(r.nodeValue)) return r;
      if (t.input.compositionNode == r) {
        let s = n.pmViewDesc;
        if (!(!s || !s.isText(n.nodeValue))) return r;
      }
    }
    return n || r;
  }
  function U6() {
    let t = document.createEvent("Event");
    return t.initEvent("event", !0, !0), t.timeStamp;
  }
  function Bs(t, e = !1) {
    if (!(dr && t.domObserver.flushingSoon >= 0)) {
      if (
        (t.domObserver.forceFlush(), W2(t), e || (t.docView && t.docView.dirty))
      ) {
        let n = Jf(t);
        return (
          n && !n.eq(t.state.selection)
            ? t.dispatch(t.state.tr.setSelection(n))
            : (t.markCursor || e) && !t.state.selection.empty
            ? t.dispatch(t.state.tr.deleteSelection())
            : t.updateState(t.state),
          !0
        );
      }
      return !1;
    }
  }
  function j6(t, e) {
    if (!t.dom.parentNode) return;
    let n = t.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(e),
      (n.style.cssText = "position: fixed; left: -10000px; top: 10px");
    let r = getSelection(),
      o = document.createRange();
    o.selectNodeContents(e),
      t.dom.blur(),
      r.removeAllRanges(),
      r.addRange(o),
      setTimeout(() => {
        n.parentNode && n.parentNode.removeChild(n), t.focus();
      }, 50);
  }
  const Ps = (Dt && zr < 15) || (mi && HE < 604);
  wt.copy = xt.cut = (t, e) => {
    let n = e,
      r = t.state.selection,
      o = n.type == "cut";
    if (r.empty) return;
    let i = Ps ? null : n.clipboardData,
      s = r.content(),
      { dom: a, text: l } = ep(t, s);
    i
      ? (n.preventDefault(),
        i.clearData(),
        i.setData("text/html", a.innerHTML),
        i.setData("text/plain", l))
      : j6(t, a),
      o &&
        t.dispatch(
          t.state.tr
            .deleteSelection()
            .scrollIntoView()
            .setMeta("uiEvent", "cut")
        );
  };
  function W6(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
      ? t.content.firstChild
      : null;
  }
  function q6(t, e) {
    if (!t.dom.parentNode) return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
      r = t.dom.parentNode.appendChild(
        document.createElement(n ? "textarea" : "div")
      );
    n || (r.contentEditable = "true"),
      (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
      r.focus();
    let o = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout(() => {
      t.focus(),
        r.parentNode && r.parentNode.removeChild(r),
        n
          ? $s(t, r.value, null, o, e)
          : $s(t, r.textContent, r.innerHTML, o, e);
    }, 50);
  }
  function $s(t, e, n, r, o) {
    let i = tp(t, e, n, r, t.state.selection.$from);
    if (t.someProp("handlePaste", (l) => l(t, o, i || z.empty))) return !0;
    if (!i) return !1;
    let s = W6(i),
      a = s
        ? t.state.tr.replaceSelectionWith(s, r)
        : t.state.tr.replaceSelection(i);
    return (
      t.dispatch(
        a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
      ),
      !0
    );
  }
  function q2(t) {
    let e = t.getData("text/plain") || t.getData("Text");
    if (e) return e;
    let n = t.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : "";
  }
  xt.paste = (t, e) => {
    let n = e;
    if (t.composing && !dr) return;
    let r = Ps ? null : n.clipboardData,
      o = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && $s(t, q2(r), r.getData("text/html"), o, n)
      ? n.preventDefault()
      : q6(t, n);
  };
  class K2 {
    constructor(e, n, r) {
      (this.slice = e), (this.move = n), (this.node = r);
    }
  }
  const G2 = nn ? "altKey" : "ctrlKey";
  (wt.dragstart = (t, e) => {
    let n = e,
      r = t.input.mouseDown;
    if ((r && r.done(), !n.dataTransfer)) return;
    let o = t.state.selection,
      i = o.empty ? null : t.posAtCoords(Wl(n)),
      s;
    if (
      !(i && i.pos >= o.from && i.pos <= (o instanceof K ? o.to - 1 : o.to))
    ) {
      if (r && r.mightDrag) s = K.create(t.state.doc, r.mightDrag.pos);
      else if (n.target && n.target.nodeType == 1) {
        let f = t.docView.nearestDesc(n.target, !0);
        f &&
          f.node.type.spec.draggable &&
          f != t.docView &&
          (s = K.create(t.state.doc, f.posBefore));
      }
    }
    let a = (s || t.state.selection).content(),
      { dom: l, text: c, slice: d } = ep(t, a);
    (!n.dataTransfer.files.length || !gt || t2 > 120) &&
      n.dataTransfer.clearData(),
      n.dataTransfer.setData(Ps ? "Text" : "text/html", l.innerHTML),
      (n.dataTransfer.effectAllowed = "copyMove"),
      Ps || n.dataTransfer.setData("text/plain", c),
      (t.dragging = new K2(d, !n[G2], s));
  }),
    (wt.dragend = (t) => {
      let e = t.dragging;
      window.setTimeout(() => {
        t.dragging == e && (t.dragging = null);
      }, 50);
    }),
    (xt.dragover = xt.dragenter = (t, e) => e.preventDefault()),
    (xt.drop = (t, e) => {
      let n = e,
        r = t.dragging;
      if (((t.dragging = null), !n.dataTransfer)) return;
      let o = t.posAtCoords(Wl(n));
      if (!o) return;
      let i = t.state.doc.resolve(o.pos),
        s = r && r.slice;
      s
        ? t.someProp("transformPasted", (m) => {
            s = m(s, t);
          })
        : (s = tp(
            t,
            q2(n.dataTransfer),
            Ps ? null : n.dataTransfer.getData("text/html"),
            !1,
            i
          ));
      let a = !!(r && !n[G2]);
      if (t.someProp("handleDrop", (m) => m(t, n, s || z.empty, a))) {
        n.preventDefault();
        return;
      }
      if (!s) return;
      n.preventDefault();
      let l = s ? gf(t.state.doc, i.pos, s) : i.pos;
      l == null && (l = i.pos);
      let c = t.state.tr;
      if (a) {
        let { node: m } = r;
        m ? m.replace(c) : c.deleteSelection();
      }
      let d = c.mapping.map(l),
        f = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
        p = c.doc;
      if (
        (f
          ? c.replaceRangeWith(d, d, s.content.firstChild)
          : c.replaceRange(d, d, s),
        c.doc.eq(p))
      )
        return;
      let h = c.doc.resolve(d);
      if (
        f &&
        K.isSelectable(s.content.firstChild) &&
        h.nodeAfter &&
        h.nodeAfter.sameMarkup(s.content.firstChild)
      )
        c.setSelection(new K(h));
      else {
        let m = c.mapping.map(l);
        c.mapping.maps[c.mapping.maps.length - 1].forEach(
          (g, b, y, x) => (m = x)
        ),
          c.setSelection(Xf(t, h, c.doc.resolve(m)));
      }
      t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
    }),
    (wt.focus = (t) => {
      (t.input.lastFocus = Date.now()),
        t.focused ||
          (t.domObserver.stop(),
          t.dom.classList.add("ProseMirror-focused"),
          t.domObserver.start(),
          (t.focused = !0),
          setTimeout(() => {
            t.docView &&
              t.hasFocus() &&
              !t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
              pr(t);
          }, 20));
    }),
    (wt.blur = (t, e) => {
      let n = e;
      t.focused &&
        (t.domObserver.stop(),
        t.dom.classList.remove("ProseMirror-focused"),
        t.domObserver.start(),
        n.relatedTarget &&
          t.dom.contains(n.relatedTarget) &&
          t.domObserver.currentSelection.clear(),
        (t.focused = !1));
    }),
    (wt.beforeinput = (t, e) => {
      if (gt && dr && e.inputType == "deleteContentBackward") {
        t.domObserver.flushSoon();
        let { domChangeCount: r } = t.input;
        setTimeout(() => {
          if (
            t.input.domChangeCount != r ||
            (t.dom.blur(),
            t.focus(),
            t.someProp("handleKeyDown", (i) => i(t, Po(8, "Backspace"))))
          )
            return;
          let { $cursor: o } = t.state.selection;
          o &&
            o.pos > 0 &&
            t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
        }, 50);
      }
    });
  for (let t in xt) wt[t] = xt[t];
  function Fs(t, e) {
    if (t == e) return !0;
    for (let n in t) if (t[n] !== e[n]) return !1;
    for (let n in e) if (!(n in t)) return !1;
    return !0;
  }
  class ql {
    constructor(e, n) {
      (this.toDOM = e),
        (this.spec = n || zo),
        (this.side = this.spec.side || 0);
    }
    map(e, n, r, o) {
      let { pos: i, deleted: s } = e.mapResult(
        n.from + o,
        this.side < 0 ? -1 : 1
      );
      return s ? null : new Te(i - r, i - r, this);
    }
    valid() {
      return !0;
    }
    eq(e) {
      return (
        this == e ||
        (e instanceof ql &&
          ((this.spec.key && this.spec.key == e.spec.key) ||
            (this.toDOM == e.toDOM && Fs(this.spec, e.spec))))
      );
    }
    destroy(e) {
      this.spec.destroy && this.spec.destroy(e);
    }
  }
  class qr {
    constructor(e, n) {
      (this.attrs = e), (this.spec = n || zo);
    }
    map(e, n, r, o) {
      let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
        s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
      return i >= s ? null : new Te(i, s, this);
    }
    valid(e, n) {
      return n.from < n.to;
    }
    eq(e) {
      return (
        this == e ||
        (e instanceof qr && Fs(this.attrs, e.attrs) && Fs(this.spec, e.spec))
      );
    }
    static is(e) {
      return e.type instanceof qr;
    }
    destroy() {}
  }
  class lp {
    constructor(e, n) {
      (this.attrs = e), (this.spec = n || zo);
    }
    map(e, n, r, o) {
      let i = e.mapResult(n.from + o, 1);
      if (i.deleted) return null;
      let s = e.mapResult(n.to + o, -1);
      return s.deleted || s.pos <= i.pos
        ? null
        : new Te(i.pos - r, s.pos - r, this);
    }
    valid(e, n) {
      let { index: r, offset: o } = e.content.findIndex(n.from),
        i;
      return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
    }
    eq(e) {
      return (
        this == e ||
        (e instanceof lp && Fs(this.attrs, e.attrs) && Fs(this.spec, e.spec))
      );
    }
    destroy() {}
  }
  class Te {
    constructor(e, n, r) {
      (this.from = e), (this.to = n), (this.type = r);
    }
    copy(e, n) {
      return new Te(e, n, this.type);
    }
    eq(e, n = 0) {
      return (
        this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
      );
    }
    map(e, n, r) {
      return this.type.map(e, this, n, r);
    }
    static widget(e, n, r) {
      return new Te(e, e, new ql(n, r));
    }
    static inline(e, n, r, o) {
      return new Te(e, n, new qr(r, o));
    }
    static node(e, n, r, o) {
      return new Te(e, n, new lp(r, o));
    }
    get spec() {
      return this.type.spec;
    }
    get inline() {
      return this.type instanceof qr;
    }
    get widget() {
      return this.type instanceof ql;
    }
  }
  const _i = [],
    zo = {};
  class ue {
    constructor(e, n) {
      (this.local = e.length ? e : _i), (this.children = n.length ? n : _i);
    }
    static create(e, n) {
      return n.length ? Kl(n, e, 0, zo) : bt;
    }
    find(e, n, r) {
      let o = [];
      return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
    }
    findInner(e, n, r, o, i) {
      for (let s = 0; s < this.local.length; s++) {
        let a = this.local[s];
        a.from <= n &&
          a.to >= e &&
          (!i || i(a.spec)) &&
          r.push(a.copy(a.from + o, a.to + o));
      }
      for (let s = 0; s < this.children.length; s += 3)
        if (this.children[s] < n && this.children[s + 1] > e) {
          let a = this.children[s] + 1;
          this.children[s + 2].findInner(e - a, n - a, r, o + a, i);
        }
    }
    map(e, n, r) {
      return this == bt || e.maps.length == 0
        ? this
        : this.mapInner(e, n, 0, 0, r || zo);
    }
    mapInner(e, n, r, o, i) {
      let s;
      for (let a = 0; a < this.local.length; a++) {
        let l = this.local[a].map(e, r, o);
        l && l.type.valid(n, l)
          ? (s || (s = [])).push(l)
          : i.onRemove && i.onRemove(this.local[a].spec);
      }
      return this.children.length
        ? K6(this.children, s || [], e, n, r, o, i)
        : s
        ? new ue(s.sort(Vo), _i)
        : bt;
    }
    add(e, n) {
      return n.length
        ? this == bt
          ? ue.create(e, n)
          : this.addInner(e, n, 0)
        : this;
    }
    addInner(e, n, r) {
      let o,
        i = 0;
      e.forEach((a, l) => {
        let c = l + r,
          d;
        if ((d = Y2(n, a, c))) {
          for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
            i += 3;
          o[i] == l
            ? (o[i + 2] = o[i + 2].addInner(a, d, c + 1))
            : o.splice(i, 0, l, l + a.nodeSize, Kl(d, a, c + 1, zo)),
            (i += 3);
        }
      });
      let s = J2(i ? X2(n) : n, -r);
      for (let a = 0; a < s.length; a++)
        s[a].type.valid(e, s[a]) || s.splice(a--, 1);
      return new ue(
        s.length ? this.local.concat(s).sort(Vo) : this.local,
        o || this.children
      );
    }
    remove(e) {
      return e.length == 0 || this == bt ? this : this.removeInner(e, 0);
    }
    removeInner(e, n) {
      let r = this.children,
        o = this.local;
      for (let i = 0; i < r.length; i += 3) {
        let s,
          a = r[i] + n,
          l = r[i + 1] + n;
        for (let d = 0, f; d < e.length; d++)
          (f = e[d]) &&
            f.from > a &&
            f.to < l &&
            ((e[d] = null), (s || (s = [])).push(f));
        if (!s) continue;
        r == this.children && (r = this.children.slice());
        let c = r[i + 2].removeInner(s, a + 1);
        c != bt ? (r[i + 2] = c) : (r.splice(i, 3), (i -= 3));
      }
      if (o.length) {
        for (let i = 0, s; i < e.length; i++)
          if ((s = e[i]))
            for (let a = 0; a < o.length; a++)
              o[a].eq(s, n) &&
                (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
      }
      return r == this.children && o == this.local
        ? this
        : o.length || r.length
        ? new ue(o, r)
        : bt;
    }
    forChild(e, n) {
      if (this == bt) return this;
      if (n.isLeaf) return ue.empty;
      let r, o;
      for (let a = 0; a < this.children.length; a += 3)
        if (this.children[a] >= e) {
          this.children[a] == e && (r = this.children[a + 2]);
          break;
        }
      let i = e + 1,
        s = i + n.content.size;
      for (let a = 0; a < this.local.length; a++) {
        let l = this.local[a];
        if (l.from < s && l.to > i && l.type instanceof qr) {
          let c = Math.max(i, l.from) - i,
            d = Math.min(s, l.to) - i;
          c < d && (o || (o = [])).push(l.copy(c, d));
        }
      }
      if (o) {
        let a = new ue(o.sort(Vo), _i);
        return r ? new Kr([a, r]) : a;
      }
      return r || bt;
    }
    eq(e) {
      if (this == e) return !0;
      if (
        !(e instanceof ue) ||
        this.local.length != e.local.length ||
        this.children.length != e.children.length
      )
        return !1;
      for (let n = 0; n < this.local.length; n++)
        if (!this.local[n].eq(e.local[n])) return !1;
      for (let n = 0; n < this.children.length; n += 3)
        if (
          this.children[n] != e.children[n] ||
          this.children[n + 1] != e.children[n + 1] ||
          !this.children[n + 2].eq(e.children[n + 2])
        )
          return !1;
      return !0;
    }
    locals(e) {
      return cp(this.localsInner(e));
    }
    localsInner(e) {
      if (this == bt) return _i;
      if (e.inlineContent || !this.local.some(qr.is)) return this.local;
      let n = [];
      for (let r = 0; r < this.local.length; r++)
        this.local[r].type instanceof qr || n.push(this.local[r]);
      return n;
    }
    forEachSet(e) {
      e(this);
    }
  }
  (ue.empty = new ue([], [])), (ue.removeOverlap = cp);
  const bt = ue.empty;
  class Kr {
    constructor(e) {
      this.members = e;
    }
    map(e, n) {
      const r = this.members.map((o) => o.map(e, n, zo));
      return Kr.from(r);
    }
    forChild(e, n) {
      if (n.isLeaf) return ue.empty;
      let r = [];
      for (let o = 0; o < this.members.length; o++) {
        let i = this.members[o].forChild(e, n);
        i != bt && (i instanceof Kr ? (r = r.concat(i.members)) : r.push(i));
      }
      return Kr.from(r);
    }
    eq(e) {
      if (!(e instanceof Kr) || e.members.length != this.members.length)
        return !1;
      for (let n = 0; n < this.members.length; n++)
        if (!this.members[n].eq(e.members[n])) return !1;
      return !0;
    }
    locals(e) {
      let n,
        r = !0;
      for (let o = 0; o < this.members.length; o++) {
        let i = this.members[o].localsInner(e);
        if (i.length)
          if (!n) n = i;
          else {
            r && ((n = n.slice()), (r = !1));
            for (let s = 0; s < i.length; s++) n.push(i[s]);
          }
      }
      return n ? cp(r ? n : n.sort(Vo)) : _i;
    }
    static from(e) {
      switch (e.length) {
        case 0:
          return bt;
        case 1:
          return e[0];
        default:
          return new Kr(
            e.every((n) => n instanceof ue)
              ? e
              : e.reduce(
                  (n, r) => n.concat(r instanceof ue ? r : r.members),
                  []
                )
          );
      }
    }
    forEachSet(e) {
      for (let n = 0; n < this.members.length; n++)
        this.members[n].forEachSet(e);
    }
  }
  function K6(t, e, n, r, o, i, s) {
    let a = t.slice();
    for (let c = 0, d = i; c < n.maps.length; c++) {
      let f = 0;
      n.maps[c].forEach((p, h, m, g) => {
        let b = g - m - (h - p);
        for (let y = 0; y < a.length; y += 3) {
          let x = a[y + 1];
          if (x < 0 || p > x + d - f) continue;
          let w = a[y] + d - f;
          h >= w
            ? (a[y + 1] = p <= w ? -2 : -1)
            : p >= d && b && ((a[y] += b), (a[y + 1] += b));
        }
        f += b;
      }),
        (d = n.maps[c].map(d, -1));
    }
    let l = !1;
    for (let c = 0; c < a.length; c += 3)
      if (a[c + 1] < 0) {
        if (a[c + 1] == -2) {
          (l = !0), (a[c + 1] = -1);
          continue;
        }
        let d = n.map(t[c] + i),
          f = d - o;
        if (f < 0 || f >= r.content.size) {
          l = !0;
          continue;
        }
        let p = n.map(t[c + 1] + i, -1),
          h = p - o,
          { index: m, offset: g } = r.content.findIndex(f),
          b = r.maybeChild(m);
        if (b && g == f && g + b.nodeSize == h) {
          let y = a[c + 2].mapInner(n, b, d + 1, t[c] + i + 1, s);
          y != bt
            ? ((a[c] = f), (a[c + 1] = h), (a[c + 2] = y))
            : ((a[c + 1] = -2), (l = !0));
        } else l = !0;
      }
    if (l) {
      let c = G6(a, t, e, n, o, i, s),
        d = Kl(c, r, 0, s);
      e = d.local;
      for (let f = 0; f < a.length; f += 3)
        a[f + 1] < 0 && (a.splice(f, 3), (f -= 3));
      for (let f = 0, p = 0; f < d.children.length; f += 3) {
        let h = d.children[f];
        for (; p < a.length && a[p] < h; ) p += 3;
        a.splice(p, 0, d.children[f], d.children[f + 1], d.children[f + 2]);
      }
    }
    return new ue(e.sort(Vo), a);
  }
  function J2(t, e) {
    if (!e || !t.length) return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      n.push(new Te(o.from + e, o.to + e, o.type));
    }
    return n;
  }
  function G6(t, e, n, r, o, i, s) {
    function a(l, c) {
      for (let d = 0; d < l.local.length; d++) {
        let f = l.local[d].map(r, o, c);
        f ? n.push(f) : s.onRemove && s.onRemove(l.local[d].spec);
      }
      for (let d = 0; d < l.children.length; d += 3)
        a(l.children[d + 2], l.children[d] + c + 1);
    }
    for (let l = 0; l < t.length; l += 3)
      t[l + 1] == -1 && a(t[l + 2], e[l] + i + 1);
    return n;
  }
  function Y2(t, e, n) {
    if (e.isLeaf) return null;
    let r = n + e.nodeSize,
      o = null;
    for (let i = 0, s; i < t.length; i++)
      (s = t[i]) &&
        s.from > n &&
        s.to < r &&
        ((o || (o = [])).push(s), (t[i] = null));
    return o;
  }
  function X2(t) {
    let e = [];
    for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
    return e;
  }
  function Kl(t, e, n, r) {
    let o = [],
      i = !1;
    e.forEach((a, l) => {
      let c = Y2(t, a, l + n);
      if (c) {
        i = !0;
        let d = Kl(c, a, n + l + 1, r);
        d != bt && o.push(l, l + a.nodeSize, d);
      }
    });
    let s = J2(i ? X2(t) : t, -n).sort(Vo);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) ||
        (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
    return s.length || o.length ? new ue(s, o) : bt;
  }
  function Vo(t, e) {
    return t.from - e.from || t.to - e.to;
  }
  function cp(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
      let r = e[n];
      if (r.from != r.to)
        for (let o = n + 1; o < e.length; o++) {
          let i = e[o];
          if (i.from == r.from) {
            i.to != r.to &&
              (e == t && (e = t.slice()),
              (e[o] = i.copy(i.from, r.to)),
              Z2(e, o + 1, i.copy(r.to, i.to)));
            continue;
          } else {
            i.from < r.to &&
              (e == t && (e = t.slice()),
              (e[n] = r.copy(r.from, i.from)),
              Z2(e, o, r.copy(i.from, r.to)));
            break;
          }
        }
    }
    return e;
  }
  function Z2(t, e, n) {
    for (; e < t.length && Vo(n, t[e]) > 0; ) e++;
    t.splice(e, 0, n);
  }
  function up(t) {
    let e = [];
    return (
      t.someProp("decorations", (n) => {
        let r = n(t.state);
        r && r != bt && e.push(r);
      }),
      t.cursorWrapper && e.push(ue.create(t.state.doc, [t.cursorWrapper.deco])),
      Kr.from(e)
    );
  }
  const J6 = {
      childList: !0,
      characterData: !0,
      characterDataOldValue: !0,
      attributes: !0,
      attributeOldValue: !0,
      subtree: !0,
    },
    Y6 = Dt && zr <= 11;
  class X6 {
    constructor() {
      (this.anchorNode = null),
        (this.anchorOffset = 0),
        (this.focusNode = null),
        (this.focusOffset = 0);
    }
    set(e) {
      (this.anchorNode = e.anchorNode),
        (this.anchorOffset = e.anchorOffset),
        (this.focusNode = e.focusNode),
        (this.focusOffset = e.focusOffset);
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(e) {
      return (
        e.anchorNode == this.anchorNode &&
        e.anchorOffset == this.anchorOffset &&
        e.focusNode == this.focusNode &&
        e.focusOffset == this.focusOffset
      );
    }
  }
  class Z6 {
    constructor(e, n) {
      (this.view = e),
        (this.handleDOMChange = n),
        (this.queue = []),
        (this.flushingSoon = -1),
        (this.observer = null),
        (this.currentSelection = new X6()),
        (this.onCharData = null),
        (this.suppressingSelectionUpdates = !1),
        (this.lastChangedTextNode = null),
        (this.observer =
          window.MutationObserver &&
          new window.MutationObserver((r) => {
            for (let o = 0; o < r.length; o++) this.queue.push(r[o]);
            Dt &&
            zr <= 11 &&
            r.some(
              (o) =>
                (o.type == "childList" && o.removedNodes.length) ||
                (o.type == "characterData" &&
                  o.oldValue.length > o.target.nodeValue.length)
            )
              ? this.flushSoon()
              : this.flush();
          })),
        Y6 &&
          (this.onCharData = (r) => {
            this.queue.push({
              target: r.target,
              type: "characterData",
              oldValue: r.prevValue,
            }),
              this.flushSoon();
          }),
        (this.onSelectionChange = this.onSelectionChange.bind(this));
    }
    flushSoon() {
      this.flushingSoon < 0 &&
        (this.flushingSoon = window.setTimeout(() => {
          (this.flushingSoon = -1), this.flush();
        }, 20));
    }
    forceFlush() {
      this.flushingSoon > -1 &&
        (window.clearTimeout(this.flushingSoon),
        (this.flushingSoon = -1),
        this.flush());
    }
    start() {
      this.observer &&
        (this.observer.takeRecords(), this.observer.observe(this.view.dom, J6)),
        this.onCharData &&
          this.view.dom.addEventListener(
            "DOMCharacterDataModified",
            this.onCharData
          ),
        this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let e = this.observer.takeRecords();
        if (e.length) {
          for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      this.onCharData &&
        this.view.dom.removeEventListener(
          "DOMCharacterDataModified",
          this.onCharData
        ),
        this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener(
        "selectionchange",
        this.onSelectionChange
      );
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener(
        "selectionchange",
        this.onSelectionChange
      );
    }
    suppressSelectionUpdates() {
      (this.suppressingSelectionUpdates = !0),
        setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
    }
    onSelectionChange() {
      if (S2(this.view)) {
        if (this.suppressingSelectionUpdates) return pr(this.view);
        if (Dt && zr <= 11 && !this.view.state.selection.empty) {
          let e = this.view.domSelectionRange();
          if (
            e.focusNode &&
            Bo(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
          )
            return this.flushSoon();
        }
        this.flush();
      }
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(e) {
      if (!e.focusNode) return !0;
      let n = new Set(),
        r;
      for (let i = e.focusNode; i; i = Ts(i)) n.add(i);
      for (let i = e.anchorNode; i; i = Ts(i))
        if (n.has(i)) {
          r = i;
          break;
        }
      let o = r && this.view.docView.nearestDesc(r);
      if (
        o &&
        o.ignoreMutation({
          type: "selection",
          target: r.nodeType == 3 ? r.parentNode : r,
        })
      )
        return this.setCurSelection(), !0;
    }
    pendingRecords() {
      if (this.observer)
        for (let e of this.observer.takeRecords()) this.queue.push(e);
      return this.queue;
    }
    flush() {
      let { view: e } = this;
      if (!e.docView || this.flushingSoon > -1) return;
      let n = this.pendingRecords();
      n.length && (this.queue = []);
      let r = e.domSelectionRange(),
        o =
          !this.suppressingSelectionUpdates &&
          !this.currentSelection.eq(r) &&
          S2(e) &&
          !this.ignoreSelectionChange(r),
        i = -1,
        s = -1,
        a = !1,
        l = [];
      if (e.editable)
        for (let d = 0; d < n.length; d++) {
          let f = this.registerMutation(n[d], l);
          f &&
            ((i = i < 0 ? f.from : Math.min(f.from, i)),
            (s = s < 0 ? f.to : Math.max(f.to, s)),
            f.typeOver && (a = !0));
        }
      if (Sn && l.length) {
        let d = l.filter((f) => f.nodeName == "BR");
        if (d.length == 2) {
          let [f, p] = d;
          f.parentNode && f.parentNode.parentNode == p.parentNode
            ? p.remove()
            : f.remove();
        } else {
          let { focusNode: f } = this.currentSelection;
          for (let p of d) {
            let h = p.parentNode;
            h && h.nodeName == "LI" && (!f || tA(e, f) != h) && p.remove();
          }
        }
      }
      let c = null;
      i < 0 &&
      o &&
      e.input.lastFocus > Date.now() - 200 &&
      Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
      zl(r) &&
      (c = Jf(e)) &&
      c.eq(J.near(e.state.doc.resolve(0), 1))
        ? ((e.input.lastFocus = 0),
          pr(e),
          this.currentSelection.set(r),
          e.scrollToSelection())
        : (i > -1 || o) &&
          (i > -1 && (e.docView.markDirty(i, s), Q6(e)),
          this.handleDOMChange(i, s, a, l),
          e.docView && e.docView.dirty
            ? e.updateState(e.state)
            : this.currentSelection.eq(r) || pr(e),
          this.currentSelection.set(r));
    }
    registerMutation(e, n) {
      if (n.indexOf(e.target) > -1) return null;
      let r = this.view.docView.nearestDesc(e.target);
      if (
        (e.type == "attributes" &&
          (r == this.view.docView ||
            e.attributeName == "contenteditable" ||
            (e.attributeName == "style" &&
              !e.oldValue &&
              !e.target.getAttribute("style")))) ||
        !r ||
        r.ignoreMutation(e)
      )
        return null;
      if (e.type == "childList") {
        for (let d = 0; d < e.addedNodes.length; d++) {
          let f = e.addedNodes[d];
          n.push(f), f.nodeType == 3 && (this.lastChangedTextNode = f);
        }
        if (
          r.contentDOM &&
          r.contentDOM != r.dom &&
          !r.contentDOM.contains(e.target)
        )
          return { from: r.posBefore, to: r.posAfter };
        let o = e.previousSibling,
          i = e.nextSibling;
        if (Dt && zr <= 11 && e.addedNodes.length)
          for (let d = 0; d < e.addedNodes.length; d++) {
            let { previousSibling: f, nextSibling: p } = e.addedNodes[d];
            (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) &&
              (o = f),
              (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) &&
                (i = p);
          }
        let s = o && o.parentNode == e.target ? at(o) + 1 : 0,
          a = r.localPosFromDOM(e.target, s, -1),
          l =
            i && i.parentNode == e.target ? at(i) : e.target.childNodes.length,
          c = r.localPosFromDOM(e.target, l, 1);
        return { from: a, to: c };
      } else
        return e.type == "attributes"
          ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
          : ((this.lastChangedTextNode = e.target),
            {
              from: r.posAtStart,
              to: r.posAtEnd,
              typeOver: e.target.nodeValue == e.oldValue,
            });
    }
  }
  let Q2 = new WeakMap(),
    eb = !1;
  function Q6(t) {
    if (
      !Q2.has(t) &&
      (Q2.set(t, null),
      ["normal", "nowrap", "pre-line"].indexOf(
        getComputedStyle(t.dom).whiteSpace
      ) !== -1)
    ) {
      if (((t.requiresGeckoHackNode = Sn), eb)) return;
      console.warn(
        "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
      ),
        (eb = !0);
    }
  }
  function tb(t, e) {
    let n = e.startContainer,
      r = e.startOffset,
      o = e.endContainer,
      i = e.endOffset,
      s = t.domAtPos(t.state.selection.anchor);
    return (
      Bo(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]),
      { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i }
    );
  }
  function eA(t, e) {
    if (e.getComposedRanges) {
      let o = e.getComposedRanges(t.root)[0];
      if (o) return tb(t, o);
    }
    let n;
    function r(o) {
      o.preventDefault(),
        o.stopImmediatePropagation(),
        (n = o.getTargetRanges()[0]);
    }
    return (
      t.dom.addEventListener("beforeinput", r, !0),
      document.execCommand("indent"),
      t.dom.removeEventListener("beforeinput", r, !0),
      n ? tb(t, n) : null
    );
  }
  function tA(t, e) {
    for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
      let r = t.docView.nearestDesc(n, !0);
      if (r && r.node.isBlock) return n;
    }
    return null;
  }
  function nA(t, e, n) {
    let {
        node: r,
        fromOffset: o,
        toOffset: i,
        from: s,
        to: a,
      } = t.docView.parseRange(e, n),
      l = t.domSelectionRange(),
      c,
      d = l.anchorNode;
    if (
      (d &&
        t.dom.contains(d.nodeType == 1 ? d : d.parentNode) &&
        ((c = [{ node: d, offset: l.anchorOffset }]),
        zl(l) || c.push({ node: l.focusNode, offset: l.focusOffset })),
      gt && t.input.lastKeyCode === 8)
    )
      for (let b = i; b > o; b--) {
        let y = r.childNodes[b - 1],
          x = y.pmViewDesc;
        if (y.nodeName == "BR" && !x) {
          i = b;
          break;
        }
        if (!x || x.size) break;
      }
    let f = t.state.doc,
      p = t.someProp("domParser") || Pn.fromSchema(t.state.schema),
      h = f.resolve(s),
      m = null,
      g = p.parse(r, {
        topNode: h.parent,
        topMatch: h.parent.contentMatchAt(h.index()),
        topOpen: !0,
        from: o,
        to: i,
        preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
        findPositions: c,
        ruleFromNode: rA,
        context: h,
      });
    if (c && c[0].pos != null) {
      let b = c[0].pos,
        y = c[1] && c[1].pos;
      y == null && (y = b), (m = { anchor: b + s, head: y + s });
    }
    return { doc: g, sel: m, from: s, to: a };
  }
  function rA(t) {
    let e = t.pmViewDesc;
    if (e) return e.parseRule();
    if (t.nodeName == "BR" && t.parentNode) {
      if (kt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
        let n = document.createElement("div");
        return n.appendChild(document.createElement("li")), { skip: n };
      } else if (
        t.parentNode.lastChild == t ||
        (kt && /^(tr|table)$/i.test(t.parentNode.nodeName))
      )
        return { ignore: !0 };
    } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
      return { ignore: !0 };
    return null;
  }
  const oA =
    /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function iA(t, e, n, r, o) {
    let i =
      t.input.compositionPendingChanges ||
      (t.composing ? t.input.compositionID : 0);
    if (((t.input.compositionPendingChanges = 0), e < 0)) {
      let M =
          t.input.lastSelectionTime > Date.now() - 50
            ? t.input.lastSelectionOrigin
            : null,
        L = Jf(t, M);
      if (L && !t.state.selection.eq(L)) {
        if (
          gt &&
          dr &&
          t.input.lastKeyCode === 13 &&
          Date.now() - 100 < t.input.lastKeyCodeTime &&
          t.someProp("handleKeyDown", (B) => B(t, Po(13, "Enter")))
        )
          return;
        let $ = t.state.tr.setSelection(L);
        M == "pointer"
          ? $.setMeta("pointer", !0)
          : M == "key" && $.scrollIntoView(),
          i && $.setMeta("composition", i),
          t.dispatch($);
      }
      return;
    }
    let s = t.state.doc.resolve(e),
      a = s.sharedDepth(n);
    (e = s.before(a + 1)), (n = t.state.doc.resolve(n).after(a + 1));
    let l = t.state.selection,
      c = nA(t, e, n),
      d = t.state.doc,
      f = d.slice(c.from, c.to),
      p,
      h;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
      ? ((p = t.state.selection.to), (h = "end"))
      : ((p = t.state.selection.from), (h = "start")),
      (t.input.lastKeyCode = null);
    let m = lA(f.content, c.doc.content, c.from, p, h);
    if (
      (m && t.input.domChangeCount++,
      ((mi && t.input.lastIOSEnter > Date.now() - 225) || dr) &&
        o.some((M) => M.nodeType == 1 && !oA.test(M.nodeName)) &&
        (!m || m.endA >= m.endB) &&
        t.someProp("handleKeyDown", (M) => M(t, Po(13, "Enter"))))
    ) {
      t.input.lastIOSEnter = 0;
      return;
    }
    if (!m)
      if (
        r &&
        l instanceof U &&
        !l.empty &&
        l.$head.sameParent(l.$anchor) &&
        !t.composing &&
        !(c.sel && c.sel.anchor != c.sel.head)
      )
        m = { start: l.from, endA: l.to, endB: l.to };
      else {
        if (c.sel) {
          let M = nb(t, t.state.doc, c.sel);
          if (M && !M.eq(t.state.selection)) {
            let L = t.state.tr.setSelection(M);
            i && L.setMeta("composition", i), t.dispatch(L);
          }
        }
        return;
      }
    t.state.selection.from < t.state.selection.to &&
      m.start == m.endB &&
      t.state.selection instanceof U &&
      (m.start > t.state.selection.from &&
      m.start <= t.state.selection.from + 2 &&
      t.state.selection.from >= c.from
        ? (m.start = t.state.selection.from)
        : m.endA < t.state.selection.to &&
          m.endA >= t.state.selection.to - 2 &&
          t.state.selection.to <= c.to &&
          ((m.endB += t.state.selection.to - m.endA),
          (m.endA = t.state.selection.to))),
      Dt &&
        zr <= 11 &&
        m.endB == m.start + 1 &&
        m.endA == m.start &&
        m.start > c.from &&
        c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == "  " &&
        (m.start--, m.endA--, m.endB--);
    let g = c.doc.resolveNoCache(m.start - c.from),
      b = c.doc.resolveNoCache(m.endB - c.from),
      y = d.resolve(m.start),
      x = g.sameParent(b) && g.parent.inlineContent && y.end() >= m.endA,
      w;
    if (
      ((mi &&
        t.input.lastIOSEnter > Date.now() - 225 &&
        (!x || o.some((M) => M.nodeName == "DIV" || M.nodeName == "P"))) ||
        (!x &&
          g.pos < c.doc.content.size &&
          !g.sameParent(b) &&
          (w = J.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) &&
          w.head == b.pos)) &&
      t.someProp("handleKeyDown", (M) => M(t, Po(13, "Enter")))
    ) {
      t.input.lastIOSEnter = 0;
      return;
    }
    if (
      t.state.selection.anchor > m.start &&
      aA(d, m.start, m.endA, g, b) &&
      t.someProp("handleKeyDown", (M) => M(t, Po(8, "Backspace")))
    ) {
      dr && gt && t.domObserver.suppressSelectionUpdates();
      return;
    }
    gt && m.endB == m.start && (t.input.lastChromeDelete = Date.now()),
      dr &&
        !x &&
        g.start() != b.start() &&
        b.parentOffset == 0 &&
        g.depth == b.depth &&
        c.sel &&
        c.sel.anchor == c.sel.head &&
        c.sel.head == m.endA &&
        ((m.endB -= 2),
        (b = c.doc.resolveNoCache(m.endB - c.from)),
        setTimeout(() => {
          t.someProp("handleKeyDown", function (M) {
            return M(t, Po(13, "Enter"));
          });
        }, 20));
    let _ = m.start,
      v = m.endA,
      C,
      S,
      N;
    if (x) {
      if (g.pos == b.pos)
        Dt &&
          zr <= 11 &&
          g.parentOffset == 0 &&
          (t.domObserver.suppressSelectionUpdates(),
          setTimeout(() => pr(t), 20)),
          (C = t.state.tr.delete(_, v)),
          (S = d.resolve(m.start).marksAcross(d.resolve(m.endA)));
      else if (
        m.endA == m.endB &&
        (N = sA(
          g.parent.content.cut(g.parentOffset, b.parentOffset),
          y.parent.content.cut(y.parentOffset, m.endA - y.start())
        ))
      )
        (C = t.state.tr),
          N.type == "add"
            ? C.addMark(_, v, N.mark)
            : C.removeMark(_, v, N.mark);
      else if (
        g.parent.child(g.index()).isText &&
        g.index() == b.index() - (b.textOffset ? 0 : 1)
      ) {
        let M = g.parent.textBetween(g.parentOffset, b.parentOffset);
        if (t.someProp("handleTextInput", (L) => L(t, _, v, M))) return;
        C = t.state.tr.insertText(M, _, v);
      }
    }
    if (
      (C ||
        (C = t.state.tr.replace(
          _,
          v,
          c.doc.slice(m.start - c.from, m.endB - c.from)
        )),
      c.sel)
    ) {
      let M = nb(t, C.doc, c.sel);
      M &&
        !(
          (gt &&
            t.composing &&
            M.empty &&
            (m.start != m.endB ||
              t.input.lastChromeDelete < Date.now() - 100) &&
            (M.head == _ || M.head == C.mapping.map(v) - 1)) ||
          (Dt && M.empty && M.head == _)
        ) &&
        C.setSelection(M);
    }
    S && C.ensureMarks(S),
      i && C.setMeta("composition", i),
      t.dispatch(C.scrollIntoView());
  }
  function nb(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size
      ? null
      : Xf(t, e.resolve(n.anchor), e.resolve(n.head));
  }
  function sA(t, e) {
    let n = t.firstChild.marks,
      r = e.firstChild.marks,
      o = n,
      i = r,
      s,
      a,
      l;
    for (let d = 0; d < r.length; d++) o = r[d].removeFromSet(o);
    for (let d = 0; d < n.length; d++) i = n[d].removeFromSet(i);
    if (o.length == 1 && i.length == 0)
      (a = o[0]), (s = "add"), (l = (d) => d.mark(a.addToSet(d.marks)));
    else if (o.length == 0 && i.length == 1)
      (a = i[0]), (s = "remove"), (l = (d) => d.mark(a.removeFromSet(d.marks)));
    else return null;
    let c = [];
    for (let d = 0; d < e.childCount; d++) c.push(l(e.child(d)));
    if (D.from(c).eq(t)) return { mark: a, type: s };
  }
  function aA(t, e, n, r, o) {
    if (n - e <= o.pos - r.pos || dp(r, !0, !1) < o.pos) return !1;
    let i = t.resolve(e);
    if (!r.parent.isTextblock) {
      let a = i.nodeAfter;
      return a != null && n == e + a.nodeSize;
    }
    if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
      return !1;
    let s = t.resolve(dp(i, !0, !0));
    return !s.parent.isTextblock || s.pos > n || dp(s, !0, !1) < n
      ? !1
      : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
  }
  function dp(t, e, n) {
    let r = t.depth,
      o = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
      r--, o++, (e = !1);
    if (n) {
      let i = t.node(r).maybeChild(t.indexAfter(r));
      for (; i && !i.isLeaf; ) (i = i.firstChild), o++;
    }
    return o;
  }
  function lA(t, e, n, r, o) {
    let i = t.findDiffStart(e, n);
    if (i == null) return null;
    let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
    if (o == "end") {
      let l = Math.max(0, i - Math.min(s, a));
      r -= s + l - i;
    }
    if (s < i && t.size < e.size) {
      let l = r <= i && r >= s ? i - r : 0;
      (i -= l),
        i && i < e.size && rb(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
        (a = i + (a - s)),
        (s = i);
    } else if (a < i) {
      let l = r <= i && r >= a ? i - r : 0;
      (i -= l),
        i && i < t.size && rb(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
        (s = i + (s - a)),
        (a = i);
    }
    return { start: i, endA: s, endB: a };
  }
  function rb(t) {
    if (t.length != 2) return !1;
    let e = t.charCodeAt(0),
      n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
  }
  const ob = ep,
    cA = tp,
    uA = Bs;
  class ib {
    constructor(e, n) {
      (this._root = null),
        (this.focused = !1),
        (this.trackWrites = null),
        (this.mounted = !1),
        (this.markCursor = null),
        (this.cursorWrapper = null),
        (this.lastSelectedViewDesc = void 0),
        (this.input = new M6()),
        (this.prevDirectPlugins = []),
        (this.pluginViews = []),
        (this.requiresGeckoHackNode = !1),
        (this.dragging = null),
        (this._props = n),
        (this.state = n.state),
        (this.directPlugins = n.plugins || []),
        this.directPlugins.forEach(ub),
        (this.dispatch = this.dispatch.bind(this)),
        (this.dom = (e && e.mount) || document.createElement("div")),
        e &&
          (e.appendChild
            ? e.appendChild(this.dom)
            : typeof e == "function"
            ? e(this.dom)
            : e.mount && (this.mounted = !0)),
        (this.editable = lb(this)),
        ab(this),
        (this.nodeViews = cb(this)),
        (this.docView = m2(this.state.doc, sb(this), up(this), this.dom, this)),
        (this.domObserver = new Z6(this, (r, o, i, s) => iA(this, r, o, i, s))),
        this.domObserver.start(),
        T6(this),
        this.updatePluginViews();
    }
    get composing() {
      return this.input.composing;
    }
    get props() {
      if (this._props.state != this.state) {
        let e = this._props;
        this._props = {};
        for (let n in e) this._props[n] = e[n];
        this._props.state = this.state;
      }
      return this._props;
    }
    update(e) {
      e.handleDOMEvents != this._props.handleDOMEvents && op(this);
      let n = this._props;
      (this._props = e),
        e.plugins && (e.plugins.forEach(ub), (this.directPlugins = e.plugins)),
        this.updateStateInner(e.state, n);
    }
    setProps(e) {
      let n = {};
      for (let r in this._props) n[r] = this._props[r];
      n.state = this.state;
      for (let r in e) n[r] = e[r];
      this.update(n);
    }
    updateState(e) {
      this.updateStateInner(e, this._props);
    }
    updateStateInner(e, n) {
      var r;
      let o = this.state,
        i = !1,
        s = !1;
      e.storedMarks && this.composing && (W2(this), (s = !0)), (this.state = e);
      let a = o.plugins != e.plugins || this._props.plugins != n.plugins;
      if (
        a ||
        this._props.plugins != n.plugins ||
        this._props.nodeViews != n.nodeViews
      ) {
        let h = cb(this);
        fA(h, this.nodeViews) && ((this.nodeViews = h), (i = !0));
      }
      (a || n.handleDOMEvents != this._props.handleDOMEvents) && op(this),
        (this.editable = lb(this)),
        ab(this);
      let l = up(this),
        c = sb(this),
        d =
          o.plugins != e.plugins && !o.doc.eq(e.doc)
            ? "reset"
            : e.scrollToSelection > o.scrollToSelection
            ? "to selection"
            : "preserve",
        f = i || !this.docView.matchesNode(e.doc, c, l);
      (f || !e.selection.eq(o.selection)) && (s = !0);
      let p =
        d == "preserve" &&
        s &&
        this.dom.style.overflowAnchor == null &&
        UE(this);
      if (s) {
        this.domObserver.stop();
        let h =
          f &&
          (Dt || gt) &&
          !this.composing &&
          !o.selection.empty &&
          !e.selection.empty &&
          dA(o.selection, e.selection);
        if (f) {
          let m = gt
            ? (this.trackWrites = this.domSelectionRange().focusNode)
            : null;
          this.composing && (this.input.compositionNode = V6(this)),
            (i || !this.docView.update(e.doc, c, l, this)) &&
              (this.docView.updateOuterDeco(c),
              this.docView.destroy(),
              (this.docView = m2(e.doc, c, l, this.dom, this))),
            m && !this.trackWrites && (h = !0);
        }
        h ||
        !(
          this.input.mouseDown &&
          this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
          p6(this)
        )
          ? pr(this, h)
          : (E2(this, e.selection), this.domObserver.setCurSelection()),
          this.domObserver.start();
      }
      this.updatePluginViews(o),
        !((r = this.dragging) === null || r === void 0) &&
          r.node &&
          !o.doc.eq(e.doc) &&
          this.updateDraggedNode(this.dragging, o),
        d == "reset"
          ? (this.dom.scrollTop = 0)
          : d == "to selection"
          ? this.scrollToSelection()
          : p && jE(p);
    }
    scrollToSelection() {
      let e = this.domSelectionRange().focusNode;
      if (!this.someProp("handleScrollToSelection", (n) => n(this)))
        if (this.state.selection instanceof K) {
          let n = this.docView.domAfterPos(this.state.selection.from);
          n.nodeType == 1 && n2(this, n.getBoundingClientRect(), e);
        } else n2(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
    destroyPluginViews() {
      let e;
      for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
    }
    updatePluginViews(e) {
      if (
        !e ||
        e.plugins != this.state.plugins ||
        this.directPlugins != this.prevDirectPlugins
      ) {
        (this.prevDirectPlugins = this.directPlugins),
          this.destroyPluginViews();
        for (let n = 0; n < this.directPlugins.length; n++) {
          let r = this.directPlugins[n];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
        for (let n = 0; n < this.state.plugins.length; n++) {
          let r = this.state.plugins[n];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
      } else
        for (let n = 0; n < this.pluginViews.length; n++) {
          let r = this.pluginViews[n];
          r.update && r.update(this, e);
        }
    }
    updateDraggedNode(e, n) {
      let r = e.node,
        o = -1;
      if (this.state.doc.nodeAt(r.from) == r.node) o = r.from;
      else {
        let i = r.from + (this.state.doc.content.size - n.doc.content.size);
        (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
      }
      this.dragging = new K2(
        e.slice,
        e.move,
        o < 0 ? void 0 : K.create(this.state.doc, o)
      );
    }
    someProp(e, n) {
      let r = this._props && this._props[e],
        o;
      if (r != null && (o = n ? n(r) : r)) return o;
      for (let s = 0; s < this.directPlugins.length; s++) {
        let a = this.directPlugins[s].props[e];
        if (a != null && (o = n ? n(a) : a)) return o;
      }
      let i = this.state.plugins;
      if (i)
        for (let s = 0; s < i.length; s++) {
          let a = i[s].props[e];
          if (a != null && (o = n ? n(a) : a)) return o;
        }
    }
    hasFocus() {
      if (Dt) {
        let e = this.root.activeElement;
        if (e == this.dom) return !0;
        if (!e || !this.dom.contains(e)) return !1;
        for (; e && this.dom != e && this.dom.contains(e); ) {
          if (e.contentEditable == "false") return !1;
          e = e.parentElement;
        }
        return !0;
      }
      return this.root.activeElement == this.dom;
    }
    focus() {
      this.domObserver.stop(),
        this.editable && WE(this.dom),
        pr(this),
        this.domObserver.start();
    }
    get root() {
      let e = this._root;
      if (e == null) {
        for (let n = this.dom.parentNode; n; n = n.parentNode)
          if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
            return (
              n.getSelection ||
                (Object.getPrototypeOf(n).getSelection = () =>
                  n.ownerDocument.getSelection()),
              (this._root = n)
            );
      }
      return e || document;
    }
    updateRoot() {
      this._root = null;
    }
    posAtCoords(e) {
      return YE(this, e);
    }
    coordsAtPos(e, n = 1) {
      return l2(this, e, n);
    }
    domAtPos(e, n = 0) {
      return this.docView.domFromPos(e, n);
    }
    nodeDOM(e) {
      let n = this.docView.descAt(e);
      return n ? n.nodeDOM : null;
    }
    posAtDOM(e, n, r = -1) {
      let o = this.docView.posFromDOM(e, n, r);
      if (o == null) throw new RangeError("DOM position not inside the editor");
      return o;
    }
    endOfTextblock(e, n) {
      return t6(this, n || this.state, e);
    }
    pasteHTML(e, n) {
      return $s(this, "", e, !1, n || new ClipboardEvent("paste"));
    }
    pasteText(e, n) {
      return $s(this, e, null, !0, n || new ClipboardEvent("paste"));
    }
    destroy() {
      this.docView &&
        (N6(this),
        this.destroyPluginViews(),
        this.mounted
          ? (this.docView.update(this.state.doc, [], up(this), this),
            (this.dom.textContent = ""))
          : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
        this.docView.destroy(),
        (this.docView = null),
        RE());
    }
    get isDestroyed() {
      return this.docView == null;
    }
    dispatchEvent(e) {
      return R6(this, e);
    }
    dispatch(e) {
      let n = this._props.dispatchTransaction;
      n ? n.call(this, e) : this.updateState(this.state.apply(e));
    }
    domSelectionRange() {
      let e = this.domSelection();
      return e
        ? (kt &&
            this.root.nodeType === 11 &&
            PE(this.dom.ownerDocument) == this.dom &&
            eA(this, e)) ||
            e
        : {
            focusNode: null,
            focusOffset: 0,
            anchorNode: null,
            anchorOffset: 0,
          };
    }
    domSelection() {
      return this.root.getSelection();
    }
  }
  function sb(t) {
    let e = Object.create(null);
    return (
      (e.class = "ProseMirror"),
      (e.contenteditable = String(t.editable)),
      t.someProp("attributes", (n) => {
        if ((typeof n == "function" && (n = n(t.state)), n))
          for (let r in n)
            r == "class"
              ? (e.class += " " + n[r])
              : r == "style"
              ? (e.style = (e.style ? e.style + ";" : "") + n[r])
              : !e[r] &&
                r != "contenteditable" &&
                r != "nodeName" &&
                (e[r] = String(n[r]));
      }),
      e.translate || (e.translate = "no"),
      [Te.node(0, t.state.doc.content.size, e)]
    );
  }
  function ab(t) {
    if (t.markCursor) {
      let e = document.createElement("img");
      (e.className = "ProseMirror-separator"),
        e.setAttribute("mark-placeholder", "true"),
        e.setAttribute("alt", ""),
        (t.cursorWrapper = {
          dom: e,
          deco: Te.widget(t.state.selection.from, e, {
            raw: !0,
            marks: t.markCursor,
          }),
        });
    } else t.cursorWrapper = null;
  }
  function lb(t) {
    return !t.someProp("editable", (e) => e(t.state) === !1);
  }
  function dA(t, e) {
    let n = Math.min(
      t.$anchor.sharedDepth(t.head),
      e.$anchor.sharedDepth(e.head)
    );
    return t.$anchor.start(n) != e.$anchor.start(n);
  }
  function cb(t) {
    let e = Object.create(null);
    function n(r) {
      for (let o in r)
        Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
    }
    return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
  }
  function fA(t, e) {
    let n = 0,
      r = 0;
    for (let o in t) {
      if (t[o] != e[o]) return !0;
      n++;
    }
    for (let o in e) r++;
    return n != r;
  }
  function ub(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
      throw new RangeError(
        "Plugins passed directly to the view must not have a state component"
      );
  }
  let Ct = class _o extends J {
    constructor(e) {
      super(e, e);
    }
    map(e, n) {
      let r = e.resolve(n.map(this.head));
      return _o.valid(r) ? new _o(r) : J.near(r);
    }
    content() {
      return z.empty;
    }
    eq(e) {
      return e instanceof _o && e.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    static fromJSON(e, n) {
      if (typeof n.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new _o(e.resolve(n.pos));
    }
    getBookmark() {
      return new pA(this.anchor);
    }
    static valid(e) {
      let n = e.parent;
      if (n.isTextblock || !hA(e) || !mA(e)) return !1;
      let r = n.type.spec.allowGapCursor;
      if (r != null) return r;
      let o = n.contentMatchAt(e.index()).defaultType;
      return o && o.isTextblock;
    }
    static findGapCursorFrom(e, n, r = !1) {
      e: for (;;) {
        if (!r && _o.valid(e)) return e;
        let o = e.pos,
          i = null;
        for (let s = e.depth; ; s--) {
          let a = e.node(s);
          if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
            i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
            break;
          } else if (s == 0) return null;
          o += n;
          let l = e.doc.resolve(o);
          if (_o.valid(l)) return l;
        }
        for (;;) {
          let s = n > 0 ? i.firstChild : i.lastChild;
          if (!s) {
            if (i.isAtom && !i.isText && !K.isSelectable(i)) {
              (e = e.doc.resolve(o + i.nodeSize * n)), (r = !1);
              continue e;
            }
            break;
          }
          (i = s), (o += n);
          let a = e.doc.resolve(o);
          if (_o.valid(a)) return a;
        }
        return null;
      }
    }
  };
  (Ct.prototype.visible = !1),
    (Ct.findFrom = Ct.findGapCursorFrom),
    J.jsonID("gapcursor", Ct);
  let pA = class $x {
    constructor(e) {
      this.pos = e;
    }
    map(e) {
      return new $x(e.map(this.pos));
    }
    resolve(e) {
      let n = e.resolve(this.pos);
      return Ct.valid(n) ? new Ct(n) : J.near(n);
    }
  };
  function hA(t) {
    for (let e = t.depth; e >= 0; e--) {
      let n = t.index(e),
        r = t.node(e);
      if (n == 0) {
        if (r.type.spec.isolating) return !0;
        continue;
      }
      for (let o = r.child(n - 1); ; o = o.lastChild) {
        if (
          (o.childCount == 0 && !o.inlineContent) ||
          o.isAtom ||
          o.type.spec.isolating
        )
          return !0;
        if (o.inlineContent) return !1;
      }
    }
    return !0;
  }
  function mA(t) {
    for (let e = t.depth; e >= 0; e--) {
      let n = t.indexAfter(e),
        r = t.node(e);
      if (n == r.childCount) {
        if (r.type.spec.isolating) return !0;
        continue;
      }
      for (let o = r.child(n); ; o = o.firstChild) {
        if (
          (o.childCount == 0 && !o.inlineContent) ||
          o.isAtom ||
          o.type.spec.isolating
        )
          return !0;
        if (o.inlineContent) return !1;
      }
    }
    return !0;
  }
  function gA() {
    return new ie({
      props: {
        decorations: kA,
        createSelectionBetween(t, e, n) {
          return e.pos == n.pos && Ct.valid(n) ? new Ct(n) : null;
        },
        handleClick: yA,
        handleKeyDown: bA,
        handleDOMEvents: { beforeinput: _A },
      },
    });
  }
  const bA = Ms({
    ArrowLeft: Gl("horiz", -1),
    ArrowRight: Gl("horiz", 1),
    ArrowUp: Gl("vert", -1),
    ArrowDown: Gl("vert", 1),
  });
  function Gl(t, e) {
    const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
    return function (r, o, i) {
      let s = r.selection,
        a = e > 0 ? s.$to : s.$from,
        l = s.empty;
      if (s instanceof U) {
        if (!i.endOfTextblock(n) || a.depth == 0) return !1;
        (l = !1), (a = r.doc.resolve(e > 0 ? a.after() : a.before()));
      }
      let c = Ct.findGapCursorFrom(a, e, l);
      return c ? (o && o(r.tr.setSelection(new Ct(c))), !0) : !1;
    };
  }
  function yA(t, e, n) {
    if (!t || !t.editable) return !1;
    let r = t.state.doc.resolve(e);
    if (!Ct.valid(r)) return !1;
    let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
    return o && o.inside > -1 && K.isSelectable(t.state.doc.nodeAt(o.inside))
      ? !1
      : (t.dispatch(t.state.tr.setSelection(new Ct(r))), !0);
  }
  function _A(t, e) {
    if (
      e.inputType != "insertCompositionText" ||
      !(t.state.selection instanceof Ct)
    )
      return !1;
    let { $from: n } = t.state.selection,
      r = n.parent
        .contentMatchAt(n.index())
        .findWrapping(t.state.schema.nodes.text);
    if (!r) return !1;
    let o = D.empty;
    for (let s = r.length - 1; s >= 0; s--)
      o = D.from(r[s].createAndFill(null, o));
    let i = t.state.tr.replace(n.pos, n.pos, new z(o, 0, 0));
    return i.setSelection(U.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
  }
  function kA(t) {
    if (!(t.selection instanceof Ct)) return null;
    let e = document.createElement("div");
    return (
      (e.className = "ProseMirror-gapcursor"),
      ue.create(t.doc, [Te.widget(t.selection.head, e, { key: "gapcursor" })])
    );
  }
  var Jl = 200,
    lt = function () {};
  (lt.prototype.append = function (e) {
    return e.length
      ? ((e = lt.from(e)),
        (!this.length && e) ||
          (e.length < Jl && this.leafAppend(e)) ||
          (this.length < Jl && e.leafPrepend(this)) ||
          this.appendInner(e))
      : this;
  }),
    (lt.prototype.prepend = function (e) {
      return e.length ? lt.from(e).append(this) : this;
    }),
    (lt.prototype.appendInner = function (e) {
      return new wA(this, e);
    }),
    (lt.prototype.slice = function (e, n) {
      return (
        e === void 0 && (e = 0),
        n === void 0 && (n = this.length),
        e >= n
          ? lt.empty
          : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
      );
    }),
    (lt.prototype.get = function (e) {
      if (!(e < 0 || e >= this.length)) return this.getInner(e);
    }),
    (lt.prototype.forEach = function (e, n, r) {
      n === void 0 && (n = 0),
        r === void 0 && (r = this.length),
        n <= r
          ? this.forEachInner(e, n, r, 0)
          : this.forEachInvertedInner(e, n, r, 0);
    }),
    (lt.prototype.map = function (e, n, r) {
      n === void 0 && (n = 0), r === void 0 && (r = this.length);
      var o = [];
      return (
        this.forEach(
          function (i, s) {
            return o.push(e(i, s));
          },
          n,
          r
        ),
        o
      );
    }),
    (lt.from = function (e) {
      return e instanceof lt ? e : e && e.length ? new db(e) : lt.empty;
    });
  var db = (function (t) {
    function e(r) {
      t.call(this), (this.values = r);
    }
    t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e);
    var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
    return (
      (e.prototype.flatten = function () {
        return this.values;
      }),
      (e.prototype.sliceInner = function (o, i) {
        return o == 0 && i == this.length
          ? this
          : new e(this.values.slice(o, i));
      }),
      (e.prototype.getInner = function (o) {
        return this.values[o];
      }),
      (e.prototype.forEachInner = function (o, i, s, a) {
        for (var l = i; l < s; l++)
          if (o(this.values[l], a + l) === !1) return !1;
      }),
      (e.prototype.forEachInvertedInner = function (o, i, s, a) {
        for (var l = i - 1; l >= s; l--)
          if (o(this.values[l], a + l) === !1) return !1;
      }),
      (e.prototype.leafAppend = function (o) {
        if (this.length + o.length <= Jl)
          return new e(this.values.concat(o.flatten()));
      }),
      (e.prototype.leafPrepend = function (o) {
        if (this.length + o.length <= Jl)
          return new e(o.flatten().concat(this.values));
      }),
      (n.length.get = function () {
        return this.values.length;
      }),
      (n.depth.get = function () {
        return 0;
      }),
      Object.defineProperties(e.prototype, n),
      e
    );
  })(lt);
  lt.empty = new db([]);
  var wA = (function (t) {
      function e(n, r) {
        t.call(this),
          (this.left = n),
          (this.right = r),
          (this.length = n.length + r.length),
          (this.depth = Math.max(n.depth, r.depth) + 1);
      }
      return (
        t && (e.__proto__ = t),
        (e.prototype = Object.create(t && t.prototype)),
        (e.prototype.constructor = e),
        (e.prototype.flatten = function () {
          return this.left.flatten().concat(this.right.flatten());
        }),
        (e.prototype.getInner = function (r) {
          return r < this.left.length
            ? this.left.get(r)
            : this.right.get(r - this.left.length);
        }),
        (e.prototype.forEachInner = function (r, o, i, s) {
          var a = this.left.length;
          if (
            (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === !1) ||
            (i > a &&
              this.right.forEachInner(
                r,
                Math.max(o - a, 0),
                Math.min(this.length, i) - a,
                s + a
              ) === !1)
          )
            return !1;
        }),
        (e.prototype.forEachInvertedInner = function (r, o, i, s) {
          var a = this.left.length;
          if (
            (o > a &&
              this.right.forEachInvertedInner(
                r,
                o - a,
                Math.max(i, a) - a,
                s + a
              ) === !1) ||
            (i < a &&
              this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === !1)
          )
            return !1;
        }),
        (e.prototype.sliceInner = function (r, o) {
          if (r == 0 && o == this.length) return this;
          var i = this.left.length;
          return o <= i
            ? this.left.slice(r, o)
            : r >= i
            ? this.right.slice(r - i, o - i)
            : this.left.slice(r, i).append(this.right.slice(0, o - i));
        }),
        (e.prototype.leafAppend = function (r) {
          var o = this.right.leafAppend(r);
          if (o) return new e(this.left, o);
        }),
        (e.prototype.leafPrepend = function (r) {
          var o = this.left.leafPrepend(r);
          if (o) return new e(o, this.right);
        }),
        (e.prototype.appendInner = function (r) {
          return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
            ? new e(this.left, new e(this.right, r))
            : new e(this, r);
        }),
        e
      );
    })(lt),
    fb = lt;
  const xA = 500;
  class Mn {
    constructor(e, n) {
      (this.items = e), (this.eventCount = n);
    }
    popEvent(e, n) {
      if (this.eventCount == 0) return null;
      let r = this.items.length;
      for (; ; r--)
        if (this.items.get(r - 1).selection) {
          --r;
          break;
        }
      let o, i;
      n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length));
      let s = e.tr,
        a,
        l,
        c = [],
        d = [];
      return (
        this.items.forEach(
          (f, p) => {
            if (!f.step) {
              o || ((o = this.remapping(r, p + 1)), (i = o.maps.length)),
                i--,
                d.push(f);
              return;
            }
            if (o) {
              d.push(new Vn(f.map));
              let h = f.step.map(o.slice(i)),
                m;
              h &&
                s.maybeStep(h).doc &&
                ((m = s.mapping.maps[s.mapping.maps.length - 1]),
                c.push(new Vn(m, void 0, void 0, c.length + d.length))),
                i--,
                m && o.appendMap(m, i);
            } else s.maybeStep(f.step);
            if (f.selection)
              return (
                (a = o ? f.selection.map(o.slice(i)) : f.selection),
                (l = new Mn(
                  this.items.slice(0, r).append(d.reverse().concat(c)),
                  this.eventCount - 1
                )),
                !1
              );
          },
          this.items.length,
          0
        ),
        { remaining: l, transform: s, selection: a }
      );
    }
    addTransform(e, n, r, o) {
      let i = [],
        s = this.eventCount,
        a = this.items,
        l = !o && a.length ? a.get(a.length - 1) : null;
      for (let d = 0; d < e.steps.length; d++) {
        let f = e.steps[d].invert(e.docs[d]),
          p = new Vn(e.mapping.maps[d], f, n),
          h;
        (h = l && l.merge(p)) &&
          ((p = h), d ? i.pop() : (a = a.slice(0, a.length - 1))),
          i.push(p),
          n && (s++, (n = void 0)),
          o || (l = p);
      }
      let c = s - r.depth;
      return c > vA && ((a = CA(a, c)), (s -= c)), new Mn(a.append(i), s);
    }
    remapping(e, n) {
      let r = new Ro();
      return (
        this.items.forEach(
          (o, i) => {
            let s =
              o.mirrorOffset != null && i - o.mirrorOffset >= e
                ? r.maps.length - o.mirrorOffset
                : void 0;
            r.appendMap(o.map, s);
          },
          e,
          n
        ),
        r
      );
    }
    addMaps(e) {
      return this.eventCount == 0
        ? this
        : new Mn(this.items.append(e.map((n) => new Vn(n))), this.eventCount);
    }
    rebased(e, n) {
      if (!this.eventCount) return this;
      let r = [],
        o = Math.max(0, this.items.length - n),
        i = e.mapping,
        s = e.steps.length,
        a = this.eventCount;
      this.items.forEach((p) => {
        p.selection && a--;
      }, o);
      let l = n;
      this.items.forEach((p) => {
        let h = i.getMirror(--l);
        if (h == null) return;
        s = Math.min(s, h);
        let m = i.maps[h];
        if (p.step) {
          let g = e.steps[h].invert(e.docs[h]),
            b = p.selection && p.selection.map(i.slice(l + 1, h));
          b && a++, r.push(new Vn(m, g, b));
        } else r.push(new Vn(m));
      }, o);
      let c = [];
      for (let p = n; p < s; p++) c.push(new Vn(i.maps[p]));
      let d = this.items.slice(0, o).append(c).append(r),
        f = new Mn(d, a);
      return (
        f.emptyItemCount() > xA &&
          (f = f.compress(this.items.length - r.length)),
        f
      );
    }
    emptyItemCount() {
      let e = 0;
      return (
        this.items.forEach((n) => {
          n.step || e++;
        }),
        e
      );
    }
    compress(e = this.items.length) {
      let n = this.remapping(0, e),
        r = n.maps.length,
        o = [],
        i = 0;
      return (
        this.items.forEach(
          (s, a) => {
            if (a >= e) o.push(s), s.selection && i++;
            else if (s.step) {
              let l = s.step.map(n.slice(r)),
                c = l && l.getMap();
              if ((r--, c && n.appendMap(c, r), l)) {
                let d = s.selection && s.selection.map(n.slice(r));
                d && i++;
                let f = new Vn(c.invert(), l, d),
                  p,
                  h = o.length - 1;
                (p = o.length && o[h].merge(f)) ? (o[h] = p) : o.push(f);
              }
            } else s.map && r--;
          },
          this.items.length,
          0
        ),
        new Mn(fb.from(o.reverse()), i)
      );
    }
  }
  Mn.empty = new Mn(fb.empty, 0);
  function CA(t, e) {
    let n;
    return (
      t.forEach((r, o) => {
        if (r.selection && e-- == 0) return (n = o), !1;
      }),
      t.slice(n)
    );
  }
  class Vn {
    constructor(e, n, r, o) {
      (this.map = e),
        (this.step = n),
        (this.selection = r),
        (this.mirrorOffset = o);
    }
    merge(e) {
      if (this.step && e.step && !e.selection) {
        let n = e.step.merge(this.step);
        if (n) return new Vn(n.getMap().invert(), n, this.selection);
      }
    }
  }
  class Gr {
    constructor(e, n, r, o, i) {
      (this.done = e),
        (this.undone = n),
        (this.prevRanges = r),
        (this.prevTime = o),
        (this.prevComposition = i);
    }
  }
  const vA = 20;
  function EA(t, e, n, r) {
    let o = n.getMeta(hr),
      i;
    if (o) return o.historyState;
    n.getMeta(mb) && (t = new Gr(t.done, t.undone, null, 0, -1));
    let s = n.getMeta("appendedTransaction");
    if (n.steps.length == 0) return t;
    if (s && s.getMeta(hr))
      return s.getMeta(hr).redo
        ? new Gr(
            t.done.addTransform(n, void 0, r, Yl(e)),
            t.undone,
            pb(n.mapping.maps),
            t.prevTime,
            t.prevComposition
          )
        : new Gr(
            t.done,
            t.undone.addTransform(n, void 0, r, Yl(e)),
            null,
            t.prevTime,
            t.prevComposition
          );
    if (
      n.getMeta("addToHistory") !== !1 &&
      !(s && s.getMeta("addToHistory") === !1)
    ) {
      let a = n.getMeta("composition"),
        l =
          t.prevTime == 0 ||
          (!s &&
            t.prevComposition != a &&
            (t.prevTime < (n.time || 0) - r.newGroupDelay ||
              !AA(n, t.prevRanges))),
        c = s ? fp(t.prevRanges, n.mapping) : pb(n.mapping.maps);
      return new Gr(
        t.done.addTransform(
          n,
          l ? e.selection.getBookmark() : void 0,
          r,
          Yl(e)
        ),
        Mn.empty,
        c,
        n.time,
        a ?? t.prevComposition
      );
    } else
      return (i = n.getMeta("rebased"))
        ? new Gr(
            t.done.rebased(n, i),
            t.undone.rebased(n, i),
            fp(t.prevRanges, n.mapping),
            t.prevTime,
            t.prevComposition
          )
        : new Gr(
            t.done.addMaps(n.mapping.maps),
            t.undone.addMaps(n.mapping.maps),
            fp(t.prevRanges, n.mapping),
            t.prevTime,
            t.prevComposition
          );
  }
  function AA(t, e) {
    if (!e) return !1;
    if (!t.docChanged) return !0;
    let n = !1;
    return (
      t.mapping.maps[0].forEach((r, o) => {
        for (let i = 0; i < e.length; i += 2)
          r <= e[i + 1] && o >= e[i] && (n = !0);
      }),
      n
    );
  }
  function pb(t) {
    let e = [];
    for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
      t[n].forEach((r, o, i, s) => e.push(i, s));
    return e;
  }
  function fp(t, e) {
    if (!t) return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
      let o = e.map(t[r], 1),
        i = e.map(t[r + 1], -1);
      o <= i && n.push(o, i);
    }
    return n;
  }
  function SA(t, e, n) {
    let r = Yl(e),
      o = hr.get(e).spec.config,
      i = (n ? t.undone : t.done).popEvent(e, r);
    if (!i) return null;
    let s = i.selection.resolve(i.transform.doc),
      a = (n ? t.done : t.undone).addTransform(
        i.transform,
        e.selection.getBookmark(),
        o,
        r
      ),
      l = new Gr(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
    return i.transform
      .setSelection(s)
      .setMeta(hr, { redo: n, historyState: l });
  }
  let pp = !1,
    hb = null;
  function Yl(t) {
    let e = t.plugins;
    if (hb != e) {
      (pp = !1), (hb = e);
      for (let n = 0; n < e.length; n++)
        if (e[n].spec.historyPreserveItems) {
          pp = !0;
          break;
        }
    }
    return pp;
  }
  function MA(t) {
    return t.setMeta(mb, !0);
  }
  const hr = new de("history"),
    mb = new de("closeHistory");
  function gb(t = {}) {
    return (
      (t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
      new ie({
        key: hr,
        state: {
          init() {
            return new Gr(Mn.empty, Mn.empty, null, 0, -1);
          },
          apply(e, n, r) {
            return EA(n, r, e, t);
          },
        },
        config: t,
        props: {
          handleDOMEvents: {
            beforeinput(e, n) {
              let r = n.inputType,
                o = r == "historyUndo" ? Hs : r == "historyRedo" ? zs : null;
              return o ? (n.preventDefault(), o(e.state, e.dispatch)) : !1;
            },
          },
        },
      })
    );
  }
  function Xl(t, e) {
    return (n, r) => {
      let o = hr.getState(n);
      if (!o || (t ? o.undone : o.done).eventCount == 0) return !1;
      if (r) {
        let i = SA(o, n, t);
        i && r(e ? i.scrollIntoView() : i);
      }
      return !0;
    };
  }
  const Hs = Xl(!1, !0),
    zs = Xl(!0, !0),
    TA = Xl(!1, !1),
    NA = Xl(!0, !1);
  function OA(t) {
    let e = hr.getState(t);
    return e ? e.done.eventCount : 0;
  }
  function RA(t) {
    let e = hr.getState(t);
    return e ? e.undone.eventCount : 0;
  }
  let mr = class {
    constructor(e, n, r = {}) {
      (this.match = e),
        (this.match = e),
        (this.handler = typeof n == "string" ? DA(n) : n),
        (this.undoable = r.undoable !== !1),
        (this.inCode = r.inCode || !1);
    }
  };
  function DA(t) {
    return function (e, n, r, o) {
      let i = t;
      if (n[1]) {
        let s = n[0].lastIndexOf(n[1]);
        (i += n[0].slice(s + n[1].length)), (r += s);
        let a = r - o;
        a > 0 && ((i = n[0].slice(s - a, s) + i), (r = o));
      }
      return e.tr.insertText(i, r, o);
    };
  }
  const LA = 500;
  function IA({ rules: t }) {
    let e = new ie({
      state: {
        init() {
          return null;
        },
        apply(n, r) {
          let o = n.getMeta(this);
          return o || (n.selectionSet || n.docChanged ? null : r);
        },
      },
      props: {
        handleTextInput(n, r, o, i) {
          return bb(n, r, o, i, t, e);
        },
        handleDOMEvents: {
          compositionend: (n) => {
            setTimeout(() => {
              let { $cursor: r } = n.state.selection;
              r && bb(n, r.pos, r.pos, "", t, e);
            });
          },
        },
      },
      isInputRules: !0,
    });
    return e;
  }
  function bb(t, e, n, r, o, i) {
    if (t.composing) return !1;
    let s = t.state,
      a = s.doc.resolve(e),
      l =
        a.parent.textBetween(
          Math.max(0, a.parentOffset - LA),
          a.parentOffset,
          null,
          "￼"
        ) + r;
    for (let c = 0; c < o.length; c++) {
      let d = o[c];
      if (a.parent.type.spec.code) {
        if (!d.inCode) continue;
      } else if (d.inCode === "only") continue;
      let f = d.match.exec(l),
        p = f && d.handler(s, f, e - (f[0].length - r.length), n);
      if (p)
        return (
          d.undoable && p.setMeta(i, { transform: p, from: e, to: n, text: r }),
          t.dispatch(p),
          !0
        );
    }
    return !1;
  }
  const BA = (t, e) => {
      let n = t.plugins;
      for (let r = 0; r < n.length; r++) {
        let o = n[r],
          i;
        if (o.spec.isInputRules && (i = o.getState(t))) {
          if (e) {
            let s = t.tr,
              a = i.transform;
            for (let l = a.steps.length - 1; l >= 0; l--)
              s.step(a.steps[l].invert(a.docs[l]));
            if (i.text) {
              let l = s.doc.resolve(i.from).marks();
              s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
            } else s.delete(i.from, i.to);
            e(s);
          }
          return !0;
        }
      }
      return !1;
    },
    PA = new mr(/--$/, "—"),
    $A = new mr(/\.\.\.$/, "…"),
    yb = new mr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"),
    _b = new mr(/"$/, "”"),
    kb = new mr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"),
    wb = new mr(/'$/, "’"),
    FA = [yb, _b, kb, wb];
  function HA(t, e, n = null, r) {
    return new mr(t, (o, i, s, a) => {
      let l = n instanceof Function ? n(i) : n,
        c = o.tr.delete(s, a),
        d = c.doc.resolve(s),
        f = d.blockRange(),
        p = f && ws(f, e, l);
      if (!p) return null;
      c.wrap(f, p);
      let h = c.doc.resolve(s - 1).nodeBefore;
      return (
        h &&
          h.type == e &&
          An(c.doc, s - 1) &&
          (!r || r(i, h)) &&
          c.join(s - 1),
        c
      );
    });
  }
  function zA(t, e, n = null) {
    return new mr(t, (r, o, i, s) => {
      let a = r.doc.resolve(i),
        l = n instanceof Function ? n(o) : n;
      return a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), e)
        ? r.tr.delete(i, s).setBlockType(i, i, e, l)
        : null;
    });
  }
  const xb = {};
  function VA(t) {
    let e = xb[t];
    if (e) return e;
    e = xb[t] = [];
    for (let n = 0; n < 128; n++) {
      const r = String.fromCharCode(n);
      e.push(r);
    }
    for (let n = 0; n < t.length; n++) {
      const r = t.charCodeAt(n);
      e[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
    }
    return e;
  }
  function ki(t, e) {
    typeof e != "string" && (e = ki.defaultChars);
    const n = VA(e);
    return t.replace(/(%[a-f0-9]{2})+/gi, function (r) {
      let o = "";
      for (let i = 0, s = r.length; i < s; i += 3) {
        const a = parseInt(r.slice(i + 1, i + 3), 16);
        if (a < 128) {
          o += n[a];
          continue;
        }
        if ((a & 224) === 192 && i + 3 < s) {
          const l = parseInt(r.slice(i + 4, i + 6), 16);
          if ((l & 192) === 128) {
            const c = ((a << 6) & 1984) | (l & 63);
            c < 128 ? (o += "��") : (o += String.fromCharCode(c)), (i += 3);
            continue;
          }
        }
        if ((a & 240) === 224 && i + 6 < s) {
          const l = parseInt(r.slice(i + 4, i + 6), 16),
            c = parseInt(r.slice(i + 7, i + 9), 16);
          if ((l & 192) === 128 && (c & 192) === 128) {
            const d = ((a << 12) & 61440) | ((l << 6) & 4032) | (c & 63);
            d < 2048 || (d >= 55296 && d <= 57343)
              ? (o += "���")
              : (o += String.fromCharCode(d)),
              (i += 6);
            continue;
          }
        }
        if ((a & 248) === 240 && i + 9 < s) {
          const l = parseInt(r.slice(i + 4, i + 6), 16),
            c = parseInt(r.slice(i + 7, i + 9), 16),
            d = parseInt(r.slice(i + 10, i + 12), 16);
          if ((l & 192) === 128 && (c & 192) === 128 && (d & 192) === 128) {
            let f =
              ((a << 18) & 1835008) |
              ((l << 12) & 258048) |
              ((c << 6) & 4032) |
              (d & 63);
            f < 65536 || f > 1114111
              ? (o += "����")
              : ((f -= 65536),
                (o += String.fromCharCode(
                  55296 + (f >> 10),
                  56320 + (f & 1023)
                ))),
              (i += 9);
            continue;
          }
        }
        o += "�";
      }
      return o;
    });
  }
  (ki.defaultChars = ";/?:@&=+$,#"), (ki.componentChars = "");
  const Cb = {};
  function UA(t) {
    let e = Cb[t];
    if (e) return e;
    e = Cb[t] = [];
    for (let n = 0; n < 128; n++) {
      const r = String.fromCharCode(n);
      /^[0-9a-z]$/i.test(r)
        ? e.push(r)
        : e.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
    }
    for (let n = 0; n < t.length; n++) e[t.charCodeAt(n)] = t[n];
    return e;
  }
  function Vs(t, e, n) {
    typeof e != "string" && ((n = e), (e = Vs.defaultChars)),
      typeof n > "u" && (n = !0);
    const r = UA(e);
    let o = "";
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t.charCodeAt(i);
      if (
        n &&
        a === 37 &&
        i + 2 < s &&
        /^[0-9a-f]{2}$/i.test(t.slice(i + 1, i + 3))
      ) {
        (o += t.slice(i, i + 3)), (i += 2);
        continue;
      }
      if (a < 128) {
        o += r[a];
        continue;
      }
      if (a >= 55296 && a <= 57343) {
        if (a >= 55296 && a <= 56319 && i + 1 < s) {
          const l = t.charCodeAt(i + 1);
          if (l >= 56320 && l <= 57343) {
            (o += encodeURIComponent(t[i] + t[i + 1])), i++;
            continue;
          }
        }
        o += "%EF%BF%BD";
        continue;
      }
      o += encodeURIComponent(t[i]);
    }
    return o;
  }
  (Vs.defaultChars = ";/?:@&=+$,-_.!~*'()#"), (Vs.componentChars = "-_.!~*'()");
  function hp(t) {
    let e = "";
    return (
      (e += t.protocol || ""),
      (e += t.slashes ? "//" : ""),
      (e += t.auth ? t.auth + "@" : ""),
      t.hostname && t.hostname.indexOf(":") !== -1
        ? (e += "[" + t.hostname + "]")
        : (e += t.hostname || ""),
      (e += t.port ? ":" + t.port : ""),
      (e += t.pathname || ""),
      (e += t.search || ""),
      (e += t.hash || ""),
      e
    );
  }
  function Zl() {
    (this.protocol = null),
      (this.slashes = null),
      (this.auth = null),
      (this.port = null),
      (this.hostname = null),
      (this.hash = null),
      (this.search = null),
      (this.pathname = null);
  }
  const jA = /^([a-z0-9.+-]+:)/i,
    WA = /:[0-9]*$/,
    qA = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    KA = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      `
`,
      "	",
    ],
    GA = ["{", "}", "|", "\\", "^", "`"].concat(KA),
    JA = ["'"].concat(GA),
    vb = ["%", "/", "?", ";", "#"].concat(JA),
    Eb = ["/", "?", "#"],
    YA = 255,
    Ab = /^[+a-z0-9A-Z_-]{0,63}$/,
    XA = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    Sb = { javascript: !0, "javascript:": !0 },
    Mb = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0,
    };
  function mp(t, e) {
    if (t && t instanceof Zl) return t;
    const n = new Zl();
    return n.parse(t, e), n;
  }
  (Zl.prototype.parse = function (t, e) {
    let n,
      r,
      o,
      i = t;
    if (((i = i.trim()), !e && t.split("#").length === 1)) {
      const c = qA.exec(i);
      if (c) return (this.pathname = c[1]), c[2] && (this.search = c[2]), this;
    }
    let s = jA.exec(i);
    if (
      (s &&
        ((s = s[0]),
        (n = s.toLowerCase()),
        (this.protocol = s),
        (i = i.substr(s.length))),
      (e || s || i.match(/^\/\/[^@\/]+@[^@\/]+/)) &&
        ((o = i.substr(0, 2) === "//"),
        o && !(s && Sb[s]) && ((i = i.substr(2)), (this.slashes = !0))),
      !Sb[s] && (o || (s && !Mb[s])))
    ) {
      let c = -1;
      for (let m = 0; m < Eb.length; m++)
        (r = i.indexOf(Eb[m])), r !== -1 && (c === -1 || r < c) && (c = r);
      let d, f;
      c === -1 ? (f = i.lastIndexOf("@")) : (f = i.lastIndexOf("@", c)),
        f !== -1 &&
          ((d = i.slice(0, f)), (i = i.slice(f + 1)), (this.auth = d)),
        (c = -1);
      for (let m = 0; m < vb.length; m++)
        (r = i.indexOf(vb[m])), r !== -1 && (c === -1 || r < c) && (c = r);
      c === -1 && (c = i.length), i[c - 1] === ":" && c--;
      const p = i.slice(0, c);
      (i = i.slice(c)),
        this.parseHost(p),
        (this.hostname = this.hostname || "");
      const h =
        this.hostname[0] === "[" &&
        this.hostname[this.hostname.length - 1] === "]";
      if (!h) {
        const m = this.hostname.split(/\./);
        for (let g = 0, b = m.length; g < b; g++) {
          const y = m[g];
          if (y && !y.match(Ab)) {
            let x = "";
            for (let w = 0, _ = y.length; w < _; w++)
              y.charCodeAt(w) > 127 ? (x += "x") : (x += y[w]);
            if (!x.match(Ab)) {
              const w = m.slice(0, g),
                _ = m.slice(g + 1),
                v = y.match(XA);
              v && (w.push(v[1]), _.unshift(v[2])),
                _.length && (i = _.join(".") + i),
                (this.hostname = w.join("."));
              break;
            }
          }
        }
      }
      this.hostname.length > YA && (this.hostname = ""),
        h &&
          (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
    }
    const a = i.indexOf("#");
    a !== -1 && ((this.hash = i.substr(a)), (i = i.slice(0, a)));
    const l = i.indexOf("?");
    return (
      l !== -1 && ((this.search = i.substr(l)), (i = i.slice(0, l))),
      i && (this.pathname = i),
      Mb[n] && this.hostname && !this.pathname && (this.pathname = ""),
      this
    );
  }),
    (Zl.prototype.parseHost = function (t) {
      let e = WA.exec(t);
      e &&
        ((e = e[0]),
        e !== ":" && (this.port = e.substr(1)),
        (t = t.substr(0, t.length - e.length))),
        t && (this.hostname = t);
    });
  const ZA = Object.freeze(
      Object.defineProperty(
        { __proto__: null, decode: ki, encode: Vs, format: hp, parse: mp },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    Tb =
      /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
    Nb = /[\0-\x1F\x7F-\x9F]/,
    QA =
      /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/,
    gp =
      /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
    Ob = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,
    eS = Object.freeze(
      Object.defineProperty(
        { __proto__: null, Any: Tb, Cc: Nb, Cf: QA, P: gp, Z: Ob },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    tS = new Uint16Array(
      'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'
        .split("")
        .map((t) => t.charCodeAt(0))
    ),
    nS = new Uint16Array(
      "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢"
        .split("")
        .map((t) => t.charCodeAt(0))
    );
  var bp;
  const rS = new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
    ]),
    oS =
      (bp = String.fromCodePoint) !== null && bp !== void 0
        ? bp
        : function (t) {
            let e = "";
            return (
              t > 65535 &&
                ((t -= 65536),
                (e += String.fromCharCode(((t >>> 10) & 1023) | 55296)),
                (t = 56320 | (t & 1023))),
              (e += String.fromCharCode(t)),
              e
            );
          };
  function iS(t) {
    var e;
    return (t >= 55296 && t <= 57343) || t > 1114111
      ? 65533
      : (e = rS.get(t)) !== null && e !== void 0
      ? e
      : t;
  }
  var nt;
  (function (t) {
    (t[(t.NUM = 35)] = "NUM"),
      (t[(t.SEMI = 59)] = "SEMI"),
      (t[(t.EQUALS = 61)] = "EQUALS"),
      (t[(t.ZERO = 48)] = "ZERO"),
      (t[(t.NINE = 57)] = "NINE"),
      (t[(t.LOWER_A = 97)] = "LOWER_A"),
      (t[(t.LOWER_F = 102)] = "LOWER_F"),
      (t[(t.LOWER_X = 120)] = "LOWER_X"),
      (t[(t.LOWER_Z = 122)] = "LOWER_Z"),
      (t[(t.UPPER_A = 65)] = "UPPER_A"),
      (t[(t.UPPER_F = 70)] = "UPPER_F"),
      (t[(t.UPPER_Z = 90)] = "UPPER_Z");
  })(nt || (nt = {}));
  const sS = 32;
  var Jr;
  (function (t) {
    (t[(t.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
      (t[(t.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
      (t[(t.JUMP_TABLE = 127)] = "JUMP_TABLE");
  })(Jr || (Jr = {}));
  function yp(t) {
    return t >= nt.ZERO && t <= nt.NINE;
  }
  function aS(t) {
    return (
      (t >= nt.UPPER_A && t <= nt.UPPER_F) ||
      (t >= nt.LOWER_A && t <= nt.LOWER_F)
    );
  }
  function lS(t) {
    return (
      (t >= nt.UPPER_A && t <= nt.UPPER_Z) ||
      (t >= nt.LOWER_A && t <= nt.LOWER_Z) ||
      yp(t)
    );
  }
  function cS(t) {
    return t === nt.EQUALS || lS(t);
  }
  var rt;
  (function (t) {
    (t[(t.EntityStart = 0)] = "EntityStart"),
      (t[(t.NumericStart = 1)] = "NumericStart"),
      (t[(t.NumericDecimal = 2)] = "NumericDecimal"),
      (t[(t.NumericHex = 3)] = "NumericHex"),
      (t[(t.NamedEntity = 4)] = "NamedEntity");
  })(rt || (rt = {}));
  var Yr;
  (function (t) {
    (t[(t.Legacy = 0)] = "Legacy"),
      (t[(t.Strict = 1)] = "Strict"),
      (t[(t.Attribute = 2)] = "Attribute");
  })(Yr || (Yr = {}));
  class uS {
    constructor(e, n, r) {
      (this.decodeTree = e),
        (this.emitCodePoint = n),
        (this.errors = r),
        (this.state = rt.EntityStart),
        (this.consumed = 1),
        (this.result = 0),
        (this.treeIndex = 0),
        (this.excess = 1),
        (this.decodeMode = Yr.Strict);
    }
    startEntity(e) {
      (this.decodeMode = e),
        (this.state = rt.EntityStart),
        (this.result = 0),
        (this.treeIndex = 0),
        (this.excess = 1),
        (this.consumed = 1);
    }
    write(e, n) {
      switch (this.state) {
        case rt.EntityStart:
          return e.charCodeAt(n) === nt.NUM
            ? ((this.state = rt.NumericStart),
              (this.consumed += 1),
              this.stateNumericStart(e, n + 1))
            : ((this.state = rt.NamedEntity), this.stateNamedEntity(e, n));
        case rt.NumericStart:
          return this.stateNumericStart(e, n);
        case rt.NumericDecimal:
          return this.stateNumericDecimal(e, n);
        case rt.NumericHex:
          return this.stateNumericHex(e, n);
        case rt.NamedEntity:
          return this.stateNamedEntity(e, n);
      }
    }
    stateNumericStart(e, n) {
      return n >= e.length
        ? -1
        : (e.charCodeAt(n) | sS) === nt.LOWER_X
        ? ((this.state = rt.NumericHex),
          (this.consumed += 1),
          this.stateNumericHex(e, n + 1))
        : ((this.state = rt.NumericDecimal), this.stateNumericDecimal(e, n));
    }
    addToNumericResult(e, n, r, o) {
      if (n !== r) {
        const i = r - n;
        (this.result =
          this.result * Math.pow(o, i) + parseInt(e.substr(n, i), o)),
          (this.consumed += i);
      }
    }
    stateNumericHex(e, n) {
      const r = n;
      for (; n < e.length; ) {
        const o = e.charCodeAt(n);
        if (yp(o) || aS(o)) n += 1;
        else
          return (
            this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(o, 3)
          );
      }
      return this.addToNumericResult(e, r, n, 16), -1;
    }
    stateNumericDecimal(e, n) {
      const r = n;
      for (; n < e.length; ) {
        const o = e.charCodeAt(n);
        if (yp(o)) n += 1;
        else
          return (
            this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(o, 2)
          );
      }
      return this.addToNumericResult(e, r, n, 10), -1;
    }
    emitNumericEntity(e, n) {
      var r;
      if (this.consumed <= n)
        return (
          (r = this.errors) === null ||
            r === void 0 ||
            r.absenceOfDigitsInNumericCharacterReference(this.consumed),
          0
        );
      if (e === nt.SEMI) this.consumed += 1;
      else if (this.decodeMode === Yr.Strict) return 0;
      return (
        this.emitCodePoint(iS(this.result), this.consumed),
        this.errors &&
          (e !== nt.SEMI &&
            this.errors.missingSemicolonAfterCharacterReference(),
          this.errors.validateNumericCharacterReference(this.result)),
        this.consumed
      );
    }
    stateNamedEntity(e, n) {
      const { decodeTree: r } = this;
      let o = r[this.treeIndex],
        i = (o & Jr.VALUE_LENGTH) >> 14;
      for (; n < e.length; n++, this.excess++) {
        const s = e.charCodeAt(n);
        if (
          ((this.treeIndex = dS(r, o, this.treeIndex + Math.max(1, i), s)),
          this.treeIndex < 0)
        )
          return this.result === 0 ||
            (this.decodeMode === Yr.Attribute && (i === 0 || cS(s)))
            ? 0
            : this.emitNotTerminatedNamedEntity();
        if (
          ((o = r[this.treeIndex]), (i = (o & Jr.VALUE_LENGTH) >> 14), i !== 0)
        ) {
          if (s === nt.SEMI)
            return this.emitNamedEntityData(
              this.treeIndex,
              i,
              this.consumed + this.excess
            );
          this.decodeMode !== Yr.Strict &&
            ((this.result = this.treeIndex),
            (this.consumed += this.excess),
            (this.excess = 0));
        }
      }
      return -1;
    }
    emitNotTerminatedNamedEntity() {
      var e;
      const { result: n, decodeTree: r } = this,
        o = (r[n] & Jr.VALUE_LENGTH) >> 14;
      return (
        this.emitNamedEntityData(n, o, this.consumed),
        (e = this.errors) === null ||
          e === void 0 ||
          e.missingSemicolonAfterCharacterReference(),
        this.consumed
      );
    }
    emitNamedEntityData(e, n, r) {
      const { decodeTree: o } = this;
      return (
        this.emitCodePoint(n === 1 ? o[e] & ~Jr.VALUE_LENGTH : o[e + 1], r),
        n === 3 && this.emitCodePoint(o[e + 2], r),
        r
      );
    }
    end() {
      var e;
      switch (this.state) {
        case rt.NamedEntity:
          return this.result !== 0 &&
            (this.decodeMode !== Yr.Attribute || this.result === this.treeIndex)
            ? this.emitNotTerminatedNamedEntity()
            : 0;
        case rt.NumericDecimal:
          return this.emitNumericEntity(0, 2);
        case rt.NumericHex:
          return this.emitNumericEntity(0, 3);
        case rt.NumericStart:
          return (
            (e = this.errors) === null ||
              e === void 0 ||
              e.absenceOfDigitsInNumericCharacterReference(this.consumed),
            0
          );
        case rt.EntityStart:
          return 0;
      }
    }
  }
  function Rb(t) {
    let e = "";
    const n = new uS(t, (r) => (e += oS(r)));
    return function (o, i) {
      let s = 0,
        a = 0;
      for (; (a = o.indexOf("&", a)) >= 0; ) {
        (e += o.slice(s, a)), n.startEntity(i);
        const c = n.write(o, a + 1);
        if (c < 0) {
          s = a + n.end();
          break;
        }
        (s = a + c), (a = c === 0 ? s + 1 : s);
      }
      const l = e + o.slice(s);
      return (e = ""), l;
    };
  }
  function dS(t, e, n, r) {
    const o = (e & Jr.BRANCH_LENGTH) >> 7,
      i = e & Jr.JUMP_TABLE;
    if (o === 0) return i !== 0 && r === i ? n : -1;
    if (i) {
      const l = r - i;
      return l < 0 || l >= o ? -1 : t[n + l] - 1;
    }
    let s = n,
      a = s + o - 1;
    for (; s <= a; ) {
      const l = (s + a) >>> 1,
        c = t[l];
      if (c < r) s = l + 1;
      else if (c > r) a = l - 1;
      else return t[l + o];
    }
    return -1;
  }
  const fS = Rb(tS);
  Rb(nS);
  function Db(t, e = Yr.Legacy) {
    return fS(t, e);
  }
  function pS(t) {
    return Object.prototype.toString.call(t);
  }
  function _p(t) {
    return pS(t) === "[object String]";
  }
  const hS = Object.prototype.hasOwnProperty;
  function mS(t, e) {
    return hS.call(t, e);
  }
  function Ql(t) {
    return (
      Array.prototype.slice.call(arguments, 1).forEach(function (n) {
        if (n) {
          if (typeof n != "object") throw new TypeError(n + "must be object");
          Object.keys(n).forEach(function (r) {
            t[r] = n[r];
          });
        }
      }),
      t
    );
  }
  function Lb(t, e, n) {
    return [].concat(t.slice(0, e), n, t.slice(e + 1));
  }
  function kp(t) {
    return !(
      (t >= 55296 && t <= 57343) ||
      (t >= 64976 && t <= 65007) ||
      (t & 65535) === 65535 ||
      (t & 65535) === 65534 ||
      (t >= 0 && t <= 8) ||
      t === 11 ||
      (t >= 14 && t <= 31) ||
      (t >= 127 && t <= 159) ||
      t > 1114111
    );
  }
  function ec(t) {
    if (t > 65535) {
      t -= 65536;
      const e = 55296 + (t >> 10),
        n = 56320 + (t & 1023);
      return String.fromCharCode(e, n);
    }
    return String.fromCharCode(t);
  }
  const Ib = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g,
    gS = /&([a-z#][a-z0-9]{1,31});/gi,
    bS = new RegExp(Ib.source + "|" + gS.source, "gi"),
    yS = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
  function _S(t, e) {
    if (e.charCodeAt(0) === 35 && yS.test(e)) {
      const r =
        e[1].toLowerCase() === "x"
          ? parseInt(e.slice(2), 16)
          : parseInt(e.slice(1), 10);
      return kp(r) ? ec(r) : t;
    }
    const n = Db(t);
    return n !== t ? n : t;
  }
  function kS(t) {
    return t.indexOf("\\") < 0 ? t : t.replace(Ib, "$1");
  }
  function Us(t) {
    return t.indexOf("\\") < 0 && t.indexOf("&") < 0
      ? t
      : t.replace(bS, function (e, n, r) {
          return n || _S(e, r);
        });
  }
  const wS = /[&<>"]/,
    xS = /[&<>"]/g,
    CS = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
  function vS(t) {
    return CS[t];
  }
  function Xr(t) {
    return wS.test(t) ? t.replace(xS, vS) : t;
  }
  const ES = /[.?*+^$[\]\\(){}|-]/g;
  function AS(t) {
    return t.replace(ES, "\\$&");
  }
  function Re(t) {
    switch (t) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function js(t) {
    if (t >= 8192 && t <= 8202) return !0;
    switch (t) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  function Ws(t) {
    return gp.test(t);
  }
  function qs(t) {
    switch (t) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function tc(t) {
    return (
      (t = t.trim().replace(/\s+/g, " ")),
      "ẞ".toLowerCase() === "Ṿ" && (t = t.replace(/ẞ/g, "ß")),
      t.toLowerCase().toUpperCase()
    );
  }
  const SS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        arrayReplaceAt: Lb,
        assign: Ql,
        escapeHtml: Xr,
        escapeRE: AS,
        fromCodePoint: ec,
        has: mS,
        isMdAsciiPunct: qs,
        isPunctChar: Ws,
        isSpace: Re,
        isString: _p,
        isValidEntityCode: kp,
        isWhiteSpace: js,
        lib: { mdurl: ZA, ucmicro: eS },
        normalizeReference: tc,
        unescapeAll: Us,
        unescapeMd: kS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  function MS(t, e, n) {
    let r, o, i, s;
    const a = t.posMax,
      l = t.pos;
    for (t.pos = e + 1, r = 1; t.pos < a; ) {
      if (((i = t.src.charCodeAt(t.pos)), i === 93 && (r--, r === 0))) {
        o = !0;
        break;
      }
      if (((s = t.pos), t.md.inline.skipToken(t), i === 91)) {
        if (s === t.pos - 1) r++;
        else if (n) return (t.pos = l), -1;
      }
    }
    let c = -1;
    return o && (c = t.pos), (t.pos = l), c;
  }
  function TS(t, e, n) {
    let r,
      o = e;
    const i = { ok: !1, pos: 0, lines: 0, str: "" };
    if (t.charCodeAt(o) === 60) {
      for (o++; o < n; ) {
        if (((r = t.charCodeAt(o)), r === 10 || r === 60)) return i;
        if (r === 62)
          return (
            (i.pos = o + 1), (i.str = Us(t.slice(e + 1, o))), (i.ok = !0), i
          );
        if (r === 92 && o + 1 < n) {
          o += 2;
          continue;
        }
        o++;
      }
      return i;
    }
    let s = 0;
    for (
      ;
      o < n && ((r = t.charCodeAt(o)), !(r === 32 || r < 32 || r === 127));

    ) {
      if (r === 92 && o + 1 < n) {
        if (t.charCodeAt(o + 1) === 32) break;
        o += 2;
        continue;
      }
      if (r === 40 && (s++, s > 32)) return i;
      if (r === 41) {
        if (s === 0) break;
        s--;
      }
      o++;
    }
    return (
      e === o ||
        s !== 0 ||
        ((i.str = Us(t.slice(e, o))), (i.pos = o), (i.ok = !0)),
      i
    );
  }
  function NS(t, e, n) {
    let r,
      o,
      i = 0,
      s = e;
    const a = { ok: !1, pos: 0, lines: 0, str: "" };
    if (s >= n || ((o = t.charCodeAt(s)), o !== 34 && o !== 39 && o !== 40))
      return a;
    for (s++, o === 40 && (o = 41); s < n; ) {
      if (((r = t.charCodeAt(s)), r === o))
        return (
          (a.pos = s + 1),
          (a.lines = i),
          (a.str = Us(t.slice(e + 1, s))),
          (a.ok = !0),
          a
        );
      if (r === 40 && o === 41) return a;
      r === 10
        ? i++
        : r === 92 && s + 1 < n && (s++, t.charCodeAt(s) === 10 && i++),
        s++;
    }
    return a;
  }
  const OS = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          parseLinkDestination: TS,
          parseLinkLabel: MS,
          parseLinkTitle: NS,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    Un = {};
  (Un.code_inline = function (t, e, n, r, o) {
    const i = t[e];
    return "<code" + o.renderAttrs(i) + ">" + Xr(i.content) + "</code>";
  }),
    (Un.code_block = function (t, e, n, r, o) {
      const i = t[e];
      return (
        "<pre" +
        o.renderAttrs(i) +
        "><code>" +
        Xr(t[e].content) +
        `</code></pre>
`
      );
    }),
    (Un.fence = function (t, e, n, r, o) {
      const i = t[e],
        s = i.info ? Us(i.info).trim() : "";
      let a = "",
        l = "";
      if (s) {
        const d = s.split(/(\s+)/g);
        (a = d[0]), (l = d.slice(2).join(""));
      }
      let c;
      if (
        (n.highlight
          ? (c = n.highlight(i.content, a, l) || Xr(i.content))
          : (c = Xr(i.content)),
        c.indexOf("<pre") === 0)
      )
        return (
          c +
          `
`
        );
      if (s) {
        const d = i.attrIndex("class"),
          f = i.attrs ? i.attrs.slice() : [];
        d < 0
          ? f.push(["class", n.langPrefix + a])
          : ((f[d] = f[d].slice()), (f[d][1] += " " + n.langPrefix + a));
        const p = { attrs: f };
        return `<pre><code${o.renderAttrs(p)}>${c}</code></pre>
`;
      }
      return `<pre><code${o.renderAttrs(i)}>${c}</code></pre>
`;
    }),
    (Un.image = function (t, e, n, r, o) {
      const i = t[e];
      return (
        (i.attrs[i.attrIndex("alt")][1] = o.renderInlineAsText(
          i.children,
          n,
          r
        )),
        o.renderToken(t, e, n)
      );
    }),
    (Un.hardbreak = function (t, e, n) {
      return n.xhtmlOut
        ? `<br />
`
        : `<br>
`;
    }),
    (Un.softbreak = function (t, e, n) {
      return n.breaks
        ? n.xhtmlOut
          ? `<br />
`
          : `<br>
`
        : `
`;
    }),
    (Un.text = function (t, e) {
      return Xr(t[e].content);
    }),
    (Un.html_block = function (t, e) {
      return t[e].content;
    }),
    (Un.html_inline = function (t, e) {
      return t[e].content;
    });
  function wi() {
    this.rules = Ql({}, Un);
  }
  (wi.prototype.renderAttrs = function (e) {
    let n, r, o;
    if (!e.attrs) return "";
    for (o = "", n = 0, r = e.attrs.length; n < r; n++)
      o += " " + Xr(e.attrs[n][0]) + '="' + Xr(e.attrs[n][1]) + '"';
    return o;
  }),
    (wi.prototype.renderToken = function (e, n, r) {
      const o = e[n];
      let i = "";
      if (o.hidden) return "";
      o.block &&
        o.nesting !== -1 &&
        n &&
        e[n - 1].hidden &&
        (i += `
`),
        (i += (o.nesting === -1 ? "</" : "<") + o.tag),
        (i += this.renderAttrs(o)),
        o.nesting === 0 && r.xhtmlOut && (i += " /");
      let s = !1;
      if (o.block && ((s = !0), o.nesting === 1 && n + 1 < e.length)) {
        const a = e[n + 1];
        (a.type === "inline" ||
          a.hidden ||
          (a.nesting === -1 && a.tag === o.tag)) &&
          (s = !1);
      }
      return (
        (i += s
          ? `>
`
          : ">"),
        i
      );
    }),
    (wi.prototype.renderInline = function (t, e, n) {
      let r = "";
      const o = this.rules;
      for (let i = 0, s = t.length; i < s; i++) {
        const a = t[i].type;
        typeof o[a] < "u"
          ? (r += o[a](t, i, e, n, this))
          : (r += this.renderToken(t, i, e));
      }
      return r;
    }),
    (wi.prototype.renderInlineAsText = function (t, e, n) {
      let r = "";
      for (let o = 0, i = t.length; o < i; o++)
        switch (t[o].type) {
          case "text":
            r += t[o].content;
            break;
          case "image":
            r += this.renderInlineAsText(t[o].children, e, n);
            break;
          case "html_inline":
          case "html_block":
            r += t[o].content;
            break;
          case "softbreak":
          case "hardbreak":
            r += `
`;
            break;
        }
      return r;
    }),
    (wi.prototype.render = function (t, e, n) {
      let r = "";
      const o = this.rules;
      for (let i = 0, s = t.length; i < s; i++) {
        const a = t[i].type;
        a === "inline"
          ? (r += this.renderInline(t[i].children, e, n))
          : typeof o[a] < "u"
          ? (r += o[a](t, i, e, n, this))
          : (r += this.renderToken(t, i, e, n));
      }
      return r;
    });
  function Lt() {
    (this.__rules__ = []), (this.__cache__ = null);
  }
  (Lt.prototype.__find__ = function (t) {
    for (let e = 0; e < this.__rules__.length; e++)
      if (this.__rules__[e].name === t) return e;
    return -1;
  }),
    (Lt.prototype.__compile__ = function () {
      const t = this,
        e = [""];
      t.__rules__.forEach(function (n) {
        n.enabled &&
          n.alt.forEach(function (r) {
            e.indexOf(r) < 0 && e.push(r);
          });
      }),
        (t.__cache__ = {}),
        e.forEach(function (n) {
          (t.__cache__[n] = []),
            t.__rules__.forEach(function (r) {
              r.enabled &&
                ((n && r.alt.indexOf(n) < 0) || t.__cache__[n].push(r.fn));
            });
        });
    }),
    (Lt.prototype.at = function (t, e, n) {
      const r = this.__find__(t),
        o = n || {};
      if (r === -1) throw new Error("Parser rule not found: " + t);
      (this.__rules__[r].fn = e),
        (this.__rules__[r].alt = o.alt || []),
        (this.__cache__ = null);
    }),
    (Lt.prototype.before = function (t, e, n, r) {
      const o = this.__find__(t),
        i = r || {};
      if (o === -1) throw new Error("Parser rule not found: " + t);
      this.__rules__.splice(o, 0, {
        name: e,
        enabled: !0,
        fn: n,
        alt: i.alt || [],
      }),
        (this.__cache__ = null);
    }),
    (Lt.prototype.after = function (t, e, n, r) {
      const o = this.__find__(t),
        i = r || {};
      if (o === -1) throw new Error("Parser rule not found: " + t);
      this.__rules__.splice(o + 1, 0, {
        name: e,
        enabled: !0,
        fn: n,
        alt: i.alt || [],
      }),
        (this.__cache__ = null);
    }),
    (Lt.prototype.push = function (t, e, n) {
      const r = n || {};
      this.__rules__.push({ name: t, enabled: !0, fn: e, alt: r.alt || [] }),
        (this.__cache__ = null);
    }),
    (Lt.prototype.enable = function (t, e) {
      Array.isArray(t) || (t = [t]);
      const n = [];
      return (
        t.forEach(function (r) {
          const o = this.__find__(r);
          if (o < 0) {
            if (e) return;
            throw new Error("Rules manager: invalid rule name " + r);
          }
          (this.__rules__[o].enabled = !0), n.push(r);
        }, this),
        (this.__cache__ = null),
        n
      );
    }),
    (Lt.prototype.enableOnly = function (t, e) {
      Array.isArray(t) || (t = [t]),
        this.__rules__.forEach(function (n) {
          n.enabled = !1;
        }),
        this.enable(t, e);
    }),
    (Lt.prototype.disable = function (t, e) {
      Array.isArray(t) || (t = [t]);
      const n = [];
      return (
        t.forEach(function (r) {
          const o = this.__find__(r);
          if (o < 0) {
            if (e) return;
            throw new Error("Rules manager: invalid rule name " + r);
          }
          (this.__rules__[o].enabled = !1), n.push(r);
        }, this),
        (this.__cache__ = null),
        n
      );
    }),
    (Lt.prototype.getRules = function (t) {
      return (
        this.__cache__ === null && this.__compile__(), this.__cache__[t] || []
      );
    });
  function Tn(t, e, n) {
    (this.type = t),
      (this.tag = e),
      (this.attrs = null),
      (this.map = null),
      (this.nesting = n),
      (this.level = 0),
      (this.children = null),
      (this.content = ""),
      (this.markup = ""),
      (this.info = ""),
      (this.meta = null),
      (this.block = !1),
      (this.hidden = !1);
  }
  (Tn.prototype.attrIndex = function (e) {
    if (!this.attrs) return -1;
    const n = this.attrs;
    for (let r = 0, o = n.length; r < o; r++) if (n[r][0] === e) return r;
    return -1;
  }),
    (Tn.prototype.attrPush = function (e) {
      this.attrs ? this.attrs.push(e) : (this.attrs = [e]);
    }),
    (Tn.prototype.attrSet = function (e, n) {
      const r = this.attrIndex(e),
        o = [e, n];
      r < 0 ? this.attrPush(o) : (this.attrs[r] = o);
    }),
    (Tn.prototype.attrGet = function (e) {
      const n = this.attrIndex(e);
      let r = null;
      return n >= 0 && (r = this.attrs[n][1]), r;
    }),
    (Tn.prototype.attrJoin = function (e, n) {
      const r = this.attrIndex(e);
      r < 0
        ? this.attrPush([e, n])
        : (this.attrs[r][1] = this.attrs[r][1] + " " + n);
    });
  function Bb(t, e, n) {
    (this.src = t),
      (this.env = n),
      (this.tokens = []),
      (this.inlineMode = !1),
      (this.md = e);
  }
  Bb.prototype.Token = Tn;
  const RS = /\r\n?|\n/g,
    DS = /\0/g;
  function LS(t) {
    let e;
    (e = t.src.replace(
      RS,
      `
`
    )),
      (e = e.replace(DS, "�")),
      (t.src = e);
  }
  function IS(t) {
    let e;
    t.inlineMode
      ? ((e = new t.Token("inline", "", 0)),
        (e.content = t.src),
        (e.map = [0, 1]),
        (e.children = []),
        t.tokens.push(e))
      : t.md.block.parse(t.src, t.md, t.env, t.tokens);
  }
  function BS(t) {
    const e = t.tokens;
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n];
      o.type === "inline" &&
        t.md.inline.parse(o.content, t.md, t.env, o.children);
    }
  }
  function PS(t) {
    return /^<a[>\s]/i.test(t);
  }
  function $S(t) {
    return /^<\/a\s*>/i.test(t);
  }
  function FS(t) {
    const e = t.tokens;
    if (t.md.options.linkify)
      for (let n = 0, r = e.length; n < r; n++) {
        if (e[n].type !== "inline" || !t.md.linkify.pretest(e[n].content))
          continue;
        let o = e[n].children,
          i = 0;
        for (let s = o.length - 1; s >= 0; s--) {
          const a = o[s];
          if (a.type === "link_close") {
            for (s--; o[s].level !== a.level && o[s].type !== "link_open"; )
              s--;
            continue;
          }
          if (
            (a.type === "html_inline" &&
              (PS(a.content) && i > 0 && i--, $S(a.content) && i++),
            !(i > 0) && a.type === "text" && t.md.linkify.test(a.content))
          ) {
            const l = a.content;
            let c = t.md.linkify.match(l);
            const d = [];
            let f = a.level,
              p = 0;
            c.length > 0 &&
              c[0].index === 0 &&
              s > 0 &&
              o[s - 1].type === "text_special" &&
              (c = c.slice(1));
            for (let h = 0; h < c.length; h++) {
              const m = c[h].url,
                g = t.md.normalizeLink(m);
              if (!t.md.validateLink(g)) continue;
              let b = c[h].text;
              c[h].schema
                ? c[h].schema === "mailto:" && !/^mailto:/i.test(b)
                  ? (b = t.md
                      .normalizeLinkText("mailto:" + b)
                      .replace(/^mailto:/, ""))
                  : (b = t.md.normalizeLinkText(b))
                : (b = t.md
                    .normalizeLinkText("http://" + b)
                    .replace(/^http:\/\//, ""));
              const y = c[h].index;
              if (y > p) {
                const v = new t.Token("text", "", 0);
                (v.content = l.slice(p, y)), (v.level = f), d.push(v);
              }
              const x = new t.Token("link_open", "a", 1);
              (x.attrs = [["href", g]]),
                (x.level = f++),
                (x.markup = "linkify"),
                (x.info = "auto"),
                d.push(x);
              const w = new t.Token("text", "", 0);
              (w.content = b), (w.level = f), d.push(w);
              const _ = new t.Token("link_close", "a", -1);
              (_.level = --f),
                (_.markup = "linkify"),
                (_.info = "auto"),
                d.push(_),
                (p = c[h].lastIndex);
            }
            if (p < l.length) {
              const h = new t.Token("text", "", 0);
              (h.content = l.slice(p)), (h.level = f), d.push(h);
            }
            e[n].children = o = Lb(o, s, d);
          }
        }
      }
  }
  const Pb = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
    HS = /\((c|tm|r)\)/i,
    zS = /\((c|tm|r)\)/gi,
    VS = { c: "©", r: "®", tm: "™" };
  function US(t, e) {
    return VS[e.toLowerCase()];
  }
  function jS(t) {
    let e = 0;
    for (let n = t.length - 1; n >= 0; n--) {
      const r = t[n];
      r.type === "text" && !e && (r.content = r.content.replace(zS, US)),
        r.type === "link_open" && r.info === "auto" && e--,
        r.type === "link_close" && r.info === "auto" && e++;
    }
  }
  function WS(t) {
    let e = 0;
    for (let n = t.length - 1; n >= 0; n--) {
      const r = t[n];
      r.type === "text" &&
        !e &&
        Pb.test(r.content) &&
        (r.content = r.content
          .replace(/\+-/g, "±")
          .replace(/\.{2,}/g, "…")
          .replace(/([?!])…/g, "$1..")
          .replace(/([?!]){4,}/g, "$1$1$1")
          .replace(/,{2,}/g, ",")
          .replace(/(^|[^-])---(?=[^-]|$)/gm, "$1—")
          .replace(/(^|\s)--(?=\s|$)/gm, "$1–")
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, "$1–")),
        r.type === "link_open" && r.info === "auto" && e--,
        r.type === "link_close" && r.info === "auto" && e++;
    }
  }
  function qS(t) {
    let e;
    if (t.md.options.typographer)
      for (e = t.tokens.length - 1; e >= 0; e--)
        t.tokens[e].type === "inline" &&
          (HS.test(t.tokens[e].content) && jS(t.tokens[e].children),
          Pb.test(t.tokens[e].content) && WS(t.tokens[e].children));
  }
  const KS = /['"]/,
    $b = /['"]/g,
    Fb = "’";
  function nc(t, e, n) {
    return t.slice(0, e) + n + t.slice(e + 1);
  }
  function GS(t, e) {
    let n;
    const r = [];
    for (let o = 0; o < t.length; o++) {
      const i = t[o],
        s = t[o].level;
      for (n = r.length - 1; n >= 0 && !(r[n].level <= s); n--);
      if (((r.length = n + 1), i.type !== "text")) continue;
      let a = i.content,
        l = 0,
        c = a.length;
      e: for (; l < c; ) {
        $b.lastIndex = l;
        const d = $b.exec(a);
        if (!d) break;
        let f = !0,
          p = !0;
        l = d.index + 1;
        const h = d[0] === "'";
        let m = 32;
        if (d.index - 1 >= 0) m = a.charCodeAt(d.index - 1);
        else
          for (
            n = o - 1;
            n >= 0 && !(t[n].type === "softbreak" || t[n].type === "hardbreak");
            n--
          )
            if (t[n].content) {
              m = t[n].content.charCodeAt(t[n].content.length - 1);
              break;
            }
        let g = 32;
        if (l < c) g = a.charCodeAt(l);
        else
          for (
            n = o + 1;
            n < t.length &&
            !(t[n].type === "softbreak" || t[n].type === "hardbreak");
            n++
          )
            if (t[n].content) {
              g = t[n].content.charCodeAt(0);
              break;
            }
        const b = qs(m) || Ws(String.fromCharCode(m)),
          y = qs(g) || Ws(String.fromCharCode(g)),
          x = js(m),
          w = js(g);
        if (
          (w ? (f = !1) : y && (x || b || (f = !1)),
          x ? (p = !1) : b && (w || y || (p = !1)),
          g === 34 && d[0] === '"' && m >= 48 && m <= 57 && (p = f = !1),
          f && p && ((f = b), (p = y)),
          !f && !p)
        ) {
          h && (i.content = nc(i.content, d.index, Fb));
          continue;
        }
        if (p)
          for (n = r.length - 1; n >= 0; n--) {
            let _ = r[n];
            if (r[n].level < s) break;
            if (_.single === h && r[n].level === s) {
              _ = r[n];
              let v, C;
              h
                ? ((v = e.md.options.quotes[2]), (C = e.md.options.quotes[3]))
                : ((v = e.md.options.quotes[0]), (C = e.md.options.quotes[1])),
                (i.content = nc(i.content, d.index, C)),
                (t[_.token].content = nc(t[_.token].content, _.pos, v)),
                (l += C.length - 1),
                _.token === o && (l += v.length - 1),
                (a = i.content),
                (c = a.length),
                (r.length = n);
              continue e;
            }
          }
        f
          ? r.push({ token: o, pos: d.index, single: h, level: s })
          : p && h && (i.content = nc(i.content, d.index, Fb));
      }
    }
  }
  function JS(t) {
    if (t.md.options.typographer)
      for (let e = t.tokens.length - 1; e >= 0; e--)
        t.tokens[e].type !== "inline" ||
          !KS.test(t.tokens[e].content) ||
          GS(t.tokens[e].children, t);
  }
  function YS(t) {
    let e, n;
    const r = t.tokens,
      o = r.length;
    for (let i = 0; i < o; i++) {
      if (r[i].type !== "inline") continue;
      const s = r[i].children,
        a = s.length;
      for (e = 0; e < a; e++)
        s[e].type === "text_special" && (s[e].type = "text");
      for (e = n = 0; e < a; e++)
        s[e].type === "text" && e + 1 < a && s[e + 1].type === "text"
          ? (s[e + 1].content = s[e].content + s[e + 1].content)
          : (e !== n && (s[n] = s[e]), n++);
      e !== n && (s.length = n);
    }
  }
  const wp = [
    ["normalize", LS],
    ["block", IS],
    ["inline", BS],
    ["linkify", FS],
    ["replacements", qS],
    ["smartquotes", JS],
    ["text_join", YS],
  ];
  function xp() {
    this.ruler = new Lt();
    for (let t = 0; t < wp.length; t++) this.ruler.push(wp[t][0], wp[t][1]);
  }
  (xp.prototype.process = function (t) {
    const e = this.ruler.getRules("");
    for (let n = 0, r = e.length; n < r; n++) e[n](t);
  }),
    (xp.prototype.State = Bb);
  function jn(t, e, n, r) {
    (this.src = t),
      (this.md = e),
      (this.env = n),
      (this.tokens = r),
      (this.bMarks = []),
      (this.eMarks = []),
      (this.tShift = []),
      (this.sCount = []),
      (this.bsCount = []),
      (this.blkIndent = 0),
      (this.line = 0),
      (this.lineMax = 0),
      (this.tight = !1),
      (this.ddIndent = -1),
      (this.listIndent = -1),
      (this.parentType = "root"),
      (this.level = 0);
    const o = this.src;
    for (let i = 0, s = 0, a = 0, l = 0, c = o.length, d = !1; s < c; s++) {
      const f = o.charCodeAt(s);
      if (!d)
        if (Re(f)) {
          a++, f === 9 ? (l += 4 - (l % 4)) : l++;
          continue;
        } else d = !0;
      (f === 10 || s === c - 1) &&
        (f !== 10 && s++,
        this.bMarks.push(i),
        this.eMarks.push(s),
        this.tShift.push(a),
        this.sCount.push(l),
        this.bsCount.push(0),
        (d = !1),
        (a = 0),
        (l = 0),
        (i = s + 1));
    }
    this.bMarks.push(o.length),
      this.eMarks.push(o.length),
      this.tShift.push(0),
      this.sCount.push(0),
      this.bsCount.push(0),
      (this.lineMax = this.bMarks.length - 1);
  }
  (jn.prototype.push = function (t, e, n) {
    const r = new Tn(t, e, n);
    return (
      (r.block = !0),
      n < 0 && this.level--,
      (r.level = this.level),
      n > 0 && this.level++,
      this.tokens.push(r),
      r
    );
  }),
    (jn.prototype.isEmpty = function (e) {
      return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
    }),
    (jn.prototype.skipEmptyLines = function (e) {
      for (
        let n = this.lineMax;
        e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]);
        e++
      );
      return e;
    }),
    (jn.prototype.skipSpaces = function (e) {
      for (let n = this.src.length; e < n; e++) {
        const r = this.src.charCodeAt(e);
        if (!Re(r)) break;
      }
      return e;
    }),
    (jn.prototype.skipSpacesBack = function (e, n) {
      if (e <= n) return e;
      for (; e > n; ) if (!Re(this.src.charCodeAt(--e))) return e + 1;
      return e;
    }),
    (jn.prototype.skipChars = function (e, n) {
      for (let r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++);
      return e;
    }),
    (jn.prototype.skipCharsBack = function (e, n, r) {
      if (e <= r) return e;
      for (; e > r; ) if (n !== this.src.charCodeAt(--e)) return e + 1;
      return e;
    }),
    (jn.prototype.getLines = function (e, n, r, o) {
      if (e >= n) return "";
      const i = new Array(n - e);
      for (let s = 0, a = e; a < n; a++, s++) {
        let l = 0;
        const c = this.bMarks[a];
        let d = c,
          f;
        for (
          a + 1 < n || o ? (f = this.eMarks[a] + 1) : (f = this.eMarks[a]);
          d < f && l < r;

        ) {
          const p = this.src.charCodeAt(d);
          if (Re(p)) p === 9 ? (l += 4 - ((l + this.bsCount[a]) % 4)) : l++;
          else if (d - c < this.tShift[a]) l++;
          else break;
          d++;
        }
        l > r
          ? (i[s] = new Array(l - r + 1).join(" ") + this.src.slice(d, f))
          : (i[s] = this.src.slice(d, f));
      }
      return i.join("");
    }),
    (jn.prototype.Token = Tn);
  function Cp(t, e) {
    const n = t.bMarks[e] + t.tShift[e],
      r = t.eMarks[e];
    return t.src.slice(n, r);
  }
  function Hb(t) {
    const e = [],
      n = t.length;
    let r = 0,
      o = t.charCodeAt(r),
      i = !1,
      s = 0,
      a = "";
    for (; r < n; )
      o === 124 &&
        (i
          ? ((a += t.substring(s, r - 1)), (s = r))
          : (e.push(a + t.substring(s, r)), (a = ""), (s = r + 1))),
        (i = o === 92),
        r++,
        (o = t.charCodeAt(r));
    return e.push(a + t.substring(s)), e;
  }
  function XS(t, e, n, r) {
    if (e + 2 > n) return !1;
    let o = e + 1;
    if (t.sCount[o] < t.blkIndent || t.sCount[o] - t.blkIndent >= 4) return !1;
    let i = t.bMarks[o] + t.tShift[o];
    if (i >= t.eMarks[o]) return !1;
    const s = t.src.charCodeAt(i++);
    if ((s !== 124 && s !== 45 && s !== 58) || i >= t.eMarks[o]) return !1;
    const a = t.src.charCodeAt(i++);
    if ((a !== 124 && a !== 45 && a !== 58 && !Re(a)) || (s === 45 && Re(a)))
      return !1;
    for (; i < t.eMarks[o]; ) {
      const w = t.src.charCodeAt(i);
      if (w !== 124 && w !== 45 && w !== 58 && !Re(w)) return !1;
      i++;
    }
    let l = Cp(t, e + 1),
      c = l.split("|");
    const d = [];
    for (let w = 0; w < c.length; w++) {
      const _ = c[w].trim();
      if (!_) {
        if (w === 0 || w === c.length - 1) continue;
        return !1;
      }
      if (!/^:?-+:?$/.test(_)) return !1;
      _.charCodeAt(_.length - 1) === 58
        ? d.push(_.charCodeAt(0) === 58 ? "center" : "right")
        : _.charCodeAt(0) === 58
        ? d.push("left")
        : d.push("");
    }
    if (
      ((l = Cp(t, e).trim()),
      l.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
    )
      return !1;
    (c = Hb(l)),
      c.length && c[0] === "" && c.shift(),
      c.length && c[c.length - 1] === "" && c.pop();
    const f = c.length;
    if (f === 0 || f !== d.length) return !1;
    if (r) return !0;
    const p = t.parentType;
    t.parentType = "table";
    const h = t.md.block.ruler.getRules("blockquote"),
      m = t.push("table_open", "table", 1),
      g = [e, 0];
    m.map = g;
    const b = t.push("thead_open", "thead", 1);
    b.map = [e, e + 1];
    const y = t.push("tr_open", "tr", 1);
    y.map = [e, e + 1];
    for (let w = 0; w < c.length; w++) {
      const _ = t.push("th_open", "th", 1);
      d[w] && (_.attrs = [["style", "text-align:" + d[w]]]);
      const v = t.push("inline", "", 0);
      (v.content = c[w].trim()),
        (v.children = []),
        t.push("th_close", "th", -1);
    }
    t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
    let x;
    for (o = e + 2; o < n && !(t.sCount[o] < t.blkIndent); o++) {
      let w = !1;
      for (let v = 0, C = h.length; v < C; v++)
        if (h[v](t, o, n, !0)) {
          w = !0;
          break;
        }
      if (w || ((l = Cp(t, o).trim()), !l) || t.sCount[o] - t.blkIndent >= 4)
        break;
      if (
        ((c = Hb(l)),
        c.length && c[0] === "" && c.shift(),
        c.length && c[c.length - 1] === "" && c.pop(),
        o === e + 2)
      ) {
        const v = t.push("tbody_open", "tbody", 1);
        v.map = x = [e + 2, 0];
      }
      const _ = t.push("tr_open", "tr", 1);
      _.map = [o, o + 1];
      for (let v = 0; v < f; v++) {
        const C = t.push("td_open", "td", 1);
        d[v] && (C.attrs = [["style", "text-align:" + d[v]]]);
        const S = t.push("inline", "", 0);
        (S.content = c[v] ? c[v].trim() : ""),
          (S.children = []),
          t.push("td_close", "td", -1);
      }
      t.push("tr_close", "tr", -1);
    }
    return (
      x && (t.push("tbody_close", "tbody", -1), (x[1] = o)),
      t.push("table_close", "table", -1),
      (g[1] = o),
      (t.parentType = p),
      (t.line = o),
      !0
    );
  }
  function ZS(t, e, n) {
    if (t.sCount[e] - t.blkIndent < 4) return !1;
    let r = e + 1,
      o = r;
    for (; r < n; ) {
      if (t.isEmpty(r)) {
        r++;
        continue;
      }
      if (t.sCount[r] - t.blkIndent >= 4) {
        r++, (o = r);
        continue;
      }
      break;
    }
    t.line = o;
    const i = t.push("code_block", "code", 0);
    return (
      (i.content =
        t.getLines(e, o, 4 + t.blkIndent, !1) +
        `
`),
      (i.map = [e, t.line]),
      !0
    );
  }
  function QS(t, e, n, r) {
    let o = t.bMarks[e] + t.tShift[e],
      i = t.eMarks[e];
    if (t.sCount[e] - t.blkIndent >= 4 || o + 3 > i) return !1;
    const s = t.src.charCodeAt(o);
    if (s !== 126 && s !== 96) return !1;
    let a = o;
    o = t.skipChars(o, s);
    let l = o - a;
    if (l < 3) return !1;
    const c = t.src.slice(a, o),
      d = t.src.slice(o, i);
    if (s === 96 && d.indexOf(String.fromCharCode(s)) >= 0) return !1;
    if (r) return !0;
    let f = e,
      p = !1;
    for (
      ;
      f++,
        !(
          f >= n ||
          ((o = a = t.bMarks[f] + t.tShift[f]),
          (i = t.eMarks[f]),
          o < i && t.sCount[f] < t.blkIndent)
        );

    )
      if (
        t.src.charCodeAt(o) === s &&
        !(t.sCount[f] - t.blkIndent >= 4) &&
        ((o = t.skipChars(o, s)),
        !(o - a < l) && ((o = t.skipSpaces(o)), !(o < i)))
      ) {
        p = !0;
        break;
      }
    (l = t.sCount[e]), (t.line = f + (p ? 1 : 0));
    const h = t.push("fence", "code", 0);
    return (
      (h.info = d),
      (h.content = t.getLines(e + 1, f, l, !0)),
      (h.markup = c),
      (h.map = [e, t.line]),
      !0
    );
  }
  function eM(t, e, n, r) {
    let o = t.bMarks[e] + t.tShift[e],
      i = t.eMarks[e];
    const s = t.lineMax;
    if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(o) !== 62) return !1;
    if (r) return !0;
    const a = [],
      l = [],
      c = [],
      d = [],
      f = t.md.block.ruler.getRules("blockquote"),
      p = t.parentType;
    t.parentType = "blockquote";
    let h = !1,
      m;
    for (m = e; m < n; m++) {
      const w = t.sCount[m] < t.blkIndent;
      if (((o = t.bMarks[m] + t.tShift[m]), (i = t.eMarks[m]), o >= i)) break;
      if (t.src.charCodeAt(o++) === 62 && !w) {
        let v = t.sCount[m] + 1,
          C,
          S;
        t.src.charCodeAt(o) === 32
          ? (o++, v++, (S = !1), (C = !0))
          : t.src.charCodeAt(o) === 9
          ? ((C = !0),
            (t.bsCount[m] + v) % 4 === 3 ? (o++, v++, (S = !1)) : (S = !0))
          : (C = !1);
        let N = v;
        for (a.push(t.bMarks[m]), t.bMarks[m] = o; o < i; ) {
          const M = t.src.charCodeAt(o);
          if (Re(M))
            M === 9 ? (N += 4 - ((N + t.bsCount[m] + (S ? 1 : 0)) % 4)) : N++;
          else break;
          o++;
        }
        (h = o >= i),
          l.push(t.bsCount[m]),
          (t.bsCount[m] = t.sCount[m] + 1 + (C ? 1 : 0)),
          c.push(t.sCount[m]),
          (t.sCount[m] = N - v),
          d.push(t.tShift[m]),
          (t.tShift[m] = o - t.bMarks[m]);
        continue;
      }
      if (h) break;
      let _ = !1;
      for (let v = 0, C = f.length; v < C; v++)
        if (f[v](t, m, n, !0)) {
          _ = !0;
          break;
        }
      if (_) {
        (t.lineMax = m),
          t.blkIndent !== 0 &&
            (a.push(t.bMarks[m]),
            l.push(t.bsCount[m]),
            d.push(t.tShift[m]),
            c.push(t.sCount[m]),
            (t.sCount[m] -= t.blkIndent));
        break;
      }
      a.push(t.bMarks[m]),
        l.push(t.bsCount[m]),
        d.push(t.tShift[m]),
        c.push(t.sCount[m]),
        (t.sCount[m] = -1);
    }
    const g = t.blkIndent;
    t.blkIndent = 0;
    const b = t.push("blockquote_open", "blockquote", 1);
    b.markup = ">";
    const y = [e, 0];
    (b.map = y), t.md.block.tokenize(t, e, m);
    const x = t.push("blockquote_close", "blockquote", -1);
    (x.markup = ">"), (t.lineMax = s), (t.parentType = p), (y[1] = t.line);
    for (let w = 0; w < d.length; w++)
      (t.bMarks[w + e] = a[w]),
        (t.tShift[w + e] = d[w]),
        (t.sCount[w + e] = c[w]),
        (t.bsCount[w + e] = l[w]);
    return (t.blkIndent = g), !0;
  }
  function tM(t, e, n, r) {
    const o = t.eMarks[e];
    if (t.sCount[e] - t.blkIndent >= 4) return !1;
    let i = t.bMarks[e] + t.tShift[e];
    const s = t.src.charCodeAt(i++);
    if (s !== 42 && s !== 45 && s !== 95) return !1;
    let a = 1;
    for (; i < o; ) {
      const c = t.src.charCodeAt(i++);
      if (c !== s && !Re(c)) return !1;
      c === s && a++;
    }
    if (a < 3) return !1;
    if (r) return !0;
    t.line = e + 1;
    const l = t.push("hr", "hr", 0);
    return (
      (l.map = [e, t.line]),
      (l.markup = Array(a + 1).join(String.fromCharCode(s))),
      !0
    );
  }
  function zb(t, e) {
    const n = t.eMarks[e];
    let r = t.bMarks[e] + t.tShift[e];
    const o = t.src.charCodeAt(r++);
    if (o !== 42 && o !== 45 && o !== 43) return -1;
    if (r < n) {
      const i = t.src.charCodeAt(r);
      if (!Re(i)) return -1;
    }
    return r;
  }
  function Vb(t, e) {
    const n = t.bMarks[e] + t.tShift[e],
      r = t.eMarks[e];
    let o = n;
    if (o + 1 >= r) return -1;
    let i = t.src.charCodeAt(o++);
    if (i < 48 || i > 57) return -1;
    for (;;) {
      if (o >= r) return -1;
      if (((i = t.src.charCodeAt(o++)), i >= 48 && i <= 57)) {
        if (o - n >= 10) return -1;
        continue;
      }
      if (i === 41 || i === 46) break;
      return -1;
    }
    return o < r && ((i = t.src.charCodeAt(o)), !Re(i)) ? -1 : o;
  }
  function nM(t, e) {
    const n = t.level + 2;
    for (let r = e + 2, o = t.tokens.length - 2; r < o; r++)
      t.tokens[r].level === n &&
        t.tokens[r].type === "paragraph_open" &&
        ((t.tokens[r + 2].hidden = !0), (t.tokens[r].hidden = !0), (r += 2));
  }
  function rM(t, e, n, r) {
    let o,
      i,
      s,
      a,
      l = e,
      c = !0;
    if (
      t.sCount[l] - t.blkIndent >= 4 ||
      (t.listIndent >= 0 &&
        t.sCount[l] - t.listIndent >= 4 &&
        t.sCount[l] < t.blkIndent)
    )
      return !1;
    let d = !1;
    r && t.parentType === "paragraph" && t.sCount[l] >= t.blkIndent && (d = !0);
    let f, p, h;
    if ((h = Vb(t, l)) >= 0) {
      if (
        ((f = !0),
        (s = t.bMarks[l] + t.tShift[l]),
        (p = Number(t.src.slice(s, h - 1))),
        d && p !== 1)
      )
        return !1;
    } else if ((h = zb(t, l)) >= 0) f = !1;
    else return !1;
    if (d && t.skipSpaces(h) >= t.eMarks[l]) return !1;
    if (r) return !0;
    const m = t.src.charCodeAt(h - 1),
      g = t.tokens.length;
    f
      ? ((a = t.push("ordered_list_open", "ol", 1)),
        p !== 1 && (a.attrs = [["start", p]]))
      : (a = t.push("bullet_list_open", "ul", 1));
    const b = [l, 0];
    (a.map = b), (a.markup = String.fromCharCode(m));
    let y = !1;
    const x = t.md.block.ruler.getRules("list"),
      w = t.parentType;
    for (t.parentType = "list"; l < n; ) {
      (i = h), (o = t.eMarks[l]);
      const _ = t.sCount[l] + h - (t.bMarks[l] + t.tShift[l]);
      let v = _;
      for (; i < o; ) {
        const X = t.src.charCodeAt(i);
        if (X === 9) v += 4 - ((v + t.bsCount[l]) % 4);
        else if (X === 32) v++;
        else break;
        i++;
      }
      const C = i;
      let S;
      C >= o ? (S = 1) : (S = v - _), S > 4 && (S = 1);
      const N = _ + S;
      (a = t.push("list_item_open", "li", 1)),
        (a.markup = String.fromCharCode(m));
      const M = [l, 0];
      (a.map = M), f && (a.info = t.src.slice(s, h - 1));
      const L = t.tight,
        $ = t.tShift[l],
        B = t.sCount[l],
        H = t.listIndent;
      if (
        ((t.listIndent = t.blkIndent),
        (t.blkIndent = N),
        (t.tight = !0),
        (t.tShift[l] = C - t.bMarks[l]),
        (t.sCount[l] = v),
        C >= o && t.isEmpty(l + 1)
          ? (t.line = Math.min(t.line + 2, n))
          : t.md.block.tokenize(t, l, n, !0),
        (!t.tight || y) && (c = !1),
        (y = t.line - l > 1 && t.isEmpty(t.line - 1)),
        (t.blkIndent = t.listIndent),
        (t.listIndent = H),
        (t.tShift[l] = $),
        (t.sCount[l] = B),
        (t.tight = L),
        (a = t.push("list_item_close", "li", -1)),
        (a.markup = String.fromCharCode(m)),
        (l = t.line),
        (M[1] = l),
        l >= n || t.sCount[l] < t.blkIndent || t.sCount[l] - t.blkIndent >= 4)
      )
        break;
      let Q = !1;
      for (let X = 0, Y = x.length; X < Y; X++)
        if (x[X](t, l, n, !0)) {
          Q = !0;
          break;
        }
      if (Q) break;
      if (f) {
        if (((h = Vb(t, l)), h < 0)) break;
        s = t.bMarks[l] + t.tShift[l];
      } else if (((h = zb(t, l)), h < 0)) break;
      if (m !== t.src.charCodeAt(h - 1)) break;
    }
    return (
      f
        ? (a = t.push("ordered_list_close", "ol", -1))
        : (a = t.push("bullet_list_close", "ul", -1)),
      (a.markup = String.fromCharCode(m)),
      (b[1] = l),
      (t.line = l),
      (t.parentType = w),
      c && nM(t, g),
      !0
    );
  }
  function oM(t, e, n, r) {
    let o = 0,
      i = t.bMarks[e] + t.tShift[e],
      s = t.eMarks[e],
      a = e + 1;
    if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 91) return !1;
    for (; ++i < s; )
      if (t.src.charCodeAt(i) === 93 && t.src.charCodeAt(i - 1) !== 92) {
        if (i + 1 === s || t.src.charCodeAt(i + 1) !== 58) return !1;
        break;
      }
    const l = t.lineMax,
      c = t.md.block.ruler.getRules("reference"),
      d = t.parentType;
    for (t.parentType = "reference"; a < l && !t.isEmpty(a); a++) {
      if (t.sCount[a] - t.blkIndent > 3 || t.sCount[a] < 0) continue;
      let v = !1;
      for (let C = 0, S = c.length; C < S; C++)
        if (c[C](t, a, l, !0)) {
          v = !0;
          break;
        }
      if (v) break;
    }
    const f = t.getLines(e, a, t.blkIndent, !1).trim();
    s = f.length;
    let p = -1;
    for (i = 1; i < s; i++) {
      const v = f.charCodeAt(i);
      if (v === 91) return !1;
      if (v === 93) {
        p = i;
        break;
      } else
        v === 10
          ? o++
          : v === 92 && (i++, i < s && f.charCodeAt(i) === 10 && o++);
    }
    if (p < 0 || f.charCodeAt(p + 1) !== 58) return !1;
    for (i = p + 2; i < s; i++) {
      const v = f.charCodeAt(i);
      if (v === 10) o++;
      else if (!Re(v)) break;
    }
    const h = t.md.helpers.parseLinkDestination(f, i, s);
    if (!h.ok) return !1;
    const m = t.md.normalizeLink(h.str);
    if (!t.md.validateLink(m)) return !1;
    (i = h.pos), (o += h.lines);
    const g = i,
      b = o,
      y = i;
    for (; i < s; i++) {
      const v = f.charCodeAt(i);
      if (v === 10) o++;
      else if (!Re(v)) break;
    }
    const x = t.md.helpers.parseLinkTitle(f, i, s);
    let w;
    for (
      i < s && y !== i && x.ok
        ? ((w = x.str), (i = x.pos), (o += x.lines))
        : ((w = ""), (i = g), (o = b));
      i < s;

    ) {
      const v = f.charCodeAt(i);
      if (!Re(v)) break;
      i++;
    }
    if (i < s && f.charCodeAt(i) !== 10 && w)
      for (w = "", i = g, o = b; i < s; ) {
        const v = f.charCodeAt(i);
        if (!Re(v)) break;
        i++;
      }
    if (i < s && f.charCodeAt(i) !== 10) return !1;
    const _ = tc(f.slice(1, p));
    return _
      ? (r ||
          (typeof t.env.references > "u" && (t.env.references = {}),
          typeof t.env.references[_] > "u" &&
            (t.env.references[_] = { title: w, href: m }),
          (t.parentType = d),
          (t.line = e + o + 1)),
        !0)
      : !1;
  }
  const iM = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul",
    ],
    sM = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
    aM =
      "(?:" +
      "[^\"'=<>`\\x00-\\x20]+" +
      "|" +
      "'[^']*'" +
      "|" +
      '"[^"]*"' +
      ")",
    Ub =
      "<[A-Za-z][A-Za-z0-9\\-]*" +
      ("(?:\\s+" + sM + "(?:\\s*=\\s*" + aM + ")?)") +
      "*\\s*\\/?>",
    jb = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
    lM = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->",
    cM = "<[?][\\s\\S]*?[?]>",
    uM = "<![A-Z]+\\s+[^>]*>",
    dM = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    fM = new RegExp(
      "^(?:" + Ub + "|" + jb + "|" + lM + "|" + cM + "|" + uM + "|" + dM + ")"
    ),
    pM = new RegExp("^(?:" + Ub + "|" + jb + ")"),
    xi = [
      [
        /^<(script|pre|style|textarea)(?=(\s|>|$))/i,
        /<\/(script|pre|style|textarea)>/i,
        !0,
      ],
      [/^<!--/, /-->/, !0],
      [/^<\?/, /\?>/, !0],
      [/^<![A-Z]/, />/, !0],
      [/^<!\[CDATA\[/, /\]\]>/, !0],
      [new RegExp("^</?(" + iM.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
      [new RegExp(pM.source + "\\s*$"), /^$/, !1],
    ];
  function hM(t, e, n, r) {
    let o = t.bMarks[e] + t.tShift[e],
      i = t.eMarks[e];
    if (
      t.sCount[e] - t.blkIndent >= 4 ||
      !t.md.options.html ||
      t.src.charCodeAt(o) !== 60
    )
      return !1;
    let s = t.src.slice(o, i),
      a = 0;
    for (; a < xi.length && !xi[a][0].test(s); a++);
    if (a === xi.length) return !1;
    if (r) return xi[a][2];
    let l = e + 1;
    if (!xi[a][1].test(s)) {
      for (; l < n && !(t.sCount[l] < t.blkIndent); l++)
        if (
          ((o = t.bMarks[l] + t.tShift[l]),
          (i = t.eMarks[l]),
          (s = t.src.slice(o, i)),
          xi[a][1].test(s))
        ) {
          s.length !== 0 && l++;
          break;
        }
    }
    t.line = l;
    const c = t.push("html_block", "", 0);
    return (
      (c.map = [e, l]), (c.content = t.getLines(e, l, t.blkIndent, !0)), !0
    );
  }
  function mM(t, e, n, r) {
    let o = t.bMarks[e] + t.tShift[e],
      i = t.eMarks[e];
    if (t.sCount[e] - t.blkIndent >= 4) return !1;
    let s = t.src.charCodeAt(o);
    if (s !== 35 || o >= i) return !1;
    let a = 1;
    for (s = t.src.charCodeAt(++o); s === 35 && o < i && a <= 6; )
      a++, (s = t.src.charCodeAt(++o));
    if (a > 6 || (o < i && !Re(s))) return !1;
    if (r) return !0;
    i = t.skipSpacesBack(i, o);
    const l = t.skipCharsBack(i, 35, o);
    l > o && Re(t.src.charCodeAt(l - 1)) && (i = l), (t.line = e + 1);
    const c = t.push("heading_open", "h" + String(a), 1);
    (c.markup = "########".slice(0, a)), (c.map = [e, t.line]);
    const d = t.push("inline", "", 0);
    (d.content = t.src.slice(o, i).trim()),
      (d.map = [e, t.line]),
      (d.children = []);
    const f = t.push("heading_close", "h" + String(a), -1);
    return (f.markup = "########".slice(0, a)), !0;
  }
  function gM(t, e, n) {
    const r = t.md.block.ruler.getRules("paragraph");
    if (t.sCount[e] - t.blkIndent >= 4) return !1;
    const o = t.parentType;
    t.parentType = "paragraph";
    let i = 0,
      s,
      a = e + 1;
    for (; a < n && !t.isEmpty(a); a++) {
      if (t.sCount[a] - t.blkIndent > 3) continue;
      if (t.sCount[a] >= t.blkIndent) {
        let h = t.bMarks[a] + t.tShift[a];
        const m = t.eMarks[a];
        if (
          h < m &&
          ((s = t.src.charCodeAt(h)),
          (s === 45 || s === 61) &&
            ((h = t.skipChars(h, s)), (h = t.skipSpaces(h)), h >= m))
        ) {
          i = s === 61 ? 1 : 2;
          break;
        }
      }
      if (t.sCount[a] < 0) continue;
      let p = !1;
      for (let h = 0, m = r.length; h < m; h++)
        if (r[h](t, a, n, !0)) {
          p = !0;
          break;
        }
      if (p) break;
    }
    if (!i) return !1;
    const l = t.getLines(e, a, t.blkIndent, !1).trim();
    t.line = a + 1;
    const c = t.push("heading_open", "h" + String(i), 1);
    (c.markup = String.fromCharCode(s)), (c.map = [e, t.line]);
    const d = t.push("inline", "", 0);
    (d.content = l), (d.map = [e, t.line - 1]), (d.children = []);
    const f = t.push("heading_close", "h" + String(i), -1);
    return (f.markup = String.fromCharCode(s)), (t.parentType = o), !0;
  }
  function bM(t, e, n) {
    const r = t.md.block.ruler.getRules("paragraph"),
      o = t.parentType;
    let i = e + 1;
    for (t.parentType = "paragraph"; i < n && !t.isEmpty(i); i++) {
      if (t.sCount[i] - t.blkIndent > 3 || t.sCount[i] < 0) continue;
      let c = !1;
      for (let d = 0, f = r.length; d < f; d++)
        if (r[d](t, i, n, !0)) {
          c = !0;
          break;
        }
      if (c) break;
    }
    const s = t.getLines(e, i, t.blkIndent, !1).trim();
    t.line = i;
    const a = t.push("paragraph_open", "p", 1);
    a.map = [e, t.line];
    const l = t.push("inline", "", 0);
    return (
      (l.content = s),
      (l.map = [e, t.line]),
      (l.children = []),
      t.push("paragraph_close", "p", -1),
      (t.parentType = o),
      !0
    );
  }
  const rc = [
    ["table", XS, ["paragraph", "reference"]],
    ["code", ZS],
    ["fence", QS, ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", eM, ["paragraph", "reference", "blockquote", "list"]],
    ["hr", tM, ["paragraph", "reference", "blockquote", "list"]],
    ["list", rM, ["paragraph", "reference", "blockquote"]],
    ["reference", oM],
    ["html_block", hM, ["paragraph", "reference", "blockquote"]],
    ["heading", mM, ["paragraph", "reference", "blockquote"]],
    ["lheading", gM],
    ["paragraph", bM],
  ];
  function oc() {
    this.ruler = new Lt();
    for (let t = 0; t < rc.length; t++)
      this.ruler.push(rc[t][0], rc[t][1], { alt: (rc[t][2] || []).slice() });
  }
  (oc.prototype.tokenize = function (t, e, n) {
    const r = this.ruler.getRules(""),
      o = r.length,
      i = t.md.options.maxNesting;
    let s = e,
      a = !1;
    for (
      ;
      s < n &&
      ((t.line = s = t.skipEmptyLines(s)),
      !(s >= n || t.sCount[s] < t.blkIndent));

    ) {
      if (t.level >= i) {
        t.line = n;
        break;
      }
      const l = t.line;
      let c = !1;
      for (let d = 0; d < o; d++)
        if (((c = r[d](t, s, n, !1)), c)) {
          if (l >= t.line)
            throw new Error("block rule didn't increment state.line");
          break;
        }
      if (!c) throw new Error("none of the block rules matched");
      (t.tight = !a),
        t.isEmpty(t.line - 1) && (a = !0),
        (s = t.line),
        s < n && t.isEmpty(s) && ((a = !0), s++, (t.line = s));
    }
  }),
    (oc.prototype.parse = function (t, e, n, r) {
      if (!t) return;
      const o = new this.State(t, e, n, r);
      this.tokenize(o, o.line, o.lineMax);
    }),
    (oc.prototype.State = jn);
  function Ks(t, e, n, r) {
    (this.src = t),
      (this.env = n),
      (this.md = e),
      (this.tokens = r),
      (this.tokens_meta = Array(r.length)),
      (this.pos = 0),
      (this.posMax = this.src.length),
      (this.level = 0),
      (this.pending = ""),
      (this.pendingLevel = 0),
      (this.cache = {}),
      (this.delimiters = []),
      (this._prev_delimiters = []),
      (this.backticks = {}),
      (this.backticksScanned = !1),
      (this.linkLevel = 0);
  }
  (Ks.prototype.pushPending = function () {
    const t = new Tn("text", "", 0);
    return (
      (t.content = this.pending),
      (t.level = this.pendingLevel),
      this.tokens.push(t),
      (this.pending = ""),
      t
    );
  }),
    (Ks.prototype.push = function (t, e, n) {
      this.pending && this.pushPending();
      const r = new Tn(t, e, n);
      let o = null;
      return (
        n < 0 &&
          (this.level--, (this.delimiters = this._prev_delimiters.pop())),
        (r.level = this.level),
        n > 0 &&
          (this.level++,
          this._prev_delimiters.push(this.delimiters),
          (this.delimiters = []),
          (o = { delimiters: this.delimiters })),
        (this.pendingLevel = this.level),
        this.tokens.push(r),
        this.tokens_meta.push(o),
        r
      );
    }),
    (Ks.prototype.scanDelims = function (t, e) {
      let n,
        r,
        o = !0,
        i = !0;
      const s = this.posMax,
        a = this.src.charCodeAt(t),
        l = t > 0 ? this.src.charCodeAt(t - 1) : 32;
      let c = t;
      for (; c < s && this.src.charCodeAt(c) === a; ) c++;
      const d = c - t,
        f = c < s ? this.src.charCodeAt(c) : 32,
        p = qs(l) || Ws(String.fromCharCode(l)),
        h = qs(f) || Ws(String.fromCharCode(f)),
        m = js(l),
        g = js(f);
      return (
        g ? (o = !1) : h && (m || p || (o = !1)),
        m ? (i = !1) : p && (g || h || (i = !1)),
        e ? ((n = o), (r = i)) : ((n = o && (!i || p)), (r = i && (!o || h))),
        { can_open: n, can_close: r, length: d }
      );
    }),
    (Ks.prototype.Token = Tn);
  function yM(t) {
    switch (t) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function _M(t, e) {
    let n = t.pos;
    for (; n < t.posMax && !yM(t.src.charCodeAt(n)); ) n++;
    return n === t.pos
      ? !1
      : (e || (t.pending += t.src.slice(t.pos, n)), (t.pos = n), !0);
  }
  const kM = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  function wM(t, e) {
    if (!t.md.options.linkify || t.linkLevel > 0) return !1;
    const n = t.pos,
      r = t.posMax;
    if (
      n + 3 > r ||
      t.src.charCodeAt(n) !== 58 ||
      t.src.charCodeAt(n + 1) !== 47 ||
      t.src.charCodeAt(n + 2) !== 47
    )
      return !1;
    const o = t.pending.match(kM);
    if (!o) return !1;
    const i = o[1],
      s = t.md.linkify.matchAtStart(t.src.slice(n - i.length));
    if (!s) return !1;
    let a = s.url;
    if (a.length <= i.length) return !1;
    a = a.replace(/\*+$/, "");
    const l = t.md.normalizeLink(a);
    if (!t.md.validateLink(l)) return !1;
    if (!e) {
      t.pending = t.pending.slice(0, -i.length);
      const c = t.push("link_open", "a", 1);
      (c.attrs = [["href", l]]), (c.markup = "linkify"), (c.info = "auto");
      const d = t.push("text", "", 0);
      d.content = t.md.normalizeLinkText(a);
      const f = t.push("link_close", "a", -1);
      (f.markup = "linkify"), (f.info = "auto");
    }
    return (t.pos += a.length - i.length), !0;
  }
  function xM(t, e) {
    let n = t.pos;
    if (t.src.charCodeAt(n) !== 10) return !1;
    const r = t.pending.length - 1,
      o = t.posMax;
    if (!e)
      if (r >= 0 && t.pending.charCodeAt(r) === 32)
        if (r >= 1 && t.pending.charCodeAt(r - 1) === 32) {
          let i = r - 1;
          for (; i >= 1 && t.pending.charCodeAt(i - 1) === 32; ) i--;
          (t.pending = t.pending.slice(0, i)), t.push("hardbreak", "br", 0);
        } else
          (t.pending = t.pending.slice(0, -1)), t.push("softbreak", "br", 0);
      else t.push("softbreak", "br", 0);
    for (n++; n < o && Re(t.src.charCodeAt(n)); ) n++;
    return (t.pos = n), !0;
  }
  const vp = [];
  for (let t = 0; t < 256; t++) vp.push(0);
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function (t) {
    vp[t.charCodeAt(0)] = 1;
  });
  function CM(t, e) {
    let n = t.pos;
    const r = t.posMax;
    if (t.src.charCodeAt(n) !== 92 || (n++, n >= r)) return !1;
    let o = t.src.charCodeAt(n);
    if (o === 10) {
      for (
        e || t.push("hardbreak", "br", 0), n++;
        n < r && ((o = t.src.charCodeAt(n)), !!Re(o));

      )
        n++;
      return (t.pos = n), !0;
    }
    let i = t.src[n];
    if (o >= 55296 && o <= 56319 && n + 1 < r) {
      const a = t.src.charCodeAt(n + 1);
      a >= 56320 && a <= 57343 && ((i += t.src[n + 1]), n++);
    }
    const s = "\\" + i;
    if (!e) {
      const a = t.push("text_special", "", 0);
      o < 256 && vp[o] !== 0 ? (a.content = i) : (a.content = s),
        (a.markup = s),
        (a.info = "escape");
    }
    return (t.pos = n + 1), !0;
  }
  function vM(t, e) {
    let n = t.pos;
    if (t.src.charCodeAt(n) !== 96) return !1;
    const o = n;
    n++;
    const i = t.posMax;
    for (; n < i && t.src.charCodeAt(n) === 96; ) n++;
    const s = t.src.slice(o, n),
      a = s.length;
    if (t.backticksScanned && (t.backticks[a] || 0) <= o)
      return e || (t.pending += s), (t.pos += a), !0;
    let l = n,
      c;
    for (; (c = t.src.indexOf("`", l)) !== -1; ) {
      for (l = c + 1; l < i && t.src.charCodeAt(l) === 96; ) l++;
      const d = l - c;
      if (d === a) {
        if (!e) {
          const f = t.push("code_inline", "code", 0);
          (f.markup = s),
            (f.content = t.src
              .slice(n, c)
              .replace(/\n/g, " ")
              .replace(/^ (.+) $/, "$1"));
        }
        return (t.pos = l), !0;
      }
      t.backticks[d] = c;
    }
    return (t.backticksScanned = !0), e || (t.pending += s), (t.pos += a), !0;
  }
  function EM(t, e) {
    const n = t.pos,
      r = t.src.charCodeAt(n);
    if (e || r !== 126) return !1;
    const o = t.scanDelims(t.pos, !0);
    let i = o.length;
    const s = String.fromCharCode(r);
    if (i < 2) return !1;
    let a;
    i % 2 && ((a = t.push("text", "", 0)), (a.content = s), i--);
    for (let l = 0; l < i; l += 2)
      (a = t.push("text", "", 0)),
        (a.content = s + s),
        t.delimiters.push({
          marker: r,
          length: 0,
          token: t.tokens.length - 1,
          end: -1,
          open: o.can_open,
          close: o.can_close,
        });
    return (t.pos += o.length), !0;
  }
  function Wb(t, e) {
    let n;
    const r = [],
      o = e.length;
    for (let i = 0; i < o; i++) {
      const s = e[i];
      if (s.marker !== 126 || s.end === -1) continue;
      const a = e[s.end];
      (n = t.tokens[s.token]),
        (n.type = "s_open"),
        (n.tag = "s"),
        (n.nesting = 1),
        (n.markup = "~~"),
        (n.content = ""),
        (n = t.tokens[a.token]),
        (n.type = "s_close"),
        (n.tag = "s"),
        (n.nesting = -1),
        (n.markup = "~~"),
        (n.content = ""),
        t.tokens[a.token - 1].type === "text" &&
          t.tokens[a.token - 1].content === "~" &&
          r.push(a.token - 1);
    }
    for (; r.length; ) {
      const i = r.pop();
      let s = i + 1;
      for (; s < t.tokens.length && t.tokens[s].type === "s_close"; ) s++;
      s--,
        i !== s &&
          ((n = t.tokens[s]), (t.tokens[s] = t.tokens[i]), (t.tokens[i] = n));
    }
  }
  function AM(t) {
    const e = t.tokens_meta,
      n = t.tokens_meta.length;
    Wb(t, t.delimiters);
    for (let r = 0; r < n; r++)
      e[r] && e[r].delimiters && Wb(t, e[r].delimiters);
  }
  const qb = { tokenize: EM, postProcess: AM };
  function SM(t, e) {
    const n = t.pos,
      r = t.src.charCodeAt(n);
    if (e || (r !== 95 && r !== 42)) return !1;
    const o = t.scanDelims(t.pos, r === 42);
    for (let i = 0; i < o.length; i++) {
      const s = t.push("text", "", 0);
      (s.content = String.fromCharCode(r)),
        t.delimiters.push({
          marker: r,
          length: o.length,
          token: t.tokens.length - 1,
          end: -1,
          open: o.can_open,
          close: o.can_close,
        });
    }
    return (t.pos += o.length), !0;
  }
  function Kb(t, e) {
    const n = e.length;
    for (let r = n - 1; r >= 0; r--) {
      const o = e[r];
      if ((o.marker !== 95 && o.marker !== 42) || o.end === -1) continue;
      const i = e[o.end],
        s =
          r > 0 &&
          e[r - 1].end === o.end + 1 &&
          e[r - 1].marker === o.marker &&
          e[r - 1].token === o.token - 1 &&
          e[o.end + 1].token === i.token + 1,
        a = String.fromCharCode(o.marker),
        l = t.tokens[o.token];
      (l.type = s ? "strong_open" : "em_open"),
        (l.tag = s ? "strong" : "em"),
        (l.nesting = 1),
        (l.markup = s ? a + a : a),
        (l.content = "");
      const c = t.tokens[i.token];
      (c.type = s ? "strong_close" : "em_close"),
        (c.tag = s ? "strong" : "em"),
        (c.nesting = -1),
        (c.markup = s ? a + a : a),
        (c.content = ""),
        s &&
          ((t.tokens[e[r - 1].token].content = ""),
          (t.tokens[e[o.end + 1].token].content = ""),
          r--);
    }
  }
  function MM(t) {
    const e = t.tokens_meta,
      n = t.tokens_meta.length;
    Kb(t, t.delimiters);
    for (let r = 0; r < n; r++)
      e[r] && e[r].delimiters && Kb(t, e[r].delimiters);
  }
  const Gb = { tokenize: SM, postProcess: MM };
  function TM(t, e) {
    let n,
      r,
      o,
      i,
      s = "",
      a = "",
      l = t.pos,
      c = !0;
    if (t.src.charCodeAt(t.pos) !== 91) return !1;
    const d = t.pos,
      f = t.posMax,
      p = t.pos + 1,
      h = t.md.helpers.parseLinkLabel(t, t.pos, !0);
    if (h < 0) return !1;
    let m = h + 1;
    if (m < f && t.src.charCodeAt(m) === 40) {
      for (
        c = !1, m++;
        m < f && ((n = t.src.charCodeAt(m)), !(!Re(n) && n !== 10));
        m++
      );
      if (m >= f) return !1;
      if (
        ((l = m),
        (o = t.md.helpers.parseLinkDestination(t.src, m, t.posMax)),
        o.ok)
      ) {
        for (
          s = t.md.normalizeLink(o.str),
            t.md.validateLink(s) ? (m = o.pos) : (s = ""),
            l = m;
          m < f && ((n = t.src.charCodeAt(m)), !(!Re(n) && n !== 10));
          m++
        );
        if (
          ((o = t.md.helpers.parseLinkTitle(t.src, m, t.posMax)),
          m < f && l !== m && o.ok)
        )
          for (
            a = o.str, m = o.pos;
            m < f && ((n = t.src.charCodeAt(m)), !(!Re(n) && n !== 10));
            m++
          );
      }
      (m >= f || t.src.charCodeAt(m) !== 41) && (c = !0), m++;
    }
    if (c) {
      if (typeof t.env.references > "u") return !1;
      if (
        (m < f && t.src.charCodeAt(m) === 91
          ? ((l = m + 1),
            (m = t.md.helpers.parseLinkLabel(t, m)),
            m >= 0 ? (r = t.src.slice(l, m++)) : (m = h + 1))
          : (m = h + 1),
        r || (r = t.src.slice(p, h)),
        (i = t.env.references[tc(r)]),
        !i)
      )
        return (t.pos = d), !1;
      (s = i.href), (a = i.title);
    }
    if (!e) {
      (t.pos = p), (t.posMax = h);
      const g = t.push("link_open", "a", 1),
        b = [["href", s]];
      (g.attrs = b),
        a && b.push(["title", a]),
        t.linkLevel++,
        t.md.inline.tokenize(t),
        t.linkLevel--,
        t.push("link_close", "a", -1);
    }
    return (t.pos = m), (t.posMax = f), !0;
  }
  function NM(t, e) {
    let n,
      r,
      o,
      i,
      s,
      a,
      l,
      c,
      d = "";
    const f = t.pos,
      p = t.posMax;
    if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
      return !1;
    const h = t.pos + 2,
      m = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
    if (m < 0) return !1;
    if (((i = m + 1), i < p && t.src.charCodeAt(i) === 40)) {
      for (
        i++;
        i < p && ((n = t.src.charCodeAt(i)), !(!Re(n) && n !== 10));
        i++
      );
      if (i >= p) return !1;
      for (
        c = i,
          a = t.md.helpers.parseLinkDestination(t.src, i, t.posMax),
          a.ok &&
            ((d = t.md.normalizeLink(a.str)),
            t.md.validateLink(d) ? (i = a.pos) : (d = "")),
          c = i;
        i < p && ((n = t.src.charCodeAt(i)), !(!Re(n) && n !== 10));
        i++
      );
      if (
        ((a = t.md.helpers.parseLinkTitle(t.src, i, t.posMax)),
        i < p && c !== i && a.ok)
      )
        for (
          l = a.str, i = a.pos;
          i < p && ((n = t.src.charCodeAt(i)), !(!Re(n) && n !== 10));
          i++
        );
      else l = "";
      if (i >= p || t.src.charCodeAt(i) !== 41) return (t.pos = f), !1;
      i++;
    } else {
      if (typeof t.env.references > "u") return !1;
      if (
        (i < p && t.src.charCodeAt(i) === 91
          ? ((c = i + 1),
            (i = t.md.helpers.parseLinkLabel(t, i)),
            i >= 0 ? (o = t.src.slice(c, i++)) : (i = m + 1))
          : (i = m + 1),
        o || (o = t.src.slice(h, m)),
        (s = t.env.references[tc(o)]),
        !s)
      )
        return (t.pos = f), !1;
      (d = s.href), (l = s.title);
    }
    if (!e) {
      r = t.src.slice(h, m);
      const g = [];
      t.md.inline.parse(r, t.md, t.env, g);
      const b = t.push("image", "img", 0),
        y = [
          ["src", d],
          ["alt", ""],
        ];
      (b.attrs = y),
        (b.children = g),
        (b.content = r),
        l && y.push(["title", l]);
    }
    return (t.pos = i), (t.posMax = p), !0;
  }
  const OM =
      /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,
    RM = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
  function DM(t, e) {
    let n = t.pos;
    if (t.src.charCodeAt(n) !== 60) return !1;
    const r = t.pos,
      o = t.posMax;
    for (;;) {
      if (++n >= o) return !1;
      const s = t.src.charCodeAt(n);
      if (s === 60) return !1;
      if (s === 62) break;
    }
    const i = t.src.slice(r + 1, n);
    if (RM.test(i)) {
      const s = t.md.normalizeLink(i);
      if (!t.md.validateLink(s)) return !1;
      if (!e) {
        const a = t.push("link_open", "a", 1);
        (a.attrs = [["href", s]]), (a.markup = "autolink"), (a.info = "auto");
        const l = t.push("text", "", 0);
        l.content = t.md.normalizeLinkText(i);
        const c = t.push("link_close", "a", -1);
        (c.markup = "autolink"), (c.info = "auto");
      }
      return (t.pos += i.length + 2), !0;
    }
    if (OM.test(i)) {
      const s = t.md.normalizeLink("mailto:" + i);
      if (!t.md.validateLink(s)) return !1;
      if (!e) {
        const a = t.push("link_open", "a", 1);
        (a.attrs = [["href", s]]), (a.markup = "autolink"), (a.info = "auto");
        const l = t.push("text", "", 0);
        l.content = t.md.normalizeLinkText(i);
        const c = t.push("link_close", "a", -1);
        (c.markup = "autolink"), (c.info = "auto");
      }
      return (t.pos += i.length + 2), !0;
    }
    return !1;
  }
  function LM(t) {
    return /^<a[>\s]/i.test(t);
  }
  function IM(t) {
    return /^<\/a\s*>/i.test(t);
  }
  function BM(t) {
    const e = t | 32;
    return e >= 97 && e <= 122;
  }
  function PM(t, e) {
    if (!t.md.options.html) return !1;
    const n = t.posMax,
      r = t.pos;
    if (t.src.charCodeAt(r) !== 60 || r + 2 >= n) return !1;
    const o = t.src.charCodeAt(r + 1);
    if (o !== 33 && o !== 63 && o !== 47 && !BM(o)) return !1;
    const i = t.src.slice(r).match(fM);
    if (!i) return !1;
    if (!e) {
      const s = t.push("html_inline", "", 0);
      (s.content = i[0]),
        LM(s.content) && t.linkLevel++,
        IM(s.content) && t.linkLevel--;
    }
    return (t.pos += i[0].length), !0;
  }
  const $M = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,
    FM = /^&([a-z][a-z0-9]{1,31});/i;
  function HM(t, e) {
    const n = t.pos,
      r = t.posMax;
    if (t.src.charCodeAt(n) !== 38 || n + 1 >= r) return !1;
    if (t.src.charCodeAt(n + 1) === 35) {
      const i = t.src.slice(n).match($M);
      if (i) {
        if (!e) {
          const s =
              i[1][0].toLowerCase() === "x"
                ? parseInt(i[1].slice(1), 16)
                : parseInt(i[1], 10),
            a = t.push("text_special", "", 0);
          (a.content = kp(s) ? ec(s) : ec(65533)),
            (a.markup = i[0]),
            (a.info = "entity");
        }
        return (t.pos += i[0].length), !0;
      }
    } else {
      const i = t.src.slice(n).match(FM);
      if (i) {
        const s = Db(i[0]);
        if (s !== i[0]) {
          if (!e) {
            const a = t.push("text_special", "", 0);
            (a.content = s), (a.markup = i[0]), (a.info = "entity");
          }
          return (t.pos += i[0].length), !0;
        }
      }
    }
    return !1;
  }
  function Jb(t) {
    const e = {},
      n = t.length;
    if (!n) return;
    let r = 0,
      o = -2;
    const i = [];
    for (let s = 0; s < n; s++) {
      const a = t[s];
      if (
        (i.push(0),
        (t[r].marker !== a.marker || o !== a.token - 1) && (r = s),
        (o = a.token),
        (a.length = a.length || 0),
        !a.close)
      )
        continue;
      e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
      const l = e[a.marker][(a.open ? 3 : 0) + (a.length % 3)];
      let c = r - i[r] - 1,
        d = c;
      for (; c > l; c -= i[c] + 1) {
        const f = t[c];
        if (f.marker === a.marker && f.open && f.end < 0) {
          let p = !1;
          if (
            ((f.close || a.open) &&
              (f.length + a.length) % 3 === 0 &&
              (f.length % 3 !== 0 || a.length % 3 !== 0) &&
              (p = !0),
            !p)
          ) {
            const h = c > 0 && !t[c - 1].open ? i[c - 1] + 1 : 0;
            (i[s] = s - c + h),
              (i[c] = h),
              (a.open = !1),
              (f.end = s),
              (f.close = !1),
              (d = -1),
              (o = -2);
            break;
          }
        }
      }
      d !== -1 && (e[a.marker][(a.open ? 3 : 0) + ((a.length || 0) % 3)] = d);
    }
  }
  function zM(t) {
    const e = t.tokens_meta,
      n = t.tokens_meta.length;
    Jb(t.delimiters);
    for (let r = 0; r < n; r++) e[r] && e[r].delimiters && Jb(e[r].delimiters);
  }
  function VM(t) {
    let e,
      n,
      r = 0;
    const o = t.tokens,
      i = t.tokens.length;
    for (e = n = 0; e < i; e++)
      o[e].nesting < 0 && r--,
        (o[e].level = r),
        o[e].nesting > 0 && r++,
        o[e].type === "text" && e + 1 < i && o[e + 1].type === "text"
          ? (o[e + 1].content = o[e].content + o[e + 1].content)
          : (e !== n && (o[n] = o[e]), n++);
    e !== n && (o.length = n);
  }
  const Ep = [
      ["text", _M],
      ["linkify", wM],
      ["newline", xM],
      ["escape", CM],
      ["backticks", vM],
      ["strikethrough", qb.tokenize],
      ["emphasis", Gb.tokenize],
      ["link", TM],
      ["image", NM],
      ["autolink", DM],
      ["html_inline", PM],
      ["entity", HM],
    ],
    Ap = [
      ["balance_pairs", zM],
      ["strikethrough", qb.postProcess],
      ["emphasis", Gb.postProcess],
      ["fragments_join", VM],
    ];
  function Gs() {
    this.ruler = new Lt();
    for (let t = 0; t < Ep.length; t++) this.ruler.push(Ep[t][0], Ep[t][1]);
    this.ruler2 = new Lt();
    for (let t = 0; t < Ap.length; t++) this.ruler2.push(Ap[t][0], Ap[t][1]);
  }
  (Gs.prototype.skipToken = function (t) {
    const e = t.pos,
      n = this.ruler.getRules(""),
      r = n.length,
      o = t.md.options.maxNesting,
      i = t.cache;
    if (typeof i[e] < "u") {
      t.pos = i[e];
      return;
    }
    let s = !1;
    if (t.level < o) {
      for (let a = 0; a < r; a++)
        if ((t.level++, (s = n[a](t, !0)), t.level--, s)) {
          if (e >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    } else t.pos = t.posMax;
    s || t.pos++, (i[e] = t.pos);
  }),
    (Gs.prototype.tokenize = function (t) {
      const e = this.ruler.getRules(""),
        n = e.length,
        r = t.posMax,
        o = t.md.options.maxNesting;
      for (; t.pos < r; ) {
        const i = t.pos;
        let s = !1;
        if (t.level < o) {
          for (let a = 0; a < n; a++)
            if (((s = e[a](t, !1)), s)) {
              if (i >= t.pos)
                throw new Error("inline rule didn't increment state.pos");
              break;
            }
        }
        if (s) {
          if (t.pos >= r) break;
          continue;
        }
        t.pending += t.src[t.pos++];
      }
      t.pending && t.pushPending();
    }),
    (Gs.prototype.parse = function (t, e, n, r) {
      const o = new this.State(t, e, n, r);
      this.tokenize(o);
      const i = this.ruler2.getRules(""),
        s = i.length;
      for (let a = 0; a < s; a++) i[a](o);
    }),
    (Gs.prototype.State = Ks);
  function UM(t) {
    const e = {};
    (t = t || {}),
      (e.src_Any = Tb.source),
      (e.src_Cc = Nb.source),
      (e.src_Z = Ob.source),
      (e.src_P = gp.source),
      (e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|")),
      (e.src_ZCc = [e.src_Z, e.src_Cc].join("|"));
    const n = "[><｜]";
    return (
      (e.src_pseudo_letter =
        "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")"),
      (e.src_ip4 =
        "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"),
      (e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?"),
      (e.src_port =
        "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?"),
      (e.src_host_terminator =
        "(?=$|" +
        n +
        "|" +
        e.src_ZPCc +
        ")(?!" +
        (t["---"] ? "-(?!--)|" : "-|") +
        "_|:\\d|\\.-|\\.(?!$|" +
        e.src_ZPCc +
        "))"),
      (e.src_path =
        "(?:[/?#](?:(?!" +
        e.src_ZCc +
        "|" +
        n +
        `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` +
        e.src_ZCc +
        "|\\]).)*\\]|\\((?:(?!" +
        e.src_ZCc +
        "|[)]).)*\\)|\\{(?:(?!" +
        e.src_ZCc +
        '|[}]).)*\\}|\\"(?:(?!' +
        e.src_ZCc +
        `|["]).)+\\"|\\'(?:(?!` +
        e.src_ZCc +
        "|[']).)+\\'|\\'(?=" +
        e.src_pseudo_letter +
        "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" +
        e.src_ZCc +
        "|[.]|$)|" +
        (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") +
        ",(?!" +
        e.src_ZCc +
        "|$)|;(?!" +
        e.src_ZCc +
        "|$)|\\!+(?!" +
        e.src_ZCc +
        "|[!]|$)|\\?(?!" +
        e.src_ZCc +
        "|[?]|$))+|\\/)?"),
      (e.src_email_name =
        '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*'),
      (e.src_xn = "xn--[a-z0-9\\-]{1,59}"),
      (e.src_domain_root =
        "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})"),
      (e.src_domain =
        "(?:" +
        e.src_xn +
        "|(?:" +
        e.src_pseudo_letter +
        ")|(?:" +
        e.src_pseudo_letter +
        "(?:-|" +
        e.src_pseudo_letter +
        "){0,61}" +
        e.src_pseudo_letter +
        "))"),
      (e.src_host =
        "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))"),
      (e.tpl_host_fuzzy =
        "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))"),
      (e.tpl_host_no_ip_fuzzy =
        "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))"),
      (e.src_host_strict = e.src_host + e.src_host_terminator),
      (e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator),
      (e.src_host_port_strict =
        e.src_host + e.src_port + e.src_host_terminator),
      (e.tpl_host_port_fuzzy_strict =
        e.tpl_host_fuzzy + e.src_port + e.src_host_terminator),
      (e.tpl_host_port_no_ip_fuzzy_strict =
        e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator),
      (e.tpl_host_fuzzy_test =
        "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" +
        e.src_ZPCc +
        "|>|$))"),
      (e.tpl_email_fuzzy =
        "(^|" +
        n +
        '|"|\\(|' +
        e.src_ZCc +
        ")(" +
        e.src_email_name +
        "@" +
        e.tpl_host_fuzzy_strict +
        ")"),
      (e.tpl_link_fuzzy =
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" +
        e.src_ZPCc +
        "))((?![$+<=>^`|｜])" +
        e.tpl_host_port_fuzzy_strict +
        e.src_path +
        ")"),
      (e.tpl_link_no_ip_fuzzy =
        "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" +
        e.src_ZPCc +
        "))((?![$+<=>^`|｜])" +
        e.tpl_host_port_no_ip_fuzzy_strict +
        e.src_path +
        ")"),
      e
    );
  }
  function Sp(t) {
    return (
      Array.prototype.slice.call(arguments, 1).forEach(function (n) {
        n &&
          Object.keys(n).forEach(function (r) {
            t[r] = n[r];
          });
      }),
      t
    );
  }
  function ic(t) {
    return Object.prototype.toString.call(t);
  }
  function jM(t) {
    return ic(t) === "[object String]";
  }
  function WM(t) {
    return ic(t) === "[object Object]";
  }
  function qM(t) {
    return ic(t) === "[object RegExp]";
  }
  function Yb(t) {
    return ic(t) === "[object Function]";
  }
  function KM(t) {
    return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  const Xb = { fuzzyLink: !0, fuzzyEmail: !0, fuzzyIP: !1 };
  function GM(t) {
    return Object.keys(t || {}).reduce(function (e, n) {
      return e || Xb.hasOwnProperty(n);
    }, !1);
  }
  const JM = {
      "http:": {
        validate: function (t, e, n) {
          const r = t.slice(e);
          return (
            n.re.http ||
              (n.re.http = new RegExp(
                "^\\/\\/" +
                  n.re.src_auth +
                  n.re.src_host_port_strict +
                  n.re.src_path,
                "i"
              )),
            n.re.http.test(r) ? r.match(n.re.http)[0].length : 0
          );
        },
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function (t, e, n) {
          const r = t.slice(e);
          return (
            n.re.no_http ||
              (n.re.no_http = new RegExp(
                "^" +
                  n.re.src_auth +
                  "(?:localhost|(?:(?:" +
                  n.re.src_domain +
                  ")\\.)+" +
                  n.re.src_domain_root +
                  ")" +
                  n.re.src_port +
                  n.re.src_host_terminator +
                  n.re.src_path,
                "i"
              )),
            n.re.no_http.test(r)
              ? (e >= 3 && t[e - 3] === ":") || (e >= 3 && t[e - 3] === "/")
                ? 0
                : r.match(n.re.no_http)[0].length
              : 0
          );
        },
      },
      "mailto:": {
        validate: function (t, e, n) {
          const r = t.slice(e);
          return (
            n.re.mailto ||
              (n.re.mailto = new RegExp(
                "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
                "i"
              )),
            n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0
          );
        },
      },
    },
    YM =
      "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
    XM =
      "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split(
        "|"
      );
  function ZM(t) {
    (t.__index__ = -1), (t.__text_cache__ = "");
  }
  function QM(t) {
    return function (e, n) {
      const r = e.slice(n);
      return t.test(r) ? r.match(t)[0].length : 0;
    };
  }
  function Zb() {
    return function (t, e) {
      e.normalize(t);
    };
  }
  function sc(t) {
    const e = (t.re = UM(t.__opts__)),
      n = t.__tlds__.slice();
    t.onCompile(),
      t.__tlds_replaced__ || n.push(YM),
      n.push(e.src_xn),
      (e.src_tlds = n.join("|"));
    function r(a) {
      return a.replace("%TLDS%", e.src_tlds);
    }
    (e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i")),
      (e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i")),
      (e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i")),
      (e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i"));
    const o = [];
    t.__compiled__ = {};
    function i(a, l) {
      throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
    }
    Object.keys(t.__schemas__).forEach(function (a) {
      const l = t.__schemas__[a];
      if (l === null) return;
      const c = { validate: null, link: null };
      if (((t.__compiled__[a] = c), WM(l))) {
        qM(l.validate)
          ? (c.validate = QM(l.validate))
          : Yb(l.validate)
          ? (c.validate = l.validate)
          : i(a, l),
          Yb(l.normalize)
            ? (c.normalize = l.normalize)
            : l.normalize
            ? i(a, l)
            : (c.normalize = Zb());
        return;
      }
      if (jM(l)) {
        o.push(a);
        return;
      }
      i(a, l);
    }),
      o.forEach(function (a) {
        t.__compiled__[t.__schemas__[a]] &&
          ((t.__compiled__[a].validate =
            t.__compiled__[t.__schemas__[a]].validate),
          (t.__compiled__[a].normalize =
            t.__compiled__[t.__schemas__[a]].normalize));
      }),
      (t.__compiled__[""] = { validate: null, normalize: Zb() });
    const s = Object.keys(t.__compiled__)
      .filter(function (a) {
        return a.length > 0 && t.__compiled__[a];
      })
      .map(KM)
      .join("|");
    (t.re.schema_test = RegExp(
      "(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + s + ")",
      "i"
    )),
      (t.re.schema_search = RegExp(
        "(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + s + ")",
        "ig"
      )),
      (t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i")),
      (t.re.pretest = RegExp(
        "(" +
          t.re.schema_test.source +
          ")|(" +
          t.re.host_fuzzy_test.source +
          ")|@",
        "i"
      )),
      ZM(t);
  }
  function e8(t, e) {
    const n = t.__index__,
      r = t.__last_index__,
      o = t.__text_cache__.slice(n, r);
    (this.schema = t.__schema__.toLowerCase()),
      (this.index = n + e),
      (this.lastIndex = r + e),
      (this.raw = o),
      (this.text = o),
      (this.url = o);
  }
  function Mp(t, e) {
    const n = new e8(t, e);
    return t.__compiled__[n.schema].normalize(n, t), n;
  }
  function zt(t, e) {
    if (!(this instanceof zt)) return new zt(t, e);
    e || (GM(t) && ((e = t), (t = {}))),
      (this.__opts__ = Sp({}, Xb, e)),
      (this.__index__ = -1),
      (this.__last_index__ = -1),
      (this.__schema__ = ""),
      (this.__text_cache__ = ""),
      (this.__schemas__ = Sp({}, JM, t)),
      (this.__compiled__ = {}),
      (this.__tlds__ = XM),
      (this.__tlds_replaced__ = !1),
      (this.re = {}),
      sc(this);
  }
  (zt.prototype.add = function (e, n) {
    return (this.__schemas__[e] = n), sc(this), this;
  }),
    (zt.prototype.set = function (e) {
      return (this.__opts__ = Sp(this.__opts__, e)), this;
    }),
    (zt.prototype.test = function (e) {
      if (((this.__text_cache__ = e), (this.__index__ = -1), !e.length))
        return !1;
      let n, r, o, i, s, a, l, c, d;
      if (this.re.schema_test.test(e)) {
        for (
          l = this.re.schema_search, l.lastIndex = 0;
          (n = l.exec(e)) !== null;

        )
          if (((i = this.testSchemaAt(e, n[2], l.lastIndex)), i)) {
            (this.__schema__ = n[2]),
              (this.__index__ = n.index + n[1].length),
              (this.__last_index__ = n.index + n[0].length + i);
            break;
          }
      }
      return (
        this.__opts__.fuzzyLink &&
          this.__compiled__["http:"] &&
          ((c = e.search(this.re.host_fuzzy_test)),
          c >= 0 &&
            (this.__index__ < 0 || c < this.__index__) &&
            (r = e.match(
              this.__opts__.fuzzyIP
                ? this.re.link_fuzzy
                : this.re.link_no_ip_fuzzy
            )) !== null &&
            ((s = r.index + r[1].length),
            (this.__index__ < 0 || s < this.__index__) &&
              ((this.__schema__ = ""),
              (this.__index__ = s),
              (this.__last_index__ = r.index + r[0].length)))),
        this.__opts__.fuzzyEmail &&
          this.__compiled__["mailto:"] &&
          ((d = e.indexOf("@")),
          d >= 0 &&
            (o = e.match(this.re.email_fuzzy)) !== null &&
            ((s = o.index + o[1].length),
            (a = o.index + o[0].length),
            (this.__index__ < 0 ||
              s < this.__index__ ||
              (s === this.__index__ && a > this.__last_index__)) &&
              ((this.__schema__ = "mailto:"),
              (this.__index__ = s),
              (this.__last_index__ = a)))),
        this.__index__ >= 0
      );
    }),
    (zt.prototype.pretest = function (e) {
      return this.re.pretest.test(e);
    }),
    (zt.prototype.testSchemaAt = function (e, n, r) {
      return this.__compiled__[n.toLowerCase()]
        ? this.__compiled__[n.toLowerCase()].validate(e, r, this)
        : 0;
    }),
    (zt.prototype.match = function (e) {
      const n = [];
      let r = 0;
      this.__index__ >= 0 &&
        this.__text_cache__ === e &&
        (n.push(Mp(this, r)), (r = this.__last_index__));
      let o = r ? e.slice(r) : e;
      for (; this.test(o); )
        n.push(Mp(this, r)),
          (o = o.slice(this.__last_index__)),
          (r += this.__last_index__);
      return n.length ? n : null;
    }),
    (zt.prototype.matchAtStart = function (e) {
      if (((this.__text_cache__ = e), (this.__index__ = -1), !e.length))
        return null;
      const n = this.re.schema_at_start.exec(e);
      if (!n) return null;
      const r = this.testSchemaAt(e, n[2], n[0].length);
      return r
        ? ((this.__schema__ = n[2]),
          (this.__index__ = n.index + n[1].length),
          (this.__last_index__ = n.index + n[0].length + r),
          Mp(this, 0))
        : null;
    }),
    (zt.prototype.tlds = function (e, n) {
      return (
        (e = Array.isArray(e) ? e : [e]),
        n
          ? ((this.__tlds__ = this.__tlds__
              .concat(e)
              .sort()
              .filter(function (r, o, i) {
                return r !== i[o - 1];
              })
              .reverse()),
            sc(this),
            this)
          : ((this.__tlds__ = e.slice()),
            (this.__tlds_replaced__ = !0),
            sc(this),
            this)
      );
    }),
    (zt.prototype.normalize = function (e) {
      e.schema || (e.url = "http://" + e.url),
        e.schema === "mailto:" &&
          !/^mailto:/i.test(e.url) &&
          (e.url = "mailto:" + e.url);
    }),
    (zt.prototype.onCompile = function () {});
  const Ci = 2147483647,
    Wn = 36,
    Tp = 1,
    Js = 26,
    t8 = 38,
    n8 = 700,
    Qb = 72,
    ey = 128,
    ty = "-",
    r8 = /^xn--/,
    o8 = /[^\0-\x7F]/,
    i8 = /[\x2E\u3002\uFF0E\uFF61]/g,
    s8 = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input",
    },
    Np = Wn - Tp,
    qn = Math.floor,
    Op = String.fromCharCode;
  function Zr(t) {
    throw new RangeError(s8[t]);
  }
  function a8(t, e) {
    const n = [];
    let r = t.length;
    for (; r--; ) n[r] = e(t[r]);
    return n;
  }
  function ny(t, e) {
    const n = t.split("@");
    let r = "";
    n.length > 1 && ((r = n[0] + "@"), (t = n[1])), (t = t.replace(i8, "."));
    const o = t.split("."),
      i = a8(o, e).join(".");
    return r + i;
  }
  function ry(t) {
    const e = [];
    let n = 0;
    const r = t.length;
    for (; n < r; ) {
      const o = t.charCodeAt(n++);
      if (o >= 55296 && o <= 56319 && n < r) {
        const i = t.charCodeAt(n++);
        (i & 64512) == 56320
          ? e.push(((o & 1023) << 10) + (i & 1023) + 65536)
          : (e.push(o), n--);
      } else e.push(o);
    }
    return e;
  }
  const l8 = (t) => String.fromCodePoint(...t),
    c8 = function (t) {
      return t >= 48 && t < 58
        ? 26 + (t - 48)
        : t >= 65 && t < 91
        ? t - 65
        : t >= 97 && t < 123
        ? t - 97
        : Wn;
    },
    oy = function (t, e) {
      return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
    },
    iy = function (t, e, n) {
      let r = 0;
      for (
        t = n ? qn(t / n8) : t >> 1, t += qn(t / e);
        t > (Np * Js) >> 1;
        r += Wn
      )
        t = qn(t / Np);
      return qn(r + ((Np + 1) * t) / (t + t8));
    },
    sy = function (t) {
      const e = [],
        n = t.length;
      let r = 0,
        o = ey,
        i = Qb,
        s = t.lastIndexOf(ty);
      s < 0 && (s = 0);
      for (let a = 0; a < s; ++a)
        t.charCodeAt(a) >= 128 && Zr("not-basic"), e.push(t.charCodeAt(a));
      for (let a = s > 0 ? s + 1 : 0; a < n; ) {
        const l = r;
        for (let d = 1, f = Wn; ; f += Wn) {
          a >= n && Zr("invalid-input");
          const p = c8(t.charCodeAt(a++));
          p >= Wn && Zr("invalid-input"),
            p > qn((Ci - r) / d) && Zr("overflow"),
            (r += p * d);
          const h = f <= i ? Tp : f >= i + Js ? Js : f - i;
          if (p < h) break;
          const m = Wn - h;
          d > qn(Ci / m) && Zr("overflow"), (d *= m);
        }
        const c = e.length + 1;
        (i = iy(r - l, c, l == 0)),
          qn(r / c) > Ci - o && Zr("overflow"),
          (o += qn(r / c)),
          (r %= c),
          e.splice(r++, 0, o);
      }
      return String.fromCodePoint(...e);
    },
    ay = function (t) {
      const e = [];
      t = ry(t);
      const n = t.length;
      let r = ey,
        o = 0,
        i = Qb;
      for (const l of t) l < 128 && e.push(Op(l));
      const s = e.length;
      let a = s;
      for (s && e.push(ty); a < n; ) {
        let l = Ci;
        for (const d of t) d >= r && d < l && (l = d);
        const c = a + 1;
        l - r > qn((Ci - o) / c) && Zr("overflow"), (o += (l - r) * c), (r = l);
        for (const d of t)
          if ((d < r && ++o > Ci && Zr("overflow"), d === r)) {
            let f = o;
            for (let p = Wn; ; p += Wn) {
              const h = p <= i ? Tp : p >= i + Js ? Js : p - i;
              if (f < h) break;
              const m = f - h,
                g = Wn - h;
              e.push(Op(oy(h + (m % g), 0))), (f = qn(m / g));
            }
            e.push(Op(oy(f, 0))), (i = iy(o, c, a === s)), (o = 0), ++a;
          }
        ++o, ++r;
      }
      return e.join("");
    },
    ly = {
      version: "2.3.1",
      ucs2: { decode: ry, encode: l8 },
      decode: sy,
      encode: ay,
      toASCII: function (t) {
        return ny(t, function (e) {
          return o8.test(e) ? "xn--" + ay(e) : e;
        });
      },
      toUnicode: function (t) {
        return ny(t, function (e) {
          return r8.test(e) ? sy(e.slice(4).toLowerCase()) : e;
        });
      },
    },
    u8 = {
      default: {
        options: {
          html: !1,
          xhtmlOut: !1,
          breaks: !1,
          langPrefix: "language-",
          linkify: !1,
          typographer: !1,
          quotes: "“”‘’",
          highlight: null,
          maxNesting: 100,
        },
        components: { core: {}, block: {}, inline: {} },
      },
      zero: {
        options: {
          html: !1,
          xhtmlOut: !1,
          breaks: !1,
          langPrefix: "language-",
          linkify: !1,
          typographer: !1,
          quotes: "“”‘’",
          highlight: null,
          maxNesting: 20,
        },
        components: {
          core: { rules: ["normalize", "block", "inline", "text_join"] },
          block: { rules: ["paragraph"] },
          inline: {
            rules: ["text"],
            rules2: ["balance_pairs", "fragments_join"],
          },
        },
      },
      commonmark: {
        options: {
          html: !0,
          xhtmlOut: !0,
          breaks: !1,
          langPrefix: "language-",
          linkify: !1,
          typographer: !1,
          quotes: "“”‘’",
          highlight: null,
          maxNesting: 20,
        },
        components: {
          core: { rules: ["normalize", "block", "inline", "text_join"] },
          block: {
            rules: [
              "blockquote",
              "code",
              "fence",
              "heading",
              "hr",
              "html_block",
              "lheading",
              "list",
              "reference",
              "paragraph",
            ],
          },
          inline: {
            rules: [
              "autolink",
              "backticks",
              "emphasis",
              "entity",
              "escape",
              "html_inline",
              "image",
              "link",
              "newline",
              "text",
            ],
            rules2: ["balance_pairs", "emphasis", "fragments_join"],
          },
        },
      },
    },
    d8 = /^(vbscript|javascript|file|data):/,
    f8 = /^data:image\/(gif|png|jpeg|webp);/;
  function p8(t) {
    const e = t.trim().toLowerCase();
    return d8.test(e) ? f8.test(e) : !0;
  }
  const cy = ["http:", "https:", "mailto:"];
  function h8(t) {
    const e = mp(t, !0);
    if (e.hostname && (!e.protocol || cy.indexOf(e.protocol) >= 0))
      try {
        e.hostname = ly.toASCII(e.hostname);
      } catch {}
    return Vs(hp(e));
  }
  function m8(t) {
    const e = mp(t, !0);
    if (e.hostname && (!e.protocol || cy.indexOf(e.protocol) >= 0))
      try {
        e.hostname = ly.toUnicode(e.hostname);
      } catch {}
    return ki(hp(e), ki.defaultChars + "%");
  }
  function on(t, e) {
    if (!(this instanceof on)) return new on(t, e);
    e || _p(t) || ((e = t || {}), (t = "default")),
      (this.inline = new Gs()),
      (this.block = new oc()),
      (this.core = new xp()),
      (this.renderer = new wi()),
      (this.linkify = new zt()),
      (this.validateLink = p8),
      (this.normalizeLink = h8),
      (this.normalizeLinkText = m8),
      (this.utils = SS),
      (this.helpers = Ql({}, OS)),
      (this.options = {}),
      this.configure(t),
      e && this.set(e);
  }
  (on.prototype.set = function (t) {
    return Ql(this.options, t), this;
  }),
    (on.prototype.configure = function (t) {
      const e = this;
      if (_p(t)) {
        const n = t;
        if (((t = u8[n]), !t))
          throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
      }
      if (!t) throw new Error("Wrong `markdown-it` preset, can't be empty");
      return (
        t.options && e.set(t.options),
        t.components &&
          Object.keys(t.components).forEach(function (n) {
            t.components[n].rules &&
              e[n].ruler.enableOnly(t.components[n].rules),
              t.components[n].rules2 &&
                e[n].ruler2.enableOnly(t.components[n].rules2);
          }),
        this
      );
    }),
    (on.prototype.enable = function (t, e) {
      let n = [];
      Array.isArray(t) || (t = [t]),
        ["core", "block", "inline"].forEach(function (o) {
          n = n.concat(this[o].ruler.enable(t, !0));
        }, this),
        (n = n.concat(this.inline.ruler2.enable(t, !0)));
      const r = t.filter(function (o) {
        return n.indexOf(o) < 0;
      });
      if (r.length && !e)
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
      return this;
    }),
    (on.prototype.disable = function (t, e) {
      let n = [];
      Array.isArray(t) || (t = [t]),
        ["core", "block", "inline"].forEach(function (o) {
          n = n.concat(this[o].ruler.disable(t, !0));
        }, this),
        (n = n.concat(this.inline.ruler2.disable(t, !0)));
      const r = t.filter(function (o) {
        return n.indexOf(o) < 0;
      });
      if (r.length && !e)
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
      return this;
    }),
    (on.prototype.use = function (t) {
      const e = [this].concat(Array.prototype.slice.call(arguments, 1));
      return t.apply(t, e), this;
    }),
    (on.prototype.parse = function (t, e) {
      if (typeof t != "string")
        throw new Error("Input data should be a String");
      const n = new this.core.State(t, this, e);
      return this.core.process(n), n.tokens;
    }),
    (on.prototype.render = function (t, e) {
      return (
        (e = e || {}), this.renderer.render(this.parse(t, e), this.options, e)
      );
    }),
    (on.prototype.parseInline = function (t, e) {
      const n = new this.core.State(t, this, e);
      return (n.inlineMode = !0), this.core.process(n), n.tokens;
    }),
    (on.prototype.renderInline = function (t, e) {
      return (
        (e = e || {}),
        this.renderer.render(this.parseInline(t, e), this.options, e)
      );
    });
  const uy = new _s({
    nodes: {
      doc: { content: "block+" },
      paragraph: {
        content: "inline*",
        group: "block",
        parseDOM: [{ tag: "p" }],
        toDOM() {
          return ["p", 0];
        },
      },
      blockquote: {
        content: "block+",
        group: "block",
        parseDOM: [{ tag: "blockquote" }],
        toDOM() {
          return ["blockquote", 0];
        },
      },
      horizontal_rule: {
        group: "block",
        parseDOM: [{ tag: "hr" }],
        toDOM() {
          return ["div", ["hr"]];
        },
      },
      heading: {
        attrs: { level: { default: 1 } },
        content: "(text | image)*",
        group: "block",
        defining: !0,
        parseDOM: [
          { tag: "h1", attrs: { level: 1 } },
          { tag: "h2", attrs: { level: 2 } },
          { tag: "h3", attrs: { level: 3 } },
          { tag: "h4", attrs: { level: 4 } },
          { tag: "h5", attrs: { level: 5 } },
          { tag: "h6", attrs: { level: 6 } },
        ],
        toDOM(t) {
          return ["h" + t.attrs.level, 0];
        },
      },
      code_block: {
        content: "text*",
        group: "block",
        code: !0,
        defining: !0,
        marks: "",
        attrs: { params: { default: "" } },
        parseDOM: [
          {
            tag: "pre",
            preserveWhitespace: "full",
            getAttrs: (t) => ({ params: t.getAttribute("data-params") || "" }),
          },
        ],
        toDOM(t) {
          return [
            "pre",
            t.attrs.params ? { "data-params": t.attrs.params } : {},
            ["code", 0],
          ];
        },
      },
      ordered_list: {
        content: "list_item+",
        group: "block",
        attrs: { order: { default: 1 }, tight: { default: !1 } },
        parseDOM: [
          {
            tag: "ol",
            getAttrs(t) {
              return {
                order: t.hasAttribute("start") ? +t.getAttribute("start") : 1,
                tight: t.hasAttribute("data-tight"),
              };
            },
          },
        ],
        toDOM(t) {
          return [
            "ol",
            {
              start: t.attrs.order == 1 ? null : t.attrs.order,
              "data-tight": t.attrs.tight ? "true" : null,
            },
            0,
          ];
        },
      },
      bullet_list: {
        content: "list_item+",
        group: "block",
        attrs: { tight: { default: !1 } },
        parseDOM: [
          {
            tag: "ul",
            getAttrs: (t) => ({ tight: t.hasAttribute("data-tight") }),
          },
        ],
        toDOM(t) {
          return ["ul", { "data-tight": t.attrs.tight ? "true" : null }, 0];
        },
      },
      list_item: {
        content: "block+",
        defining: !0,
        parseDOM: [{ tag: "li" }],
        toDOM() {
          return ["li", 0];
        },
      },
      text: { group: "inline" },
      image: {
        inline: !0,
        attrs: { src: {}, alt: { default: null }, title: { default: null } },
        group: "inline",
        draggable: !0,
        parseDOM: [
          {
            tag: "img[src]",
            getAttrs(t) {
              return {
                src: t.getAttribute("src"),
                title: t.getAttribute("title"),
                alt: t.getAttribute("alt"),
              };
            },
          },
        ],
        toDOM(t) {
          return ["img", t.attrs];
        },
      },
      hard_break: {
        inline: !0,
        group: "inline",
        selectable: !1,
        parseDOM: [{ tag: "br" }],
        toDOM() {
          return ["br"];
        },
      },
    },
    marks: {
      em: {
        parseDOM: [
          { tag: "i" },
          { tag: "em" },
          { style: "font-style=italic" },
          { style: "font-style=normal", clearMark: (t) => t.type.name == "em" },
        ],
        toDOM() {
          return ["em"];
        },
      },
      strong: {
        parseDOM: [
          { tag: "strong" },
          { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
          {
            style: "font-weight=400",
            clearMark: (t) => t.type.name == "strong",
          },
          {
            style: "font-weight",
            getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
          },
        ],
        toDOM() {
          return ["strong"];
        },
      },
      link: {
        attrs: { href: {}, title: { default: null } },
        inclusive: !1,
        parseDOM: [
          {
            tag: "a[href]",
            getAttrs(t) {
              return {
                href: t.getAttribute("href"),
                title: t.getAttribute("title"),
              };
            },
          },
        ],
        toDOM(t) {
          return ["a", t.attrs];
        },
      },
      code: {
        parseDOM: [{ tag: "code" }],
        toDOM() {
          return ["code"];
        },
      },
    },
  });
  function g8(t, e) {
    if (t.isText && e.isText && _e.sameSet(t.marks, e.marks))
      return t.withText(t.text + e.text);
  }
  class b8 {
    constructor(e, n) {
      (this.schema = e),
        (this.tokenHandlers = n),
        (this.stack = [
          { type: e.topNodeType, attrs: null, content: [], marks: _e.none },
        ]);
    }
    top() {
      return this.stack[this.stack.length - 1];
    }
    push(e) {
      this.stack.length && this.top().content.push(e);
    }
    addText(e) {
      if (!e) return;
      let n = this.top(),
        r = n.content,
        o = r[r.length - 1],
        i = this.schema.text(e, n.marks),
        s;
      o && (s = g8(o, i)) ? (r[r.length - 1] = s) : r.push(i);
    }
    openMark(e) {
      let n = this.top();
      n.marks = e.addToSet(n.marks);
    }
    closeMark(e) {
      let n = this.top();
      n.marks = e.removeFromSet(n.marks);
    }
    parseTokens(e) {
      for (let n = 0; n < e.length; n++) {
        let r = e[n],
          o = this.tokenHandlers[r.type];
        if (!o)
          throw new Error(
            "Token type `" + r.type + "` not supported by Markdown parser"
          );
        o(this, r, e, n);
      }
    }
    addNode(e, n, r) {
      let o = this.top(),
        i = e.createAndFill(n, r, o ? o.marks : []);
      return i ? (this.push(i), i) : null;
    }
    openNode(e, n) {
      this.stack.push({ type: e, attrs: n, content: [], marks: _e.none });
    }
    closeNode() {
      let e = this.stack.pop();
      return this.addNode(e.type, e.attrs, e.content);
    }
  }
  function Ys(t, e, n, r) {
    return t.getAttrs
      ? t.getAttrs(e, n, r)
      : t.attrs instanceof Function
      ? t.attrs(e)
      : t.attrs;
  }
  function Rp(t, e) {
    return (
      t.noCloseToken || e == "code_inline" || e == "code_block" || e == "fence"
    );
  }
  function dy(t) {
    return t[t.length - 1] ==
      `
`
      ? t.slice(0, t.length - 1)
      : t;
  }
  function Dp() {}
  function y8(t, e) {
    let n = Object.create(null);
    for (let r in e) {
      let o = e[r];
      if (o.block) {
        let i = t.nodeType(o.block);
        Rp(o, r)
          ? (n[r] = (s, a, l, c) => {
              s.openNode(i, Ys(o, a, l, c)),
                s.addText(dy(a.content)),
                s.closeNode();
            })
          : ((n[r + "_open"] = (s, a, l, c) => s.openNode(i, Ys(o, a, l, c))),
            (n[r + "_close"] = (s) => s.closeNode()));
      } else if (o.node) {
        let i = t.nodeType(o.node);
        n[r] = (s, a, l, c) => s.addNode(i, Ys(o, a, l, c));
      } else if (o.mark) {
        let i = t.marks[o.mark];
        Rp(o, r)
          ? (n[r] = (s, a, l, c) => {
              s.openMark(i.create(Ys(o, a, l, c))),
                s.addText(dy(a.content)),
                s.closeMark(i);
            })
          : ((n[r + "_open"] = (s, a, l, c) =>
              s.openMark(i.create(Ys(o, a, l, c)))),
            (n[r + "_close"] = (s) => s.closeMark(i)));
      } else if (o.ignore)
        Rp(o, r)
          ? (n[r] = Dp)
          : ((n[r + "_open"] = Dp), (n[r + "_close"] = Dp));
      else
        throw new RangeError("Unrecognized parsing spec " + JSON.stringify(o));
    }
    return (
      (n.text = (r, o) => r.addText(o.content)),
      (n.inline = (r, o) => r.parseTokens(o.children)),
      (n.softbreak = n.softbreak || ((r) => r.addText(" "))),
      n
    );
  }
  class fy {
    constructor(e, n, r) {
      (this.schema = e),
        (this.tokenizer = n),
        (this.tokens = r),
        (this.tokenHandlers = y8(e, r));
    }
    parse(e, n = {}) {
      let r = new b8(this.schema, this.tokenHandlers),
        o;
      r.parseTokens(this.tokenizer.parse(e, n));
      do o = r.closeNode();
      while (r.stack.length);
      return o || this.schema.topNodeType.createAndFill();
    }
  }
  function py(t, e) {
    for (; ++e < t.length; )
      if (t[e].type != "list_item_open") return t[e].hidden;
    return !1;
  }
  const _8 = new fy(uy, on("commonmark", { html: !1 }), {
      blockquote: { block: "blockquote" },
      paragraph: { block: "paragraph" },
      list_item: { block: "list_item" },
      bullet_list: {
        block: "bullet_list",
        getAttrs: (t, e, n) => ({ tight: py(e, n) }),
      },
      ordered_list: {
        block: "ordered_list",
        getAttrs: (t, e, n) => ({
          order: +t.attrGet("start") || 1,
          tight: py(e, n),
        }),
      },
      heading: {
        block: "heading",
        getAttrs: (t) => ({ level: +t.tag.slice(1) }),
      },
      code_block: { block: "code_block", noCloseToken: !0 },
      fence: {
        block: "code_block",
        getAttrs: (t) => ({ params: t.info || "" }),
        noCloseToken: !0,
      },
      hr: { node: "horizontal_rule" },
      image: {
        node: "image",
        getAttrs: (t) => ({
          src: t.attrGet("src"),
          title: t.attrGet("title") || null,
          alt: (t.children[0] && t.children[0].content) || null,
        }),
      },
      hardbreak: { node: "hard_break" },
      em: { mark: "em" },
      strong: { mark: "strong" },
      link: {
        mark: "link",
        getAttrs: (t) => ({
          href: t.attrGet("href"),
          title: t.attrGet("title") || null,
        }),
      },
      code_inline: { mark: "code", noCloseToken: !0 },
    }),
    k8 = { open: "", close: "", mixable: !0 };
  class hy {
    constructor(e, n, r = {}) {
      (this.nodes = e), (this.marks = n), (this.options = r);
    }
    serialize(e, n = {}) {
      n = Object.assign({}, this.options, n);
      let r = new gy(this.nodes, this.marks, n);
      return r.renderContent(e), r.out;
    }
  }
  const w8 = new hy(
    {
      blockquote(t, e) {
        t.wrapBlock("> ", null, e, () => t.renderContent(e));
      },
      code_block(t, e) {
        const n = e.textContent.match(/`{3,}/gm),
          r = n ? n.sort().slice(-1)[0] + "`" : "```";
        t.write(
          r +
            (e.attrs.params || "") +
            `
`
        ),
          t.text(e.textContent, !1),
          t.write(`
`),
          t.write(r),
          t.closeBlock(e);
      },
      heading(t, e) {
        t.write(t.repeat("#", e.attrs.level) + " "),
          t.renderInline(e, !1),
          t.closeBlock(e);
      },
      horizontal_rule(t, e) {
        t.write(e.attrs.markup || "---"), t.closeBlock(e);
      },
      bullet_list(t, e) {
        t.renderList(e, "  ", () => (e.attrs.bullet || "*") + " ");
      },
      ordered_list(t, e) {
        let n = e.attrs.order || 1,
          r = String(n + e.childCount - 1).length,
          o = t.repeat(" ", r + 2);
        t.renderList(e, o, (i) => {
          let s = String(n + i);
          return t.repeat(" ", r - s.length) + s + ". ";
        });
      },
      list_item(t, e) {
        t.renderContent(e);
      },
      paragraph(t, e) {
        t.renderInline(e), t.closeBlock(e);
      },
      image(t, e) {
        t.write(
          "![" +
            t.esc(e.attrs.alt || "") +
            "](" +
            e.attrs.src.replace(/[\(\)]/g, "\\$&") +
            (e.attrs.title
              ? ' "' + e.attrs.title.replace(/"/g, '\\"') + '"'
              : "") +
            ")"
        );
      },
      hard_break(t, e, n, r) {
        for (let o = r + 1; o < n.childCount; o++)
          if (n.child(o).type != e.type) {
            t.write(`\\
`);
            return;
          }
      },
      text(t, e) {
        t.text(e.text, !t.inAutolink);
      },
    },
    {
      em: { open: "*", close: "*", mixable: !0, expelEnclosingWhitespace: !0 },
      strong: {
        open: "**",
        close: "**",
        mixable: !0,
        expelEnclosingWhitespace: !0,
      },
      link: {
        open(t, e, n, r) {
          return (t.inAutolink = x8(e, n, r)), t.inAutolink ? "<" : "[";
        },
        close(t, e, n, r) {
          let { inAutolink: o } = t;
          return (
            (t.inAutolink = void 0),
            o
              ? ">"
              : "](" +
                e.attrs.href.replace(/[\(\)"]/g, "\\$&") +
                (e.attrs.title
                  ? ` "${e.attrs.title.replace(/"/g, '\\"')}"`
                  : "") +
                ")"
          );
        },
        mixable: !0,
      },
      code: {
        open(t, e, n, r) {
          return my(n.child(r), -1);
        },
        close(t, e, n, r) {
          return my(n.child(r - 1), 1);
        },
        escape: !1,
      },
    }
  );
  function my(t, e) {
    let n = /`+/g,
      r,
      o = 0;
    if (t.isText) for (; (r = n.exec(t.text)); ) o = Math.max(o, r[0].length);
    let i = o > 0 && e > 0 ? " `" : "`";
    for (let s = 0; s < o; s++) i += "`";
    return o > 0 && e < 0 && (i += " "), i;
  }
  function x8(t, e, n) {
    if (t.attrs.title || !/^\w+:/.test(t.attrs.href)) return !1;
    let r = e.child(n);
    return !r.isText ||
      r.text != t.attrs.href ||
      r.marks[r.marks.length - 1] != t
      ? !1
      : n == e.childCount - 1 || !t.isInSet(e.child(n + 1).marks);
  }
  class gy {
    constructor(e, n, r) {
      (this.nodes = e),
        (this.marks = n),
        (this.options = r),
        (this.delim = ""),
        (this.out = ""),
        (this.closed = null),
        (this.inAutolink = void 0),
        (this.atBlockStart = !1),
        (this.inTightList = !1),
        typeof this.options.tightLists > "u" && (this.options.tightLists = !1),
        typeof this.options.hardBreakNodeName > "u" &&
          (this.options.hardBreakNodeName = "hard_break");
    }
    flushClose(e = 2) {
      if (this.closed) {
        if (
          (this.atBlank() ||
            (this.out += `
`),
          e > 1)
        ) {
          let n = this.delim,
            r = /\s+$/.exec(n);
          r && (n = n.slice(0, n.length - r[0].length));
          for (let o = 1; o < e; o++)
            this.out +=
              n +
              `
`;
        }
        this.closed = null;
      }
    }
    getMark(e) {
      let n = this.marks[e];
      if (!n) {
        if (this.options.strict !== !1)
          throw new Error(
            `Mark type \`${e}\` not supported by Markdown renderer`
          );
        n = k8;
      }
      return n;
    }
    wrapBlock(e, n, r, o) {
      let i = this.delim;
      this.write(n ?? e),
        (this.delim += e),
        o(),
        (this.delim = i),
        this.closeBlock(r);
    }
    atBlank() {
      return /(^|\n)$/.test(this.out);
    }
    ensureNewLine() {
      this.atBlank() ||
        (this.out += `
`);
    }
    write(e) {
      this.flushClose(),
        this.delim && this.atBlank() && (this.out += this.delim),
        e && (this.out += e);
    }
    closeBlock(e) {
      this.closed = e;
    }
    text(e, n = !0) {
      let r = e.split(`
`);
      for (let o = 0; o < r.length; o++)
        this.write(),
          !n &&
            r[o][0] == "[" &&
            /(^|[^\\])\!$/.test(this.out) &&
            (this.out = this.out.slice(0, this.out.length - 1) + "\\!"),
          (this.out += n ? this.esc(r[o], this.atBlockStart) : r[o]),
          o != r.length - 1 &&
            (this.out += `
`);
    }
    render(e, n, r) {
      if (this.nodes[e.type.name]) this.nodes[e.type.name](this, e, n, r);
      else {
        if (this.options.strict !== !1)
          throw new Error(
            "Token type `" +
              e.type.name +
              "` not supported by Markdown renderer"
          );
        e.type.isLeaf ||
          (e.type.inlineContent ? this.renderInline(e) : this.renderContent(e),
          e.isBlock && this.closeBlock(e));
      }
    }
    renderContent(e) {
      e.forEach((n, r, o) => this.render(n, e, o));
    }
    renderInline(e, n = !0) {
      this.atBlockStart = n;
      let r = [],
        o = "",
        i = (s, a, l) => {
          let c = s ? s.marks : [];
          s &&
            s.type.name === this.options.hardBreakNodeName &&
            (c = c.filter((g) => {
              if (l + 1 == e.childCount) return !1;
              let b = e.child(l + 1);
              return g.isInSet(b.marks) && (!b.isText || /\S/.test(b.text));
            }));
          let d = o;
          if (
            ((o = ""),
            s &&
              s.isText &&
              c.some((g) => {
                let b = this.getMark(g.type.name);
                return b && b.expelEnclosingWhitespace && !g.isInSet(r);
              }))
          ) {
            let [g, b, y] = /^(\s*)(.*)$/m.exec(s.text);
            b && ((d += b), (s = y ? s.withText(y) : null), s || (c = r));
          }
          if (
            s &&
            s.isText &&
            c.some((g) => {
              let b = this.getMark(g.type.name);
              return (
                b &&
                b.expelEnclosingWhitespace &&
                (l == e.childCount - 1 || !g.isInSet(e.child(l + 1).marks))
              );
            })
          ) {
            let [g, b, y] = /^(.*?)(\s*)$/m.exec(s.text);
            y && ((o = y), (s = b ? s.withText(b) : null), s || (c = r));
          }
          let f = c.length ? c[c.length - 1] : null,
            p = f && this.getMark(f.type.name).escape === !1,
            h = c.length - (p ? 1 : 0);
          e: for (let g = 0; g < h; g++) {
            let b = c[g];
            if (!this.getMark(b.type.name).mixable) break;
            for (let y = 0; y < r.length; y++) {
              let x = r[y];
              if (!this.getMark(x.type.name).mixable) break;
              if (b.eq(x)) {
                g > y
                  ? (c = c
                      .slice(0, y)
                      .concat(b)
                      .concat(c.slice(y, g))
                      .concat(c.slice(g + 1, h)))
                  : y > g &&
                    (c = c
                      .slice(0, g)
                      .concat(c.slice(g + 1, y))
                      .concat(b)
                      .concat(c.slice(y, h)));
                continue e;
              }
            }
          }
          let m = 0;
          for (; m < Math.min(r.length, h) && c[m].eq(r[m]); ) ++m;
          for (; m < r.length; )
            this.text(this.markString(r.pop(), !1, e, l), !1);
          if ((d && this.text(d), s)) {
            for (; r.length < h; ) {
              let g = c[r.length];
              r.push(g),
                this.text(this.markString(g, !0, e, l), !1),
                (this.atBlockStart = !1);
            }
            p && s.isText
              ? this.text(
                  this.markString(f, !0, e, l) +
                    s.text +
                    this.markString(f, !1, e, l + 1),
                  !1
                )
              : this.render(s, e, l),
              (this.atBlockStart = !1);
          }
          s != null && s.isText && s.nodeSize > 0 && (this.atBlockStart = !1);
        };
      e.forEach(i), i(null, 0, e.childCount), (this.atBlockStart = !1);
    }
    renderList(e, n, r) {
      this.closed && this.closed.type == e.type
        ? this.flushClose(3)
        : this.inTightList && this.flushClose(1);
      let o =
          typeof e.attrs.tight < "u" ? e.attrs.tight : this.options.tightLists,
        i = this.inTightList;
      (this.inTightList = o),
        e.forEach((s, a, l) => {
          l && o && this.flushClose(1),
            this.wrapBlock(n, r(l), e, () => this.render(s, e, l));
        }),
        (this.inTightList = i);
    }
    esc(e, n = !1) {
      return (
        (e = e.replace(/[`*\\~\[\]_]/g, (r, o) =>
          r == "_" &&
          o > 0 &&
          o + 1 < e.length &&
          e[o - 1].match(/\w/) &&
          e[o + 1].match(/\w/)
            ? r
            : "\\" + r
        )),
        n &&
          (e = e
            .replace(/^(\+[ ]|[\-*>])/, "\\$&")
            .replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3")
            .replace(/^(\s*\d+)\.\s/, "$1\\. ")),
        this.options.escapeExtraCharacters &&
          (e = e.replace(this.options.escapeExtraCharacters, "\\$&")),
        e
      );
    }
    quote(e) {
      let n = e.indexOf('"') == -1 ? '""' : e.indexOf("'") == -1 ? "''" : "()";
      return n[0] + e + n[1];
    }
    repeat(e, n) {
      let r = "";
      for (let o = 0; o < n; o++) r += e;
      return r;
    }
    markString(e, n, r, o) {
      let i = this.getMark(e.type.name),
        s = n ? i.open : i.close;
      return typeof s == "string" ? s : s(this, e, r, o);
    }
    getEnclosingWhitespace(e) {
      return {
        leading: (e.match(/^(\s+)/) || [void 0])[0],
        trailing: (e.match(/(\s+)$/) || [void 0])[0],
      };
    }
  }
  function Vt() {
    var t = arguments[0];
    typeof t == "string" && (t = document.createElement(t));
    var e = 1,
      n = arguments[1];
    if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
      for (var r in n)
        if (Object.prototype.hasOwnProperty.call(n, r)) {
          var o = n[r];
          typeof o == "string" ? t.setAttribute(r, o) : o != null && (t[r] = o);
        }
      e++;
    }
    for (; e < arguments.length; e++) by(t, arguments[e]);
    return t;
  }
  function by(t, e) {
    if (typeof e == "string") t.appendChild(document.createTextNode(e));
    else if (e != null)
      if (e.nodeType != null) t.appendChild(e);
      else if (Array.isArray(e)) for (var n = 0; n < e.length; n++) by(t, e[n]);
      else throw new RangeError("Unsupported child node: " + e);
  }
  const Xs = "http://www.w3.org/2000/svg",
    C8 = "http://www.w3.org/1999/xlink",
    Lp = "ProseMirror-icon";
  function v8(t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) e = ((e << 5) - e + t.charCodeAt(n)) | 0;
    return e;
  }
  function E8(t, e) {
    let n = (t.nodeType == 9 ? t : t.ownerDocument) || document,
      r = n.createElement("div");
    if (((r.className = Lp), e.path)) {
      let { path: o, width: i, height: s } = e,
        a = "pm-icon-" + v8(o).toString(16);
      n.getElementById(a) || A8(t, a, e);
      let l = r.appendChild(n.createElementNS(Xs, "svg"));
      (l.style.width = i / s + "em"),
        l
          .appendChild(n.createElementNS(Xs, "use"))
          .setAttributeNS(
            C8,
            "href",
            /([^#]*)/.exec(n.location.toString())[1] + "#" + a
          );
    } else if (e.dom) r.appendChild(e.dom.cloneNode(!0));
    else {
      let { text: o, css: i } = e;
      (r.appendChild(n.createElement("span")).textContent = o || ""),
        i && (r.firstChild.style.cssText = i);
    }
    return r;
  }
  function A8(t, e, n) {
    let [r, o] =
        t.nodeType == 9 ? [t, t.body] : [t.ownerDocument || document, t],
      i = r.getElementById(Lp + "-collection");
    i ||
      ((i = r.createElementNS(Xs, "svg")),
      (i.id = Lp + "-collection"),
      (i.style.display = "none"),
      o.insertBefore(i, o.firstChild));
    let s = r.createElementNS(Xs, "symbol");
    (s.id = e),
      s.setAttribute("viewBox", "0 0 " + n.width + " " + n.height),
      s.appendChild(r.createElementNS(Xs, "path")).setAttribute("d", n.path),
      i.appendChild(s);
  }
  const It = "ProseMirror-menu";
  class Qr {
    constructor(e) {
      this.spec = e;
    }
    render(e) {
      let n = this.spec,
        r = n.render
          ? n.render(e)
          : n.icon
          ? E8(e.root, n.icon)
          : n.label
          ? Vt("div", null, Zs(e, n.label))
          : null;
      if (!r) throw new RangeError("MenuItem without icon or label property");
      if (n.title) {
        const i = typeof n.title == "function" ? n.title(e.state) : n.title;
        r.setAttribute("title", Zs(e, i));
      }
      n.class && r.classList.add(n.class),
        n.css && (r.style.cssText += n.css),
        r.addEventListener("mousedown", (i) => {
          i.preventDefault(),
            r.classList.contains(It + "-disabled") ||
              n.run(e.state, e.dispatch, e, i);
        });
      function o(i) {
        if (n.select) {
          let a = n.select(i);
          if (((r.style.display = a ? "" : "none"), !a)) return !1;
        }
        let s = !0;
        if (
          (n.enable && ((s = n.enable(i) || !1), Ip(r, It + "-disabled", !s)),
          n.active)
        ) {
          let a = (s && n.active(i)) || !1;
          Ip(r, It + "-active", a);
        }
        return !0;
      }
      return { dom: r, update: o };
    }
  }
  function Zs(t, e) {
    return t._props.translate ? t._props.translate(e) : e;
  }
  let Qs = { time: 0, node: null };
  function yy(t) {
    (Qs.time = Date.now()), (Qs.node = t.target);
  }
  function _y(t) {
    return Date.now() - 100 < Qs.time && Qs.node && t.contains(Qs.node);
  }
  class S8 {
    constructor(e, n = {}) {
      (this.options = n),
        (this.options = n || {}),
        (this.content = Array.isArray(e) ? e : [e]);
    }
    render(e) {
      let n = ky(this.content, e),
        r = e.dom.ownerDocument.defaultView || window,
        o = Vt(
          "div",
          {
            class: It + "-dropdown " + (this.options.class || ""),
            style: this.options.css,
          },
          Zs(e, this.options.label || "")
        );
      this.options.title && o.setAttribute("title", Zs(e, this.options.title));
      let i = Vt("div", { class: It + "-dropdown-wrap" }, o),
        s = null,
        a = null,
        l = () => {
          s && s.close() && ((s = null), r.removeEventListener("mousedown", a));
        };
      o.addEventListener("mousedown", (d) => {
        d.preventDefault(),
          yy(d),
          s
            ? l()
            : ((s = this.expand(i, n.dom)),
              r.addEventListener(
                "mousedown",
                (a = () => {
                  _y(i) || l();
                })
              ));
      });
      function c(d) {
        let f = n.update(d);
        return (i.style.display = f ? "" : "none"), f;
      }
      return { dom: i, update: c };
    }
    expand(e, n) {
      let r = Vt(
          "div",
          { class: It + "-dropdown-menu " + (this.options.class || "") },
          n
        ),
        o = !1;
      function i() {
        return o ? !1 : ((o = !0), e.removeChild(r), !0);
      }
      return e.appendChild(r), { close: i, node: r };
    }
  }
  function ky(t, e) {
    let n = [],
      r = [];
    for (let o = 0; o < t.length; o++) {
      let { dom: i, update: s } = t[o].render(e);
      n.push(Vt("div", { class: It + "-dropdown-item" }, i)), r.push(s);
    }
    return { dom: n, update: wy(r, n) };
  }
  function wy(t, e) {
    return (n) => {
      let r = !1;
      for (let o = 0; o < t.length; o++) {
        let i = t[o](n);
        (e[o].style.display = i ? "" : "none"), i && (r = !0);
      }
      return r;
    };
  }
  class M8 {
    constructor(e, n = {}) {
      (this.options = n), (this.content = Array.isArray(e) ? e : [e]);
    }
    render(e) {
      let n = ky(this.content, e),
        r = e.dom.ownerDocument.defaultView || window,
        o = Vt(
          "div",
          { class: It + "-submenu-label" },
          Zs(e, this.options.label || "")
        ),
        i = Vt(
          "div",
          { class: It + "-submenu-wrap" },
          o,
          Vt("div", { class: It + "-submenu" }, n.dom)
        ),
        s = null;
      o.addEventListener("mousedown", (l) => {
        l.preventDefault(),
          yy(l),
          Ip(i, It + "-submenu-wrap-active", !1),
          s ||
            r.addEventListener(
              "mousedown",
              (s = () => {
                _y(i) ||
                  (i.classList.remove(It + "-submenu-wrap-active"),
                  r.removeEventListener("mousedown", s),
                  (s = null));
              })
            );
      });
      function a(l) {
        let c = n.update(l);
        return (i.style.display = c ? "" : "none"), c;
      }
      return { dom: i, update: a };
    }
  }
  function xy(t, e) {
    let n = document.createDocumentFragment(),
      r = [],
      o = [];
    for (let s = 0; s < e.length; s++) {
      let a = e[s],
        l = [],
        c = [];
      for (let d = 0; d < a.length; d++) {
        let { dom: f, update: p } = a[d].render(t),
          h = Vt("span", { class: It + "item" }, f);
        n.appendChild(h), c.push(h), l.push(p);
      }
      l.length &&
        (r.push(wy(l, c)), s < e.length - 1 && o.push(n.appendChild(T8())));
    }
    function i(s) {
      let a = !1,
        l = !1;
      for (let c = 0; c < r.length; c++) {
        let d = r[c](s);
        c && (o[c - 1].style.display = l && d ? "" : "none"),
          (l = d),
          d && (a = !0);
      }
      return a;
    }
    return { dom: n, update: i };
  }
  function T8() {
    return Vt("span", { class: It + "separator" });
  }
  const vi = {
      join: {
        width: 800,
        height: 900,
        path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z",
      },
      lift: {
        width: 1024,
        height: 1024,
        path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z",
      },
      selectParentNode: { text: "⬚", css: "font-weight: bold" },
      undo: {
        width: 1024,
        height: 1024,
        path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z",
      },
      redo: {
        width: 1024,
        height: 1024,
        path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z",
      },
      strong: {
        width: 805,
        height: 1024,
        path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z",
      },
      em: {
        width: 585,
        height: 1024,
        path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z",
      },
      code: {
        width: 896,
        height: 1024,
        path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z",
      },
      link: {
        width: 951,
        height: 1024,
        path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z",
      },
      bulletList: {
        width: 768,
        height: 896,
        path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z",
      },
      orderedList: {
        width: 768,
        height: 896,
        path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z",
      },
      blockquote: {
        width: 640,
        height: 896,
        path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z",
      },
    },
    N8 = new Qr({
      title: "Join with above block",
      run: Ll,
      select: (t) => Ll(t),
      icon: vi.join,
    }),
    O8 = new Qr({
      title: "Lift out of enclosing block",
      run: Il,
      select: (t) => Il(t),
      icon: vi.lift,
    }),
    R8 = new Qr({
      title: "Select parent node",
      run: Bl,
      select: (t) => Bl(t),
      icon: vi.selectParentNode,
    });
  let D8 = new Qr({
      title: "Undo last change",
      run: Hs,
      enable: (t) => Hs(t),
      icon: vi.undo,
    }),
    L8 = new Qr({
      title: "Redo last undone change",
      run: zs,
      enable: (t) => zs(t),
      icon: vi.redo,
    });
  function I8(t, e) {
    let n = {
      run(r, o) {
        return Pl(t, e.attrs)(r, o);
      },
      select(r) {
        return Pl(t, e.attrs)(r);
      },
    };
    for (let r in e) n[r] = e[r];
    return new Qr(n);
  }
  function B8(t, e) {
    let n = $l(t, e.attrs),
      r = {
        run: n,
        enable(o) {
          return n(o);
        },
        active(o) {
          let { $from: i, to: s, node: a } = o.selection;
          return a
            ? a.hasMarkup(t, e.attrs)
            : s <= i.end() && i.parent.hasMarkup(t, e.attrs);
        },
      };
    for (let o in e) r[o] = e[o];
    return new Qr(r);
  }
  function Ip(t, e, n) {
    n ? t.classList.add(e) : t.classList.remove(e);
  }
  const ac = "ProseMirror-menubar";
  function P8() {
    if (typeof navigator > "u") return !1;
    let t = navigator.userAgent;
    return (
      !/Edge\/\d/.test(t) && /AppleWebKit/.test(t) && /Mobile\/\w+/.test(t)
    );
  }
  function $8(t) {
    return new ie({
      view(e) {
        return new F8(e, t);
      },
    });
  }
  class F8 {
    constructor(e, n) {
      (this.editorView = e),
        (this.options = n),
        (this.spacer = null),
        (this.maxHeight = 0),
        (this.widthForMaxHeight = 0),
        (this.floating = !1),
        (this.scrollHandler = null),
        (this.wrapper = Vt("div", { class: ac + "-wrapper" })),
        (this.menu = this.wrapper.appendChild(Vt("div", { class: ac }))),
        (this.menu.className = ac),
        e.dom.parentNode && e.dom.parentNode.replaceChild(this.wrapper, e.dom),
        this.wrapper.appendChild(e.dom);
      let { dom: r, update: o } = xy(this.editorView, this.options.content);
      if (
        ((this.contentUpdate = o),
        this.menu.appendChild(r),
        this.update(),
        n.floating && !P8())
      ) {
        this.updateFloat();
        let i = V8(this.wrapper);
        (this.scrollHandler = (s) => {
          let a = this.editorView.root;
          (a.body || a).contains(this.wrapper)
            ? this.updateFloat(
                s.target.getBoundingClientRect ? s.target : void 0
              )
            : i.forEach((l) =>
                l.removeEventListener("scroll", this.scrollHandler)
              );
        }),
          i.forEach((s) => s.addEventListener("scroll", this.scrollHandler));
      }
    }
    update() {
      this.contentUpdate(this.editorView.state),
        this.floating
          ? this.updateScrollCursor()
          : (this.menu.offsetWidth != this.widthForMaxHeight &&
              ((this.widthForMaxHeight = this.menu.offsetWidth),
              (this.maxHeight = 0)),
            this.menu.offsetHeight > this.maxHeight &&
              ((this.maxHeight = this.menu.offsetHeight),
              (this.menu.style.minHeight = this.maxHeight + "px")));
    }
    updateScrollCursor() {
      let e = this.editorView.root.getSelection();
      if (!e.focusNode) return;
      let n = e.getRangeAt(0).getClientRects(),
        r = n[H8(e) ? 0 : n.length - 1];
      if (!r) return;
      let o = this.menu.getBoundingClientRect();
      if (r.top < o.bottom && r.bottom > o.top) {
        let i = z8(this.wrapper);
        i && (i.scrollTop -= o.bottom - r.top);
      }
    }
    updateFloat(e) {
      let n = this.wrapper,
        r = n.getBoundingClientRect(),
        o = e ? Math.max(0, e.getBoundingClientRect().top) : 0;
      if (this.floating)
        if (r.top >= o || r.bottom < this.menu.offsetHeight + 10)
          (this.floating = !1),
            (this.menu.style.position =
              this.menu.style.left =
              this.menu.style.top =
              this.menu.style.width =
                ""),
            (this.menu.style.display = ""),
            this.spacer.parentNode.removeChild(this.spacer),
            (this.spacer = null);
        else {
          let i = (n.offsetWidth - n.clientWidth) / 2;
          (this.menu.style.left = r.left + i + "px"),
            (this.menu.style.display =
              r.top >
              (this.editorView.dom.ownerDocument.defaultView || window)
                .innerHeight
                ? "none"
                : ""),
            e && (this.menu.style.top = o + "px");
        }
      else if (r.top < o && r.bottom >= this.menu.offsetHeight + 10) {
        this.floating = !0;
        let i = this.menu.getBoundingClientRect();
        (this.menu.style.left = i.left + "px"),
          (this.menu.style.width = i.width + "px"),
          e && (this.menu.style.top = o + "px"),
          (this.menu.style.position = "fixed"),
          (this.spacer = Vt("div", {
            class: ac + "-spacer",
            style: `height: ${i.height}px`,
          })),
          n.insertBefore(this.spacer, this.menu);
      }
    }
    destroy() {
      this.wrapper.parentNode &&
        this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
    }
  }
  function H8(t) {
    return t.anchorNode == t.focusNode
      ? t.anchorOffset > t.focusOffset
      : t.anchorNode.compareDocumentPosition(t.focusNode) ==
          Node.DOCUMENT_POSITION_FOLLOWING;
  }
  function z8(t) {
    for (let e = t.parentNode; e; e = e.parentNode)
      if (e.scrollHeight > e.clientHeight) return e;
  }
  function V8(t) {
    let e = [t.ownerDocument.defaultView || window];
    for (let n = t.parentNode; n; n = n.parentNode) e.push(n);
    return e;
  }
  const U8 = ["p", 0],
    j8 = ["blockquote", 0],
    W8 = ["hr"],
    q8 = ["pre", ["code", 0]],
    K8 = ["br"],
    Cy = {
      doc: { content: "block+" },
      paragraph: {
        content: "inline*",
        group: "block",
        parseDOM: [{ tag: "p" }],
        toDOM() {
          return U8;
        },
      },
      blockquote: {
        content: "block+",
        group: "block",
        defining: !0,
        parseDOM: [{ tag: "blockquote" }],
        toDOM() {
          return j8;
        },
      },
      horizontal_rule: {
        group: "block",
        parseDOM: [{ tag: "hr" }],
        toDOM() {
          return W8;
        },
      },
      heading: {
        attrs: { level: { default: 1, validate: "number" } },
        content: "inline*",
        group: "block",
        defining: !0,
        parseDOM: [
          { tag: "h1", attrs: { level: 1 } },
          { tag: "h2", attrs: { level: 2 } },
          { tag: "h3", attrs: { level: 3 } },
          { tag: "h4", attrs: { level: 4 } },
          { tag: "h5", attrs: { level: 5 } },
          { tag: "h6", attrs: { level: 6 } },
        ],
        toDOM(t) {
          return ["h" + t.attrs.level, 0];
        },
      },
      code_block: {
        content: "text*",
        marks: "",
        group: "block",
        code: !0,
        defining: !0,
        parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
        toDOM() {
          return q8;
        },
      },
      text: { group: "inline" },
      image: {
        inline: !0,
        attrs: {
          src: { validate: "string" },
          alt: { default: null, validate: "string|null" },
          title: { default: null, validate: "string|null" },
        },
        group: "inline",
        draggable: !0,
        parseDOM: [
          {
            tag: "img[src]",
            getAttrs(t) {
              return {
                src: t.getAttribute("src"),
                title: t.getAttribute("title"),
                alt: t.getAttribute("alt"),
              };
            },
          },
        ],
        toDOM(t) {
          let { src: e, alt: n, title: r } = t.attrs;
          return ["img", { src: e, alt: n, title: r }];
        },
      },
      hard_break: {
        inline: !0,
        group: "inline",
        selectable: !1,
        parseDOM: [{ tag: "br" }],
        toDOM() {
          return K8;
        },
      },
    },
    G8 = ["em", 0],
    J8 = ["strong", 0],
    Y8 = ["code", 0],
    vy = {
      link: {
        attrs: {
          href: { validate: "string" },
          title: { default: null, validate: "string|null" },
        },
        inclusive: !1,
        parseDOM: [
          {
            tag: "a[href]",
            getAttrs(t) {
              return {
                href: t.getAttribute("href"),
                title: t.getAttribute("title"),
              };
            },
          },
        ],
        toDOM(t) {
          let { href: e, title: n } = t.attrs;
          return ["a", { href: e, title: n }, 0];
        },
      },
      em: {
        parseDOM: [
          { tag: "i" },
          { tag: "em" },
          { style: "font-style=italic" },
          { style: "font-style=normal", clearMark: (t) => t.type.name == "em" },
        ],
        toDOM() {
          return G8;
        },
      },
      strong: {
        parseDOM: [
          { tag: "strong" },
          { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
          {
            style: "font-weight=400",
            clearMark: (t) => t.type.name == "strong",
          },
          {
            style: "font-weight",
            getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
          },
        ],
        toDOM() {
          return J8;
        },
      },
      code: {
        parseDOM: [{ tag: "code" }],
        toDOM() {
          return Y8;
        },
      },
    },
    X8 = new _s({ nodes: Cy, marks: vy }),
    Z8 = ["ol", 0],
    Q8 = ["ul", 0],
    eT = ["li", 0],
    Ey = {
      attrs: { order: { default: 1, validate: "number" } },
      parseDOM: [
        {
          tag: "ol",
          getAttrs(t) {
            return {
              order: t.hasAttribute("start") ? +t.getAttribute("start") : 1,
            };
          },
        },
      ],
      toDOM(t) {
        return t.attrs.order == 1 ? Z8 : ["ol", { start: t.attrs.order }, 0];
      },
    },
    Ay = {
      parseDOM: [{ tag: "ul" }],
      toDOM() {
        return Q8;
      },
    },
    Sy = {
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return eT;
      },
      defining: !0,
    };
  function Bp(t, e) {
    let n = {};
    for (let r in t) n[r] = t[r];
    for (let r in e) n[r] = e[r];
    return n;
  }
  function tT(t, e, n) {
    return t.append({
      ordered_list: Bp(Ey, { content: "list_item+", group: n }),
      bullet_list: Bp(Ay, { content: "list_item+", group: n }),
      list_item: Bp(Sy, { content: e }),
    });
  }
  function My(t, e = null) {
    return function (n, r) {
      let { $from: o, $to: i } = n.selection,
        s = o.blockRange(i),
        a = !1,
        l = s;
      if (!s) return !1;
      if (
        s.depth >= 2 &&
        o.node(s.depth - 1).type.compatibleContent(t) &&
        s.startIndex == 0
      ) {
        if (o.index(s.depth - 1) == 0) return !1;
        let d = n.doc.resolve(s.start - 2);
        (l = new bs(d, d, s.depth)),
          s.endIndex < s.parent.childCount &&
            (s = new bs(o, n.doc.resolve(i.end(s.depth)), s.depth)),
          (a = !0);
      }
      let c = ws(l, t, e, s);
      return c ? (r && r(nT(n.tr, s, c, a, t).scrollIntoView()), !0) : !1;
    };
  }
  function nT(t, e, n, r, o) {
    let i = D.empty;
    for (let d = n.length - 1; d >= 0; d--)
      i = D.from(n[d].type.create(n[d].attrs, i));
    t.step(
      new Qe(
        e.start - (r ? 2 : 0),
        e.end,
        e.start,
        e.end,
        new z(i, 0, 0),
        n.length,
        !0
      )
    );
    let s = 0;
    for (let d = 0; d < n.length; d++) n[d].type == o && (s = d + 1);
    let a = n.length - s,
      l = e.start + n.length - (r ? 2 : 0),
      c = e.parent;
    for (let d = e.startIndex, f = e.endIndex, p = !0; d < f; d++, p = !1)
      !p && En(t.doc, l, a) && (t.split(l, a), (l += 2 * a)),
        (l += c.child(d).nodeSize);
    return t;
  }
  function Ty(t, e) {
    return function (n, r) {
      let { $from: o, $to: i, node: s } = n.selection;
      if ((s && s.isBlock) || o.depth < 2 || !o.sameParent(i)) return !1;
      let a = o.node(-1);
      if (a.type != t) return !1;
      if (
        o.parent.content.size == 0 &&
        o.node(-1).childCount == o.indexAfter(-1)
      ) {
        if (
          o.depth == 3 ||
          o.node(-3).type != t ||
          o.index(-2) != o.node(-2).childCount - 1
        )
          return !1;
        if (r) {
          let f = D.empty,
            p = o.index(-1) ? 1 : o.index(-2) ? 2 : 3;
          for (let y = o.depth - p; y >= o.depth - 3; y--)
            f = D.from(o.node(y).copy(f));
          let h =
            o.indexAfter(-1) < o.node(-2).childCount
              ? 1
              : o.indexAfter(-2) < o.node(-3).childCount
              ? 2
              : 3;
          f = f.append(D.from(t.createAndFill()));
          let m = o.before(o.depth - (p - 1)),
            g = n.tr.replace(m, o.after(-h), new z(f, 4 - p, 0)),
            b = -1;
          g.doc.nodesBetween(m, g.doc.content.size, (y, x) => {
            if (b > -1) return !1;
            y.isTextblock && y.content.size == 0 && (b = x + 1);
          }),
            b > -1 && g.setSelection(J.near(g.doc.resolve(b))),
            r(g.scrollIntoView());
        }
        return !0;
      }
      let l = i.pos == o.end() ? a.contentMatchAt(0).defaultType : null,
        c = n.tr.delete(o.pos, i.pos),
        d = l ? [e ? { type: t, attrs: e } : null, { type: l }] : void 0;
      return En(c.doc, o.pos, 2, d)
        ? (r && r(c.split(o.pos, 2, d).scrollIntoView()), !0)
        : !1;
    };
  }
  function rT(t, e) {
    let n = Ty(t, e);
    return (r, o) =>
      n(
        r,
        o &&
          ((i) => {
            let s =
              r.storedMarks ||
              (r.selection.$to.parentOffset && r.selection.$from.marks());
            s && i.ensureMarks(s), o(i);
          })
      );
  }
  function Ny(t) {
    return function (e, n) {
      let { $from: r, $to: o } = e.selection,
        i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t);
      return i
        ? n
          ? r.node(i.depth - 1).type == t
            ? oT(e, n, t, i)
            : iT(e, n, i)
          : !0
        : !1;
    };
  }
  function oT(t, e, n, r) {
    let o = t.tr,
      i = r.end,
      s = r.$to.end(r.depth);
    i < s &&
      (o.step(
        new Qe(
          i - 1,
          s,
          i,
          s,
          new z(D.from(n.create(null, r.parent.copy())), 1, 0),
          1,
          !0
        )
      ),
      (r = new bs(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth)));
    const a = Lo(r);
    if (a == null) return !1;
    o.lift(r, a);
    let l = o.mapping.map(i, -1) - 1;
    return An(o.doc, l) && o.join(l), e(o.scrollIntoView()), !0;
  }
  function iT(t, e, n) {
    let r = t.tr,
      o = n.parent;
    for (let h = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
      (h -= o.child(m).nodeSize), r.delete(h - 1, h + 1);
    let i = r.doc.resolve(n.start),
      s = i.nodeAfter;
    if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1;
    let a = n.startIndex == 0,
      l = n.endIndex == o.childCount,
      c = i.node(-1),
      d = i.index(-1);
    if (
      !c.canReplace(
        d + (a ? 0 : 1),
        d + 1,
        s.content.append(l ? D.empty : D.from(o))
      )
    )
      return !1;
    let f = i.pos,
      p = f + s.nodeSize;
    return (
      r.step(
        new Qe(
          f - (a ? 1 : 0),
          p + (l ? 1 : 0),
          f + 1,
          p - 1,
          new z(
            (a ? D.empty : D.from(o.copy(D.empty))).append(
              l ? D.empty : D.from(o.copy(D.empty))
            ),
            a ? 0 : 1,
            l ? 0 : 1
          ),
          a ? 0 : 1
        )
      ),
      e(r.scrollIntoView()),
      !0
    );
  }
  function Oy(t) {
    return function (e, n) {
      let { $from: r, $to: o } = e.selection,
        i = r.blockRange(o, (c) => c.childCount > 0 && c.firstChild.type == t);
      if (!i) return !1;
      let s = i.startIndex;
      if (s == 0) return !1;
      let a = i.parent,
        l = a.child(s - 1);
      if (l.type != t) return !1;
      if (n) {
        let c = l.lastChild && l.lastChild.type == a.type,
          d = D.from(c ? t.create() : null),
          f = new z(
            D.from(t.create(null, D.from(a.type.create(null, d)))),
            c ? 3 : 1,
            0
          ),
          p = i.start,
          h = i.end;
        n(
          e.tr.step(new Qe(p - (c ? 3 : 1), h, p, h, f, 1, !0)).scrollIntoView()
        );
      }
      return !0;
    };
  }
  var Pp, $p;
  if (typeof WeakMap < "u") {
    let t = new WeakMap();
    (Pp = (e) => t.get(e)), ($p = (e, n) => (t.set(e, n), n));
  } else {
    const t = [];
    let n = 0;
    (Pp = (r) => {
      for (let o = 0; o < t.length; o += 2) if (t[o] == r) return t[o + 1];
    }),
      ($p = (r, o) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = o)));
  }
  var me = class {
    constructor(t, e, n, r) {
      (this.width = t), (this.height = e), (this.map = n), (this.problems = r);
    }
    findCell(t) {
      for (let e = 0; e < this.map.length; e++) {
        const n = this.map[e];
        if (n != t) continue;
        const r = e % this.width,
          o = (e / this.width) | 0;
        let i = r + 1,
          s = o + 1;
        for (let a = 1; i < this.width && this.map[e + a] == n; a++) i++;
        for (
          let a = 1;
          s < this.height && this.map[e + this.width * a] == n;
          a++
        )
          s++;
        return { left: r, top: o, right: i, bottom: s };
      }
      throw new RangeError(`No cell with offset ${t} found`);
    }
    colCount(t) {
      for (let e = 0; e < this.map.length; e++)
        if (this.map[e] == t) return e % this.width;
      throw new RangeError(`No cell with offset ${t} found`);
    }
    nextCell(t, e, n) {
      const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
      return e == "horiz"
        ? (n < 0 ? r == 0 : o == this.width)
          ? null
          : this.map[i * this.width + (n < 0 ? r - 1 : o)]
        : (n < 0 ? i == 0 : s == this.height)
        ? null
        : this.map[r + this.width * (n < 0 ? i - 1 : s)];
    }
    rectBetween(t, e) {
      const { left: n, right: r, top: o, bottom: i } = this.findCell(t),
        { left: s, right: a, top: l, bottom: c } = this.findCell(e);
      return {
        left: Math.min(n, s),
        top: Math.min(o, l),
        right: Math.max(r, a),
        bottom: Math.max(i, c),
      };
    }
    cellsInRect(t) {
      const e = [],
        n = {};
      for (let r = t.top; r < t.bottom; r++)
        for (let o = t.left; o < t.right; o++) {
          const i = r * this.width + o,
            s = this.map[i];
          n[s] ||
            ((n[s] = !0),
            !(
              (o == t.left && o && this.map[i - 1] == s) ||
              (r == t.top && r && this.map[i - this.width] == s)
            ) && e.push(s));
        }
      return e;
    }
    positionAt(t, e, n) {
      for (let r = 0, o = 0; ; r++) {
        const i = o + n.child(r).nodeSize;
        if (r == t) {
          let s = e + t * this.width;
          const a = (t + 1) * this.width;
          for (; s < a && this.map[s] < o; ) s++;
          return s == a ? i - 1 : this.map[s];
        }
        o = i;
      }
    }
    static get(t) {
      return Pp(t) || $p(t, sT(t));
    }
  };
  function sT(t) {
    if (t.type.spec.tableRole != "table")
      throw new RangeError("Not a table node: " + t.type.name);
    const e = aT(t),
      n = t.childCount,
      r = [];
    let o = 0,
      i = null;
    const s = [];
    for (let c = 0, d = e * n; c < d; c++) r[c] = 0;
    for (let c = 0, d = 0; c < n; c++) {
      const f = t.child(c);
      d++;
      for (let m = 0; ; m++) {
        for (; o < r.length && r[o] != 0; ) o++;
        if (m == f.childCount) break;
        const g = f.child(m),
          { colspan: b, rowspan: y, colwidth: x } = g.attrs;
        for (let w = 0; w < y; w++) {
          if (w + c >= n) {
            (i || (i = [])).push({
              type: "overlong_rowspan",
              pos: d,
              n: y - w,
            });
            break;
          }
          const _ = o + w * e;
          for (let v = 0; v < b; v++) {
            r[_ + v] == 0
              ? (r[_ + v] = d)
              : (i || (i = [])).push({
                  type: "collision",
                  row: c,
                  pos: d,
                  n: b - v,
                });
            const C = x && x[v];
            if (C) {
              const S = ((_ + v) % e) * 2,
                N = s[S];
              N == null || (N != C && s[S + 1] == 1)
                ? ((s[S] = C), (s[S + 1] = 1))
                : N == C && s[S + 1]++;
            }
          }
        }
        (o += b), (d += g.nodeSize);
      }
      const p = (c + 1) * e;
      let h = 0;
      for (; o < p; ) r[o++] == 0 && h++;
      h && (i || (i = [])).push({ type: "missing", row: c, n: h }), d++;
    }
    const a = new me(e, n, r, i);
    let l = !1;
    for (let c = 0; !l && c < s.length; c += 2)
      s[c] != null && s[c + 1] < n && (l = !0);
    return l && lT(a, s, t), a;
  }
  function aT(t) {
    let e = -1,
      n = !1;
    for (let r = 0; r < t.childCount; r++) {
      const o = t.child(r);
      let i = 0;
      if (n)
        for (let s = 0; s < r; s++) {
          const a = t.child(s);
          for (let l = 0; l < a.childCount; l++) {
            const c = a.child(l);
            s + c.attrs.rowspan > r && (i += c.attrs.colspan);
          }
        }
      for (let s = 0; s < o.childCount; s++) {
        const a = o.child(s);
        (i += a.attrs.colspan), a.attrs.rowspan > 1 && (n = !0);
      }
      e == -1 ? (e = i) : e != i && (e = Math.max(e, i));
    }
    return e;
  }
  function lT(t, e, n) {
    t.problems || (t.problems = []);
    const r = {};
    for (let o = 0; o < t.map.length; o++) {
      const i = t.map[o];
      if (r[i]) continue;
      r[i] = !0;
      const s = n.nodeAt(i);
      if (!s) throw new RangeError(`No cell with offset ${i} found`);
      let a = null;
      const l = s.attrs;
      for (let c = 0; c < l.colspan; c++) {
        const d = (o + c) % t.width,
          f = e[d * 2];
        f != null &&
          (!l.colwidth || l.colwidth[c] != f) &&
          ((a || (a = cT(l)))[c] = f);
      }
      a &&
        t.problems.unshift({ type: "colwidth mismatch", pos: i, colwidth: a });
    }
  }
  function cT(t) {
    if (t.colwidth) return t.colwidth.slice();
    const e = [];
    for (let n = 0; n < t.colspan; n++) e.push(0);
    return e;
  }
  function Ry(t, e) {
    if (typeof t == "string") return {};
    const n = t.getAttribute("data-colwidth"),
      r =
        n && /^\d+(,\d+)*$/.test(n) ? n.split(",").map((s) => Number(s)) : null,
      o = Number(t.getAttribute("colspan") || 1),
      i = {
        colspan: o,
        rowspan: Number(t.getAttribute("rowspan") || 1),
        colwidth: r && r.length == o ? r : null,
      };
    for (const s in e) {
      const a = e[s].getFromDOM,
        l = a && a(t);
      l != null && (i[s] = l);
    }
    return i;
  }
  function Dy(t, e) {
    const n = {};
    t.attrs.colspan != 1 && (n.colspan = t.attrs.colspan),
      t.attrs.rowspan != 1 && (n.rowspan = t.attrs.rowspan),
      t.attrs.colwidth && (n["data-colwidth"] = t.attrs.colwidth.join(","));
    for (const r in e) {
      const o = e[r].setDOMAttr;
      o && o(t.attrs[r], n);
    }
    return n;
  }
  function uT(t) {
    const e = t.cellAttributes || {},
      n = {
        colspan: { default: 1 },
        rowspan: { default: 1 },
        colwidth: { default: null },
      };
    for (const r in e) n[r] = { default: e[r].default };
    return {
      table: {
        content: "table_row+",
        tableRole: "table",
        isolating: !0,
        group: t.tableGroup,
        parseDOM: [{ tag: "table" }],
        toDOM() {
          return ["table", ["tbody", 0]];
        },
      },
      table_row: {
        content: "(table_cell | table_header)*",
        tableRole: "row",
        parseDOM: [{ tag: "tr" }],
        toDOM() {
          return ["tr", 0];
        },
      },
      table_cell: {
        content: t.cellContent,
        attrs: n,
        tableRole: "cell",
        isolating: !0,
        parseDOM: [{ tag: "td", getAttrs: (r) => Ry(r, e) }],
        toDOM(r) {
          return ["td", Dy(r, e), 0];
        },
      },
      table_header: {
        content: t.cellContent,
        attrs: n,
        tableRole: "header_cell",
        isolating: !0,
        parseDOM: [{ tag: "th", getAttrs: (r) => Ry(r, e) }],
        toDOM(r) {
          return ["th", Dy(r, e), 0];
        },
      },
    };
  }
  function ct(t) {
    let e = t.cached.tableNodeTypes;
    if (!e) {
      e = t.cached.tableNodeTypes = {};
      for (const n in t.nodes) {
        const r = t.nodes[n],
          o = r.spec.tableRole;
        o && (e[o] = r);
      }
    }
    return e;
  }
  var gr = new de("selectingCells");
  function Uo(t) {
    for (let e = t.depth - 1; e > 0; e--)
      if (t.node(e).type.spec.tableRole == "row")
        return t.node(0).resolve(t.before(e + 1));
    return null;
  }
  function dT(t) {
    for (let e = t.depth; e > 0; e--) {
      const n = t.node(e).type.spec.tableRole;
      if (n === "cell" || n === "header_cell") return t.node(e);
    }
    return null;
  }
  function sn(t) {
    const e = t.selection.$head;
    for (let n = e.depth; n > 0; n--)
      if (e.node(n).type.spec.tableRole == "row") return !0;
    return !1;
  }
  function ea(t) {
    const e = t.selection;
    if ("$anchorCell" in e && e.$anchorCell)
      return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
    if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
      return e.$anchor;
    const n = Uo(e.$head) || Ly(e.$head);
    if (n) return n;
    throw new RangeError(`No cell found around position ${e.head}`);
  }
  function Ly(t) {
    for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
      const r = e.type.spec.tableRole;
      if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
    }
    for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
      const r = e.type.spec.tableRole;
      if (r == "cell" || r == "header_cell")
        return t.doc.resolve(n - e.nodeSize);
    }
  }
  function lc(t) {
    return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
  }
  function Iy(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
  }
  function cc(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
  }
  function fT(t) {
    return me.get(t.node(-1)).findCell(t.pos - t.start(-1));
  }
  function pT(t) {
    return me.get(t.node(-1)).colCount(t.pos - t.start(-1));
  }
  function Fp(t, e, n) {
    const r = t.node(-1),
      o = me.get(r),
      i = t.start(-1),
      s = o.nextCell(t.pos - i, e, n);
    return s == null ? null : t.node(0).resolve(i + s);
  }
  function eo(t, e, n = 1) {
    const r = { ...t, colspan: t.colspan - n };
    return (
      r.colwidth &&
        ((r.colwidth = r.colwidth.slice()),
        r.colwidth.splice(e, n),
        r.colwidth.some((o) => o > 0) || (r.colwidth = null)),
      r
    );
  }
  function Hp(t, e, n = 1) {
    const r = { ...t, colspan: t.colspan + n };
    if (r.colwidth) {
      r.colwidth = r.colwidth.slice();
      for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
    }
    return r;
  }
  function By(t, e, n) {
    const r = ct(e.type.schema).header_cell;
    for (let o = 0; o < t.height; o++)
      if (e.nodeAt(t.map[n + o * t.width]).type != r) return !1;
    return !0;
  }
  var ke = class Ar extends J {
    constructor(e, n = e) {
      const r = e.node(-1),
        o = me.get(r),
        i = e.start(-1),
        s = o.rectBetween(e.pos - i, n.pos - i),
        a = e.node(0),
        l = o.cellsInRect(s).filter((d) => d != n.pos - i);
      l.unshift(n.pos - i);
      const c = l.map((d) => {
        const f = r.nodeAt(d);
        if (!f) throw RangeError(`No cell with offset ${d} found`);
        const p = i + d + 1;
        return new As(a.resolve(p), a.resolve(p + f.content.size));
      });
      super(c[0].$from, c[0].$to, c),
        (this.$anchorCell = e),
        (this.$headCell = n);
    }
    map(e, n) {
      const r = e.resolve(n.map(this.$anchorCell.pos)),
        o = e.resolve(n.map(this.$headCell.pos));
      if (lc(r) && lc(o) && cc(r, o)) {
        const i = this.$anchorCell.node(-1) != r.node(-1);
        return i && this.isRowSelection()
          ? Ar.rowSelection(r, o)
          : i && this.isColSelection()
          ? Ar.colSelection(r, o)
          : new Ar(r, o);
      }
      return U.between(r, o);
    }
    content() {
      const e = this.$anchorCell.node(-1),
        n = me.get(e),
        r = this.$anchorCell.start(-1),
        o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
        i = {},
        s = [];
      for (let l = o.top; l < o.bottom; l++) {
        const c = [];
        for (let d = l * n.width + o.left, f = o.left; f < o.right; f++, d++) {
          const p = n.map[d];
          if (i[p]) continue;
          i[p] = !0;
          const h = n.findCell(p);
          let m = e.nodeAt(p);
          if (!m) throw RangeError(`No cell with offset ${p} found`);
          const g = o.left - h.left,
            b = h.right - o.right;
          if (g > 0 || b > 0) {
            let y = m.attrs;
            if (
              (g > 0 && (y = eo(y, 0, g)),
              b > 0 && (y = eo(y, y.colspan - b, b)),
              h.left < o.left)
            ) {
              if (((m = m.type.createAndFill(y)), !m))
                throw RangeError(
                  `Could not create cell with attrs ${JSON.stringify(y)}`
                );
            } else m = m.type.create(y, m.content);
          }
          if (h.top < o.top || h.bottom > o.bottom) {
            const y = {
              ...m.attrs,
              rowspan: Math.min(h.bottom, o.bottom) - Math.max(h.top, o.top),
            };
            h.top < o.top
              ? (m = m.type.createAndFill(y))
              : (m = m.type.create(y, m.content));
          }
          c.push(m);
        }
        s.push(e.child(l).copy(D.from(c)));
      }
      const a = this.isColSelection() && this.isRowSelection() ? e : s;
      return new z(D.from(a), 1, 1);
    }
    replace(e, n = z.empty) {
      const r = e.steps.length,
        o = this.ranges;
      for (let s = 0; s < o.length; s++) {
        const { $from: a, $to: l } = o[s],
          c = e.mapping.slice(r);
        e.replace(c.map(a.pos), c.map(l.pos), s ? z.empty : n);
      }
      const i = J.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
      i && e.setSelection(i);
    }
    replaceWith(e, n) {
      this.replace(e, new z(D.from(n), 0, 0));
    }
    forEachCell(e) {
      const n = this.$anchorCell.node(-1),
        r = me.get(n),
        o = this.$anchorCell.start(-1),
        i = r.cellsInRect(
          r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o)
        );
      for (let s = 0; s < i.length; s++) e(n.nodeAt(i[s]), o + i[s]);
    }
    isColSelection() {
      const e = this.$anchorCell.index(-1),
        n = this.$headCell.index(-1);
      if (Math.min(e, n) > 0) return !1;
      const r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
        o = n + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(r, o) == this.$headCell.node(-1).childCount;
    }
    static colSelection(e, n = e) {
      const r = e.node(-1),
        o = me.get(r),
        i = e.start(-1),
        s = o.findCell(e.pos - i),
        a = o.findCell(n.pos - i),
        l = e.node(0);
      return (
        s.top <= a.top
          ? (s.top > 0 && (e = l.resolve(i + o.map[s.left])),
            a.bottom < o.height &&
              (n = l.resolve(
                i + o.map[o.width * (o.height - 1) + a.right - 1]
              )))
          : (a.top > 0 && (n = l.resolve(i + o.map[a.left])),
            s.bottom < o.height &&
              (e = l.resolve(
                i + o.map[o.width * (o.height - 1) + s.right - 1]
              ))),
        new Ar(e, n)
      );
    }
    isRowSelection() {
      const e = this.$anchorCell.node(-1),
        n = me.get(e),
        r = this.$anchorCell.start(-1),
        o = n.colCount(this.$anchorCell.pos - r),
        i = n.colCount(this.$headCell.pos - r);
      if (Math.min(o, i) > 0) return !1;
      const s = o + this.$anchorCell.nodeAfter.attrs.colspan,
        a = i + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(s, a) == n.width;
    }
    eq(e) {
      return (
        e instanceof Ar &&
        e.$anchorCell.pos == this.$anchorCell.pos &&
        e.$headCell.pos == this.$headCell.pos
      );
    }
    static rowSelection(e, n = e) {
      const r = e.node(-1),
        o = me.get(r),
        i = e.start(-1),
        s = o.findCell(e.pos - i),
        a = o.findCell(n.pos - i),
        l = e.node(0);
      return (
        s.left <= a.left
          ? (s.left > 0 && (e = l.resolve(i + o.map[s.top * o.width])),
            a.right < o.width &&
              (n = l.resolve(i + o.map[o.width * (a.top + 1) - 1])))
          : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])),
            s.right < o.width &&
              (e = l.resolve(i + o.map[o.width * (s.top + 1) - 1]))),
        new Ar(e, n)
      );
    }
    toJSON() {
      return {
        type: "cell",
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos,
      };
    }
    static fromJSON(e, n) {
      return new Ar(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r = n) {
      return new Ar(e.resolve(n), e.resolve(r));
    }
    getBookmark() {
      return new Py(this.$anchorCell.pos, this.$headCell.pos);
    }
  };
  (ke.prototype.visible = !1), J.jsonID("cell", ke);
  var Py = class Fx {
    constructor(e, n) {
      (this.anchor = e), (this.head = n);
    }
    map(e) {
      return new Fx(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      const n = e.resolve(this.anchor),
        r = e.resolve(this.head);
      return n.parent.type.spec.tableRole == "row" &&
        r.parent.type.spec.tableRole == "row" &&
        n.index() < n.parent.childCount &&
        r.index() < r.parent.childCount &&
        cc(n, r)
        ? new ke(n, r)
        : J.near(r, 1);
    }
  };
  function hT(t) {
    if (!(t.selection instanceof ke)) return null;
    const e = [];
    return (
      t.selection.forEachCell((n, r) => {
        e.push(Te.node(r, r + n.nodeSize, { class: "selectedCell" }));
      }),
      ue.create(t.doc, e)
    );
  }
  function mT({ $from: t, $to: e }) {
    if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
    let n = t.pos,
      r = e.pos,
      o = t.depth;
    for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++);
    for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--);
    return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
  }
  function gT({ $from: t, $to: e }) {
    let n, r;
    for (let o = t.depth; o > 0; o--) {
      const i = t.node(o);
      if (
        i.type.spec.tableRole === "cell" ||
        i.type.spec.tableRole === "header_cell"
      ) {
        n = i;
        break;
      }
    }
    for (let o = e.depth; o > 0; o--) {
      const i = e.node(o);
      if (
        i.type.spec.tableRole === "cell" ||
        i.type.spec.tableRole === "header_cell"
      ) {
        r = i;
        break;
      }
    }
    return n !== r && e.parentOffset === 0;
  }
  function bT(t, e, n) {
    const r = (e || t).selection,
      o = (e || t).doc;
    let i, s;
    if (r instanceof K && (s = r.node.type.spec.tableRole)) {
      if (s == "cell" || s == "header_cell") i = ke.create(o, r.from);
      else if (s == "row") {
        const a = o.resolve(r.from + 1);
        i = ke.rowSelection(a, a);
      } else if (!n) {
        const a = me.get(r.node),
          l = r.from + 1,
          c = l + a.map[a.width * a.height - 1];
        i = ke.create(o, l + 1, c);
      }
    } else
      r instanceof U && mT(r)
        ? (i = U.create(o, r.from))
        : r instanceof U &&
          gT(r) &&
          (i = U.create(o, r.$from.start(), r.$from.end()));
    return i && (e || (e = t.tr)).setSelection(i), e;
  }
  var $y = new de("fix-tables");
  function Fy(t, e, n, r) {
    const o = t.childCount,
      i = e.childCount;
    e: for (let s = 0, a = 0; s < i; s++) {
      const l = e.child(s);
      for (let c = a, d = Math.min(o, s + 3); c < d; c++)
        if (t.child(c) == l) {
          (a = c + 1), (n += l.nodeSize);
          continue e;
        }
      r(l, n),
        a < o && t.child(a).sameMarkup(l)
          ? Fy(t.child(a), l, n + 1, r)
          : l.nodesBetween(0, l.content.size, r, n + 1),
        (n += l.nodeSize);
    }
  }
  function zp(t, e) {
    let n;
    const r = (o, i) => {
      o.type.spec.tableRole == "table" && (n = yT(t, o, i, n));
    };
    return (
      e ? e.doc != t.doc && Fy(e.doc, t.doc, 0, r) : t.doc.descendants(r), n
    );
  }
  function yT(t, e, n, r) {
    const o = me.get(e);
    if (!o.problems) return r;
    r || (r = t.tr);
    const i = [];
    for (let l = 0; l < o.height; l++) i.push(0);
    for (let l = 0; l < o.problems.length; l++) {
      const c = o.problems[l];
      if (c.type == "collision") {
        const d = e.nodeAt(c.pos);
        if (!d) continue;
        const f = d.attrs;
        for (let p = 0; p < f.rowspan; p++) i[c.row + p] += c.n;
        r.setNodeMarkup(
          r.mapping.map(n + 1 + c.pos),
          null,
          eo(f, f.colspan - c.n, c.n)
        );
      } else if (c.type == "missing") i[c.row] += c.n;
      else if (c.type == "overlong_rowspan") {
        const d = e.nodeAt(c.pos);
        if (!d) continue;
        r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
          ...d.attrs,
          rowspan: d.attrs.rowspan - c.n,
        });
      } else if (c.type == "colwidth mismatch") {
        const d = e.nodeAt(c.pos);
        if (!d) continue;
        r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
          ...d.attrs,
          colwidth: c.colwidth,
        });
      }
    }
    let s, a;
    for (let l = 0; l < i.length; l++) i[l] && (s == null && (s = l), (a = l));
    for (let l = 0, c = n + 1; l < o.height; l++) {
      const d = e.child(l),
        f = c + d.nodeSize,
        p = i[l];
      if (p > 0) {
        let h = "cell";
        d.firstChild && (h = d.firstChild.type.spec.tableRole);
        const m = [];
        for (let b = 0; b < p; b++) {
          const y = ct(t.schema)[h].createAndFill();
          y && m.push(y);
        }
        const g = (l == 0 || s == l - 1) && a == l ? c + 1 : f - 1;
        r.insert(r.mapping.map(g), m);
      }
      c = f;
    }
    return r.setMeta($y, { fixTables: !0 });
  }
  function an(t) {
    const e = t.selection,
      n = ea(t),
      r = n.node(-1),
      o = n.start(-1),
      i = me.get(r);
    return {
      ...(e instanceof ke
        ? i.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o)
        : i.findCell(n.pos - o)),
      tableStart: o,
      map: i,
      table: r,
    };
  }
  function Vp(t, { map: e, tableStart: n, table: r }, o) {
    let i = o > 0 ? -1 : 0;
    By(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
    for (let s = 0; s < e.height; s++) {
      const a = s * e.width + o;
      if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
        const l = e.map[a],
          c = r.nodeAt(l);
        t.setNodeMarkup(
          t.mapping.map(n + l),
          null,
          Hp(c.attrs, o - e.colCount(l))
        ),
          (s += c.attrs.rowspan - 1);
      } else {
        const l =
            i == null ? ct(r.type.schema).cell : r.nodeAt(e.map[a + i]).type,
          c = e.positionAt(s, o, r);
        t.insert(t.mapping.map(n + c), l.createAndFill());
      }
    }
    return t;
  }
  function Hy(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t);
      e(Vp(t.tr, n, n.left));
    }
    return !0;
  }
  function Up(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t);
      e(Vp(t.tr, n, n.right));
    }
    return !0;
  }
  function zy(t, { map: e, table: n, tableStart: r }, o) {
    const i = t.mapping.maps.length;
    for (let s = 0; s < e.height; ) {
      const a = s * e.width + o,
        l = e.map[a],
        c = n.nodeAt(l),
        d = c.attrs;
      if (
        (o > 0 && e.map[a - 1] == l) ||
        (o < e.width - 1 && e.map[a + 1] == l)
      )
        t.setNodeMarkup(
          t.mapping.slice(i).map(r + l),
          null,
          eo(d, o - e.colCount(l))
        );
      else {
        const f = t.mapping.slice(i).map(r + l);
        t.delete(f, f + c.nodeSize);
      }
      s += d.rowspan;
    }
  }
  function Vy(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t),
        r = t.tr;
      if (n.left == 0 && n.right == n.map.width) return !1;
      for (let o = n.right - 1; zy(r, n, o), o != n.left; o--) {
        const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
        if (!i) throw RangeError("No table found");
        (n.table = i), (n.map = me.get(i));
      }
      e(r);
    }
    return !0;
  }
  function Uy(t, e, n) {
    var r;
    const o = ct(e.type.schema).header_cell;
    for (let i = 0; i < t.width; i++)
      if (
        ((r = e.nodeAt(t.map[i + n * t.width])) == null ? void 0 : r.type) != o
      )
        return !1;
    return !0;
  }
  function jp(t, { map: e, tableStart: n, table: r }, o) {
    var i;
    let s = n;
    for (let c = 0; c < o; c++) s += r.child(c).nodeSize;
    const a = [];
    let l = o > 0 ? -1 : 0;
    Uy(e, r, o + l) && (l = o == 0 || o == e.height ? null : 0);
    for (let c = 0, d = e.width * o; c < e.width; c++, d++)
      if (o > 0 && o < e.height && e.map[d] == e.map[d - e.width]) {
        const f = e.map[d],
          p = r.nodeAt(f).attrs;
        t.setNodeMarkup(n + f, null, { ...p, rowspan: p.rowspan + 1 }),
          (c += p.colspan - 1);
      } else {
        const f =
            l == null
              ? ct(r.type.schema).cell
              : (i = r.nodeAt(e.map[d + l * e.width])) == null
              ? void 0
              : i.type,
          p = f == null ? void 0 : f.createAndFill();
        p && a.push(p);
      }
    return t.insert(s, ct(r.type.schema).row.create(null, a)), t;
  }
  function jy(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t);
      e(jp(t.tr, n, n.top));
    }
    return !0;
  }
  function Wp(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t);
      e(jp(t.tr, n, n.bottom));
    }
    return !0;
  }
  function Wy(t, { map: e, table: n, tableStart: r }, o) {
    let i = 0;
    for (let c = 0; c < o; c++) i += n.child(c).nodeSize;
    const s = i + n.child(o).nodeSize,
      a = t.mapping.maps.length;
    t.delete(i + r, s + r);
    const l = new Set();
    for (let c = 0, d = o * e.width; c < e.width; c++, d++) {
      const f = e.map[d];
      if (!l.has(f)) {
        if ((l.add(f), o > 0 && f == e.map[d - e.width])) {
          const p = n.nodeAt(f).attrs;
          t.setNodeMarkup(t.mapping.slice(a).map(f + r), null, {
            ...p,
            rowspan: p.rowspan - 1,
          }),
            (c += p.colspan - 1);
        } else if (o < e.height && f == e.map[d + e.width]) {
          const p = n.nodeAt(f),
            h = p.attrs,
            m = p.type.create(
              { ...h, rowspan: p.attrs.rowspan - 1 },
              p.content
            ),
            g = e.positionAt(o + 1, c, n);
          t.insert(t.mapping.slice(a).map(r + g), m), (c += h.colspan - 1);
        }
      }
    }
  }
  function qy(t, e) {
    if (!sn(t)) return !1;
    if (e) {
      const n = an(t),
        r = t.tr;
      if (n.top == 0 && n.bottom == n.map.height) return !1;
      for (let o = n.bottom - 1; Wy(r, n, o), o != n.top; o--) {
        const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
        if (!i) throw RangeError("No table found");
        (n.table = i), (n.map = me.get(n.table));
      }
      e(r);
    }
    return !0;
  }
  function Ky(t) {
    const e = t.content;
    return (
      e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0
    );
  }
  function _T({ width: t, height: e, map: n }, r) {
    let o = r.top * t + r.left,
      i = o,
      s = (r.bottom - 1) * t + r.left,
      a = o + (r.right - r.left - 1);
    for (let l = r.top; l < r.bottom; l++) {
      if ((r.left > 0 && n[i] == n[i - 1]) || (r.right < t && n[a] == n[a + 1]))
        return !0;
      (i += t), (a += t);
    }
    for (let l = r.left; l < r.right; l++) {
      if ((r.top > 0 && n[o] == n[o - t]) || (r.bottom < e && n[s] == n[s + t]))
        return !0;
      o++, s++;
    }
    return !1;
  }
  function qp(t, e) {
    const n = t.selection;
    if (!(n instanceof ke) || n.$anchorCell.pos == n.$headCell.pos) return !1;
    const r = an(t),
      { map: o } = r;
    if (_T(o, r)) return !1;
    if (e) {
      const i = t.tr,
        s = {};
      let a = D.empty,
        l,
        c;
      for (let d = r.top; d < r.bottom; d++)
        for (let f = r.left; f < r.right; f++) {
          const p = o.map[d * o.width + f],
            h = r.table.nodeAt(p);
          if (!(s[p] || !h))
            if (((s[p] = !0), l == null)) (l = p), (c = h);
            else {
              Ky(h) || (a = a.append(h.content));
              const m = i.mapping.map(p + r.tableStart);
              i.delete(m, m + h.nodeSize);
            }
        }
      if (l == null || c == null) return !0;
      if (
        (i.setNodeMarkup(l + r.tableStart, null, {
          ...Hp(c.attrs, c.attrs.colspan, r.right - r.left - c.attrs.colspan),
          rowspan: r.bottom - r.top,
        }),
        a.size)
      ) {
        const d = l + 1 + c.content.size,
          f = Ky(c) ? l + 1 : d;
        i.replaceWith(f + r.tableStart, d + r.tableStart, a);
      }
      i.setSelection(new ke(i.doc.resolve(l + r.tableStart))), e(i);
    }
    return !0;
  }
  function Kp(t, e) {
    const n = ct(t.schema);
    return Gy(({ node: r }) => n[r.type.spec.tableRole])(t, e);
  }
  function Gy(t) {
    return (e, n) => {
      var r;
      const o = e.selection;
      let i, s;
      if (o instanceof ke) {
        if (o.$anchorCell.pos != o.$headCell.pos) return !1;
        (i = o.$anchorCell.nodeAfter), (s = o.$anchorCell.pos);
      } else {
        if (((i = dT(o.$from)), !i)) return !1;
        s = (r = Uo(o.$from)) == null ? void 0 : r.pos;
      }
      if (
        i == null ||
        s == null ||
        (i.attrs.colspan == 1 && i.attrs.rowspan == 1)
      )
        return !1;
      if (n) {
        let a = i.attrs;
        const l = [],
          c = a.colwidth;
        a.rowspan > 1 && (a = { ...a, rowspan: 1 }),
          a.colspan > 1 && (a = { ...a, colspan: 1 });
        const d = an(e),
          f = e.tr;
        for (let h = 0; h < d.right - d.left; h++)
          l.push(c ? { ...a, colwidth: c && c[h] ? [c[h]] : null } : a);
        let p;
        for (let h = d.top; h < d.bottom; h++) {
          let m = d.map.positionAt(h, d.left, d.table);
          h == d.top && (m += i.nodeSize);
          for (let g = d.left, b = 0; g < d.right; g++, b++)
            (g == d.left && h == d.top) ||
              f.insert(
                (p = f.mapping.map(m + d.tableStart, 1)),
                t({ node: i, row: h, col: g }).createAndFill(l[b])
              );
        }
        f.setNodeMarkup(s, t({ node: i, row: d.top, col: d.left }), l[0]),
          o instanceof ke &&
            f.setSelection(
              new ke(
                f.doc.resolve(o.$anchorCell.pos),
                p ? f.doc.resolve(p) : void 0
              )
            ),
          n(f);
      }
      return !0;
    };
  }
  function Jy(t, e) {
    return function (n, r) {
      if (!sn(n)) return !1;
      const o = ea(n);
      if (o.nodeAfter.attrs[t] === e) return !1;
      if (r) {
        const i = n.tr;
        n.selection instanceof ke
          ? n.selection.forEachCell((s, a) => {
              s.attrs[t] !== e &&
                i.setNodeMarkup(a, null, { ...s.attrs, [t]: e });
            })
          : i.setNodeMarkup(o.pos, null, { ...o.nodeAfter.attrs, [t]: e }),
          r(i);
      }
      return !0;
    };
  }
  function kT(t) {
    return function (e, n) {
      if (!sn(e)) return !1;
      if (n) {
        const r = ct(e.schema),
          o = an(e),
          i = e.tr,
          s = o.map.cellsInRect(
            t == "column"
              ? { left: o.left, top: 0, right: o.right, bottom: o.map.height }
              : t == "row"
              ? { left: 0, top: o.top, right: o.map.width, bottom: o.bottom }
              : o
          ),
          a = s.map((l) => o.table.nodeAt(l));
        for (let l = 0; l < s.length; l++)
          a[l].type == r.header_cell &&
            i.setNodeMarkup(o.tableStart + s[l], r.cell, a[l].attrs);
        if (i.steps.length == 0)
          for (let l = 0; l < s.length; l++)
            i.setNodeMarkup(o.tableStart + s[l], r.header_cell, a[l].attrs);
        n(i);
      }
      return !0;
    };
  }
  function Yy(t, e, n) {
    const r = e.map.cellsInRect({
      left: 0,
      top: 0,
      right: t == "row" ? e.map.width : 1,
      bottom: t == "column" ? e.map.height : 1,
    });
    for (let o = 0; o < r.length; o++) {
      const i = e.table.nodeAt(r[o]);
      if (i && i.type !== n.header_cell) return !1;
    }
    return !0;
  }
  function Ei(t, e) {
    return (
      (e = e || { useDeprecatedLogic: !1 }),
      e.useDeprecatedLogic
        ? kT(t)
        : function (n, r) {
            if (!sn(n)) return !1;
            if (r) {
              const o = ct(n.schema),
                i = an(n),
                s = n.tr,
                a = Yy("row", i, o),
                l = Yy("column", i, o),
                d = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0,
                f =
                  t == "column"
                    ? { left: 0, top: d, right: 1, bottom: i.map.height }
                    : t == "row"
                    ? { left: d, top: 0, right: i.map.width, bottom: 1 }
                    : i,
                p =
                  t == "column"
                    ? l
                      ? o.cell
                      : o.header_cell
                    : t == "row"
                    ? a
                      ? o.cell
                      : o.header_cell
                    : o.cell;
              i.map.cellsInRect(f).forEach((h) => {
                const m = h + i.tableStart,
                  g = s.doc.nodeAt(m);
                g && s.setNodeMarkup(m, p, g.attrs);
              }),
                r(s);
            }
            return !0;
          }
    );
  }
  var wT = Ei("row", { useDeprecatedLogic: !0 }),
    xT = Ei("column", { useDeprecatedLogic: !0 }),
    Xy = Ei("cell", { useDeprecatedLogic: !0 });
  function CT(t, e) {
    if (e < 0) {
      const n = t.nodeBefore;
      if (n) return t.pos - n.nodeSize;
      for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
        const i = t.node(-1).child(r),
          s = i.lastChild;
        if (s) return o - 1 - s.nodeSize;
        o -= i.nodeSize;
      }
    } else {
      if (t.index() < t.parent.childCount - 1)
        return t.pos + t.nodeAfter.nodeSize;
      const n = t.node(-1);
      for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
        const i = n.child(r);
        if (i.childCount) return o + 1;
        o += i.nodeSize;
      }
    }
    return null;
  }
  function Gp(t) {
    return function (e, n) {
      if (!sn(e)) return !1;
      const r = CT(ea(e), t);
      if (r == null) return !1;
      if (n) {
        const o = e.doc.resolve(r);
        n(e.tr.setSelection(U.between(o, Iy(o))).scrollIntoView());
      }
      return !0;
    };
  }
  function Zy(t, e) {
    const n = t.selection.$anchor;
    for (let r = n.depth; r > 0; r--)
      if (n.node(r).type.spec.tableRole == "table")
        return (
          e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0
        );
    return !1;
  }
  function ta(t, e) {
    const n = t.selection;
    if (!(n instanceof ke)) return !1;
    if (e) {
      const r = t.tr,
        o = ct(t.schema).cell.createAndFill().content;
      n.forEachCell((i, s) => {
        i.content.eq(o) ||
          r.replace(
            r.mapping.map(s + 1),
            r.mapping.map(s + i.nodeSize - 1),
            new z(o, 0, 0)
          );
      }),
        r.docChanged && e(r);
    }
    return !0;
  }
  function Qy(t) {
    if (!t.size) return null;
    let { content: e, openStart: n, openEnd: r } = t;
    for (
      ;
      e.childCount == 1 &&
      ((n > 0 && r > 0) || e.child(0).type.spec.tableRole == "table");

    )
      n--, r--, (e = e.child(0).content);
    const o = e.child(0),
      i = o.type.spec.tableRole,
      s = o.type.schema,
      a = [];
    if (i == "row")
      for (let l = 0; l < e.childCount; l++) {
        let c = e.child(l).content;
        const d = l ? 0 : Math.max(0, n - 1),
          f = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
        (d || f) && (c = Jp(ct(s).row, new z(c, d, f)).content), a.push(c);
      }
    else if (i == "cell" || i == "header_cell")
      a.push(n || r ? Jp(ct(s).row, new z(e, n, r)).content : e);
    else return null;
    return vT(s, a);
  }
  function vT(t, e) {
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const i = e[o];
      for (let s = i.childCount - 1; s >= 0; s--) {
        const { rowspan: a, colspan: l } = i.child(s).attrs;
        for (let c = o; c < o + a; c++) n[c] = (n[c] || 0) + l;
      }
    }
    let r = 0;
    for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
    for (let o = 0; o < n.length; o++)
      if ((o >= e.length && e.push(D.empty), n[o] < r)) {
        const i = ct(t).cell.createAndFill(),
          s = [];
        for (let a = n[o]; a < r; a++) s.push(i);
        e[o] = e[o].append(D.from(s));
      }
    return { height: e.length, width: r, rows: e };
  }
  function Jp(t, e) {
    const n = t.createAndFill();
    return new Tl(n).replace(0, n.content.size, e).doc;
  }
  function e_({ width: t, height: e, rows: n }, r, o) {
    if (t != r) {
      const i = [],
        s = [];
      for (let a = 0; a < n.length; a++) {
        const l = n[a],
          c = [];
        for (let d = i[a] || 0, f = 0; d < r; f++) {
          let p = l.child(f % l.childCount);
          d + p.attrs.colspan > r &&
            (p = p.type.createChecked(
              eo(p.attrs, p.attrs.colspan, d + p.attrs.colspan - r),
              p.content
            )),
            c.push(p),
            (d += p.attrs.colspan);
          for (let h = 1; h < p.attrs.rowspan; h++)
            i[a + h] = (i[a + h] || 0) + p.attrs.colspan;
        }
        s.push(D.from(c));
      }
      (n = s), (t = r);
    }
    if (e != o) {
      const i = [];
      for (let s = 0, a = 0; s < o; s++, a++) {
        const l = [],
          c = n[a % e];
        for (let d = 0; d < c.childCount; d++) {
          let f = c.child(d);
          s + f.attrs.rowspan > o &&
            (f = f.type.create(
              { ...f.attrs, rowspan: Math.max(1, o - f.attrs.rowspan) },
              f.content
            )),
            l.push(f);
        }
        i.push(D.from(l));
      }
      (n = i), (e = o);
    }
    return { width: t, height: e, rows: n };
  }
  function ET(t, e, n, r, o, i, s) {
    const a = t.doc.type.schema,
      l = ct(a);
    let c, d;
    if (o > e.width)
      for (let f = 0, p = 0; f < e.height; f++) {
        const h = n.child(f);
        p += h.nodeSize;
        const m = [];
        let g;
        h.lastChild == null || h.lastChild.type == l.cell
          ? (g = c || (c = l.cell.createAndFill()))
          : (g = d || (d = l.header_cell.createAndFill()));
        for (let b = e.width; b < o; b++) m.push(g);
        t.insert(t.mapping.slice(s).map(p - 1 + r), m);
      }
    if (i > e.height) {
      const f = [];
      for (
        let m = 0, g = (e.height - 1) * e.width;
        m < Math.max(e.width, o);
        m++
      ) {
        const b =
          m >= e.width ? !1 : n.nodeAt(e.map[g + m]).type == l.header_cell;
        f.push(
          b
            ? d || (d = l.header_cell.createAndFill())
            : c || (c = l.cell.createAndFill())
        );
      }
      const p = l.row.create(null, D.from(f)),
        h = [];
      for (let m = e.height; m < i; m++) h.push(p);
      t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), h);
    }
    return !!(c || d);
  }
  function t_(t, e, n, r, o, i, s, a) {
    if (s == 0 || s == e.height) return !1;
    let l = !1;
    for (let c = o; c < i; c++) {
      const d = s * e.width + c,
        f = e.map[d];
      if (e.map[d - e.width] == f) {
        l = !0;
        const p = n.nodeAt(f),
          { top: h, left: m } = e.findCell(f);
        t.setNodeMarkup(t.mapping.slice(a).map(f + r), null, {
          ...p.attrs,
          rowspan: s - h,
        }),
          t.insert(
            t.mapping.slice(a).map(e.positionAt(s, m, n)),
            p.type.createAndFill({
              ...p.attrs,
              rowspan: h + p.attrs.rowspan - s,
            })
          ),
          (c += p.attrs.colspan - 1);
      }
    }
    return l;
  }
  function n_(t, e, n, r, o, i, s, a) {
    if (s == 0 || s == e.width) return !1;
    let l = !1;
    for (let c = o; c < i; c++) {
      const d = c * e.width + s,
        f = e.map[d];
      if (e.map[d - 1] == f) {
        l = !0;
        const p = n.nodeAt(f),
          h = e.colCount(f),
          m = t.mapping.slice(a).map(f + r);
        t.setNodeMarkup(m, null, eo(p.attrs, s - h, p.attrs.colspan - (s - h))),
          t.insert(m + p.nodeSize, p.type.createAndFill(eo(p.attrs, 0, s - h))),
          (c += p.attrs.rowspan - 1);
      }
    }
    return l;
  }
  function Yp(t, e, n, r, o) {
    let i = n ? t.doc.nodeAt(n - 1) : t.doc;
    if (!i) throw new Error("No table found");
    let s = me.get(i);
    const { top: a, left: l } = r,
      c = l + o.width,
      d = a + o.height,
      f = t.tr;
    let p = 0;
    function h() {
      if (((i = n ? f.doc.nodeAt(n - 1) : f.doc), !i))
        throw new Error("No table found");
      (s = me.get(i)), (p = f.mapping.maps.length);
    }
    ET(f, s, i, n, c, d, p) && h(),
      t_(f, s, i, n, l, c, a, p) && h(),
      t_(f, s, i, n, l, c, d, p) && h(),
      n_(f, s, i, n, a, d, l, p) && h(),
      n_(f, s, i, n, a, d, c, p) && h();
    for (let m = a; m < d; m++) {
      const g = s.positionAt(m, l, i),
        b = s.positionAt(m, c, i);
      f.replace(
        f.mapping.slice(p).map(g + n),
        f.mapping.slice(p).map(b + n),
        new z(o.rows[m - a], 0, 0)
      );
    }
    h(),
      f.setSelection(
        new ke(
          f.doc.resolve(n + s.positionAt(a, l, i)),
          f.doc.resolve(n + s.positionAt(d - 1, c - 1, i))
        )
      ),
      e(f);
  }
  var AT = Ms({
    ArrowLeft: dc("horiz", -1),
    ArrowRight: dc("horiz", 1),
    ArrowUp: dc("vert", -1),
    ArrowDown: dc("vert", 1),
    "Shift-ArrowLeft": fc("horiz", -1),
    "Shift-ArrowRight": fc("horiz", 1),
    "Shift-ArrowUp": fc("vert", -1),
    "Shift-ArrowDown": fc("vert", 1),
    Backspace: ta,
    "Mod-Backspace": ta,
    Delete: ta,
    "Mod-Delete": ta,
  });
  function uc(t, e, n) {
    return n.eq(t.selection)
      ? !1
      : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
  }
  function dc(t, e) {
    return (n, r, o) => {
      if (!o) return !1;
      const i = n.selection;
      if (i instanceof ke) return uc(n, r, J.near(i.$headCell, e));
      if (t != "horiz" && !i.empty) return !1;
      const s = o_(o, t, e);
      if (s == null) return !1;
      if (t == "horiz") return uc(n, r, J.near(n.doc.resolve(i.head + e), e));
      {
        const a = n.doc.resolve(s),
          l = Fp(a, t, e);
        let c;
        return (
          l
            ? (c = J.near(l, 1))
            : e < 0
            ? (c = J.near(n.doc.resolve(a.before(-1)), -1))
            : (c = J.near(n.doc.resolve(a.after(-1)), 1)),
          uc(n, r, c)
        );
      }
    };
  }
  function fc(t, e) {
    return (n, r, o) => {
      if (!o) return !1;
      const i = n.selection;
      let s;
      if (i instanceof ke) s = i;
      else {
        const l = o_(o, t, e);
        if (l == null) return !1;
        s = new ke(n.doc.resolve(l));
      }
      const a = Fp(s.$headCell, t, e);
      return a ? uc(n, r, new ke(s.$anchorCell, a)) : !1;
    };
  }
  function ST(t, e) {
    const n = t.state.doc,
      r = Uo(n.resolve(e));
    return r ? (t.dispatch(t.state.tr.setSelection(new ke(r))), !0) : !1;
  }
  function r_(t, e, n) {
    if (!sn(t.state)) return !1;
    let r = Qy(n);
    const o = t.state.selection;
    if (o instanceof ke) {
      r ||
        (r = {
          width: 1,
          height: 1,
          rows: [D.from(Jp(ct(t.state.schema).cell, n))],
        });
      const i = o.$anchorCell.node(-1),
        s = o.$anchorCell.start(-1),
        a = me.get(i).rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
      return (
        (r = e_(r, a.right - a.left, a.bottom - a.top)),
        Yp(t.state, t.dispatch, s, a, r),
        !0
      );
    } else if (r) {
      const i = ea(t.state),
        s = i.start(-1);
      return (
        Yp(t.state, t.dispatch, s, me.get(i.node(-1)).findCell(i.pos - s), r),
        !0
      );
    } else return !1;
  }
  function MT(t, e) {
    var n;
    if (e.ctrlKey || e.metaKey) return;
    const r = i_(t, e.target);
    let o;
    if (e.shiftKey && t.state.selection instanceof ke)
      i(t.state.selection.$anchorCell, e), e.preventDefault();
    else if (
      e.shiftKey &&
      r &&
      (o = Uo(t.state.selection.$anchor)) != null &&
      ((n = Xp(t, e)) == null ? void 0 : n.pos) != o.pos
    )
      i(o, e), e.preventDefault();
    else if (!r) return;
    function i(l, c) {
      let d = Xp(t, c);
      const f = gr.getState(t.state) == null;
      if (!d || !cc(l, d))
        if (f) d = l;
        else return;
      const p = new ke(l, d);
      if (f || !t.state.selection.eq(p)) {
        const h = t.state.tr.setSelection(p);
        f && h.setMeta(gr, l.pos), t.dispatch(h);
      }
    }
    function s() {
      t.root.removeEventListener("mouseup", s),
        t.root.removeEventListener("dragstart", s),
        t.root.removeEventListener("mousemove", a),
        gr.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(gr, -1));
    }
    function a(l) {
      const c = l,
        d = gr.getState(t.state);
      let f;
      if (d != null) f = t.state.doc.resolve(d);
      else if (i_(t, c.target) != r && ((f = Xp(t, e)), !f)) return s();
      f && i(f, c);
    }
    t.root.addEventListener("mouseup", s),
      t.root.addEventListener("dragstart", s),
      t.root.addEventListener("mousemove", a);
  }
  function o_(t, e, n) {
    if (!(t.state.selection instanceof U)) return null;
    const { $head: r } = t.state.selection;
    for (let o = r.depth - 1; o >= 0; o--) {
      const i = r.node(o);
      if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount))
        return null;
      if (
        i.type.spec.tableRole == "cell" ||
        i.type.spec.tableRole == "header_cell"
      ) {
        const a = r.before(o),
          l = e == "vert" ? (n > 0 ? "down" : "up") : n > 0 ? "right" : "left";
        return t.endOfTextblock(l) ? a : null;
      }
    }
    return null;
  }
  function i_(t, e) {
    for (; e && e != t.dom; e = e.parentNode)
      if (e.nodeName == "TD" || e.nodeName == "TH") return e;
    return null;
  }
  function Xp(t, e) {
    const n = t.posAtCoords({ left: e.clientX, top: e.clientY });
    return n && n ? Uo(t.state.doc.resolve(n.pos)) : null;
  }
  var s_ = class {
    constructor(e, n) {
      (this.node = e),
        (this.defaultCellMinWidth = n),
        (this.dom = document.createElement("div")),
        (this.dom.className = "tableWrapper"),
        (this.table = this.dom.appendChild(document.createElement("table"))),
        this.table.style.setProperty("--default-cell-min-width", `${n}px`),
        (this.colgroup = this.table.appendChild(
          document.createElement("colgroup")
        )),
        pc(e, this.colgroup, this.table, n),
        (this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        ));
    }
    update(e) {
      return e.type != this.node.type
        ? !1
        : ((this.node = e),
          pc(e, this.colgroup, this.table, this.defaultCellMinWidth),
          !0);
    }
    ignoreMutation(e) {
      return (
        e.type == "attributes" &&
        (e.target == this.table || this.colgroup.contains(e.target))
      );
    }
  };
  function pc(t, e, n, r, o, i) {
    var s;
    let a = 0,
      l = !0,
      c = e.firstChild;
    const d = t.firstChild;
    if (d) {
      for (let f = 0, p = 0; f < d.childCount; f++) {
        const { colspan: h, colwidth: m } = d.child(f).attrs;
        for (let g = 0; g < h; g++, p++) {
          const b = o == p ? i : m && m[g],
            y = b ? b + "px" : "";
          if (((a += b || r), b || (l = !1), c))
            c.style.width != y && (c.style.width = y), (c = c.nextSibling);
          else {
            const x = document.createElement("col");
            (x.style.width = y), e.appendChild(x);
          }
        }
      }
      for (; c; ) {
        const f = c.nextSibling;
        (s = c.parentNode) == null || s.removeChild(c), (c = f);
      }
      l
        ? ((n.style.width = a + "px"), (n.style.minWidth = ""))
        : ((n.style.width = ""), (n.style.minWidth = a + "px"));
    }
  }
  var Bt = new de("tableColumnResizing");
  function a_({
    handleWidth: t = 5,
    cellMinWidth: e = 25,
    defaultCellMinWidth: n = 100,
    View: r = s_,
    lastColumnResizable: o = !0,
  } = {}) {
    const i = new ie({
      key: Bt,
      state: {
        init(s, a) {
          var l, c;
          const d =
              (c = (l = i.spec) == null ? void 0 : l.props) == null
                ? void 0
                : c.nodeViews,
            f = ct(a.schema).table.name;
          return r && d && (d[f] = (p, h) => new r(p, n, h)), new l_(-1, !1);
        },
        apply(s, a) {
          return a.apply(s);
        },
      },
      props: {
        attributes: (s) => {
          const a = Bt.getState(s);
          return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
        },
        handleDOMEvents: {
          mousemove: (s, a) => {
            TT(s, a, t, o);
          },
          mouseleave: (s) => {
            NT(s);
          },
          mousedown: (s, a) => {
            OT(s, a, e, n);
          },
        },
        decorations: (s) => {
          const a = Bt.getState(s);
          if (a && a.activeHandle > -1) return BT(s, a.activeHandle);
        },
        nodeViews: {},
      },
    });
    return i;
  }
  var l_ = class vd {
    constructor(e, n) {
      (this.activeHandle = e), (this.dragging = n);
    }
    apply(e) {
      const n = this,
        r = e.getMeta(Bt);
      if (r && r.setHandle != null) return new vd(r.setHandle, !1);
      if (r && r.setDragging !== void 0)
        return new vd(n.activeHandle, r.setDragging);
      if (n.activeHandle > -1 && e.docChanged) {
        let o = e.mapping.map(n.activeHandle, -1);
        return lc(e.doc.resolve(o)) || (o = -1), new vd(o, n.dragging);
      }
      return n;
    }
  };
  function TT(t, e, n, r) {
    const o = Bt.getState(t.state);
    if (o && !o.dragging) {
      const i = DT(e.target);
      let s = -1;
      if (i) {
        const { left: a, right: l } = i.getBoundingClientRect();
        e.clientX - a <= n
          ? (s = c_(t, e, "left", n))
          : l - e.clientX <= n && (s = c_(t, e, "right", n));
      }
      if (s != o.activeHandle) {
        if (!r && s !== -1) {
          const a = t.state.doc.resolve(s),
            l = a.node(-1),
            c = me.get(l),
            d = a.start(-1);
          if (
            c.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 ==
            c.width - 1
          )
            return;
        }
        d_(t, s);
      }
    }
  }
  function NT(t) {
    const e = Bt.getState(t.state);
    e && e.activeHandle > -1 && !e.dragging && d_(t, -1);
  }
  function OT(t, e, n, r) {
    var o;
    const i = (o = t.dom.ownerDocument.defaultView) != null ? o : window,
      s = Bt.getState(t.state);
    if (!s || s.activeHandle == -1 || s.dragging) return !1;
    const a = t.state.doc.nodeAt(s.activeHandle),
      l = RT(t, s.activeHandle, a.attrs);
    t.dispatch(
      t.state.tr.setMeta(Bt, {
        setDragging: { startX: e.clientX, startWidth: l },
      })
    );
    function c(f) {
      i.removeEventListener("mouseup", c),
        i.removeEventListener("mousemove", d);
      const p = Bt.getState(t.state);
      p != null &&
        p.dragging &&
        (LT(t, p.activeHandle, u_(p.dragging, f, n)),
        t.dispatch(t.state.tr.setMeta(Bt, { setDragging: null })));
    }
    function d(f) {
      if (!f.which) return c(f);
      const p = Bt.getState(t.state);
      if (p && p.dragging) {
        const h = u_(p.dragging, f, n);
        f_(t, p.activeHandle, h, r);
      }
    }
    return (
      f_(t, s.activeHandle, l, r),
      i.addEventListener("mouseup", c),
      i.addEventListener("mousemove", d),
      e.preventDefault(),
      !0
    );
  }
  function RT(t, e, { colspan: n, colwidth: r }) {
    const o = r && r[r.length - 1];
    if (o) return o;
    const i = t.domAtPos(e);
    let a = i.node.childNodes[i.offset].offsetWidth,
      l = n;
    if (r) for (let c = 0; c < n; c++) r[c] && ((a -= r[c]), l--);
    return a / l;
  }
  function DT(t) {
    for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
      t =
        t.classList && t.classList.contains("ProseMirror")
          ? null
          : t.parentNode;
    return t;
  }
  function c_(t, e, n, r) {
    const o = n == "right" ? -r : r,
      i = t.posAtCoords({ left: e.clientX + o, top: e.clientY });
    if (!i) return -1;
    const { pos: s } = i,
      a = Uo(t.state.doc.resolve(s));
    if (!a) return -1;
    if (n == "right") return a.pos;
    const l = me.get(a.node(-1)),
      c = a.start(-1),
      d = l.map.indexOf(a.pos - c);
    return d % l.width == 0 ? -1 : c + l.map[d - 1];
  }
  function u_(t, e, n) {
    const r = e.clientX - t.startX;
    return Math.max(n, t.startWidth + r);
  }
  function d_(t, e) {
    t.dispatch(t.state.tr.setMeta(Bt, { setHandle: e }));
  }
  function LT(t, e, n) {
    const r = t.state.doc.resolve(e),
      o = r.node(-1),
      i = me.get(o),
      s = r.start(-1),
      a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1,
      l = t.state.tr;
    for (let c = 0; c < i.height; c++) {
      const d = c * i.width + a;
      if (c && i.map[d] == i.map[d - i.width]) continue;
      const f = i.map[d],
        p = o.nodeAt(f).attrs,
        h = p.colspan == 1 ? 0 : a - i.colCount(f);
      if (p.colwidth && p.colwidth[h] == n) continue;
      const m = p.colwidth ? p.colwidth.slice() : IT(p.colspan);
      (m[h] = n), l.setNodeMarkup(s + f, null, { ...p, colwidth: m });
    }
    l.docChanged && t.dispatch(l);
  }
  function f_(t, e, n, r) {
    const o = t.state.doc.resolve(e),
      i = o.node(-1),
      s = o.start(-1),
      a = me.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
    let l = t.domAtPos(o.start(-1)).node;
    for (; l && l.nodeName != "TABLE"; ) l = l.parentNode;
    l && pc(i, l.firstChild, l, r, a, n);
  }
  function IT(t) {
    return Array(t).fill(0);
  }
  function BT(t, e) {
    var n;
    const r = [],
      o = t.doc.resolve(e),
      i = o.node(-1);
    if (!i) return ue.empty;
    const s = me.get(i),
      a = o.start(-1),
      l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
    for (let c = 0; c < s.height; c++) {
      const d = l + c * s.width;
      if (
        (l == s.width - 1 || s.map[d] != s.map[d + 1]) &&
        (c == 0 || s.map[d] != s.map[d - s.width])
      ) {
        const f = s.map[d],
          p = a + f + i.nodeAt(f).nodeSize - 1,
          h = document.createElement("div");
        (h.className = "column-resize-handle"),
          (n = Bt.getState(t)) != null &&
            n.dragging &&
            r.push(
              Te.node(a + f, a + f + i.nodeAt(f).nodeSize, {
                class: "column-resize-dragging",
              })
            ),
          r.push(Te.widget(p, h));
      }
    }
    return ue.create(t.doc, r);
  }
  function p_({ allowTableNodeSelection: t = !1 } = {}) {
    return new ie({
      key: gr,
      state: {
        init() {
          return null;
        },
        apply(e, n) {
          const r = e.getMeta(gr);
          if (r != null) return r == -1 ? null : r;
          if (n == null || !e.docChanged) return n;
          const { deleted: o, pos: i } = e.mapping.mapResult(n);
          return o ? null : i;
        },
      },
      props: {
        decorations: hT,
        handleDOMEvents: { mousedown: MT },
        createSelectionBetween(e) {
          return gr.getState(e.state) != null ? e.state.selection : null;
        },
        handleTripleClick: ST,
        handleKeyDown: AT,
        handlePaste: r_,
      },
      appendTransaction(e, n, r) {
        return bT(r, zp(r, n), t);
      },
    });
  }
  var h_ = new de("trailingNode");
  function PT(t) {
    const { ignoredNodes: e = [], nodeName: n = "paragraph" } = t ?? {},
      r = new Set([...e, n]);
    let o, i;
    return new ie({
      key: h_,
      appendTransaction(s, a, l) {
        const { doc: c, tr: d } = l,
          f = h_.getState(l),
          p = c.content.size;
        if (f) return d.insert(p, o.create());
      },
      state: {
        init: (s, { doc: a, schema: l }) => {
          var c;
          const d = l.nodes[n];
          if (!d)
            throw new Error(
              "Invalid node being used for trailing node extension: '".concat(
                n,
                "'"
              )
            );
          return (
            (o = d),
            (i = Object.values(l.nodes)
              .map((f) => f)
              .filter((f) => !r.has(f.name))),
            i.includes((c = a.lastChild) == null ? void 0 : c.type)
          );
        },
        apply: (s, a) => {
          var l;
          return s.docChanged
            ? i.includes((l = s.doc.lastChild) == null ? void 0 : l.type)
            : a;
        },
      },
    });
  }
  function na(t) {
    const { state: e, transaction: n } = t;
    let { selection: r } = n,
      { doc: o } = n,
      { storedMarks: i } = n;
    return {
      ...e,
      apply: e.apply.bind(e),
      applyTransaction: e.applyTransaction.bind(e),
      plugins: e.plugins,
      schema: e.schema,
      reconfigure: e.reconfigure.bind(e),
      toJSON: e.toJSON.bind(e),
      get storedMarks() {
        return i;
      },
      get selection() {
        return r;
      },
      get doc() {
        return o;
      },
      get tr() {
        return (r = n.selection), (o = n.doc), (i = n.storedMarks), n;
      },
    };
  }
  class ra {
    constructor(e) {
      (this.editor = e.editor),
        (this.rawCommands = this.editor.extensionManager.commands),
        (this.customState = e.state);
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands: e, editor: n, state: r } = this,
        { view: o } = n,
        { tr: i } = r,
        s = this.buildProps(i);
      return Object.fromEntries(
        Object.entries(e).map(([a, l]) => [
          a,
          (...d) => {
            const f = l(...d)(s);
            return (
              !i.getMeta("preventDispatch") &&
                !this.hasCustomState &&
                o.dispatch(i),
              f
            );
          },
        ])
      );
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(e, n = !0) {
      const { rawCommands: r, editor: o, state: i } = this,
        { view: s } = o,
        a = [],
        l = !!e,
        c = e || i.tr,
        d = () => (
          !l &&
            n &&
            !c.getMeta("preventDispatch") &&
            !this.hasCustomState &&
            s.dispatch(c),
          a.every((p) => p === !0)
        ),
        f = {
          ...Object.fromEntries(
            Object.entries(r).map(([p, h]) => [
              p,
              (...g) => {
                const b = this.buildProps(c, n),
                  y = h(...g)(b);
                return a.push(y), f;
              },
            ])
          ),
          run: d,
        };
      return f;
    }
    createCan(e) {
      const { rawCommands: n, state: r } = this,
        o = !1,
        i = e || r.tr,
        s = this.buildProps(i, o);
      return {
        ...Object.fromEntries(
          Object.entries(n).map(([l, c]) => [
            l,
            (...d) => c(...d)({ ...s, dispatch: void 0 }),
          ])
        ),
        chain: () => this.createChain(i, o),
      };
    }
    buildProps(e, n = !0) {
      const { rawCommands: r, editor: o, state: i } = this,
        { view: s } = o,
        a = {
          tr: e,
          editor: o,
          view: s,
          state: na({ state: i, transaction: e }),
          dispatch: n ? () => {} : void 0,
          chain: () => this.createChain(e, n),
          can: () => this.createCan(e),
          get commands() {
            return Object.fromEntries(
              Object.entries(r).map(([l, c]) => [l, (...d) => c(...d)(a)])
            );
          },
        };
      return a;
    }
  }
  class $T {
    constructor() {
      this.callbacks = {};
    }
    on(e, n) {
      return (
        this.callbacks[e] || (this.callbacks[e] = []),
        this.callbacks[e].push(n),
        this
      );
    }
    emit(e, ...n) {
      const r = this.callbacks[e];
      return r && r.forEach((o) => o.apply(this, n)), this;
    }
    off(e, n) {
      const r = this.callbacks[e];
      return (
        r &&
          (n
            ? (this.callbacks[e] = r.filter((o) => o !== n))
            : delete this.callbacks[e]),
        this
      );
    }
    once(e, n) {
      const r = (...o) => {
        this.off(e, r), n.apply(this, o);
      };
      return this.on(e, r);
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  }
  function j(t, e, n) {
    return t.config[e] === void 0 && t.parent
      ? j(t.parent, e, n)
      : typeof t.config[e] == "function"
      ? t.config[e].bind({ ...n, parent: t.parent ? j(t.parent, e, n) : null })
      : t.config[e];
  }
  function oa(t) {
    const e = t.filter((o) => o.type === "extension"),
      n = t.filter((o) => o.type === "node"),
      r = t.filter((o) => o.type === "mark");
    return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
  }
  function Zp(t) {
    const e = [],
      { nodeExtensions: n, markExtensions: r } = oa(t),
      o = [...n, ...r],
      i = {
        default: null,
        rendered: !0,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: !0,
        isRequired: !1,
      };
    return (
      t.forEach((s) => {
        const a = {
            name: s.name,
            options: s.options,
            storage: s.storage,
            extensions: o,
          },
          l = j(s, "addGlobalAttributes", a);
        if (!l) return;
        l().forEach((d) => {
          d.types.forEach((f) => {
            Object.entries(d.attributes).forEach(([p, h]) => {
              e.push({ type: f, name: p, attribute: { ...i, ...h } });
            });
          });
        });
      }),
      o.forEach((s) => {
        const a = { name: s.name, options: s.options, storage: s.storage },
          l = j(s, "addAttributes", a);
        if (!l) return;
        const c = l();
        Object.entries(c).forEach(([d, f]) => {
          const p = { ...i, ...f };
          typeof (p == null ? void 0 : p.default) == "function" &&
            (p.default = p.default()),
            p != null &&
              p.isRequired &&
              (p == null ? void 0 : p.default) === void 0 &&
              delete p.default,
            e.push({ type: s.name, name: d, attribute: p });
        });
      }),
      e
    );
  }
  function Ke(t, e) {
    if (typeof t == "string") {
      if (!e.nodes[t])
        throw Error(
          `There is no node type named '${t}'. Maybe you forgot to add the extension?`
        );
      return e.nodes[t];
    }
    return t;
  }
  function se(...t) {
    return t
      .filter((e) => !!e)
      .reduce((e, n) => {
        const r = { ...e };
        return (
          Object.entries(n).forEach(([o, i]) => {
            if (!r[o]) {
              r[o] = i;
              return;
            }
            if (o === "class") {
              const a = i ? String(i).split(" ") : [],
                l = r[o] ? r[o].split(" ") : [],
                c = a.filter((d) => !l.includes(d));
              r[o] = [...l, ...c].join(" ");
            } else if (o === "style") {
              const a = i
                  ? i
                      .split(";")
                      .map((d) => d.trim())
                      .filter(Boolean)
                  : [],
                l = r[o]
                  ? r[o]
                      .split(";")
                      .map((d) => d.trim())
                      .filter(Boolean)
                  : [],
                c = new Map();
              l.forEach((d) => {
                const [f, p] = d.split(":").map((h) => h.trim());
                c.set(f, p);
              }),
                a.forEach((d) => {
                  const [f, p] = d.split(":").map((h) => h.trim());
                  c.set(f, p);
                }),
                (r[o] = Array.from(c.entries())
                  .map(([d, f]) => `${d}: ${f}`)
                  .join("; "));
            } else r[o] = i;
          }),
          r
        );
      }, {});
  }
  function hc(t, e) {
    return e
      .filter((n) => n.type === t.type.name)
      .filter((n) => n.attribute.rendered)
      .map((n) =>
        n.attribute.renderHTML
          ? n.attribute.renderHTML(t.attrs) || {}
          : { [n.name]: t.attrs[n.name] }
      )
      .reduce((n, r) => se(n, r), {});
  }
  function Qp(t) {
    return typeof t == "function";
  }
  function re(t, e = void 0, ...n) {
    return Qp(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
  }
  function m_(t = {}) {
    return Object.keys(t).length === 0 && t.constructor === Object;
  }
  function g_(t) {
    return typeof t != "string"
      ? t
      : t.match(/^[+-]?(?:\d*\.)?\d+$/)
      ? Number(t)
      : t === "true"
      ? !0
      : t === "false"
      ? !1
      : t;
  }
  function eh(t, e) {
    return "style" in t
      ? t
      : {
          ...t,
          getAttrs: (n) => {
            const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
            if (r === !1) return !1;
            const o = e.reduce((i, s) => {
              const a = s.attribute.parseHTML
                ? s.attribute.parseHTML(n)
                : g_(n.getAttribute(s.name));
              return a == null ? i : { ...i, [s.name]: a };
            }, {});
            return { ...r, ...o };
          },
        };
  }
  function b_(t) {
    return Object.fromEntries(
      Object.entries(t).filter(([e, n]) =>
        e === "attrs" && m_(n) ? !1 : n != null
      )
    );
  }
  function th(t, e) {
    var n;
    const r = Zp(t),
      { nodeExtensions: o, markExtensions: i } = oa(t),
      s =
        (n = o.find((c) => j(c, "topNode"))) === null || n === void 0
          ? void 0
          : n.name,
      a = Object.fromEntries(
        o.map((c) => {
          const d = r.filter((y) => y.type === c.name),
            f = {
              name: c.name,
              options: c.options,
              storage: c.storage,
              editor: e,
            },
            p = t.reduce((y, x) => {
              const w = j(x, "extendNodeSchema", f);
              return { ...y, ...(w ? w(c) : {}) };
            }, {}),
            h = b_({
              ...p,
              content: re(j(c, "content", f)),
              marks: re(j(c, "marks", f)),
              group: re(j(c, "group", f)),
              inline: re(j(c, "inline", f)),
              atom: re(j(c, "atom", f)),
              selectable: re(j(c, "selectable", f)),
              draggable: re(j(c, "draggable", f)),
              code: re(j(c, "code", f)),
              whitespace: re(j(c, "whitespace", f)),
              linebreakReplacement: re(j(c, "linebreakReplacement", f)),
              defining: re(j(c, "defining", f)),
              isolating: re(j(c, "isolating", f)),
              attrs: Object.fromEntries(
                d.map((y) => {
                  var x;
                  return [
                    y.name,
                    {
                      default:
                        (x = y == null ? void 0 : y.attribute) === null ||
                        x === void 0
                          ? void 0
                          : x.default,
                    },
                  ];
                })
              ),
            }),
            m = re(j(c, "parseHTML", f));
          m && (h.parseDOM = m.map((y) => eh(y, d)));
          const g = j(c, "renderHTML", f);
          g && (h.toDOM = (y) => g({ node: y, HTMLAttributes: hc(y, d) }));
          const b = j(c, "renderText", f);
          return b && (h.toText = b), [c.name, h];
        })
      ),
      l = Object.fromEntries(
        i.map((c) => {
          const d = r.filter((b) => b.type === c.name),
            f = {
              name: c.name,
              options: c.options,
              storage: c.storage,
              editor: e,
            },
            p = t.reduce((b, y) => {
              const x = j(y, "extendMarkSchema", f);
              return { ...b, ...(x ? x(c) : {}) };
            }, {}),
            h = b_({
              ...p,
              inclusive: re(j(c, "inclusive", f)),
              excludes: re(j(c, "excludes", f)),
              group: re(j(c, "group", f)),
              spanning: re(j(c, "spanning", f)),
              code: re(j(c, "code", f)),
              attrs: Object.fromEntries(
                d.map((b) => {
                  var y;
                  return [
                    b.name,
                    {
                      default:
                        (y = b == null ? void 0 : b.attribute) === null ||
                        y === void 0
                          ? void 0
                          : y.default,
                    },
                  ];
                })
              ),
            }),
            m = re(j(c, "parseHTML", f));
          m && (h.parseDOM = m.map((b) => eh(b, d)));
          const g = j(c, "renderHTML", f);
          return (
            g && (h.toDOM = (b) => g({ mark: b, HTMLAttributes: hc(b, d) })),
            [c.name, h]
          );
        })
      );
    return new _s({ topNode: s, nodes: a, marks: l });
  }
  function mc(t, e) {
    return e.nodes[t] || e.marks[t] || null;
  }
  function nh(t, e) {
    return Array.isArray(e)
      ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name)
      : e;
  }
  function ia(t, e) {
    const n = Pr.fromSchema(e).serializeFragment(t),
      o = document.implementation.createHTMLDocument().createElement("div");
    return o.appendChild(n), o.innerHTML;
  }
  const y_ = (t, e = 500) => {
    let n = "";
    const r = t.parentOffset;
    return (
      t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, a) => {
        var l, c;
        const d =
          ((c = (l = o.type.spec).toText) === null || c === void 0
            ? void 0
            : c.call(l, { node: o, pos: i, parent: s, index: a })) ||
          o.textContent ||
          "%leaf%";
        n += o.isAtom && !o.isText ? d : d.slice(0, Math.max(0, r - i));
      }),
      n
    );
  };
  function gc(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]";
  }
  class Ai {
    constructor(e) {
      (this.find = e.find), (this.handler = e.handler);
    }
  }
  const FT = (t, e) => {
    if (gc(e)) return e.exec(t);
    const n = e(t);
    if (!n) return null;
    const r = [n.text];
    return (
      (r.index = n.index),
      (r.input = t),
      (r.data = n.data),
      n.replaceWith &&
        (n.text.includes(n.replaceWith) ||
          console.warn(
            '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
          ),
        r.push(n.replaceWith)),
      r
    );
  };
  function bc(t) {
    var e;
    const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = t,
      { view: l } = n;
    if (l.composing) return !1;
    const c = l.state.doc.resolve(r);
    if (
      c.parent.type.spec.code ||
      (!((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) &&
        e.marks.find((p) => p.type.spec.code))
    )
      return !1;
    let d = !1;
    const f = y_(c) + i;
    return (
      s.forEach((p) => {
        if (d) return;
        const h = FT(f, p.find);
        if (!h) return;
        const m = l.state.tr,
          g = na({ state: l.state, transaction: m }),
          b = { from: r - (h[0].length - i.length), to: o },
          { commands: y, chain: x, can: w } = new ra({ editor: n, state: g });
        p.handler({
          state: g,
          range: b,
          match: h,
          commands: y,
          chain: x,
          can: w,
        }) === null ||
          !m.steps.length ||
          (m.setMeta(a, { transform: m, from: r, to: o, text: i }),
          l.dispatch(m),
          (d = !0));
      }),
      d
    );
  }
  function __(t) {
    const { editor: e, rules: n } = t,
      r = new ie({
        state: {
          init() {
            return null;
          },
          apply(o, i, s) {
            const a = o.getMeta(r);
            if (a) return a;
            const l = o.getMeta("applyInputRules");
            return (
              !!l &&
                setTimeout(() => {
                  let { text: d } = l;
                  typeof d == "string"
                    ? (d = d)
                    : (d = ia(D.from(d), s.schema));
                  const { from: f } = l,
                    p = f + d.length;
                  bc({
                    editor: e,
                    from: f,
                    to: p,
                    text: d,
                    rules: n,
                    plugin: r,
                  });
                }),
              o.selectionSet || o.docChanged ? null : i
            );
          },
        },
        props: {
          handleTextInput(o, i, s, a) {
            return bc({
              editor: e,
              from: i,
              to: s,
              text: a,
              rules: n,
              plugin: r,
            });
          },
          handleDOMEvents: {
            compositionend: (o) => (
              setTimeout(() => {
                const { $cursor: i } = o.state.selection;
                i &&
                  bc({
                    editor: e,
                    from: i.pos,
                    to: i.pos,
                    text: "",
                    rules: n,
                    plugin: r,
                  });
              }),
              !1
            ),
          },
          handleKeyDown(o, i) {
            if (i.key !== "Enter") return !1;
            const { $cursor: s } = o.state.selection;
            return s
              ? bc({
                  editor: e,
                  from: s.pos,
                  to: s.pos,
                  text: `
`,
                  rules: n,
                  plugin: r,
                })
              : !1;
          },
        },
        isInputRules: !0,
      });
    return r;
  }
  function HT(t) {
    return Object.prototype.toString.call(t).slice(8, -1);
  }
  function sa(t) {
    return HT(t) !== "Object"
      ? !1
      : t.constructor === Object &&
          Object.getPrototypeOf(t) === Object.prototype;
  }
  function aa(t, e) {
    const n = { ...t };
    return (
      sa(t) &&
        sa(e) &&
        Object.keys(e).forEach((r) => {
          sa(e[r]) && sa(t[r]) ? (n[r] = aa(t[r], e[r])) : (n[r] = e[r]);
        }),
      n
    );
  }
  class vt {
    constructor(e = {}) {
      (this.type = "mark"),
        (this.name = "mark"),
        (this.parent = null),
        (this.child = null),
        (this.config = { name: this.name, defaultOptions: {} }),
        (this.config = { ...this.config, ...e }),
        (this.name = this.config.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
          ),
        (this.options = this.config.defaultOptions),
        this.config.addOptions &&
          (this.options = re(j(this, "addOptions", { name: this.name }))),
        (this.storage =
          re(
            j(this, "addStorage", { name: this.name, options: this.options })
          ) || {});
    }
    static create(e = {}) {
      return new vt(e);
    }
    configure(e = {}) {
      const n = this.extend({
        ...this.config,
        addOptions: () => aa(this.options, e),
      });
      return (n.name = this.name), (n.parent = this.parent), n;
    }
    extend(e = {}) {
      const n = new vt(e);
      return (
        (n.parent = this),
        (this.child = n),
        (n.name = e.name ? e.name : n.parent.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
          ),
        (n.options = re(j(n, "addOptions", { name: n.name }))),
        (n.storage = re(
          j(n, "addStorage", { name: n.name, options: n.options })
        )),
        n
      );
    }
    static handleExit({ editor: e, mark: n }) {
      const { tr: r } = e.state,
        o = e.state.selection.$from;
      if (o.pos === o.end()) {
        const s = o.marks();
        if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
          return !1;
        const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name);
        return (
          l && r.removeStoredMark(l),
          r.insertText(" ", o.pos),
          e.view.dispatch(r),
          !0
        );
      }
      return !1;
    }
  }
  function k_(t) {
    return typeof t == "number";
  }
  class yc {
    constructor(e) {
      (this.find = e.find), (this.handler = e.handler);
    }
  }
  const zT = (t, e, n) => {
    if (gc(e)) return [...t.matchAll(e)];
    const r = e(t, n);
    return r
      ? r.map((o) => {
          const i = [o.text];
          return (
            (i.index = o.index),
            (i.input = t),
            (i.data = o.data),
            o.replaceWith &&
              (o.text.includes(o.replaceWith) ||
                console.warn(
                  '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
                ),
              i.push(o.replaceWith)),
            i
          );
        })
      : [];
  };
  function VT(t) {
    const {
        editor: e,
        state: n,
        from: r,
        to: o,
        rule: i,
        pasteEvent: s,
        dropEvent: a,
      } = t,
      { commands: l, chain: c, can: d } = new ra({ editor: e, state: n }),
      f = [];
    return (
      n.doc.nodesBetween(r, o, (h, m) => {
        if (!h.isTextblock || h.type.spec.code) return;
        const g = Math.max(r, m),
          b = Math.min(o, m + h.content.size),
          y = h.textBetween(g - m, b - m, void 0, "￼");
        zT(y, i.find, s).forEach((w) => {
          if (w.index === void 0) return;
          const _ = g + w.index + 1,
            v = _ + w[0].length,
            C = { from: n.tr.mapping.map(_), to: n.tr.mapping.map(v) },
            S = i.handler({
              state: n,
              range: C,
              match: w,
              commands: l,
              chain: c,
              can: d,
              pasteEvent: s,
              dropEvent: a,
            });
          f.push(S);
        });
      }),
      f.every((h) => h !== null)
    );
  }
  let _c = null;
  const UT = (t) => {
    var e;
    const n = new ClipboardEvent("paste", {
      clipboardData: new DataTransfer(),
    });
    return (
      (e = n.clipboardData) === null ||
        e === void 0 ||
        e.setData("text/html", t),
      n
    );
  };
  function w_(t) {
    const { editor: e, rules: n } = t;
    let r = null,
      o = !1,
      i = !1,
      s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
      a;
    try {
      a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
    } catch {
      a = null;
    }
    const l = ({ state: d, from: f, to: p, rule: h, pasteEvt: m }) => {
      const g = d.tr,
        b = na({ state: d, transaction: g });
      if (
        !(
          !VT({
            editor: e,
            state: b,
            from: Math.max(f - 1, 0),
            to: p.b - 1,
            rule: h,
            pasteEvent: m,
            dropEvent: a,
          }) || !g.steps.length
        )
      ) {
        try {
          a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
        } catch {
          a = null;
        }
        return (
          (s =
            typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null),
          g
        );
      }
    };
    return n.map(
      (d) =>
        new ie({
          view(f) {
            const p = (m) => {
                var g;
                (r =
                  !((g = f.dom.parentElement) === null || g === void 0) &&
                  g.contains(m.target)
                    ? f.dom.parentElement
                    : null),
                  r && (_c = e);
              },
              h = () => {
                _c && (_c = null);
              };
            return (
              window.addEventListener("dragstart", p),
              window.addEventListener("dragend", h),
              {
                destroy() {
                  window.removeEventListener("dragstart", p),
                    window.removeEventListener("dragend", h);
                },
              }
            );
          },
          props: {
            handleDOMEvents: {
              drop: (f, p) => {
                if (((i = r === f.dom.parentElement), (a = p), !i)) {
                  const h = _c;
                  h &&
                    setTimeout(() => {
                      const m = h.state.selection;
                      m && h.commands.deleteRange({ from: m.from, to: m.to });
                    }, 10);
                }
                return !1;
              },
              paste: (f, p) => {
                var h;
                const m =
                  (h = p.clipboardData) === null || h === void 0
                    ? void 0
                    : h.getData("text/html");
                return (
                  (s = p),
                  (o = !!(m != null && m.includes("data-pm-slice"))),
                  !1
                );
              },
            },
          },
          appendTransaction: (f, p, h) => {
            const m = f[0],
              g = m.getMeta("uiEvent") === "paste" && !o,
              b = m.getMeta("uiEvent") === "drop" && !i,
              y = m.getMeta("applyPasteRules"),
              x = !!y;
            if (!g && !b && !x) return;
            if (x) {
              let { text: v } = y;
              typeof v == "string" ? (v = v) : (v = ia(D.from(v), h.schema));
              const { from: C } = y,
                S = C + v.length,
                N = UT(v);
              return l({
                rule: d,
                state: h,
                from: C,
                to: { b: S },
                pasteEvt: N,
              });
            }
            const w = p.doc.content.findDiffStart(h.doc.content),
              _ = p.doc.content.findDiffEnd(h.doc.content);
            if (!(!k_(w) || !_ || w === _.b))
              return l({ rule: d, state: h, from: w, to: _, pasteEvt: s });
          },
        })
    );
  }
  function x_(t) {
    const e = t.filter((n, r) => t.indexOf(n) !== r);
    return Array.from(new Set(e));
  }
  class jo {
    constructor(e, n) {
      (this.splittableMarks = []),
        (this.editor = n),
        (this.extensions = jo.resolve(e)),
        (this.schema = th(this.extensions, n)),
        this.setupExtensions();
    }
    static resolve(e) {
      const n = jo.sort(jo.flatten(e)),
        r = x_(n.map((o) => o.name));
      return (
        r.length &&
          console.warn(
            `[tiptap warn]: Duplicate extension names found: [${r
              .map((o) => `'${o}'`)
              .join(", ")}]. This can lead to issues.`
          ),
        n
      );
    }
    static flatten(e) {
      return e
        .map((n) => {
          const r = { name: n.name, options: n.options, storage: n.storage },
            o = j(n, "addExtensions", r);
          return o ? [n, ...this.flatten(o())] : n;
        })
        .flat(10);
    }
    static sort(e) {
      return e.sort((r, o) => {
        const i = j(r, "priority") || 100,
          s = j(o, "priority") || 100;
        return i > s ? -1 : i < s ? 1 : 0;
      });
    }
    get commands() {
      return this.extensions.reduce((e, n) => {
        const r = {
            name: n.name,
            options: n.options,
            storage: n.storage,
            editor: this.editor,
            type: mc(n.name, this.schema),
          },
          o = j(n, "addCommands", r);
        return o ? { ...e, ...o() } : e;
      }, {});
    }
    get plugins() {
      const { editor: e } = this,
        n = jo.sort([...this.extensions].reverse()),
        r = [],
        o = [],
        i = n
          .map((s) => {
            const a = {
                name: s.name,
                options: s.options,
                storage: s.storage,
                editor: e,
                type: mc(s.name, this.schema),
              },
              l = [],
              c = j(s, "addKeyboardShortcuts", a);
            let d = {};
            if (
              (s.type === "mark" &&
                j(s, "exitable", a) &&
                (d.ArrowRight = () => vt.handleExit({ editor: e, mark: s })),
              c)
            ) {
              const g = Object.fromEntries(
                Object.entries(c()).map(([b, y]) => [b, () => y({ editor: e })])
              );
              d = { ...d, ...g };
            }
            const f = Xg(d);
            l.push(f);
            const p = j(s, "addInputRules", a);
            nh(s, e.options.enableInputRules) && p && r.push(...p());
            const h = j(s, "addPasteRules", a);
            nh(s, e.options.enablePasteRules) && h && o.push(...h());
            const m = j(s, "addProseMirrorPlugins", a);
            if (m) {
              const g = m();
              l.push(...g);
            }
            return l;
          })
          .flat();
      return [
        __({ editor: e, rules: r }),
        ...w_({ editor: e, rules: o }),
        ...i,
      ];
    }
    get attributes() {
      return Zp(this.extensions);
    }
    get nodeViews() {
      const { editor: e } = this,
        { nodeExtensions: n } = oa(this.extensions);
      return Object.fromEntries(
        n
          .filter((r) => !!j(r, "addNodeView"))
          .map((r) => {
            const o = this.attributes.filter((l) => l.type === r.name),
              i = {
                name: r.name,
                options: r.options,
                storage: r.storage,
                editor: e,
                type: Ke(r.name, this.schema),
              },
              s = j(r, "addNodeView", i);
            if (!s) return [];
            const a = (l, c, d, f, p) => {
              const h = hc(l, o);
              return s()({
                node: l,
                view: c,
                getPos: d,
                decorations: f,
                innerDecorations: p,
                editor: e,
                extension: r,
                HTMLAttributes: h,
              });
            };
            return [r.name, a];
          })
      );
    }
    setupExtensions() {
      this.extensions.forEach((e) => {
        var n;
        this.editor.extensionStorage[e.name] = e.storage;
        const r = {
          name: e.name,
          options: e.options,
          storage: e.storage,
          editor: this.editor,
          type: mc(e.name, this.schema),
        };
        e.type === "mark" &&
          (!((n = re(j(e, "keepOnSplit", r))) !== null && n !== void 0) || n) &&
          this.splittableMarks.push(e.name);
        const o = j(e, "onBeforeCreate", r),
          i = j(e, "onCreate", r),
          s = j(e, "onUpdate", r),
          a = j(e, "onSelectionUpdate", r),
          l = j(e, "onTransaction", r),
          c = j(e, "onFocus", r),
          d = j(e, "onBlur", r),
          f = j(e, "onDestroy", r);
        o && this.editor.on("beforeCreate", o),
          i && this.editor.on("create", i),
          s && this.editor.on("update", s),
          a && this.editor.on("selectionUpdate", a),
          l && this.editor.on("transaction", l),
          c && this.editor.on("focus", c),
          d && this.editor.on("blur", d),
          f && this.editor.on("destroy", f);
      });
    }
  }
  class we {
    constructor(e = {}) {
      (this.type = "extension"),
        (this.name = "extension"),
        (this.parent = null),
        (this.child = null),
        (this.config = { name: this.name, defaultOptions: {} }),
        (this.config = { ...this.config, ...e }),
        (this.name = this.config.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
          ),
        (this.options = this.config.defaultOptions),
        this.config.addOptions &&
          (this.options = re(j(this, "addOptions", { name: this.name }))),
        (this.storage =
          re(
            j(this, "addStorage", { name: this.name, options: this.options })
          ) || {});
    }
    static create(e = {}) {
      return new we(e);
    }
    configure(e = {}) {
      const n = this.extend({
        ...this.config,
        addOptions: () => aa(this.options, e),
      });
      return (n.name = this.name), (n.parent = this.parent), n;
    }
    extend(e = {}) {
      const n = new we({ ...this.config, ...e });
      return (
        (n.parent = this),
        (this.child = n),
        (n.name = e.name ? e.name : n.parent.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
          ),
        (n.options = re(j(n, "addOptions", { name: n.name }))),
        (n.storage = re(
          j(n, "addStorage", { name: n.name, options: n.options })
        )),
        n
      );
    }
  }
  function rh(t, e, n) {
    const { from: r, to: o } = e,
      {
        blockSeparator: i = `

`,
        textSerializers: s = {},
      } = n || {};
    let a = "";
    return (
      t.nodesBetween(r, o, (l, c, d, f) => {
        var p;
        l.isBlock && c > r && (a += i);
        const h = s == null ? void 0 : s[l.type.name];
        if (h)
          return (
            d && (a += h({ node: l, pos: c, parent: d, index: f, range: e })),
            !1
          );
        l.isText &&
          (a +=
            (p = l == null ? void 0 : l.text) === null || p === void 0
              ? void 0
              : p.slice(Math.max(r, c) - c, o - c));
      }),
      a
    );
  }
  function la(t) {
    return Object.fromEntries(
      Object.entries(t.nodes)
        .filter(([, e]) => e.spec.toText)
        .map(([e, n]) => [e, n.spec.toText])
    );
  }
  const C_ = we.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return { blockSeparator: void 0 };
      },
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor: t } = this,
                  { state: e, schema: n } = t,
                  { doc: r, selection: o } = e,
                  { ranges: i } = o,
                  s = Math.min(...i.map((d) => d.$from.pos)),
                  a = Math.max(...i.map((d) => d.$to.pos)),
                  l = la(n);
                return rh(
                  r,
                  { from: s, to: a },
                  {
                    ...(this.options.blockSeparator !== void 0
                      ? { blockSeparator: this.options.blockSeparator }
                      : {}),
                    textSerializers: l,
                  }
                );
              },
            },
          }),
        ];
      },
    }),
    jT =
      () =>
      ({ editor: t, view: e }) => (
        requestAnimationFrame(() => {
          var n;
          t.isDestroyed ||
            (e.dom.blur(),
            (n = window == null ? void 0 : window.getSelection()) === null ||
              n === void 0 ||
              n.removeAllRanges());
        }),
        !0
      ),
    WT =
      (t = !1) =>
      ({ commands: e }) =>
        e.setContent("", t),
    qT =
      () =>
      ({ state: t, tr: e, dispatch: n }) => {
        const { selection: r } = e,
          { ranges: o } = r;
        return (
          n &&
            o.forEach(({ $from: i, $to: s }) => {
              t.doc.nodesBetween(i.pos, s.pos, (a, l) => {
                if (a.type.isText) return;
                const { doc: c, mapping: d } = e,
                  f = c.resolve(d.map(l)),
                  p = c.resolve(d.map(l + a.nodeSize)),
                  h = f.blockRange(p);
                if (!h) return;
                const m = Lo(h);
                if (a.type.isTextblock) {
                  const { defaultType: g } = f.parent.contentMatchAt(f.index());
                  e.setNodeMarkup(h.start, g);
                }
                (m || m === 0) && e.lift(h, m);
              });
            }),
          !0
        );
      },
    KT = (t) => (e) => t(e),
    GT =
      () =>
      ({ state: t, dispatch: e }) =>
        Rf(t, e),
    JT =
      (t, e) =>
      ({ editor: n, tr: r }) => {
        const { state: o } = n,
          i = o.doc.slice(t.from, t.to);
        r.deleteRange(t.from, t.to);
        const s = r.mapping.map(e);
        return (
          r.insert(s, i.content),
          r.setSelection(new U(r.doc.resolve(s - 1))),
          !0
        );
      },
    YT =
      () =>
      ({ tr: t, dispatch: e }) => {
        const { selection: n } = t,
          r = n.$anchor.node();
        if (r.content.size > 0) return !1;
        const o = t.selection.$anchor;
        for (let i = o.depth; i > 0; i -= 1)
          if (o.node(i).type === r.type) {
            if (e) {
              const a = o.before(i),
                l = o.after(i);
              t.delete(a, l).scrollIntoView();
            }
            return !0;
          }
        return !1;
      },
    XT =
      (t) =>
      ({ tr: e, state: n, dispatch: r }) => {
        const o = Ke(t, n.schema),
          i = e.selection.$anchor;
        for (let s = i.depth; s > 0; s -= 1)
          if (i.node(s).type === o) {
            if (r) {
              const l = i.before(s),
                c = i.after(s);
              e.delete(l, c).scrollIntoView();
            }
            return !0;
          }
        return !1;
      },
    ZT =
      (t) =>
      ({ tr: e, dispatch: n }) => {
        const { from: r, to: o } = t;
        return n && e.delete(r, o), !0;
      },
    QT =
      () =>
      ({ state: t, dispatch: e }) =>
        Dl(t, e),
    eN =
      () =>
      ({ commands: t }) =>
        t.keyboardShortcut("Enter"),
    tN =
      () =>
      ({ state: t, dispatch: e }) =>
        Of(t, e);
  function ca(t, e, n = { strict: !0 }) {
    const r = Object.keys(e);
    return r.length
      ? r.every((o) =>
          n.strict ? e[o] === t[o] : gc(e[o]) ? e[o].test(t[o]) : e[o] === t[o]
        )
      : !0;
  }
  function v_(t, e, n = {}) {
    return t.find(
      (r) =>
        r.type === e &&
        ca(Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])), n)
    );
  }
  function E_(t, e, n = {}) {
    return !!v_(t, e, n);
  }
  function kc(t, e, n) {
    var r;
    if (!t || !e) return;
    let o = t.parent.childAfter(t.parentOffset);
    if (
      ((!o.node || !o.node.marks.some((d) => d.type === e)) &&
        (o = t.parent.childBefore(t.parentOffset)),
      !o.node ||
        !o.node.marks.some((d) => d.type === e) ||
        ((n =
          n ||
          ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs)),
        !v_([...o.node.marks], e, n)))
    )
      return;
    let s = o.index,
      a = t.start() + o.offset,
      l = s + 1,
      c = a + o.node.nodeSize;
    for (; s > 0 && E_([...t.parent.child(s - 1).marks], e, n); )
      (s -= 1), (a -= t.parent.child(s).nodeSize);
    for (; l < t.parent.childCount && E_([...t.parent.child(l).marks], e, n); )
      (c += t.parent.child(l).nodeSize), (l += 1);
    return { from: a, to: c };
  }
  function br(t, e) {
    if (typeof t == "string") {
      if (!e.marks[t])
        throw Error(
          `There is no mark type named '${t}'. Maybe you forgot to add the extension?`
        );
      return e.marks[t];
    }
    return t;
  }
  const nN =
      (t, e = {}) =>
      ({ tr: n, state: r, dispatch: o }) => {
        const i = br(t, r.schema),
          { doc: s, selection: a } = n,
          { $from: l, from: c, to: d } = a;
        if (o) {
          const f = kc(l, i, e);
          if (f && f.from <= c && f.to >= d) {
            const p = U.create(s, f.from, f.to);
            n.setSelection(p);
          }
        }
        return !0;
      },
    rN = (t) => (e) => {
      const n = typeof t == "function" ? t(e) : t;
      for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
      return !1;
    };
  function Si(t) {
    return t instanceof U;
  }
  function Kn(t = 0, e = 0, n = 0) {
    return Math.min(Math.max(t, e), n);
  }
  function oh(t, e = null) {
    if (!e) return null;
    const n = J.atStart(t),
      r = J.atEnd(t);
    if (e === "start" || e === !0) return n;
    if (e === "end") return r;
    const o = n.from,
      i = r.to;
    return e === "all"
      ? U.create(t, Kn(0, o, i), Kn(t.content.size, o, i))
      : U.create(t, Kn(e, o, i), Kn(e, o, i));
  }
  const oN =
      (t = null, e = {}) =>
      ({ editor: n, view: r, tr: o, dispatch: i }) => {
        e = { scrollIntoView: !0, ...e };
        const s = () => {
          r.dom.focus(),
            requestAnimationFrame(() => {
              n.isDestroyed ||
                (r.focus(),
                e != null && e.scrollIntoView && n.commands.scrollIntoView());
            });
        };
        if ((r.hasFocus() && t === null) || t === !1) return !0;
        if (i && t === null && !Si(n.state.selection)) return s(), !0;
        const a = oh(o.doc, t) || n.state.selection,
          l = n.state.selection.eq(a);
        return (
          i &&
            (l || o.setSelection(a),
            l && o.storedMarks && o.setStoredMarks(o.storedMarks),
            s()),
          !0
        );
      },
    iN = (t, e) => (n) => t.every((r, o) => e(r, { ...n, index: o })),
    sN =
      (t, e) =>
      ({ tr: n, commands: r }) =>
        r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
    A_ = (t) => {
      const e = t.childNodes;
      for (let n = e.length - 1; n >= 0; n -= 1) {
        const r = e[n];
        r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
          ? t.removeChild(r)
          : r.nodeType === 1 && A_(r);
      }
      return t;
    };
  function Mi(t) {
    const e = `<body>${t}</body>`,
      n = new window.DOMParser().parseFromString(e, "text/html").body;
    return A_(n);
  }
  function ua(t, e, n) {
    if (t instanceof Qt || t instanceof D) return t;
    n = { slice: !0, parseOptions: {}, ...n };
    const r = typeof t == "object" && t !== null,
      o = typeof t == "string";
    if (r)
      try {
        if (Array.isArray(t) && t.length > 0)
          return D.fromArray(t.map((a) => e.nodeFromJSON(a)));
        const s = e.nodeFromJSON(t);
        return n.errorOnInvalidContent && s.check(), s;
      } catch (i) {
        if (n.errorOnInvalidContent)
          throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
        return (
          console.warn(
            "[tiptap warn]: Invalid content.",
            "Passed value:",
            t,
            "Error:",
            i
          ),
          ua("", e, n)
        );
      }
    if (o) {
      if (n.errorOnInvalidContent) {
        let s = !1,
          a = "";
        const l = new _s({
          topNode: e.spec.topNode,
          marks: e.spec.marks,
          nodes: e.spec.nodes.append({
            __tiptap__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [
                {
                  tag: "*",
                  getAttrs: (c) => (
                    (s = !0), (a = typeof c == "string" ? c : c.outerHTML), null
                  ),
                },
              ],
            },
          }),
        });
        if (
          (n.slice
            ? Pn.fromSchema(l).parseSlice(Mi(t), n.parseOptions)
            : Pn.fromSchema(l).parse(Mi(t), n.parseOptions),
          n.errorOnInvalidContent && s)
        )
          throw new Error("[tiptap error]: Invalid HTML content", {
            cause: new Error(`Invalid element found: ${a}`),
          });
      }
      const i = Pn.fromSchema(e);
      return n.slice
        ? i.parseSlice(Mi(t), n.parseOptions).content
        : i.parse(Mi(t), n.parseOptions);
    }
    return ua("", e, n);
  }
  function S_(t, e, n) {
    const r = t.steps.length - 1;
    if (r < e) return;
    const o = t.steps[r];
    if (!(o instanceof Ze || o instanceof Qe)) return;
    const i = t.mapping.maps[r];
    let s = 0;
    i.forEach((a, l, c, d) => {
      s === 0 && (s = d);
    }),
      t.setSelection(J.near(t.doc.resolve(s), n));
  }
  const aN = (t) => !("type" in t),
    lN =
      (t, e, n) =>
      ({ tr: r, dispatch: o, editor: i }) => {
        var s;
        if (o) {
          n = {
            parseOptions: i.options.parseOptions,
            updateSelection: !0,
            applyInputRules: !1,
            applyPasteRules: !1,
            ...n,
          };
          let a;
          try {
            a = ua(e, i.schema, {
              parseOptions: { preserveWhitespace: "full", ...n.parseOptions },
              errorOnInvalidContent:
                (s = n.errorOnInvalidContent) !== null && s !== void 0
                  ? s
                  : i.options.enableContentCheck,
            });
          } catch (m) {
            return (
              i.emit("contentError", {
                editor: i,
                error: m,
                disableCollaboration: () => {
                  i.storage.collaboration &&
                    (i.storage.collaboration.isDisabled = !0);
                },
              }),
              !1
            );
          }
          let { from: l, to: c } =
              typeof t == "number"
                ? { from: t, to: t }
                : { from: t.from, to: t.to },
            d = !0,
            f = !0;
          if (
            ((aN(a) ? a : [a]).forEach((m) => {
              m.check(),
                (d = d ? m.isText && m.marks.length === 0 : !1),
                (f = f ? m.isBlock : !1);
            }),
            l === c && f)
          ) {
            const { parent: m } = r.doc.resolve(l);
            m.isTextblock &&
              !m.type.spec.code &&
              !m.childCount &&
              ((l -= 1), (c += 1));
          }
          let h;
          if (d) {
            if (Array.isArray(e)) h = e.map((m) => m.text || "").join("");
            else if (e instanceof D) {
              let m = "";
              e.forEach((g) => {
                g.text && (m += g.text);
              }),
                (h = m);
            } else typeof e == "object" && e && e.text ? (h = e.text) : (h = e);
            r.insertText(h, l, c);
          } else (h = a), r.replaceWith(l, c, h);
          n.updateSelection && S_(r, r.steps.length - 1, -1),
            n.applyInputRules &&
              r.setMeta("applyInputRules", { from: l, text: h }),
            n.applyPasteRules &&
              r.setMeta("applyPasteRules", { from: l, text: h });
        }
        return !0;
      },
    cN =
      () =>
      ({ state: t, dispatch: e }) =>
        Ll(t, e),
    uN =
      () =>
      ({ state: t, dispatch: e }) =>
        Ug(t, e),
    dN =
      () =>
      ({ state: t, dispatch: e }) =>
        Cf(t, e),
    fN =
      () =>
      ({ state: t, dispatch: e }) =>
        Af(t, e),
    pN =
      () =>
      ({ state: t, dispatch: e, tr: n }) => {
        try {
          const r = xs(t.doc, t.selection.$from.pos, -1);
          return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
        } catch {
          return !1;
        }
      },
    hN =
      () =>
      ({ state: t, dispatch: e, tr: n }) => {
        try {
          const r = xs(t.doc, t.selection.$from.pos, 1);
          return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
        } catch {
          return !1;
        }
      },
    mN =
      () =>
      ({ state: t, dispatch: e }) =>
        Fg(t, e),
    gN =
      () =>
      ({ state: t, dispatch: e }) =>
        Hg(t, e);
  function wc() {
    return (
      [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod",
      ].includes(navigator.platform) ||
      (navigator.userAgent.includes("Mac") && "ontouchend" in document)
    );
  }
  function ih() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
  }
  function bN(t) {
    const e = t.split(/-(?!$)/);
    let n = e[e.length - 1];
    n === "Space" && (n = " ");
    let r, o, i, s;
    for (let a = 0; a < e.length - 1; a += 1) {
      const l = e[a];
      if (/^(cmd|meta|m)$/i.test(l)) s = !0;
      else if (/^a(lt)?$/i.test(l)) r = !0;
      else if (/^(c|ctrl|control)$/i.test(l)) o = !0;
      else if (/^s(hift)?$/i.test(l)) i = !0;
      else if (/^mod$/i.test(l)) wc() || ih() ? (s = !0) : (o = !0);
      else throw new Error(`Unrecognized modifier name: ${l}`);
    }
    return (
      r && (n = `Alt-${n}`),
      o && (n = `Ctrl-${n}`),
      s && (n = `Meta-${n}`),
      i && (n = `Shift-${n}`),
      n
    );
  }
  const yN =
    (t) =>
    ({ editor: e, view: n, tr: r, dispatch: o }) => {
      const i = bN(t).split(/-(?!$)/),
        s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)),
        a = new KeyboardEvent("keydown", {
          key: s === "Space" ? " " : s,
          altKey: i.includes("Alt"),
          ctrlKey: i.includes("Ctrl"),
          metaKey: i.includes("Meta"),
          shiftKey: i.includes("Shift"),
          bubbles: !0,
          cancelable: !0,
        }),
        l = e.captureTransaction(() => {
          n.someProp("handleKeyDown", (c) => c(n, a));
        });
      return (
        l == null ||
          l.steps.forEach((c) => {
            const d = c.map(r.mapping);
            d && o && r.maybeStep(d);
          }),
        !0
      );
    };
  function Ut(t, e, n = {}) {
    const { from: r, to: o, empty: i } = t.selection,
      s = e ? Ke(e, t.schema) : null,
      a = [];
    t.doc.nodesBetween(r, o, (f, p) => {
      if (f.isText) return;
      const h = Math.max(r, p),
        m = Math.min(o, p + f.nodeSize);
      a.push({ node: f, from: h, to: m });
    });
    const l = o - r,
      c = a
        .filter((f) => (s ? s.name === f.node.type.name : !0))
        .filter((f) => ca(f.node.attrs, n, { strict: !1 }));
    return i ? !!c.length : c.reduce((f, p) => f + p.to - p.from, 0) >= l;
  }
  const _N =
      (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const o = Ke(t, n.schema);
        return Ut(n, o, e) ? Il(n, r) : !1;
      },
    kN =
      () =>
      ({ state: t, dispatch: e }) =>
        Df(t, e),
    wN =
      (t) =>
      ({ state: e, dispatch: n }) => {
        const r = Ke(t, e.schema);
        return Ny(r)(e, n);
      },
    xN =
      () =>
      ({ state: t, dispatch: e }) =>
        Tf(t, e);
  function da(t, e) {
    return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
  }
  function sh(t, e) {
    const n = typeof e == "string" ? [e] : e;
    return Object.keys(t).reduce(
      (r, o) => (n.includes(o) || (r[o] = t[o]), r),
      {}
    );
  }
  const CN =
      (t, e) =>
      ({ tr: n, state: r, dispatch: o }) => {
        let i = null,
          s = null;
        const a = da(typeof t == "string" ? t : t.name, r.schema);
        return a
          ? (a === "node" && (i = Ke(t, r.schema)),
            a === "mark" && (s = br(t, r.schema)),
            o &&
              n.selection.ranges.forEach((l) => {
                r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, d) => {
                  i &&
                    i === c.type &&
                    n.setNodeMarkup(d, void 0, sh(c.attrs, e)),
                    s &&
                      c.marks.length &&
                      c.marks.forEach((f) => {
                        s === f.type &&
                          n.addMark(
                            d,
                            d + c.nodeSize,
                            s.create(sh(f.attrs, e))
                          );
                      });
                });
              }),
            !0)
          : !1;
      },
    vN =
      () =>
      ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
    EN =
      () =>
      ({ tr: t, dispatch: e }) => {
        if (e) {
          const n = new mt(t.doc);
          t.setSelection(n);
        }
        return !0;
      },
    AN =
      () =>
      ({ state: t, dispatch: e }) =>
        vf(t, e),
    SN =
      () =>
      ({ state: t, dispatch: e }) =>
        Sf(t, e),
    MN =
      () =>
      ({ state: t, dispatch: e }) =>
        Bl(t, e),
    TN =
      () =>
      ({ state: t, dispatch: e }) =>
        Bf(t, e),
    NN =
      () =>
      ({ state: t, dispatch: e }) =>
        If(t, e);
  function xc(t, e, n = {}, r = {}) {
    return ua(t, e, {
      slice: !1,
      parseOptions: n,
      errorOnInvalidContent: r.errorOnInvalidContent,
    });
  }
  const ON =
    (t, e = !1, n = {}, r = {}) =>
    ({ editor: o, tr: i, dispatch: s, commands: a }) => {
      var l, c;
      const { doc: d } = i;
      if (n.preserveWhitespace !== "full") {
        const f = xc(t, o.schema, n, {
          errorOnInvalidContent:
            (l = r.errorOnInvalidContent) !== null && l !== void 0
              ? l
              : o.options.enableContentCheck,
        });
        return (
          s && i.replaceWith(0, d.content.size, f).setMeta("preventUpdate", !e),
          !0
        );
      }
      return (
        s && i.setMeta("preventUpdate", !e),
        a.insertContentAt({ from: 0, to: d.content.size }, t, {
          parseOptions: n,
          errorOnInvalidContent:
            (c = r.errorOnInvalidContent) !== null && c !== void 0
              ? c
              : o.options.enableContentCheck,
        })
      );
    };
  function ah(t, e) {
    const n = br(e, t.schema),
      { from: r, to: o, empty: i } = t.selection,
      s = [];
    i
      ? (t.storedMarks && s.push(...t.storedMarks),
        s.push(...t.selection.$head.marks()))
      : t.doc.nodesBetween(r, o, (l) => {
          s.push(...l.marks);
        });
    const a = s.find((l) => l.type.name === n.name);
    return a ? { ...a.attrs } : {};
  }
  function M_(t, e) {
    const n = new Tl(t);
    return (
      e.forEach((r) => {
        r.steps.forEach((o) => {
          n.step(o);
        });
      }),
      n
    );
  }
  function T_(t) {
    for (let e = 0; e < t.edgeCount; e += 1) {
      const { type: n } = t.edge(e);
      if (n.isTextblock && !n.hasRequiredAttrs()) return n;
    }
    return null;
  }
  function RN(t, e) {
    const n = [];
    return (
      t.descendants((r, o) => {
        e(r) && n.push({ node: r, pos: o });
      }),
      n
    );
  }
  function N_(t, e, n) {
    const r = [];
    return (
      t.nodesBetween(e.from, e.to, (o, i) => {
        n(o) && r.push({ node: o, pos: i });
      }),
      r
    );
  }
  function lh(t, e) {
    for (let n = t.depth; n > 0; n -= 1) {
      const r = t.node(n);
      if (e(r))
        return {
          pos: n > 0 ? t.before(n) : 0,
          start: t.start(n),
          depth: n,
          node: r,
        };
    }
  }
  function jt(t) {
    return (e) => lh(e.$from, t);
  }
  function Cc(t, e) {
    const n = jo.resolve(t);
    return th(n, e);
  }
  function DN(t, e) {
    const n = Cc(e),
      r = Qt.fromJSON(n, t);
    return ia(r.content, n);
  }
  function LN(t, e) {
    const n = Cc(e),
      r = Mi(t);
    return Pn.fromSchema(n).parse(r).toJSON();
  }
  function vc(t, e) {
    const n = { from: 0, to: t.content.size };
    return rh(t, n, e);
  }
  function IN(t, e, n) {
    const {
        blockSeparator: r = `

`,
        textSerializers: o = {},
      } = n || {},
      i = Cc(e),
      s = Qt.fromJSON(i, t);
    return vc(s, { blockSeparator: r, textSerializers: { ...la(i), ...o } });
  }
  function O_(t, e) {
    const n = Ke(e, t.schema),
      { from: r, to: o } = t.selection,
      i = [];
    t.doc.nodesBetween(r, o, (a) => {
      i.push(a);
    });
    const s = i.reverse().find((a) => a.type.name === n.name);
    return s ? { ...s.attrs } : {};
  }
  function ch(t, e) {
    const n = da(typeof e == "string" ? e : e.name, t.schema);
    return n === "node" ? O_(t, e) : n === "mark" ? ah(t, e) : {};
  }
  function R_(t, e = JSON.stringify) {
    const n = {};
    return t.filter((r) => {
      const o = e(r);
      return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0);
    });
  }
  function BN(t) {
    const e = R_(t);
    return e.length === 1
      ? e
      : e.filter(
          (n, r) =>
            !e
              .filter((i, s) => s !== r)
              .some(
                (i) =>
                  n.oldRange.from >= i.oldRange.from &&
                  n.oldRange.to <= i.oldRange.to &&
                  n.newRange.from >= i.newRange.from &&
                  n.newRange.to <= i.newRange.to
              )
        );
  }
  function D_(t) {
    const { mapping: e, steps: n } = t,
      r = [];
    return (
      e.maps.forEach((o, i) => {
        const s = [];
        if (o.ranges.length)
          o.forEach((a, l) => {
            s.push({ from: a, to: l });
          });
        else {
          const { from: a, to: l } = n[i];
          if (a === void 0 || l === void 0) return;
          s.push({ from: a, to: l });
        }
        s.forEach(({ from: a, to: l }) => {
          const c = e.slice(i).map(a, -1),
            d = e.slice(i).map(l),
            f = e.invert().map(c, -1),
            p = e.invert().map(d);
          r.push({
            oldRange: { from: f, to: p },
            newRange: { from: c, to: d },
          });
        });
      }),
      BN(r)
    );
  }
  function L_(t, e = 0) {
    const r = t.type === t.type.schema.topNodeType ? 0 : 1,
      o = e,
      i = o + t.nodeSize,
      s = t.marks.map((c) => {
        const d = { type: c.type.name };
        return Object.keys(c.attrs).length && (d.attrs = { ...c.attrs }), d;
      }),
      a = { ...t.attrs },
      l = { type: t.type.name, from: o, to: i };
    return (
      Object.keys(a).length && (l.attrs = a),
      s.length && (l.marks = s),
      t.content.childCount &&
        ((l.content = []),
        t.forEach((c, d) => {
          var f;
          (f = l.content) === null || f === void 0 || f.push(L_(c, e + d + r));
        })),
      t.text && (l.text = t.text),
      l
    );
  }
  function Ec(t, e, n) {
    const r = [];
    return (
      t === e
        ? n
            .resolve(t)
            .marks()
            .forEach((o) => {
              const i = n.resolve(t),
                s = kc(i, o.type);
              s && r.push({ mark: o, ...s });
            })
        : n.nodesBetween(t, e, (o, i) => {
            !o ||
              (o == null ? void 0 : o.nodeSize) === void 0 ||
              r.push(
                ...o.marks.map((s) => ({
                  from: i,
                  to: i + o.nodeSize,
                  mark: s,
                }))
              );
          }),
      r
    );
  }
  const I_ = (t, e, n, r = 20) => {
    const o = t.doc.resolve(n);
    let i = r,
      s = null;
    for (; i > 0 && s === null; ) {
      const a = o.node(i);
      (a == null ? void 0 : a.type.name) === e ? (s = a) : (i -= 1);
    }
    return [s, i];
  };
  function fa(t, e, n) {
    return Object.fromEntries(
      Object.entries(n).filter(([r]) => {
        const o = t.find((i) => i.type === e && i.name === r);
        return o ? o.attribute.keepOnSplit : !1;
      })
    );
  }
  function Ac(t, e, n = {}) {
    const { empty: r, ranges: o } = t.selection,
      i = e ? br(e, t.schema) : null;
    if (r)
      return !!(t.storedMarks || t.selection.$from.marks())
        .filter((f) => (i ? i.name === f.type.name : !0))
        .find((f) => ca(f.attrs, n, { strict: !1 }));
    let s = 0;
    const a = [];
    if (
      (o.forEach(({ $from: f, $to: p }) => {
        const h = f.pos,
          m = p.pos;
        t.doc.nodesBetween(h, m, (g, b) => {
          if (!g.isText && !g.marks.length) return;
          const y = Math.max(h, b),
            x = Math.min(m, b + g.nodeSize),
            w = x - y;
          (s += w),
            a.push(...g.marks.map((_) => ({ mark: _, from: y, to: x })));
        });
      }),
      s === 0)
    )
      return !1;
    const l = a
        .filter((f) => (i ? i.name === f.mark.type.name : !0))
        .filter((f) => ca(f.mark.attrs, n, { strict: !1 }))
        .reduce((f, p) => f + p.to - p.from, 0),
      c = a
        .filter((f) => (i ? f.mark.type !== i && f.mark.type.excludes(i) : !0))
        .reduce((f, p) => f + p.to - p.from, 0);
    return (l > 0 ? l + c : l) >= s;
  }
  function Et(t, e, n = {}) {
    if (!e) return Ut(t, null, n) || Ac(t, null, n);
    const r = da(e, t.schema);
    return r === "node" ? Ut(t, e, n) : r === "mark" ? Ac(t, e, n) : !1;
  }
  const B_ = (t, e) => {
      const { $from: n, $to: r, $anchor: o } = t.selection;
      if (e) {
        const i = jt((a) => a.type.name === e)(t.selection);
        if (!i) return !1;
        const s = t.doc.resolve(i.pos + 1);
        return o.pos + 1 === s.end();
      }
      return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
    },
    P_ = (t) => {
      const { $from: e, $to: n } = t.selection;
      return !(e.parentOffset > 0 || e.pos !== n.pos);
    };
  function Sc(t, e) {
    const { nodeExtensions: n } = oa(e),
      r = n.find((s) => s.name === t);
    if (!r) return !1;
    const o = { name: r.name, options: r.options, storage: r.storage },
      i = re(j(r, "group", o));
    return typeof i != "string" ? !1 : i.split(" ").includes("list");
  }
  function pa(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
    var r;
    if (n) {
      if (t.type.name === "hardBreak") return !0;
      if (t.isText)
        return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
    }
    if (t.isText) return !t.text;
    if (t.isAtom || t.isLeaf) return !1;
    if (t.content.childCount === 0) return !0;
    if (e) {
      let o = !0;
      return (
        t.content.forEach((i) => {
          o !== !1 &&
            (pa(i, { ignoreWhitespace: n, checkChildren: e }) || (o = !1));
        }),
        o
      );
    }
    return !1;
  }
  function ha(t) {
    return t instanceof K;
  }
  function Mc(t, e, n) {
    const o = t.state.doc.content.size,
      i = Kn(e, 0, o),
      s = Kn(n, 0, o),
      a = t.coordsAtPos(i),
      l = t.coordsAtPos(s, -1),
      c = Math.min(a.top, l.top),
      d = Math.max(a.bottom, l.bottom),
      f = Math.min(a.left, l.left),
      p = Math.max(a.right, l.right),
      h = p - f,
      m = d - c,
      y = {
        top: c,
        bottom: d,
        left: f,
        right: p,
        width: h,
        height: m,
        x: f,
        y: c,
      };
    return { ...y, toJSON: () => y };
  }
  function $_({
    json: t,
    validMarks: e,
    validNodes: n,
    options: r,
    rewrittenContent: o = [],
  }) {
    return (
      t.marks &&
        Array.isArray(t.marks) &&
        (t.marks = t.marks.filter((i) => {
          const s = typeof i == "string" ? i : i.type;
          return e.has(s)
            ? !0
            : (o.push({
                original: JSON.parse(JSON.stringify(i)),
                unsupported: s,
              }),
              !1);
        })),
      t.content &&
        Array.isArray(t.content) &&
        (t.content = t.content
          .map(
            (i) =>
              $_({
                json: i,
                validMarks: e,
                validNodes: n,
                options: r,
                rewrittenContent: o,
              }).json
          )
          .filter((i) => i != null)),
      t.type && !n.has(t.type)
        ? (o.push({
            original: JSON.parse(JSON.stringify(t)),
            unsupported: t.type,
          }),
          t.content &&
          Array.isArray(t.content) &&
          (r == null ? void 0 : r.fallbackToParagraph) !== !1
            ? ((t.type = "paragraph"), { json: t, rewrittenContent: o })
            : { json: null, rewrittenContent: o })
        : { json: t, rewrittenContent: o }
    );
  }
  function PN(t, e, n) {
    return $_({
      json: t,
      validNodes: new Set(Object.keys(e.nodes)),
      validMarks: new Set(Object.keys(e.marks)),
      options: n,
    });
  }
  function $N(t, e, n) {
    var r;
    const { selection: o } = e;
    let i = null;
    if ((Si(o) && (i = o.$cursor), i)) {
      const a = (r = t.storedMarks) !== null && r !== void 0 ? r : i.marks();
      return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
    }
    const { ranges: s } = o;
    return s.some(({ $from: a, $to: l }) => {
      let c =
        a.depth === 0
          ? t.doc.inlineContent && t.doc.type.allowsMarkType(n)
          : !1;
      return (
        t.doc.nodesBetween(a.pos, l.pos, (d, f, p) => {
          if (c) return !1;
          if (d.isInline) {
            const h = !p || p.type.allowsMarkType(n),
              m =
                !!n.isInSet(d.marks) ||
                !d.marks.some((g) => g.type.excludes(n));
            c = h && m;
          }
          return !c;
        }),
        c
      );
    });
  }
  const FN =
      (t, e = {}) =>
      ({ tr: n, state: r, dispatch: o }) => {
        const { selection: i } = n,
          { empty: s, ranges: a } = i,
          l = br(t, r.schema);
        if (o)
          if (s) {
            const c = ah(r, l);
            n.addStoredMark(l.create({ ...c, ...e }));
          } else
            a.forEach((c) => {
              const d = c.$from.pos,
                f = c.$to.pos;
              r.doc.nodesBetween(d, f, (p, h) => {
                const m = Math.max(h, d),
                  g = Math.min(h + p.nodeSize, f);
                p.marks.find((y) => y.type === l)
                  ? p.marks.forEach((y) => {
                      l === y.type &&
                        n.addMark(m, g, l.create({ ...y.attrs, ...e }));
                    })
                  : n.addMark(m, g, l.create(e));
              });
            });
        return $N(r, n, l);
      },
    HN =
      (t, e) =>
      ({ tr: n }) => (n.setMeta(t, e), !0),
    zN =
      (t, e = {}) =>
      ({ state: n, dispatch: r, chain: o }) => {
        const i = Ke(t, n.schema);
        let s;
        return (
          n.selection.$anchor.sameParent(n.selection.$head) &&
            (s = n.selection.$anchor.parent.attrs),
          i.isTextblock
            ? o()
                .command(({ commands: a }) =>
                  $l(i, { ...s, ...e })(n) ? !0 : a.clearNodes()
                )
                .command(({ state: a }) => $l(i, { ...s, ...e })(a, r))
                .run()
            : (console.warn(
                '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
              ),
              !1)
        );
      },
    VN =
      (t) =>
      ({ tr: e, dispatch: n }) => {
        if (n) {
          const { doc: r } = e,
            o = Kn(t, 0, r.content.size),
            i = K.create(r, o);
          e.setSelection(i);
        }
        return !0;
      },
    UN =
      (t) =>
      ({ tr: e, dispatch: n }) => {
        if (n) {
          const { doc: r } = e,
            { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : t,
            s = U.atStart(r).from,
            a = U.atEnd(r).to,
            l = Kn(o, s, a),
            c = Kn(i, s, a),
            d = U.create(r, l, c);
          e.setSelection(d);
        }
        return !0;
      },
    jN =
      (t) =>
      ({ state: e, dispatch: n }) => {
        const r = Ke(t, e.schema);
        return Oy(r)(e, n);
      };
  function F_(t, e) {
    const n =
      t.storedMarks ||
      (t.selection.$to.parentOffset && t.selection.$from.marks());
    if (n) {
      const r = n.filter((o) => (e == null ? void 0 : e.includes(o.type.name)));
      t.tr.ensureMarks(r);
    }
  }
  const WN =
      ({ keepMarks: t = !0 } = {}) =>
      ({ tr: e, state: n, dispatch: r, editor: o }) => {
        const { selection: i, doc: s } = e,
          { $from: a, $to: l } = i,
          c = o.extensionManager.attributes,
          d = fa(c, a.node().type.name, a.node().attrs);
        if (i instanceof K && i.node.isBlock)
          return !a.parentOffset || !En(s, a.pos)
            ? !1
            : (r &&
                (t && F_(n, o.extensionManager.splittableMarks),
                e.split(a.pos).scrollIntoView()),
              !0);
        if (!a.parent.isBlock) return !1;
        const f = l.parentOffset === l.parent.content.size,
          p =
            a.depth === 0
              ? void 0
              : T_(a.node(-1).contentMatchAt(a.indexAfter(-1)));
        let h = f && p ? [{ type: p, attrs: d }] : void 0,
          m = En(e.doc, e.mapping.map(a.pos), 1, h);
        if (
          (!h &&
            !m &&
            En(e.doc, e.mapping.map(a.pos), 1, p ? [{ type: p }] : void 0) &&
            ((m = !0), (h = p ? [{ type: p, attrs: d }] : void 0)),
          r)
        ) {
          if (
            m &&
            (i instanceof U && e.deleteSelection(),
            e.split(e.mapping.map(a.pos), 1, h),
            p && !f && !a.parentOffset && a.parent.type !== p)
          ) {
            const g = e.mapping.map(a.before()),
              b = e.doc.resolve(g);
            a.node(-1).canReplaceWith(b.index(), b.index() + 1, p) &&
              e.setNodeMarkup(e.mapping.map(a.before()), p);
          }
          t && F_(n, o.extensionManager.splittableMarks), e.scrollIntoView();
        }
        return m;
      },
    qN =
      (t, e = {}) =>
      ({ tr: n, state: r, dispatch: o, editor: i }) => {
        var s;
        const a = Ke(t, r.schema),
          { $from: l, $to: c } = r.selection,
          d = r.selection.node;
        if ((d && d.isBlock) || l.depth < 2 || !l.sameParent(c)) return !1;
        const f = l.node(-1);
        if (f.type !== a) return !1;
        const p = i.extensionManager.attributes;
        if (
          l.parent.content.size === 0 &&
          l.node(-1).childCount === l.indexAfter(-1)
        ) {
          if (
            l.depth === 2 ||
            l.node(-3).type !== a ||
            l.index(-2) !== l.node(-2).childCount - 1
          )
            return !1;
          if (o) {
            let y = D.empty;
            const x = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
            for (let N = l.depth - x; N >= l.depth - 3; N -= 1)
              y = D.from(l.node(N).copy(y));
            const w =
                l.indexAfter(-1) < l.node(-2).childCount
                  ? 1
                  : l.indexAfter(-2) < l.node(-3).childCount
                  ? 2
                  : 3,
              _ = { ...fa(p, l.node().type.name, l.node().attrs), ...e },
              v =
                ((s = a.contentMatch.defaultType) === null || s === void 0
                  ? void 0
                  : s.createAndFill(_)) || void 0;
            y = y.append(D.from(a.createAndFill(null, v) || void 0));
            const C = l.before(l.depth - (x - 1));
            n.replace(C, l.after(-w), new z(y, 4 - x, 0));
            let S = -1;
            n.doc.nodesBetween(C, n.doc.content.size, (N, M) => {
              if (S > -1) return !1;
              N.isTextblock && N.content.size === 0 && (S = M + 1);
            }),
              S > -1 && n.setSelection(U.near(n.doc.resolve(S))),
              n.scrollIntoView();
          }
          return !0;
        }
        const h = c.pos === l.end() ? f.contentMatchAt(0).defaultType : null,
          m = { ...fa(p, f.type.name, f.attrs), ...e },
          g = { ...fa(p, l.node().type.name, l.node().attrs), ...e };
        n.delete(l.pos, c.pos);
        const b = h
          ? [
              { type: a, attrs: m },
              { type: h, attrs: g },
            ]
          : [{ type: a, attrs: m }];
        if (!En(n.doc, l.pos, 2)) return !1;
        if (o) {
          const { selection: y, storedMarks: x } = r,
            { splittableMarks: w } = i.extensionManager,
            _ = x || (y.$to.parentOffset && y.$from.marks());
          if ((n.split(l.pos, 2, b).scrollIntoView(), !_ || !o)) return !0;
          const v = _.filter((C) => w.includes(C.type.name));
          n.ensureMarks(v);
        }
        return !0;
      },
    uh = (t, e) => {
      const n = jt((s) => s.type === e)(t.selection);
      if (!n) return !0;
      const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
      if (r === void 0) return !0;
      const o = t.doc.nodeAt(r);
      return (
        n.node.type === (o == null ? void 0 : o.type) &&
          An(t.doc, n.pos) &&
          t.join(n.pos),
        !0
      );
    },
    dh = (t, e) => {
      const n = jt((s) => s.type === e)(t.selection);
      if (!n) return !0;
      const r = t.doc.resolve(n.start).after(n.depth);
      if (r === void 0) return !0;
      const o = t.doc.nodeAt(r);
      return (
        n.node.type === (o == null ? void 0 : o.type) &&
          An(t.doc, r) &&
          t.join(r),
        !0
      );
    };
  var KN = Object.freeze({
    __proto__: null,
    blur: jT,
    clearContent: WT,
    clearNodes: qT,
    command: KT,
    createParagraphNear: GT,
    cut: JT,
    deleteCurrentNode: YT,
    deleteNode: XT,
    deleteRange: ZT,
    deleteSelection: QT,
    enter: eN,
    exitCode: tN,
    extendMarkRange: nN,
    first: rN,
    focus: oN,
    forEach: iN,
    insertContent: sN,
    insertContentAt: lN,
    joinBackward: dN,
    joinDown: uN,
    joinForward: fN,
    joinItemBackward: pN,
    joinItemForward: hN,
    joinTextblockBackward: mN,
    joinTextblockForward: gN,
    joinUp: cN,
    keyboardShortcut: yN,
    lift: _N,
    liftEmptyBlock: kN,
    liftListItem: wN,
    newlineInCode: xN,
    resetAttributes: CN,
    scrollIntoView: vN,
    selectAll: EN,
    selectNodeBackward: AN,
    selectNodeForward: SN,
    selectParentNode: MN,
    selectTextblockEnd: TN,
    selectTextblockStart: NN,
    setContent: ON,
    setMark: FN,
    setMeta: HN,
    setNode: zN,
    setNodeSelection: VN,
    setTextSelection: UN,
    sinkListItem: jN,
    splitBlock: WN,
    splitListItem: qN,
    toggleList:
      (t, e, n, r = {}) =>
      ({
        editor: o,
        tr: i,
        state: s,
        dispatch: a,
        chain: l,
        commands: c,
        can: d,
      }) => {
        const { extensions: f, splittableMarks: p } = o.extensionManager,
          h = Ke(t, s.schema),
          m = Ke(e, s.schema),
          { selection: g, storedMarks: b } = s,
          { $from: y, $to: x } = g,
          w = y.blockRange(x),
          _ = b || (g.$to.parentOffset && g.$from.marks());
        if (!w) return !1;
        const v = jt((C) => Sc(C.type.name, f))(g);
        if (w.depth >= 1 && v && w.depth - v.depth <= 1) {
          if (v.node.type === h) return c.liftListItem(m);
          if (Sc(v.node.type.name, f) && h.validContent(v.node.content) && a)
            return l()
              .command(() => (i.setNodeMarkup(v.pos, h), !0))
              .command(() => uh(i, h))
              .command(() => dh(i, h))
              .run();
        }
        return !n || !_ || !a
          ? l()
              .command(() => (d().wrapInList(h, r) ? !0 : c.clearNodes()))
              .wrapInList(h, r)
              .command(() => uh(i, h))
              .command(() => dh(i, h))
              .run()
          : l()
              .command(() => {
                const C = d().wrapInList(h, r),
                  S = _.filter((N) => p.includes(N.type.name));
                return i.ensureMarks(S), C ? !0 : c.clearNodes();
              })
              .wrapInList(h, r)
              .command(() => uh(i, h))
              .command(() => dh(i, h))
              .run();
      },
    toggleMark:
      (t, e = {}, n = {}) =>
      ({ state: r, commands: o }) => {
        const { extendEmptyMarkRange: i = !1 } = n,
          s = br(t, r.schema);
        return Ac(r, s, e)
          ? o.unsetMark(s, { extendEmptyMarkRange: i })
          : o.setMark(s, e);
      },
    toggleNode:
      (t, e, n = {}) =>
      ({ state: r, commands: o }) => {
        const i = Ke(t, r.schema),
          s = Ke(e, r.schema),
          a = Ut(r, i, n);
        let l;
        return (
          r.selection.$anchor.sameParent(r.selection.$head) &&
            (l = r.selection.$anchor.parent.attrs),
          a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n })
        );
      },
    toggleWrap:
      (t, e = {}) =>
      ({ state: n, commands: r }) => {
        const o = Ke(t, n.schema);
        return Ut(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
      },
    undoInputRule:
      () =>
      ({ state: t, dispatch: e }) => {
        const n = t.plugins;
        for (let r = 0; r < n.length; r += 1) {
          const o = n[r];
          let i;
          if (o.spec.isInputRules && (i = o.getState(t))) {
            if (e) {
              const s = t.tr,
                a = i.transform;
              for (let l = a.steps.length - 1; l >= 0; l -= 1)
                s.step(a.steps[l].invert(a.docs[l]));
              if (i.text) {
                const l = s.doc.resolve(i.from).marks();
                s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
              } else s.delete(i.from, i.to);
            }
            return !0;
          }
        }
        return !1;
      },
    unsetAllMarks:
      () =>
      ({ tr: t, dispatch: e }) => {
        const { selection: n } = t,
          { empty: r, ranges: o } = n;
        return (
          r ||
            (e &&
              o.forEach((i) => {
                t.removeMark(i.$from.pos, i.$to.pos);
              })),
          !0
        );
      },
    unsetMark:
      (t, e = {}) =>
      ({ tr: n, state: r, dispatch: o }) => {
        var i;
        const { extendEmptyMarkRange: s = !1 } = e,
          { selection: a } = n,
          l = br(t, r.schema),
          { $from: c, empty: d, ranges: f } = a;
        if (!o) return !0;
        if (d && s) {
          let { from: p, to: h } = a;
          const m =
              (i = c.marks().find((b) => b.type === l)) === null || i === void 0
                ? void 0
                : i.attrs,
            g = kc(c, l, m);
          g && ((p = g.from), (h = g.to)), n.removeMark(p, h, l);
        } else
          f.forEach((p) => {
            n.removeMark(p.$from.pos, p.$to.pos, l);
          });
        return n.removeStoredMark(l), !0;
      },
    updateAttributes:
      (t, e = {}) =>
      ({ tr: n, state: r, dispatch: o }) => {
        let i = null,
          s = null;
        const a = da(typeof t == "string" ? t : t.name, r.schema);
        return a
          ? (a === "node" && (i = Ke(t, r.schema)),
            a === "mark" && (s = br(t, r.schema)),
            o &&
              n.selection.ranges.forEach((l) => {
                const c = l.$from.pos,
                  d = l.$to.pos;
                let f, p, h, m;
                n.selection.empty
                  ? r.doc.nodesBetween(c, d, (g, b) => {
                      i &&
                        i === g.type &&
                        ((h = Math.max(b, c)),
                        (m = Math.min(b + g.nodeSize, d)),
                        (f = b),
                        (p = g));
                    })
                  : r.doc.nodesBetween(c, d, (g, b) => {
                      b < c &&
                        i &&
                        i === g.type &&
                        ((h = Math.max(b, c)),
                        (m = Math.min(b + g.nodeSize, d)),
                        (f = b),
                        (p = g)),
                        b >= c &&
                          b <= d &&
                          (i &&
                            i === g.type &&
                            n.setNodeMarkup(b, void 0, { ...g.attrs, ...e }),
                          s &&
                            g.marks.length &&
                            g.marks.forEach((y) => {
                              if (s === y.type) {
                                const x = Math.max(b, c),
                                  w = Math.min(b + g.nodeSize, d);
                                n.addMark(x, w, s.create({ ...y.attrs, ...e }));
                              }
                            }));
                    }),
                  p &&
                    (f !== void 0 &&
                      n.setNodeMarkup(f, void 0, { ...p.attrs, ...e }),
                    s &&
                      p.marks.length &&
                      p.marks.forEach((g) => {
                        s === g.type &&
                          n.addMark(h, m, s.create({ ...g.attrs, ...e }));
                      }));
              }),
            !0)
          : !1;
      },
    wrapIn:
      (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const o = Ke(t, n.schema);
        return Pl(o, e)(n, r);
      },
    wrapInList:
      (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const o = Ke(t, n.schema);
        return My(o, e)(n, r);
      },
  });
  const H_ = we.create({
      name: "commands",
      addCommands() {
        return { ...KN };
      },
    }),
    z_ = we.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("tiptapDrop"),
            props: {
              handleDrop: (t, e, n, r) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice: n,
                  moved: r,
                });
              },
            },
          }),
        ];
      },
    }),
    V_ = we.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("editable"),
            props: { editable: () => this.editor.options.editable },
          }),
        ];
      },
    }),
    U_ = we.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor: t } = this;
        return [
          new ie({
            key: new de("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (e, n) => {
                  t.isFocused = !0;
                  const r = t.state.tr
                    .setMeta("focus", { event: n })
                    .setMeta("addToHistory", !1);
                  return e.dispatch(r), !1;
                },
                blur: (e, n) => {
                  t.isFocused = !1;
                  const r = t.state.tr
                    .setMeta("blur", { event: n })
                    .setMeta("addToHistory", !1);
                  return e.dispatch(r), !1;
                },
              },
            },
          }),
        ];
      },
    }),
    j_ = we.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const t = () =>
            this.editor.commands.first(({ commands: s }) => [
              () => s.undoInputRule(),
              () =>
                s.command(({ tr: a }) => {
                  const { selection: l, doc: c } = a,
                    { empty: d, $anchor: f } = l,
                    { pos: p, parent: h } = f,
                    m =
                      f.parent.isTextblock && p > 0 ? a.doc.resolve(p - 1) : f,
                    g = m.parent.type.spec.isolating,
                    b = f.pos - f.parentOffset,
                    y =
                      g && m.parent.childCount === 1
                        ? b === f.pos
                        : J.atStart(c).from === p;
                  return !d ||
                    !h.type.isTextblock ||
                    h.textContent.length ||
                    !y ||
                    (y && f.parent.type.name === "paragraph")
                    ? !1
                    : s.clearNodes();
                }),
              () => s.deleteSelection(),
              () => s.joinBackward(),
              () => s.selectNodeBackward(),
            ]),
          e = () =>
            this.editor.commands.first(({ commands: s }) => [
              () => s.deleteSelection(),
              () => s.deleteCurrentNode(),
              () => s.joinForward(),
              () => s.selectNodeForward(),
            ]),
          r = {
            Enter: () =>
              this.editor.commands.first(({ commands: s }) => [
                () => s.newlineInCode(),
                () => s.createParagraphNear(),
                () => s.liftEmptyBlock(),
                () => s.splitBlock(),
              ]),
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: t,
            "Mod-Backspace": t,
            "Shift-Backspace": t,
            Delete: e,
            "Mod-Delete": e,
            "Mod-a": () => this.editor.commands.selectAll(),
          },
          o = { ...r },
          i = {
            ...r,
            "Ctrl-h": t,
            "Alt-Backspace": t,
            "Ctrl-d": e,
            "Ctrl-Alt-Backspace": e,
            "Alt-Delete": e,
            "Alt-d": e,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
          };
        return wc() || ih() ? i : o;
      },
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("clearDocument"),
            appendTransaction: (t, e, n) => {
              const r = t.some((g) => g.docChanged) && !e.doc.eq(n.doc),
                o = t.some((g) => g.getMeta("preventClearDocument"));
              if (!r || o) return;
              const { empty: i, from: s, to: a } = e.selection,
                l = J.atStart(e.doc).from,
                c = J.atEnd(e.doc).to;
              if (i || !(s === l && a === c) || !pa(n.doc)) return;
              const p = n.tr,
                h = na({ state: n, transaction: p }),
                { commands: m } = new ra({ editor: this.editor, state: h });
              if ((m.clearNodes(), !!p.steps.length)) return p;
            },
          }),
        ];
      },
    }),
    W_ = we.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("tiptapPaste"),
            props: {
              handlePaste: (t, e, n) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice: n,
                });
              },
            },
          }),
        ];
      },
    }),
    q_ = we.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("tabindex"),
            props: {
              attributes: () =>
                this.editor.isEditable ? { tabindex: "0" } : {},
            },
          }),
        ];
      },
    });
  var GN = Object.freeze({
    __proto__: null,
    ClipboardTextSerializer: C_,
    Commands: H_,
    Drop: z_,
    Editable: V_,
    FocusEvents: U_,
    Keymap: j_,
    Paste: W_,
    Tabindex: q_,
  });
  class to {
    get name() {
      return this.node.type.name;
    }
    constructor(e, n, r = !1, o = null) {
      (this.currentNode = null),
        (this.actualDepth = null),
        (this.isBlock = r),
        (this.resolvedPos = e),
        (this.editor = n),
        (this.currentNode = o);
    }
    get node() {
      return this.currentNode || this.resolvedPos.node();
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node;
    }
    get depth() {
      var e;
      return (e = this.actualDepth) !== null && e !== void 0
        ? e
        : this.resolvedPos.depth;
    }
    get pos() {
      return this.resolvedPos.pos;
    }
    get content() {
      return this.node.content;
    }
    set content(e) {
      let n = this.from,
        r = this.to;
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(
            `You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
          );
          return;
        }
        (n = this.from + 1), (r = this.to - 1);
      }
      this.editor.commands.insertContentAt({ from: n, to: r }, e);
    }
    get attributes() {
      return this.node.attrs;
    }
    get textContent() {
      return this.node.textContent;
    }
    get size() {
      return this.node.nodeSize;
    }
    get from() {
      return this.isBlock
        ? this.pos
        : this.resolvedPos.start(this.resolvedPos.depth);
    }
    get range() {
      return { from: this.from, to: this.to };
    }
    get to() {
      return this.isBlock
        ? this.pos + this.size
        : this.resolvedPos.end(this.resolvedPos.depth) +
            (this.node.isText ? 0 : 1);
    }
    get parent() {
      if (this.depth === 0) return null;
      const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
        n = this.resolvedPos.doc.resolve(e);
      return new to(n, this.editor);
    }
    get before() {
      let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
      return (
        e.depth !== this.depth &&
          (e = this.resolvedPos.doc.resolve(this.from - 3)),
        new to(e, this.editor)
      );
    }
    get after() {
      let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
      return (
        e.depth !== this.depth &&
          (e = this.resolvedPos.doc.resolve(this.to + 3)),
        new to(e, this.editor)
      );
    }
    get children() {
      const e = [];
      return (
        this.node.content.forEach((n, r) => {
          const o = n.isBlock && !n.isTextblock,
            i = n.isAtom && !n.isText,
            s = this.pos + r + (i ? 0 : 1),
            a = this.resolvedPos.doc.resolve(s);
          if (!o && a.depth <= this.depth) return;
          const l = new to(a, this.editor, o, o ? n : null);
          o && (l.actualDepth = this.depth + 1),
            e.push(new to(a, this.editor, o, o ? n : null));
        }),
        e
      );
    }
    get firstChild() {
      return this.children[0] || null;
    }
    get lastChild() {
      const e = this.children;
      return e[e.length - 1] || null;
    }
    closest(e, n = {}) {
      let r = null,
        o = this.parent;
      for (; o && !r; ) {
        if (o.node.type.name === e)
          if (Object.keys(n).length > 0) {
            const i = o.node.attrs,
              s = Object.keys(n);
            for (let a = 0; a < s.length; a += 1) {
              const l = s[a];
              if (i[l] !== n[l]) break;
            }
          } else r = o;
        o = o.parent;
      }
      return r;
    }
    querySelector(e, n = {}) {
      return this.querySelectorAll(e, n, !0)[0] || null;
    }
    querySelectorAll(e, n = {}, r = !1) {
      let o = [];
      if (!this.children || this.children.length === 0) return o;
      const i = Object.keys(n);
      return (
        this.children.forEach((s) => {
          (r && o.length > 0) ||
            (s.node.type.name === e &&
              i.every((l) => n[l] === s.node.attrs[l]) &&
              o.push(s),
            !(r && o.length > 0) &&
              (o = o.concat(s.querySelectorAll(e, n, r))));
        }),
        o
      );
    }
    setAttribute(e) {
      const { tr: n } = this.editor.state;
      n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }),
        this.editor.view.dispatch(n);
    }
  }
  const JN = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function K_(t, e, n) {
    const r = document.querySelector(
      `style[data-tiptap-style${n ? `-${n}` : ""}]`
    );
    if (r !== null) return r;
    const o = document.createElement("style");
    return (
      e && o.setAttribute("nonce", e),
      o.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
      (o.innerHTML = t),
      document.getElementsByTagName("head")[0].appendChild(o),
      o
    );
  }
  let G_ = class extends $T {
    constructor(e = {}) {
      super(),
        (this.isFocused = !1),
        (this.isInitialized = !1),
        (this.extensionStorage = {}),
        (this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: !0,
          injectNonce: void 0,
          extensions: [],
          autofocus: !1,
          editable: !0,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: !0,
          enablePasteRules: !0,
          enableCoreExtensions: !0,
          enableContentCheck: !1,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error: n }) => {
            throw n;
          },
          onPaste: () => null,
          onDrop: () => null,
        }),
        (this.isCapturingTransaction = !1),
        (this.capturedTransaction = null),
        this.setOptions(e),
        this.createExtensionManager(),
        this.createCommandManager(),
        this.createSchema(),
        this.on("beforeCreate", this.options.onBeforeCreate),
        this.emit("beforeCreate", { editor: this }),
        this.on("contentError", this.options.onContentError),
        this.createView(),
        this.injectCSS(),
        this.on("create", this.options.onCreate),
        this.on("update", this.options.onUpdate),
        this.on("selectionUpdate", this.options.onSelectionUpdate),
        this.on("transaction", this.options.onTransaction),
        this.on("focus", this.options.onFocus),
        this.on("blur", this.options.onBlur),
        this.on("destroy", this.options.onDestroy),
        this.on("drop", ({ event: n, slice: r, moved: o }) =>
          this.options.onDrop(n, r, o)
        ),
        this.on("paste", ({ event: n, slice: r }) =>
          this.options.onPaste(n, r)
        ),
        window.setTimeout(() => {
          this.isDestroyed ||
            (this.commands.focus(this.options.autofocus),
            this.emit("create", { editor: this }),
            (this.isInitialized = !0));
        }, 0);
    }
    get storage() {
      return this.extensionStorage;
    }
    get commands() {
      return this.commandManager.commands;
    }
    chain() {
      return this.commandManager.chain();
    }
    can() {
      return this.commandManager.can();
    }
    injectCSS() {
      this.options.injectCSS &&
        document &&
        (this.css = K_(JN, this.options.injectNonce));
    }
    setOptions(e = {}) {
      (this.options = { ...this.options, ...e }),
        !(!this.view || !this.state || this.isDestroyed) &&
          (this.options.editorProps &&
            this.view.setProps(this.options.editorProps),
          this.view.updateState(this.state));
    }
    setEditable(e, n = !0) {
      this.setOptions({ editable: e }),
        n && this.emit("update", { editor: this, transaction: this.state.tr });
    }
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    get state() {
      return this.view.state;
    }
    registerPlugin(e, n) {
      const r = Qp(n)
          ? n(e, [...this.state.plugins])
          : [...this.state.plugins, e],
        o = this.state.reconfigure({ plugins: r });
      return this.view.updateState(o), o;
    }
    unregisterPlugin(e) {
      if (this.isDestroyed) return;
      const n = this.state.plugins;
      let r = n;
      if (
        ([].concat(e).forEach((i) => {
          const s = typeof i == "string" ? `${i}$` : i.key;
          r = n.filter((a) => !a.key.startsWith(s));
        }),
        n.length === r.length)
      )
        return;
      const o = this.state.reconfigure({ plugins: r });
      return this.view.updateState(o), o;
    }
    createExtensionManager() {
      var e, n;
      const o = [
        ...(this.options.enableCoreExtensions
          ? [
              V_,
              C_.configure({
                blockSeparator:
                  (n =
                    (e = this.options.coreExtensionOptions) === null ||
                    e === void 0
                      ? void 0
                      : e.clipboardTextSerializer) === null || n === void 0
                    ? void 0
                    : n.blockSeparator,
              }),
              H_,
              U_,
              j_,
              q_,
              z_,
              W_,
            ].filter((i) =>
              typeof this.options.enableCoreExtensions == "object"
                ? this.options.enableCoreExtensions[i.name] !== !1
                : !0
            )
          : []),
        ...this.options.extensions,
      ].filter((i) =>
        ["extension", "node", "mark"].includes(i == null ? void 0 : i.type)
      );
      this.extensionManager = new jo(o, this);
    }
    createCommandManager() {
      this.commandManager = new ra({ editor: this });
    }
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    createView() {
      var e;
      let n;
      try {
        n = xc(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: this.options.enableContentCheck,
        });
      } catch (s) {
        if (
          !(s instanceof Error) ||
          ![
            "[tiptap error]: Invalid JSON content",
            "[tiptap error]: Invalid HTML content",
          ].includes(s.message)
        )
          throw s;
        this.emit("contentError", {
          editor: this,
          error: s,
          disableCollaboration: () => {
            this.storage.collaboration &&
              (this.storage.collaboration.isDisabled = !0),
              (this.options.extensions = this.options.extensions.filter(
                (a) => a.name !== "collaboration"
              )),
              this.createExtensionManager();
          },
        }),
          (n = xc(
            this.options.content,
            this.schema,
            this.options.parseOptions,
            { errorOnInvalidContent: !1 }
          ));
      }
      const r = oh(n, this.options.autofocus);
      this.view = new ib(this.options.element, {
        ...this.options.editorProps,
        attributes: {
          role: "textbox",
          ...((e = this.options.editorProps) === null || e === void 0
            ? void 0
            : e.attributes),
        },
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: Io.create({ doc: n, selection: r || void 0 }),
      });
      const o = this.state.reconfigure({
        plugins: this.extensionManager.plugins,
      });
      this.view.updateState(o), this.createNodeViews(), this.prependClass();
      const i = this.view.dom;
      i.editor = this;
    }
    createNodeViews() {
      this.view.isDestroyed ||
        this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
    }
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(e) {
      (this.isCapturingTransaction = !0),
        e(),
        (this.isCapturingTransaction = !1);
      const n = this.capturedTransaction;
      return (this.capturedTransaction = null), n;
    }
    dispatchTransaction(e) {
      if (this.view.isDestroyed) return;
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = e;
          return;
        }
        e.steps.forEach((s) => {
          var a;
          return (a = this.capturedTransaction) === null || a === void 0
            ? void 0
            : a.step(s);
        });
        return;
      }
      const n = this.state.apply(e),
        r = !this.state.selection.eq(n.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction: e,
        nextState: n,
      }),
        this.view.updateState(n),
        this.emit("transaction", { editor: this, transaction: e }),
        r && this.emit("selectionUpdate", { editor: this, transaction: e });
      const o = e.getMeta("focus"),
        i = e.getMeta("blur");
      o && this.emit("focus", { editor: this, event: o.event, transaction: e }),
        i &&
          this.emit("blur", { editor: this, event: i.event, transaction: e }),
        !(!e.docChanged || e.getMeta("preventUpdate")) &&
          this.emit("update", { editor: this, transaction: e });
    }
    getAttributes(e) {
      return ch(this.state, e);
    }
    isActive(e, n) {
      const r = typeof e == "string" ? e : null,
        o = typeof e == "string" ? n : e;
      return Et(this.state, r, o);
    }
    getJSON() {
      return this.state.doc.toJSON();
    }
    getHTML() {
      return ia(this.state.doc.content, this.schema);
    }
    getText(e) {
      const {
        blockSeparator: n = `

`,
        textSerializers: r = {},
      } = e || {};
      return vc(this.state.doc, {
        blockSeparator: n,
        textSerializers: { ...la(this.schema), ...r },
      });
    }
    get isEmpty() {
      return pa(this.state.doc);
    }
    getCharacterCount() {
      return (
        console.warn(
          '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
        ),
        this.state.doc.content.size - 2
      );
    }
    destroy() {
      if ((this.emit("destroy"), this.view)) {
        const e = this.view.dom;
        e && e.editor && delete e.editor, this.view.destroy();
      }
      this.removeAllListeners();
    }
    get isDestroyed() {
      var e;
      return !(!((e = this.view) === null || e === void 0) && e.docView);
    }
    $node(e, n) {
      var r;
      return (
        ((r = this.$doc) === null || r === void 0
          ? void 0
          : r.querySelector(e, n)) || null
      );
    }
    $nodes(e, n) {
      var r;
      return (
        ((r = this.$doc) === null || r === void 0
          ? void 0
          : r.querySelectorAll(e, n)) || null
      );
    }
    $pos(e) {
      const n = this.state.doc.resolve(e);
      return new to(n, this);
    }
    get $doc() {
      return this.$pos(0);
    }
  };
  function no(t) {
    return new Ai({
      find: t.find,
      handler: ({ state: e, range: n, match: r }) => {
        const o = re(t.getAttributes, void 0, r);
        if (o === !1 || o === null) return null;
        const { tr: i } = e,
          s = r[r.length - 1],
          a = r[0];
        if (s) {
          const l = a.search(/\S/),
            c = n.from + a.indexOf(s),
            d = c + s.length;
          if (
            Ec(n.from, n.to, e.doc)
              .filter((h) =>
                h.mark.type.excluded.find(
                  (g) => g === t.type && g !== h.mark.type
                )
              )
              .filter((h) => h.to > c).length
          )
            return null;
          d < n.to && i.delete(d, n.to), c > n.from && i.delete(n.from + l, c);
          const p = n.from + l + s.length;
          i.addMark(n.from + l, p, t.type.create(o || {})),
            i.removeStoredMark(t.type);
        }
      },
    });
  }
  function Ti(t) {
    return new Ai({
      find: t.find,
      handler: ({ state: e, range: n, match: r }) => {
        const o = re(t.getAttributes, void 0, r) || {},
          { tr: i } = e,
          s = n.from;
        let a = n.to;
        const l = t.type.create(o);
        if (r[1]) {
          const c = r[0].lastIndexOf(r[1]);
          let d = s + c;
          d > a ? (d = a) : (a = d + r[1].length);
          const f = r[0][r[0].length - 1];
          i.insertText(f, s + r[0].length - 1), i.replaceWith(d, a, l);
        } else if (r[0]) {
          const c = t.type.isInline ? s : s - 1;
          i.insert(c, t.type.create(o)).delete(
            i.mapping.map(s),
            i.mapping.map(a)
          );
        }
        i.scrollIntoView();
      },
    });
  }
  function Tc(t) {
    return new Ai({
      find: t.find,
      handler: ({ state: e, range: n, match: r }) => {
        const o = e.doc.resolve(n.from),
          i = re(t.getAttributes, void 0, r) || {};
        if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
          return null;
        e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
      },
    });
  }
  function YN(t) {
    return new Ai({
      find: t.find,
      handler: ({ state: e, range: n, match: r }) => {
        let o = t.replace,
          i = n.from;
        const s = n.to;
        if (r[1]) {
          const a = r[0].lastIndexOf(r[1]);
          (o += r[0].slice(a + r[1].length)), (i += a);
          const l = i - s;
          l > 0 && ((o = r[0].slice(a - l, a) + o), (i = s));
        }
        e.tr.insertText(o, i, s);
      },
    });
  }
  function Wo(t) {
    return new Ai({
      find: t.find,
      handler: ({ state: e, range: n, match: r, chain: o }) => {
        const i = re(t.getAttributes, void 0, r) || {},
          s = e.tr.delete(n.from, n.to),
          l = s.doc.resolve(n.from).blockRange(),
          c = l && ws(l, t.type, i);
        if (!c) return null;
        if ((s.wrap(l, c), t.keepMarks && t.editor)) {
          const { selection: f, storedMarks: p } = e,
            { splittableMarks: h } = t.editor.extensionManager,
            m = p || (f.$to.parentOffset && f.$from.marks());
          if (m) {
            const g = m.filter((b) => h.includes(b.type.name));
            s.ensureMarks(g);
          }
        }
        if (t.keepAttributes) {
          const f =
            t.type.name === "bulletList" || t.type.name === "orderedList"
              ? "listItem"
              : "taskList";
          o().updateAttributes(f, i).run();
        }
        const d = s.doc.resolve(n.from - 1).nodeBefore;
        d &&
          d.type === t.type &&
          An(s.doc, n.from - 1) &&
          (!t.joinPredicate || t.joinPredicate(r, d)) &&
          s.join(n.from - 1);
      },
    });
  }
  let Pe = class K0 {
    constructor(e = {}) {
      (this.type = "node"),
        (this.name = "node"),
        (this.parent = null),
        (this.child = null),
        (this.config = { name: this.name, defaultOptions: {} }),
        (this.config = { ...this.config, ...e }),
        (this.name = this.config.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
          ),
        (this.options = this.config.defaultOptions),
        this.config.addOptions &&
          (this.options = re(j(this, "addOptions", { name: this.name }))),
        (this.storage =
          re(
            j(this, "addStorage", { name: this.name, options: this.options })
          ) || {});
    }
    static create(e = {}) {
      return new K0(e);
    }
    configure(e = {}) {
      const n = this.extend({
        ...this.config,
        addOptions: () => aa(this.options, e),
      });
      return (n.name = this.name), (n.parent = this.parent), n;
    }
    extend(e = {}) {
      const n = new K0(e);
      return (
        (n.parent = this),
        (this.child = n),
        (n.name = e.name ? e.name : n.parent.name),
        e.defaultOptions &&
          Object.keys(e.defaultOptions).length > 0 &&
          console.warn(
            `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
          ),
        (n.options = re(j(n, "addOptions", { name: n.name }))),
        (n.storage = re(
          j(n, "addStorage", { name: n.name, options: n.options })
        )),
        n
      );
    }
  };
  function XN() {
    return (
      navigator.platform === "Android" || /android/i.test(navigator.userAgent)
    );
  }
  class J_ {
    constructor(e, n, r) {
      (this.isDragging = !1),
        (this.component = e),
        (this.editor = n.editor),
        (this.options = { stopEvent: null, ignoreMutation: null, ...r }),
        (this.extension = n.extension),
        (this.node = n.node),
        (this.decorations = n.decorations),
        (this.innerDecorations = n.innerDecorations),
        (this.view = n.view),
        (this.HTMLAttributes = n.HTMLAttributes),
        (this.getPos = n.getPos),
        this.mount();
    }
    mount() {}
    get dom() {
      return this.editor.view.dom;
    }
    get contentDOM() {
      return null;
    }
    onDragStart(e) {
      var n, r, o, i, s, a, l;
      const { view: c } = this.editor,
        d = e.target,
        f =
          d.nodeType === 3
            ? (n = d.parentElement) === null || n === void 0
              ? void 0
              : n.closest("[data-drag-handle]")
            : d.closest("[data-drag-handle]");
      if (
        !this.dom ||
        (!((r = this.contentDOM) === null || r === void 0) && r.contains(d)) ||
        !f
      )
        return;
      let p = 0,
        h = 0;
      if (this.dom !== f) {
        const y = this.dom.getBoundingClientRect(),
          x = f.getBoundingClientRect(),
          w =
            (o = e.offsetX) !== null && o !== void 0
              ? o
              : (i = e.nativeEvent) === null || i === void 0
              ? void 0
              : i.offsetX,
          _ =
            (s = e.offsetY) !== null && s !== void 0
              ? s
              : (a = e.nativeEvent) === null || a === void 0
              ? void 0
              : a.offsetY;
        (p = x.x - y.x + w), (h = x.y - y.y + _);
      }
      (l = e.dataTransfer) === null ||
        l === void 0 ||
        l.setDragImage(this.dom, p, h);
      const m = this.getPos();
      if (typeof m != "number") return;
      const g = K.create(c.state.doc, m),
        b = c.state.tr.setSelection(g);
      c.dispatch(b);
    }
    stopEvent(e) {
      var n;
      if (!this.dom) return !1;
      if (typeof this.options.stopEvent == "function")
        return this.options.stopEvent({ event: e });
      const r = e.target;
      if (
        !(
          this.dom.contains(r) &&
          !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))
        )
      )
        return !1;
      const i = e.type.startsWith("drag"),
        s = e.type === "drop";
      if (
        (["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) ||
          r.isContentEditable) &&
        !s &&
        !i
      )
        return !0;
      const { isEditable: l } = this.editor,
        { isDragging: c } = this,
        d = !!this.node.type.spec.draggable,
        f = K.isSelectable(this.node),
        p = e.type === "copy",
        h = e.type === "paste",
        m = e.type === "cut",
        g = e.type === "mousedown";
      if (
        (!d && f && i && e.target === this.dom && e.preventDefault(),
        d && i && !c && e.target === this.dom)
      )
        return e.preventDefault(), !1;
      if (d && l && !c && g) {
        const b = r.closest("[data-drag-handle]");
        b &&
          (this.dom === b || this.dom.contains(b)) &&
          ((this.isDragging = !0),
          document.addEventListener(
            "dragend",
            () => {
              this.isDragging = !1;
            },
            { once: !0 }
          ),
          document.addEventListener(
            "drop",
            () => {
              this.isDragging = !1;
            },
            { once: !0 }
          ),
          document.addEventListener(
            "mouseup",
            () => {
              this.isDragging = !1;
            },
            { once: !0 }
          ));
      }
      return !(c || s || p || h || m || (g && f));
    }
    ignoreMutation(e) {
      return !this.dom || !this.contentDOM
        ? !0
        : typeof this.options.ignoreMutation == "function"
        ? this.options.ignoreMutation({ mutation: e })
        : this.node.isLeaf || this.node.isAtom
        ? !0
        : e.type === "selection" ||
          (this.dom.contains(e.target) &&
            e.type === "childList" &&
            (wc() || XN()) &&
            this.editor.isFocused &&
            [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every(
              (r) => r.isContentEditable
            ))
        ? !1
        : this.contentDOM === e.target && e.type === "attributes"
        ? !0
        : !this.contentDOM.contains(e.target);
    }
    updateAttributes(e) {
      this.editor.commands.command(({ tr: n }) => {
        const r = this.getPos();
        return typeof r != "number"
          ? !1
          : (n.setNodeMarkup(r, void 0, { ...this.node.attrs, ...e }), !0);
      });
    }
    deleteNode() {
      const e = this.getPos();
      if (typeof e != "number") return;
      const n = e + this.node.nodeSize;
      this.editor.commands.deleteRange({ from: e, to: n });
    }
  }
  function yr(t) {
    return new yc({
      find: t.find,
      handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
        const i = re(t.getAttributes, void 0, r, o);
        if (i === !1 || i === null) return null;
        const { tr: s } = e,
          a = r[r.length - 1],
          l = r[0];
        let c = n.to;
        if (a) {
          const d = l.search(/\S/),
            f = n.from + l.indexOf(a),
            p = f + a.length;
          if (
            Ec(n.from, n.to, e.doc)
              .filter((m) =>
                m.mark.type.excluded.find(
                  (b) => b === t.type && b !== m.mark.type
                )
              )
              .filter((m) => m.to > f).length
          )
            return null;
          p < n.to && s.delete(p, n.to),
            f > n.from && s.delete(n.from + d, f),
            (c = n.from + d + a.length),
            s.addMark(n.from + d, c, t.type.create(i || {})),
            s.removeStoredMark(t.type);
        }
      },
    });
  }
  function Y_(t) {
    return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function ZN(t) {
    return typeof t == "string";
  }
  function X_(t) {
    return new yc({
      find: t.find,
      handler({ match: e, chain: n, range: r, pasteEvent: o }) {
        const i = re(t.getAttributes, void 0, e, o),
          s = re(t.getContent, void 0, i);
        if (i === !1 || i === null) return null;
        const a = { type: t.type.name, attrs: i };
        s && (a.content = s),
          e.input && n().deleteRange(r).insertContentAt(r.from, a);
      },
    });
  }
  function QN(t) {
    return new yc({
      find: t.find,
      handler: ({ state: e, range: n, match: r }) => {
        let o = t.replace,
          i = n.from;
        const s = n.to;
        if (r[1]) {
          const a = r[0].lastIndexOf(r[1]);
          (o += r[0].slice(a + r[1].length)), (i += a);
          const l = i - s;
          l > 0 && ((o = r[0].slice(a - l, a) + o), (i = s));
        }
        e.tr.insertText(o, i, s);
      },
    });
  }
  class eO {
    constructor(e) {
      (this.transaction = e),
        (this.currentStep = this.transaction.steps.length);
    }
    map(e) {
      let n = !1;
      return {
        position: this.transaction.steps
          .slice(this.currentStep)
          .reduce((o, i) => {
            const s = i.getMap().mapResult(o);
            return s.deleted && (n = !0), s.pos;
          }, e),
        deleted: n,
      };
    }
  }
  var Pt = "top",
    ln = "bottom",
    cn = "right",
    $t = "left",
    fh = "auto",
    ma = [Pt, ln, cn, $t],
    Ni = "start",
    ga = "end",
    tO = "clippingParents",
    Z_ = "viewport",
    ba = "popper",
    nO = "reference",
    Q_ = ma.reduce(function (t, e) {
      return t.concat([e + "-" + Ni, e + "-" + ga]);
    }, []),
    ek = [].concat(ma, [fh]).reduce(function (t, e) {
      return t.concat([e, e + "-" + Ni, e + "-" + ga]);
    }, []),
    rO = "beforeRead",
    oO = "read",
    iO = "afterRead",
    sO = "beforeMain",
    aO = "main",
    lO = "afterMain",
    cO = "beforeWrite",
    uO = "write",
    dO = "afterWrite",
    fO = [rO, oO, iO, sO, aO, lO, cO, uO, dO];
  function Gn(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function un(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
      var e = t.ownerDocument;
      return (e && e.defaultView) || window;
    }
    return t;
  }
  function qo(t) {
    var e = un(t).Element;
    return t instanceof e || t instanceof Element;
  }
  function dn(t) {
    var e = un(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement;
  }
  function ph(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = un(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot;
  }
  function pO(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function (n) {
      var r = e.styles[n] || {},
        o = e.attributes[n] || {},
        i = e.elements[n];
      !dn(i) ||
        !Gn(i) ||
        (Object.assign(i.style, r),
        Object.keys(o).forEach(function (s) {
          var a = o[s];
          a === !1
            ? i.removeAttribute(s)
            : i.setAttribute(s, a === !0 ? "" : a);
        }));
    });
  }
  function hO(t) {
    var e = t.state,
      n = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    return (
      Object.assign(e.elements.popper.style, n.popper),
      (e.styles = n),
      e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
      function () {
        Object.keys(e.elements).forEach(function (r) {
          var o = e.elements[r],
            i = e.attributes[r] || {},
            s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
            a = s.reduce(function (l, c) {
              return (l[c] = ""), l;
            }, {});
          !dn(o) ||
            !Gn(o) ||
            (Object.assign(o.style, a),
            Object.keys(i).forEach(function (l) {
              o.removeAttribute(l);
            }));
        });
      }
    );
  }
  const tk = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: pO,
    effect: hO,
    requires: ["computeStyles"],
  };
  function Jn(t) {
    return t.split("-")[0];
  }
  var Ko = Math.max,
    Nc = Math.min,
    Oi = Math.round;
  function hh() {
    var t = navigator.userAgentData;
    return t != null && t.brands
      ? t.brands
          .map(function (e) {
            return e.brand + "/" + e.version;
          })
          .join(" ")
      : navigator.userAgent;
  }
  function nk() {
    return !/^((?!chrome|android).)*safari/i.test(hh());
  }
  function Ri(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    var r = t.getBoundingClientRect(),
      o = 1,
      i = 1;
    e &&
      dn(t) &&
      ((o = (t.offsetWidth > 0 && Oi(r.width) / t.offsetWidth) || 1),
      (i = (t.offsetHeight > 0 && Oi(r.height) / t.offsetHeight) || 1));
    var s = qo(t) ? un(t) : window,
      a = s.visualViewport,
      l = !nk() && n,
      c = (r.left + (l && a ? a.offsetLeft : 0)) / o,
      d = (r.top + (l && a ? a.offsetTop : 0)) / i,
      f = r.width / o,
      p = r.height / i;
    return {
      width: f,
      height: p,
      top: d,
      right: c + f,
      bottom: d + p,
      left: c,
      x: c,
      y: d,
    };
  }
  function mh(t) {
    var e = Ri(t),
      n = t.offsetWidth,
      r = t.offsetHeight;
    return (
      Math.abs(e.width - n) <= 1 && (n = e.width),
      Math.abs(e.height - r) <= 1 && (r = e.height),
      { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
    );
  }
  function rk(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (n && ph(n)) {
      var r = e;
      do {
        if (r && t.isSameNode(r)) return !0;
        r = r.parentNode || r.host;
      } while (r);
    }
    return !1;
  }
  function _r(t) {
    return un(t).getComputedStyle(t);
  }
  function mO(t) {
    return ["table", "td", "th"].indexOf(Gn(t)) >= 0;
  }
  function ro(t) {
    return ((qo(t) ? t.ownerDocument : t.document) || window.document)
      .documentElement;
  }
  function Oc(t) {
    return Gn(t) === "html"
      ? t
      : t.assignedSlot || t.parentNode || (ph(t) ? t.host : null) || ro(t);
  }
  function ok(t) {
    return !dn(t) || _r(t).position === "fixed" ? null : t.offsetParent;
  }
  function gO(t) {
    var e = /firefox/i.test(hh()),
      n = /Trident/i.test(hh());
    if (n && dn(t)) {
      var r = _r(t);
      if (r.position === "fixed") return null;
    }
    var o = Oc(t);
    for (
      ph(o) && (o = o.host);
      dn(o) && ["html", "body"].indexOf(Gn(o)) < 0;

    ) {
      var i = _r(o);
      if (
        i.transform !== "none" ||
        i.perspective !== "none" ||
        i.contain === "paint" ||
        ["transform", "perspective"].indexOf(i.willChange) !== -1 ||
        (e && i.willChange === "filter") ||
        (e && i.filter && i.filter !== "none")
      )
        return o;
      o = o.parentNode;
    }
    return null;
  }
  function ya(t) {
    for (var e = un(t), n = ok(t); n && mO(n) && _r(n).position === "static"; )
      n = ok(n);
    return n &&
      (Gn(n) === "html" || (Gn(n) === "body" && _r(n).position === "static"))
      ? e
      : n || gO(t) || e;
  }
  function gh(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function _a(t, e, n) {
    return Ko(t, Nc(e, n));
  }
  function bO(t, e, n) {
    var r = _a(t, e, n);
    return r > n ? n : r;
  }
  function ik() {
    return { top: 0, right: 0, bottom: 0, left: 0 };
  }
  function sk(t) {
    return Object.assign({}, ik(), t);
  }
  function ak(t, e) {
    return e.reduce(function (n, r) {
      return (n[r] = t), n;
    }, {});
  }
  var yO = function (e, n) {
    return (
      (e =
        typeof e == "function"
          ? e(Object.assign({}, n.rects, { placement: n.placement }))
          : e),
      sk(typeof e != "number" ? e : ak(e, ma))
    );
  };
  function _O(t) {
    var e,
      n = t.state,
      r = t.name,
      o = t.options,
      i = n.elements.arrow,
      s = n.modifiersData.popperOffsets,
      a = Jn(n.placement),
      l = gh(a),
      c = [$t, cn].indexOf(a) >= 0,
      d = c ? "height" : "width";
    if (!(!i || !s)) {
      var f = yO(o.padding, n),
        p = mh(i),
        h = l === "y" ? Pt : $t,
        m = l === "y" ? ln : cn,
        g =
          n.rects.reference[d] +
          n.rects.reference[l] -
          s[l] -
          n.rects.popper[d],
        b = s[l] - n.rects.reference[l],
        y = ya(i),
        x = y ? (l === "y" ? y.clientHeight || 0 : y.clientWidth || 0) : 0,
        w = g / 2 - b / 2,
        _ = f[h],
        v = x - p[d] - f[m],
        C = x / 2 - p[d] / 2 + w,
        S = _a(_, C, v),
        N = l;
      n.modifiersData[r] = ((e = {}), (e[N] = S), (e.centerOffset = S - C), e);
    }
  }
  function kO(t) {
    var e = t.state,
      n = t.options,
      r = n.element,
      o = r === void 0 ? "[data-popper-arrow]" : r;
    o != null &&
      ((typeof o == "string" &&
        ((o = e.elements.popper.querySelector(o)), !o)) ||
        (rk(e.elements.popper, o) && (e.elements.arrow = o)));
  }
  const wO = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: _O,
    effect: kO,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
  };
  function Di(t) {
    return t.split("-")[1];
  }
  var xO = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function CO(t) {
    var e = t.x,
      n = t.y,
      r = window,
      o = r.devicePixelRatio || 1;
    return { x: Oi(e * o) / o || 0, y: Oi(n * o) / o || 0 };
  }
  function lk(t) {
    var e,
      n = t.popper,
      r = t.popperRect,
      o = t.placement,
      i = t.variation,
      s = t.offsets,
      a = t.position,
      l = t.gpuAcceleration,
      c = t.adaptive,
      d = t.roundOffsets,
      f = t.isFixed,
      p = s.x,
      h = p === void 0 ? 0 : p,
      m = s.y,
      g = m === void 0 ? 0 : m,
      b = typeof d == "function" ? d({ x: h, y: g }) : { x: h, y: g };
    (h = b.x), (g = b.y);
    var y = s.hasOwnProperty("x"),
      x = s.hasOwnProperty("y"),
      w = $t,
      _ = Pt,
      v = window;
    if (c) {
      var C = ya(n),
        S = "clientHeight",
        N = "clientWidth";
      if (
        (C === un(n) &&
          ((C = ro(n)),
          _r(C).position !== "static" &&
            a === "absolute" &&
            ((S = "scrollHeight"), (N = "scrollWidth"))),
        (C = C),
        o === Pt || ((o === $t || o === cn) && i === ga))
      ) {
        _ = ln;
        var M =
          f && C === v && v.visualViewport ? v.visualViewport.height : C[S];
        (g -= M - r.height), (g *= l ? 1 : -1);
      }
      if (o === $t || ((o === Pt || o === ln) && i === ga)) {
        w = cn;
        var L =
          f && C === v && v.visualViewport ? v.visualViewport.width : C[N];
        (h -= L - r.width), (h *= l ? 1 : -1);
      }
    }
    var $ = Object.assign({ position: a }, c && xO),
      B = d === !0 ? CO({ x: h, y: g }) : { x: h, y: g };
    if (((h = B.x), (g = B.y), l)) {
      var H;
      return Object.assign(
        {},
        $,
        ((H = {}),
        (H[_] = x ? "0" : ""),
        (H[w] = y ? "0" : ""),
        (H.transform =
          (v.devicePixelRatio || 1) <= 1
            ? "translate(" + h + "px, " + g + "px)"
            : "translate3d(" + h + "px, " + g + "px, 0)"),
        H)
      );
    }
    return Object.assign(
      {},
      $,
      ((e = {}),
      (e[_] = x ? g + "px" : ""),
      (e[w] = y ? h + "px" : ""),
      (e.transform = ""),
      e)
    );
  }
  function vO(t) {
    var e = t.state,
      n = t.options,
      r = n.gpuAcceleration,
      o = r === void 0 ? !0 : r,
      i = n.adaptive,
      s = i === void 0 ? !0 : i,
      a = n.roundOffsets,
      l = a === void 0 ? !0 : a,
      c = {
        placement: Jn(e.placement),
        variation: Di(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: o,
        isFixed: e.options.strategy === "fixed",
      };
    e.modifiersData.popperOffsets != null &&
      (e.styles.popper = Object.assign(
        {},
        e.styles.popper,
        lk(
          Object.assign({}, c, {
            offsets: e.modifiersData.popperOffsets,
            position: e.options.strategy,
            adaptive: s,
            roundOffsets: l,
          })
        )
      )),
      e.modifiersData.arrow != null &&
        (e.styles.arrow = Object.assign(
          {},
          e.styles.arrow,
          lk(
            Object.assign({}, c, {
              offsets: e.modifiersData.arrow,
              position: "absolute",
              adaptive: !1,
              roundOffsets: l,
            })
          )
        )),
      (e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement,
      }));
  }
  const EO = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: vO,
    data: {},
  };
  var Rc = { passive: !0 };
  function AO(t) {
    var e = t.state,
      n = t.instance,
      r = t.options,
      o = r.scroll,
      i = o === void 0 ? !0 : o,
      s = r.resize,
      a = s === void 0 ? !0 : s,
      l = un(e.elements.popper),
      c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return (
      i &&
        c.forEach(function (d) {
          d.addEventListener("scroll", n.update, Rc);
        }),
      a && l.addEventListener("resize", n.update, Rc),
      function () {
        i &&
          c.forEach(function (d) {
            d.removeEventListener("scroll", n.update, Rc);
          }),
          a && l.removeEventListener("resize", n.update, Rc);
      }
    );
  }
  const SO = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: AO,
    data: {},
  };
  var MO = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function Dc(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
      return MO[e];
    });
  }
  var TO = { start: "end", end: "start" };
  function ck(t) {
    return t.replace(/start|end/g, function (e) {
      return TO[e];
    });
  }
  function bh(t) {
    var e = un(t),
      n = e.pageXOffset,
      r = e.pageYOffset;
    return { scrollLeft: n, scrollTop: r };
  }
  function yh(t) {
    return Ri(ro(t)).left + bh(t).scrollLeft;
  }
  function NO(t, e) {
    var n = un(t),
      r = ro(t),
      o = n.visualViewport,
      i = r.clientWidth,
      s = r.clientHeight,
      a = 0,
      l = 0;
    if (o) {
      (i = o.width), (s = o.height);
      var c = nk();
      (c || (!c && e === "fixed")) && ((a = o.offsetLeft), (l = o.offsetTop));
    }
    return { width: i, height: s, x: a + yh(t), y: l };
  }
  function OO(t) {
    var e,
      n = ro(t),
      r = bh(t),
      o = (e = t.ownerDocument) == null ? void 0 : e.body,
      i = Ko(
        n.scrollWidth,
        n.clientWidth,
        o ? o.scrollWidth : 0,
        o ? o.clientWidth : 0
      ),
      s = Ko(
        n.scrollHeight,
        n.clientHeight,
        o ? o.scrollHeight : 0,
        o ? o.clientHeight : 0
      ),
      a = -r.scrollLeft + yh(t),
      l = -r.scrollTop;
    return (
      _r(o || n).direction === "rtl" &&
        (a += Ko(n.clientWidth, o ? o.clientWidth : 0) - i),
      { width: i, height: s, x: a, y: l }
    );
  }
  function _h(t) {
    var e = _r(t),
      n = e.overflow,
      r = e.overflowX,
      o = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + o + r);
  }
  function uk(t) {
    return ["html", "body", "#document"].indexOf(Gn(t)) >= 0
      ? t.ownerDocument.body
      : dn(t) && _h(t)
      ? t
      : uk(Oc(t));
  }
  function ka(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = uk(t),
      o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
      i = un(r),
      s = o ? [i].concat(i.visualViewport || [], _h(r) ? r : []) : r,
      a = e.concat(s);
    return o ? a : a.concat(ka(Oc(s)));
  }
  function kh(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height,
    });
  }
  function RO(t, e) {
    var n = Ri(t, !1, e === "fixed");
    return (
      (n.top = n.top + t.clientTop),
      (n.left = n.left + t.clientLeft),
      (n.bottom = n.top + t.clientHeight),
      (n.right = n.left + t.clientWidth),
      (n.width = t.clientWidth),
      (n.height = t.clientHeight),
      (n.x = n.left),
      (n.y = n.top),
      n
    );
  }
  function dk(t, e, n) {
    return e === Z_ ? kh(NO(t, n)) : qo(e) ? RO(e, n) : kh(OO(ro(t)));
  }
  function DO(t) {
    var e = ka(Oc(t)),
      n = ["absolute", "fixed"].indexOf(_r(t).position) >= 0,
      r = n && dn(t) ? ya(t) : t;
    return qo(r)
      ? e.filter(function (o) {
          return qo(o) && rk(o, r) && Gn(o) !== "body";
        })
      : [];
  }
  function LO(t, e, n, r) {
    var o = e === "clippingParents" ? DO(t) : [].concat(e),
      i = [].concat(o, [n]),
      s = i[0],
      a = i.reduce(function (l, c) {
        var d = dk(t, c, r);
        return (
          (l.top = Ko(d.top, l.top)),
          (l.right = Nc(d.right, l.right)),
          (l.bottom = Nc(d.bottom, l.bottom)),
          (l.left = Ko(d.left, l.left)),
          l
        );
      }, dk(t, s, r));
    return (
      (a.width = a.right - a.left),
      (a.height = a.bottom - a.top),
      (a.x = a.left),
      (a.y = a.top),
      a
    );
  }
  function fk(t) {
    var e = t.reference,
      n = t.element,
      r = t.placement,
      o = r ? Jn(r) : null,
      i = r ? Di(r) : null,
      s = e.x + e.width / 2 - n.width / 2,
      a = e.y + e.height / 2 - n.height / 2,
      l;
    switch (o) {
      case Pt:
        l = { x: s, y: e.y - n.height };
        break;
      case ln:
        l = { x: s, y: e.y + e.height };
        break;
      case cn:
        l = { x: e.x + e.width, y: a };
        break;
      case $t:
        l = { x: e.x - n.width, y: a };
        break;
      default:
        l = { x: e.x, y: e.y };
    }
    var c = o ? gh(o) : null;
    if (c != null) {
      var d = c === "y" ? "height" : "width";
      switch (i) {
        case Ni:
          l[c] = l[c] - (e[d] / 2 - n[d] / 2);
          break;
        case ga:
          l[c] = l[c] + (e[d] / 2 - n[d] / 2);
          break;
      }
    }
    return l;
  }
  function wa(t, e) {
    e === void 0 && (e = {});
    var n = e,
      r = n.placement,
      o = r === void 0 ? t.placement : r,
      i = n.strategy,
      s = i === void 0 ? t.strategy : i,
      a = n.boundary,
      l = a === void 0 ? tO : a,
      c = n.rootBoundary,
      d = c === void 0 ? Z_ : c,
      f = n.elementContext,
      p = f === void 0 ? ba : f,
      h = n.altBoundary,
      m = h === void 0 ? !1 : h,
      g = n.padding,
      b = g === void 0 ? 0 : g,
      y = sk(typeof b != "number" ? b : ak(b, ma)),
      x = p === ba ? nO : ba,
      w = t.rects.popper,
      _ = t.elements[m ? x : p],
      v = LO(qo(_) ? _ : _.contextElement || ro(t.elements.popper), l, d, s),
      C = Ri(t.elements.reference),
      S = fk({ reference: C, element: w, strategy: "absolute", placement: o }),
      N = kh(Object.assign({}, w, S)),
      M = p === ba ? N : C,
      L = {
        top: v.top - M.top + y.top,
        bottom: M.bottom - v.bottom + y.bottom,
        left: v.left - M.left + y.left,
        right: M.right - v.right + y.right,
      },
      $ = t.modifiersData.offset;
    if (p === ba && $) {
      var B = $[o];
      Object.keys(L).forEach(function (H) {
        var Q = [cn, ln].indexOf(H) >= 0 ? 1 : -1,
          X = [Pt, ln].indexOf(H) >= 0 ? "y" : "x";
        L[H] += B[X] * Q;
      });
    }
    return L;
  }
  function IO(t, e) {
    e === void 0 && (e = {});
    var n = e,
      r = n.placement,
      o = n.boundary,
      i = n.rootBoundary,
      s = n.padding,
      a = n.flipVariations,
      l = n.allowedAutoPlacements,
      c = l === void 0 ? ek : l,
      d = Di(r),
      f = d
        ? a
          ? Q_
          : Q_.filter(function (m) {
              return Di(m) === d;
            })
        : ma,
      p = f.filter(function (m) {
        return c.indexOf(m) >= 0;
      });
    p.length === 0 && (p = f);
    var h = p.reduce(function (m, g) {
      return (
        (m[g] = wa(t, {
          placement: g,
          boundary: o,
          rootBoundary: i,
          padding: s,
        })[Jn(g)]),
        m
      );
    }, {});
    return Object.keys(h).sort(function (m, g) {
      return h[m] - h[g];
    });
  }
  function BO(t) {
    if (Jn(t) === fh) return [];
    var e = Dc(t);
    return [ck(t), e, ck(e)];
  }
  function PO(t) {
    var e = t.state,
      n = t.options,
      r = t.name;
    if (!e.modifiersData[r]._skip) {
      for (
        var o = n.mainAxis,
          i = o === void 0 ? !0 : o,
          s = n.altAxis,
          a = s === void 0 ? !0 : s,
          l = n.fallbackPlacements,
          c = n.padding,
          d = n.boundary,
          f = n.rootBoundary,
          p = n.altBoundary,
          h = n.flipVariations,
          m = h === void 0 ? !0 : h,
          g = n.allowedAutoPlacements,
          b = e.options.placement,
          y = Jn(b),
          x = y === b,
          w = l || (x || !m ? [Dc(b)] : BO(b)),
          _ = [b].concat(w).reduce(function (We, Oe) {
            return We.concat(
              Jn(Oe) === fh
                ? IO(e, {
                    placement: Oe,
                    boundary: d,
                    rootBoundary: f,
                    padding: c,
                    flipVariations: m,
                    allowedAutoPlacements: g,
                  })
                : Oe
            );
          }, []),
          v = e.rects.reference,
          C = e.rects.popper,
          S = new Map(),
          N = !0,
          M = _[0],
          L = 0;
        L < _.length;
        L++
      ) {
        var $ = _[L],
          B = Jn($),
          H = Di($) === Ni,
          Q = [Pt, ln].indexOf(B) >= 0,
          X = Q ? "width" : "height",
          Y = wa(e, {
            placement: $,
            boundary: d,
            rootBoundary: f,
            altBoundary: p,
            padding: c,
          }),
          Z = Q ? (H ? cn : $t) : H ? ln : Pt;
        v[X] > C[X] && (Z = Dc(Z));
        var ce = Dc(Z),
          Ae = [];
        if (
          (i && Ae.push(Y[B] <= 0),
          a && Ae.push(Y[Z] <= 0, Y[ce] <= 0),
          Ae.every(function (We) {
            return We;
          }))
        ) {
          (M = $), (N = !1);
          break;
        }
        S.set($, Ae);
      }
      if (N)
        for (
          var Ie = m ? 3 : 1,
            xe = function (Oe) {
              var Be = _.find(function (pt) {
                var Je = S.get(pt);
                if (Je)
                  return Je.slice(0, Oe).every(function (yt) {
                    return yt;
                  });
              });
              if (Be) return (M = Be), "break";
            },
            De = Ie;
          De > 0;
          De--
        ) {
          var He = xe(De);
          if (He === "break") break;
        }
      e.placement !== M &&
        ((e.modifiersData[r]._skip = !0), (e.placement = M), (e.reset = !0));
    }
  }
  const $O = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: PO,
    requiresIfExists: ["offset"],
    data: { _skip: !1 },
  };
  function pk(t, e, n) {
    return (
      n === void 0 && (n = { x: 0, y: 0 }),
      {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x,
      }
    );
  }
  function hk(t) {
    return [Pt, cn, ln, $t].some(function (e) {
      return t[e] >= 0;
    });
  }
  function FO(t) {
    var e = t.state,
      n = t.name,
      r = e.rects.reference,
      o = e.rects.popper,
      i = e.modifiersData.preventOverflow,
      s = wa(e, { elementContext: "reference" }),
      a = wa(e, { altBoundary: !0 }),
      l = pk(s, r),
      c = pk(a, o, i),
      d = hk(l),
      f = hk(c);
    (e.modifiersData[n] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c,
      isReferenceHidden: d,
      hasPopperEscaped: f,
    }),
      (e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": d,
        "data-popper-escaped": f,
      }));
  }
  const HO = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: FO,
  };
  function zO(t, e, n) {
    var r = Jn(t),
      o = [$t, Pt].indexOf(r) >= 0 ? -1 : 1,
      i =
        typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n,
      s = i[0],
      a = i[1];
    return (
      (s = s || 0),
      (a = (a || 0) * o),
      [$t, cn].indexOf(r) >= 0 ? { x: a, y: s } : { x: s, y: a }
    );
  }
  function VO(t) {
    var e = t.state,
      n = t.options,
      r = t.name,
      o = n.offset,
      i = o === void 0 ? [0, 0] : o,
      s = ek.reduce(function (d, f) {
        return (d[f] = zO(f, e.rects, i)), d;
      }, {}),
      a = s[e.placement],
      l = a.x,
      c = a.y;
    e.modifiersData.popperOffsets != null &&
      ((e.modifiersData.popperOffsets.x += l),
      (e.modifiersData.popperOffsets.y += c)),
      (e.modifiersData[r] = s);
  }
  const UO = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: VO,
  };
  function jO(t) {
    var e = t.state,
      n = t.name;
    e.modifiersData[n] = fk({
      reference: e.rects.reference,
      element: e.rects.popper,
      strategy: "absolute",
      placement: e.placement,
    });
  }
  const WO = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: jO,
    data: {},
  };
  function qO(t) {
    return t === "x" ? "y" : "x";
  }
  function KO(t) {
    var e = t.state,
      n = t.options,
      r = t.name,
      o = n.mainAxis,
      i = o === void 0 ? !0 : o,
      s = n.altAxis,
      a = s === void 0 ? !1 : s,
      l = n.boundary,
      c = n.rootBoundary,
      d = n.altBoundary,
      f = n.padding,
      p = n.tether,
      h = p === void 0 ? !0 : p,
      m = n.tetherOffset,
      g = m === void 0 ? 0 : m,
      b = wa(e, { boundary: l, rootBoundary: c, padding: f, altBoundary: d }),
      y = Jn(e.placement),
      x = Di(e.placement),
      w = !x,
      _ = gh(y),
      v = qO(_),
      C = e.modifiersData.popperOffsets,
      S = e.rects.reference,
      N = e.rects.popper,
      M =
        typeof g == "function"
          ? g(Object.assign({}, e.rects, { placement: e.placement }))
          : g,
      L =
        typeof M == "number"
          ? { mainAxis: M, altAxis: M }
          : Object.assign({ mainAxis: 0, altAxis: 0 }, M),
      $ = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
      B = { x: 0, y: 0 };
    if (C) {
      if (i) {
        var H,
          Q = _ === "y" ? Pt : $t,
          X = _ === "y" ? ln : cn,
          Y = _ === "y" ? "height" : "width",
          Z = C[_],
          ce = Z + b[Q],
          Ae = Z - b[X],
          Ie = h ? -N[Y] / 2 : 0,
          xe = x === Ni ? S[Y] : N[Y],
          De = x === Ni ? -N[Y] : -S[Y],
          He = e.elements.arrow,
          We = h && He ? mh(He) : { width: 0, height: 0 },
          Oe = e.modifiersData["arrow#persistent"]
            ? e.modifiersData["arrow#persistent"].padding
            : ik(),
          Be = Oe[Q],
          pt = Oe[X],
          Je = _a(0, S[Y], We[Y]),
          yt = w
            ? S[Y] / 2 - Ie - Je - Be - L.mainAxis
            : xe - Je - Be - L.mainAxis,
          tt = w
            ? -S[Y] / 2 + Ie + Je + pt + L.mainAxis
            : De + Je + pt + L.mainAxis,
          Gt = e.elements.arrow && ya(e.elements.arrow),
          Rn = Gt ? (_ === "y" ? Gt.clientTop || 0 : Gt.clientLeft || 0) : 0,
          Er = (H = $ == null ? void 0 : $[_]) != null ? H : 0,
          go = Z + yt - Er - Rn,
          nr = Z + tt - Er,
          bn = _a(h ? Nc(ce, go) : ce, Z, h ? Ko(Ae, nr) : Ae);
        (C[_] = bn), (B[_] = bn - Z);
      }
      if (a) {
        var yn,
          rr = _ === "x" ? Pt : $t,
          bo = _ === "x" ? ln : cn,
          E = C[v],
          A = v === "y" ? "height" : "width",
          I = E + b[rr],
          W = E - b[bo],
          ve = [Pt, $t].indexOf(y) !== -1,
          te = (yn = $ == null ? void 0 : $[v]) != null ? yn : 0,
          O = ve ? I : E - S[A] - N[A] - te + L.altAxis,
          P = ve ? E + S[A] + N[A] - te - L.altAxis : W,
          ye = h && ve ? bO(O, E, P) : _a(h ? O : I, E, h ? P : W);
        (C[v] = ye), (B[v] = ye - E);
      }
      e.modifiersData[r] = B;
    }
  }
  const GO = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: KO,
    requiresIfExists: ["offset"],
  };
  function JO(t) {
    return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
  }
  function YO(t) {
    return t === un(t) || !dn(t) ? bh(t) : JO(t);
  }
  function XO(t) {
    var e = t.getBoundingClientRect(),
      n = Oi(e.width) / t.offsetWidth || 1,
      r = Oi(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1;
  }
  function ZO(t, e, n) {
    n === void 0 && (n = !1);
    var r = dn(e),
      o = dn(e) && XO(e),
      i = ro(e),
      s = Ri(t, o, n),
      a = { scrollLeft: 0, scrollTop: 0 },
      l = { x: 0, y: 0 };
    return (
      (r || (!r && !n)) &&
        ((Gn(e) !== "body" || _h(i)) && (a = YO(e)),
        dn(e)
          ? ((l = Ri(e, !0)), (l.x += e.clientLeft), (l.y += e.clientTop))
          : i && (l.x = yh(i))),
      {
        x: s.left + a.scrollLeft - l.x,
        y: s.top + a.scrollTop - l.y,
        width: s.width,
        height: s.height,
      }
    );
  }
  function QO(t) {
    var e = new Map(),
      n = new Set(),
      r = [];
    t.forEach(function (i) {
      e.set(i.name, i);
    });
    function o(i) {
      n.add(i.name);
      var s = [].concat(i.requires || [], i.requiresIfExists || []);
      s.forEach(function (a) {
        if (!n.has(a)) {
          var l = e.get(a);
          l && o(l);
        }
      }),
        r.push(i);
    }
    return (
      t.forEach(function (i) {
        n.has(i.name) || o(i);
      }),
      r
    );
  }
  function eR(t) {
    var e = QO(t);
    return fO.reduce(function (n, r) {
      return n.concat(
        e.filter(function (o) {
          return o.phase === r;
        })
      );
    }, []);
  }
  function tR(t) {
    var e;
    return function () {
      return (
        e ||
          (e = new Promise(function (n) {
            Promise.resolve().then(function () {
              (e = void 0), n(t());
            });
          })),
        e
      );
    };
  }
  function nR(t) {
    var e = t.reduce(function (n, r) {
      var o = n[r.name];
      return (
        (n[r.name] = o
          ? Object.assign({}, o, r, {
              options: Object.assign({}, o.options, r.options),
              data: Object.assign({}, o.data, r.data),
            })
          : r),
        n
      );
    }, {});
    return Object.keys(e).map(function (n) {
      return e[n];
    });
  }
  var mk = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function gk() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return !e.some(function (r) {
      return !(r && typeof r.getBoundingClientRect == "function");
    });
  }
  function rR(t) {
    t === void 0 && (t = {});
    var e = t,
      n = e.defaultModifiers,
      r = n === void 0 ? [] : n,
      o = e.defaultOptions,
      i = o === void 0 ? mk : o;
    return function (a, l, c) {
      c === void 0 && (c = i);
      var d = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, mk, i),
          modifiersData: {},
          elements: { reference: a, popper: l },
          attributes: {},
          styles: {},
        },
        f = [],
        p = !1,
        h = {
          state: d,
          setOptions: function (y) {
            var x = typeof y == "function" ? y(d.options) : y;
            g(),
              (d.options = Object.assign({}, i, d.options, x)),
              (d.scrollParents = {
                reference: qo(a)
                  ? ka(a)
                  : a.contextElement
                  ? ka(a.contextElement)
                  : [],
                popper: ka(l),
              });
            var w = eR(nR([].concat(r, d.options.modifiers)));
            return (
              (d.orderedModifiers = w.filter(function (_) {
                return _.enabled;
              })),
              m(),
              h.update()
            );
          },
          forceUpdate: function () {
            if (!p) {
              var y = d.elements,
                x = y.reference,
                w = y.popper;
              if (gk(x, w)) {
                (d.rects = {
                  reference: ZO(x, ya(w), d.options.strategy === "fixed"),
                  popper: mh(w),
                }),
                  (d.reset = !1),
                  (d.placement = d.options.placement),
                  d.orderedModifiers.forEach(function (L) {
                    return (d.modifiersData[L.name] = Object.assign(
                      {},
                      L.data
                    ));
                  });
                for (var _ = 0; _ < d.orderedModifiers.length; _++) {
                  if (d.reset === !0) {
                    (d.reset = !1), (_ = -1);
                    continue;
                  }
                  var v = d.orderedModifiers[_],
                    C = v.fn,
                    S = v.options,
                    N = S === void 0 ? {} : S,
                    M = v.name;
                  typeof C == "function" &&
                    (d =
                      C({ state: d, options: N, name: M, instance: h }) || d);
                }
              }
            }
          },
          update: tR(function () {
            return new Promise(function (b) {
              h.forceUpdate(), b(d);
            });
          }),
          destroy: function () {
            g(), (p = !0);
          },
        };
      if (!gk(a, l)) return h;
      h.setOptions(c).then(function (b) {
        !p && c.onFirstUpdate && c.onFirstUpdate(b);
      });
      function m() {
        d.orderedModifiers.forEach(function (b) {
          var y = b.name,
            x = b.options,
            w = x === void 0 ? {} : x,
            _ = b.effect;
          if (typeof _ == "function") {
            var v = _({ state: d, name: y, instance: h, options: w }),
              C = function () {};
            f.push(v || C);
          }
        });
      }
      function g() {
        f.forEach(function (b) {
          return b();
        }),
          (f = []);
      }
      return h;
    };
  }
  var oR = [SO, WO, EO, tk, UO, $O, GO, wO, HO],
    iR = rR({ defaultModifiers: oR }),
    sR = "tippy-box",
    bk = "tippy-content",
    aR = "tippy-backdrop",
    yk = "tippy-arrow",
    _k = "tippy-svg-arrow",
    Go = { passive: !0, capture: !0 },
    kk = function () {
      return document.body;
    };
  function wh(t, e, n) {
    if (Array.isArray(t)) {
      var r = t[e];
      return r ?? (Array.isArray(n) ? n[e] : n);
    }
    return t;
  }
  function xh(t, e) {
    var n = {}.toString.call(t);
    return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
  }
  function wk(t, e) {
    return typeof t == "function" ? t.apply(void 0, e) : t;
  }
  function xk(t, e) {
    if (e === 0) return t;
    var n;
    return function (r) {
      clearTimeout(n),
        (n = setTimeout(function () {
          t(r);
        }, e));
    };
  }
  function lR(t) {
    return t.split(/\s+/).filter(Boolean);
  }
  function Li(t) {
    return [].concat(t);
  }
  function Ck(t, e) {
    t.indexOf(e) === -1 && t.push(e);
  }
  function cR(t) {
    return t.filter(function (e, n) {
      return t.indexOf(e) === n;
    });
  }
  function uR(t) {
    return t.split("-")[0];
  }
  function Lc(t) {
    return [].slice.call(t);
  }
  function vk(t) {
    return Object.keys(t).reduce(function (e, n) {
      return t[n] !== void 0 && (e[n] = t[n]), e;
    }, {});
  }
  function xa() {
    return document.createElement("div");
  }
  function Ic(t) {
    return ["Element", "Fragment"].some(function (e) {
      return xh(t, e);
    });
  }
  function dR(t) {
    return xh(t, "NodeList");
  }
  function fR(t) {
    return xh(t, "MouseEvent");
  }
  function pR(t) {
    return !!(t && t._tippy && t._tippy.reference === t);
  }
  function hR(t) {
    return Ic(t)
      ? [t]
      : dR(t)
      ? Lc(t)
      : Array.isArray(t)
      ? t
      : Lc(document.querySelectorAll(t));
  }
  function Ch(t, e) {
    t.forEach(function (n) {
      n && (n.style.transitionDuration = e + "ms");
    });
  }
  function Ek(t, e) {
    t.forEach(function (n) {
      n && n.setAttribute("data-state", e);
    });
  }
  function mR(t) {
    var e,
      n = Li(t),
      r = n[0];
    return r != null && (e = r.ownerDocument) != null && e.body
      ? r.ownerDocument
      : document;
  }
  function gR(t, e) {
    var n = e.clientX,
      r = e.clientY;
    return t.every(function (o) {
      var i = o.popperRect,
        s = o.popperState,
        a = o.props,
        l = a.interactiveBorder,
        c = uR(s.placement),
        d = s.modifiersData.offset;
      if (!d) return !0;
      var f = c === "bottom" ? d.top.y : 0,
        p = c === "top" ? d.bottom.y : 0,
        h = c === "right" ? d.left.x : 0,
        m = c === "left" ? d.right.x : 0,
        g = i.top - r + f > l,
        b = r - i.bottom - p > l,
        y = i.left - n + h > l,
        x = n - i.right - m > l;
      return g || b || y || x;
    });
  }
  function vh(t, e, n) {
    var r = e + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function (o) {
      t[r](o, n);
    });
  }
  function Ak(t, e) {
    for (var n = e; n; ) {
      var r;
      if (t.contains(n)) return !0;
      n =
        n.getRootNode == null || (r = n.getRootNode()) == null
          ? void 0
          : r.host;
    }
    return !1;
  }
  var Yn = { isTouch: !1 },
    Sk = 0;
  function bR() {
    Yn.isTouch ||
      ((Yn.isTouch = !0),
      window.performance && document.addEventListener("mousemove", Mk));
  }
  function Mk() {
    var t = performance.now();
    t - Sk < 20 &&
      ((Yn.isTouch = !1), document.removeEventListener("mousemove", Mk)),
      (Sk = t);
  }
  function yR() {
    var t = document.activeElement;
    if (pR(t)) {
      var e = t._tippy;
      t.blur && !e.state.isVisible && t.blur();
    }
  }
  function _R() {
    document.addEventListener("touchstart", bR, Go),
      window.addEventListener("blur", yR);
  }
  var kR = typeof window < "u" && typeof document < "u",
    wR = kR ? !!window.msCrypto : !1,
    xR = {
      animateFill: !1,
      followCursor: !1,
      inlinePositioning: !1,
      sticky: !1,
    },
    CR = {
      allowHTML: !1,
      animation: "fade",
      arrow: !0,
      content: "",
      inertia: !1,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999,
    },
    Nn = Object.assign(
      {
        appendTo: kk,
        aria: { content: "auto", expanded: "auto" },
        delay: 0,
        duration: [300, 250],
        getReferenceClientRect: null,
        hideOnClick: !0,
        ignoreAttributes: !1,
        interactive: !1,
        interactiveBorder: 2,
        interactiveDebounce: 0,
        moveTransition: "",
        offset: [0, 10],
        onAfterUpdate: function () {},
        onBeforeUpdate: function () {},
        onCreate: function () {},
        onDestroy: function () {},
        onHidden: function () {},
        onHide: function () {},
        onMount: function () {},
        onShow: function () {},
        onShown: function () {},
        onTrigger: function () {},
        onUntrigger: function () {},
        onClickOutside: function () {},
        placement: "top",
        plugins: [],
        popperOptions: {},
        render: null,
        showOnCreate: !1,
        touch: !0,
        trigger: "mouseenter focus",
        triggerTarget: null,
      },
      xR,
      CR
    ),
    vR = Object.keys(Nn),
    ER = function (e) {
      var n = Object.keys(e);
      n.forEach(function (r) {
        Nn[r] = e[r];
      });
    };
  function Tk(t) {
    var e = t.plugins || [],
      n = e.reduce(function (r, o) {
        var i = o.name,
          s = o.defaultValue;
        if (i) {
          var a;
          r[i] = t[i] !== void 0 ? t[i] : (a = Nn[i]) != null ? a : s;
        }
        return r;
      }, {});
    return Object.assign({}, t, n);
  }
  function AR(t, e) {
    var n = e ? Object.keys(Tk(Object.assign({}, Nn, { plugins: e }))) : vR,
      r = n.reduce(function (o, i) {
        var s = (t.getAttribute("data-tippy-" + i) || "").trim();
        if (!s) return o;
        if (i === "content") o[i] = s;
        else
          try {
            o[i] = JSON.parse(s);
          } catch {
            o[i] = s;
          }
        return o;
      }, {});
    return r;
  }
  function Nk(t, e) {
    var n = Object.assign(
      {},
      e,
      { content: wk(e.content, [t]) },
      e.ignoreAttributes ? {} : AR(t, e.plugins)
    );
    return (
      (n.aria = Object.assign({}, Nn.aria, n.aria)),
      (n.aria = {
        expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
        content:
          n.aria.content === "auto"
            ? e.interactive
              ? null
              : "describedby"
            : n.aria.content,
      }),
      n
    );
  }
  var SR = function () {
    return "innerHTML";
  };
  function Eh(t, e) {
    t[SR()] = e;
  }
  function Ok(t) {
    var e = xa();
    return (
      t === !0
        ? (e.className = yk)
        : ((e.className = _k), Ic(t) ? e.appendChild(t) : Eh(e, t)),
      e
    );
  }
  function Rk(t, e) {
    Ic(e.content)
      ? (Eh(t, ""), t.appendChild(e.content))
      : typeof e.content != "function" &&
        (e.allowHTML ? Eh(t, e.content) : (t.textContent = e.content));
  }
  function Ah(t) {
    var e = t.firstElementChild,
      n = Lc(e.children);
    return {
      box: e,
      content: n.find(function (r) {
        return r.classList.contains(bk);
      }),
      arrow: n.find(function (r) {
        return r.classList.contains(yk) || r.classList.contains(_k);
      }),
      backdrop: n.find(function (r) {
        return r.classList.contains(aR);
      }),
    };
  }
  function Dk(t) {
    var e = xa(),
      n = xa();
    (n.className = sR),
      n.setAttribute("data-state", "hidden"),
      n.setAttribute("tabindex", "-1");
    var r = xa();
    (r.className = bk),
      r.setAttribute("data-state", "hidden"),
      Rk(r, t.props),
      e.appendChild(n),
      n.appendChild(r),
      o(t.props, t.props);
    function o(i, s) {
      var a = Ah(e),
        l = a.box,
        c = a.content,
        d = a.arrow;
      s.theme
        ? l.setAttribute("data-theme", s.theme)
        : l.removeAttribute("data-theme"),
        typeof s.animation == "string"
          ? l.setAttribute("data-animation", s.animation)
          : l.removeAttribute("data-animation"),
        s.inertia
          ? l.setAttribute("data-inertia", "")
          : l.removeAttribute("data-inertia"),
        (l.style.maxWidth =
          typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth),
        s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"),
        (i.content !== s.content || i.allowHTML !== s.allowHTML) &&
          Rk(c, t.props),
        s.arrow
          ? d
            ? i.arrow !== s.arrow &&
              (l.removeChild(d), l.appendChild(Ok(s.arrow)))
            : l.appendChild(Ok(s.arrow))
          : d && l.removeChild(d);
    }
    return { popper: e, onUpdate: o };
  }
  Dk.$$tippy = !0;
  var MR = 1,
    Bc = [],
    Sh = [];
  function TR(t, e) {
    var n = Nk(t, Object.assign({}, Nn, Tk(vk(e)))),
      r,
      o,
      i,
      s = !1,
      a = !1,
      l = !1,
      c = !1,
      d,
      f,
      p,
      h = [],
      m = xk(go, n.interactiveDebounce),
      g,
      b = MR++,
      y = null,
      x = cR(n.plugins),
      w = {
        isEnabled: !0,
        isVisible: !1,
        isDestroyed: !1,
        isMounted: !1,
        isShown: !1,
      },
      _ = {
        id: b,
        reference: t,
        popper: xa(),
        popperInstance: y,
        props: n,
        state: w,
        plugins: x,
        clearDelayTimeouts: O,
        setProps: P,
        setContent: ye,
        show: ze,
        hide: or,
        hideWithInteractivity: Ji,
        enable: ve,
        disable: te,
        unmount: yo,
        destroy: V0,
      };
    if (!n.render) return _;
    var v = n.render(_),
      C = v.popper,
      S = v.onUpdate;
    C.setAttribute("data-tippy-root", ""),
      (C.id = "tippy-" + _.id),
      (_.popper = C),
      (t._tippy = _),
      (C._tippy = _);
    var N = x.map(function (R) {
        return R.fn(_);
      }),
      M = t.hasAttribute("aria-expanded");
    return (
      Gt(),
      Ie(),
      Z(),
      ce("onCreate", [_]),
      n.showOnCreate && I(),
      C.addEventListener("mouseenter", function () {
        _.props.interactive && _.state.isVisible && _.clearDelayTimeouts();
      }),
      C.addEventListener("mouseleave", function () {
        _.props.interactive &&
          _.props.trigger.indexOf("mouseenter") >= 0 &&
          Q().addEventListener("mousemove", m);
      }),
      _
    );
    function L() {
      var R = _.props.touch;
      return Array.isArray(R) ? R : [R, 0];
    }
    function $() {
      return L()[0] === "hold";
    }
    function B() {
      var R;
      return !!((R = _.props.render) != null && R.$$tippy);
    }
    function H() {
      return g || t;
    }
    function Q() {
      var R = H().parentNode;
      return R ? mR(R) : document;
    }
    function X() {
      return Ah(C);
    }
    function Y(R) {
      return (_.state.isMounted && !_.state.isVisible) ||
        Yn.isTouch ||
        (d && d.type === "focus")
        ? 0
        : wh(_.props.delay, R ? 0 : 1, Nn.delay);
    }
    function Z(R) {
      R === void 0 && (R = !1),
        (C.style.pointerEvents = _.props.interactive && !R ? "" : "none"),
        (C.style.zIndex = "" + _.props.zIndex);
    }
    function ce(R, G, ne) {
      if (
        (ne === void 0 && (ne = !0),
        N.forEach(function (ge) {
          ge[R] && ge[R].apply(ge, G);
        }),
        ne)
      ) {
        var Se;
        (Se = _.props)[R].apply(Se, G);
      }
    }
    function Ae() {
      var R = _.props.aria;
      if (R.content) {
        var G = "aria-" + R.content,
          ne = C.id,
          Se = Li(_.props.triggerTarget || t);
        Se.forEach(function (ge) {
          var Nt = ge.getAttribute(G);
          if (_.state.isVisible) ge.setAttribute(G, Nt ? Nt + " " + ne : ne);
          else {
            var _n = Nt && Nt.replace(ne, "").trim();
            _n ? ge.setAttribute(G, _n) : ge.removeAttribute(G);
          }
        });
      }
    }
    function Ie() {
      if (!(M || !_.props.aria.expanded)) {
        var R = Li(_.props.triggerTarget || t);
        R.forEach(function (G) {
          _.props.interactive
            ? G.setAttribute(
                "aria-expanded",
                _.state.isVisible && G === H() ? "true" : "false"
              )
            : G.removeAttribute("aria-expanded");
        });
      }
    }
    function xe() {
      Q().removeEventListener("mousemove", m),
        (Bc = Bc.filter(function (R) {
          return R !== m;
        }));
    }
    function De(R) {
      if (!(Yn.isTouch && (l || R.type === "mousedown"))) {
        var G = (R.composedPath && R.composedPath()[0]) || R.target;
        if (!(_.props.interactive && Ak(C, G))) {
          if (
            Li(_.props.triggerTarget || t).some(function (ne) {
              return Ak(ne, G);
            })
          ) {
            if (
              Yn.isTouch ||
              (_.state.isVisible && _.props.trigger.indexOf("click") >= 0)
            )
              return;
          } else ce("onClickOutside", [_, R]);
          _.props.hideOnClick === !0 &&
            (_.clearDelayTimeouts(),
            _.hide(),
            (a = !0),
            setTimeout(function () {
              a = !1;
            }),
            _.state.isMounted || Be());
        }
      }
    }
    function He() {
      l = !0;
    }
    function We() {
      l = !1;
    }
    function Oe() {
      var R = Q();
      R.addEventListener("mousedown", De, !0),
        R.addEventListener("touchend", De, Go),
        R.addEventListener("touchstart", We, Go),
        R.addEventListener("touchmove", He, Go);
    }
    function Be() {
      var R = Q();
      R.removeEventListener("mousedown", De, !0),
        R.removeEventListener("touchend", De, Go),
        R.removeEventListener("touchstart", We, Go),
        R.removeEventListener("touchmove", He, Go);
    }
    function pt(R, G) {
      yt(R, function () {
        !_.state.isVisible && C.parentNode && C.parentNode.contains(C) && G();
      });
    }
    function Je(R, G) {
      yt(R, G);
    }
    function yt(R, G) {
      var ne = X().box;
      function Se(ge) {
        ge.target === ne && (vh(ne, "remove", Se), G());
      }
      if (R === 0) return G();
      vh(ne, "remove", f), vh(ne, "add", Se), (f = Se);
    }
    function tt(R, G, ne) {
      ne === void 0 && (ne = !1);
      var Se = Li(_.props.triggerTarget || t);
      Se.forEach(function (ge) {
        ge.addEventListener(R, G, ne),
          h.push({ node: ge, eventType: R, handler: G, options: ne });
      });
    }
    function Gt() {
      $() &&
        (tt("touchstart", Er, { passive: !0 }),
        tt("touchend", nr, { passive: !0 })),
        lR(_.props.trigger).forEach(function (R) {
          if (R !== "manual")
            switch ((tt(R, Er), R)) {
              case "mouseenter":
                tt("mouseleave", nr);
                break;
              case "focus":
                tt(wR ? "focusout" : "blur", bn);
                break;
              case "focusin":
                tt("focusout", bn);
                break;
            }
        });
    }
    function Rn() {
      h.forEach(function (R) {
        var G = R.node,
          ne = R.eventType,
          Se = R.handler,
          ge = R.options;
        G.removeEventListener(ne, Se, ge);
      }),
        (h = []);
    }
    function Er(R) {
      var G,
        ne = !1;
      if (!(!_.state.isEnabled || yn(R) || a)) {
        var Se = ((G = d) == null ? void 0 : G.type) === "focus";
        (d = R),
          (g = R.currentTarget),
          Ie(),
          !_.state.isVisible &&
            fR(R) &&
            Bc.forEach(function (ge) {
              return ge(R);
            }),
          R.type === "click" &&
          (_.props.trigger.indexOf("mouseenter") < 0 || s) &&
          _.props.hideOnClick !== !1 &&
          _.state.isVisible
            ? (ne = !0)
            : I(R),
          R.type === "click" && (s = !ne),
          ne && !Se && W(R);
      }
    }
    function go(R) {
      var G = R.target,
        ne = H().contains(G) || C.contains(G);
      if (!(R.type === "mousemove" && ne)) {
        var Se = A()
          .concat(C)
          .map(function (ge) {
            var Nt,
              _n = ge._tippy,
              Yi = (Nt = _n.popperInstance) == null ? void 0 : Nt.state;
            return Yi
              ? {
                  popperRect: ge.getBoundingClientRect(),
                  popperState: Yi,
                  props: n,
                }
              : null;
          })
          .filter(Boolean);
        gR(Se, R) && (xe(), W(R));
      }
    }
    function nr(R) {
      var G = yn(R) || (_.props.trigger.indexOf("click") >= 0 && s);
      if (!G) {
        if (_.props.interactive) {
          _.hideWithInteractivity(R);
          return;
        }
        W(R);
      }
    }
    function bn(R) {
      (_.props.trigger.indexOf("focusin") < 0 && R.target !== H()) ||
        (_.props.interactive &&
          R.relatedTarget &&
          C.contains(R.relatedTarget)) ||
        W(R);
    }
    function yn(R) {
      return Yn.isTouch ? $() !== R.type.indexOf("touch") >= 0 : !1;
    }
    function rr() {
      bo();
      var R = _.props,
        G = R.popperOptions,
        ne = R.placement,
        Se = R.offset,
        ge = R.getReferenceClientRect,
        Nt = R.moveTransition,
        _n = B() ? Ah(C).arrow : null,
        Yi = ge
          ? {
              getBoundingClientRect: ge,
              contextElement: ge.contextElement || H(),
            }
          : t,
        Bx = {
          name: "$$tippy",
          enabled: !0,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function (xd) {
            var Xi = xd.state;
            if (B()) {
              var yz = X(),
                j0 = yz.box;
              ["placement", "reference-hidden", "escaped"].forEach(function (
                Cd
              ) {
                Cd === "placement"
                  ? j0.setAttribute("data-placement", Xi.placement)
                  : Xi.attributes.popper["data-popper-" + Cd]
                  ? j0.setAttribute("data-" + Cd, "")
                  : j0.removeAttribute("data-" + Cd);
              }),
                (Xi.attributes.popper = {});
            }
          },
        },
        ni = [
          { name: "offset", options: { offset: Se } },
          {
            name: "preventOverflow",
            options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
          },
          { name: "flip", options: { padding: 5 } },
          { name: "computeStyles", options: { adaptive: !Nt } },
          Bx,
        ];
      B() &&
        _n &&
        ni.push({ name: "arrow", options: { element: _n, padding: 3 } }),
        ni.push.apply(ni, (G == null ? void 0 : G.modifiers) || []),
        (_.popperInstance = iR(
          Yi,
          C,
          Object.assign({}, G, {
            placement: ne,
            onFirstUpdate: p,
            modifiers: ni,
          })
        ));
    }
    function bo() {
      _.popperInstance &&
        (_.popperInstance.destroy(), (_.popperInstance = null));
    }
    function E() {
      var R = _.props.appendTo,
        G,
        ne = H();
      (_.props.interactive && R === kk) || R === "parent"
        ? (G = ne.parentNode)
        : (G = wk(R, [ne])),
        G.contains(C) || G.appendChild(C),
        (_.state.isMounted = !0),
        rr();
    }
    function A() {
      return Lc(C.querySelectorAll("[data-tippy-root]"));
    }
    function I(R) {
      _.clearDelayTimeouts(), R && ce("onTrigger", [_, R]), Oe();
      var G = Y(!0),
        ne = L(),
        Se = ne[0],
        ge = ne[1];
      Yn.isTouch && Se === "hold" && ge && (G = ge),
        G
          ? (r = setTimeout(function () {
              _.show();
            }, G))
          : _.show();
    }
    function W(R) {
      if (
        (_.clearDelayTimeouts(), ce("onUntrigger", [_, R]), !_.state.isVisible)
      ) {
        Be();
        return;
      }
      if (
        !(
          _.props.trigger.indexOf("mouseenter") >= 0 &&
          _.props.trigger.indexOf("click") >= 0 &&
          ["mouseleave", "mousemove"].indexOf(R.type) >= 0 &&
          s
        )
      ) {
        var G = Y(!1);
        G
          ? (o = setTimeout(function () {
              _.state.isVisible && _.hide();
            }, G))
          : (i = requestAnimationFrame(function () {
              _.hide();
            }));
      }
    }
    function ve() {
      _.state.isEnabled = !0;
    }
    function te() {
      _.hide(), (_.state.isEnabled = !1);
    }
    function O() {
      clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
    }
    function P(R) {
      if (!_.state.isDestroyed) {
        ce("onBeforeUpdate", [_, R]), Rn();
        var G = _.props,
          ne = Nk(t, Object.assign({}, G, vk(R), { ignoreAttributes: !0 }));
        (_.props = ne),
          Gt(),
          G.interactiveDebounce !== ne.interactiveDebounce &&
            (xe(), (m = xk(go, ne.interactiveDebounce))),
          G.triggerTarget && !ne.triggerTarget
            ? Li(G.triggerTarget).forEach(function (Se) {
                Se.removeAttribute("aria-expanded");
              })
            : ne.triggerTarget && t.removeAttribute("aria-expanded"),
          Ie(),
          Z(),
          S && S(G, ne),
          _.popperInstance &&
            (rr(),
            A().forEach(function (Se) {
              requestAnimationFrame(Se._tippy.popperInstance.forceUpdate);
            })),
          ce("onAfterUpdate", [_, R]);
      }
    }
    function ye(R) {
      _.setProps({ content: R });
    }
    function ze() {
      var R = _.state.isVisible,
        G = _.state.isDestroyed,
        ne = !_.state.isEnabled,
        Se = Yn.isTouch && !_.props.touch,
        ge = wh(_.props.duration, 0, Nn.duration);
      if (
        !(R || G || ne || Se) &&
        !H().hasAttribute("disabled") &&
        (ce("onShow", [_], !1), _.props.onShow(_) !== !1)
      ) {
        if (
          ((_.state.isVisible = !0),
          B() && (C.style.visibility = "visible"),
          Z(),
          Oe(),
          _.state.isMounted || (C.style.transition = "none"),
          B())
        ) {
          var Nt = X(),
            _n = Nt.box,
            Yi = Nt.content;
          Ch([_n, Yi], 0);
        }
        (p = function () {
          var ni;
          if (!(!_.state.isVisible || c)) {
            if (
              ((c = !0),
              C.offsetHeight,
              (C.style.transition = _.props.moveTransition),
              B() && _.props.animation)
            ) {
              var U0 = X(),
                xd = U0.box,
                Xi = U0.content;
              Ch([xd, Xi], ge), Ek([xd, Xi], "visible");
            }
            Ae(),
              Ie(),
              Ck(Sh, _),
              (ni = _.popperInstance) == null || ni.forceUpdate(),
              ce("onMount", [_]),
              _.props.animation &&
                B() &&
                Je(ge, function () {
                  (_.state.isShown = !0), ce("onShown", [_]);
                });
          }
        }),
          E();
      }
    }
    function or() {
      var R = !_.state.isVisible,
        G = _.state.isDestroyed,
        ne = !_.state.isEnabled,
        Se = wh(_.props.duration, 1, Nn.duration);
      if (
        !(R || G || ne) &&
        (ce("onHide", [_], !1), _.props.onHide(_) !== !1)
      ) {
        if (
          ((_.state.isVisible = !1),
          (_.state.isShown = !1),
          (c = !1),
          (s = !1),
          B() && (C.style.visibility = "hidden"),
          xe(),
          Be(),
          Z(!0),
          B())
        ) {
          var ge = X(),
            Nt = ge.box,
            _n = ge.content;
          _.props.animation && (Ch([Nt, _n], Se), Ek([Nt, _n], "hidden"));
        }
        Ae(), Ie(), _.props.animation ? B() && pt(Se, _.unmount) : _.unmount();
      }
    }
    function Ji(R) {
      Q().addEventListener("mousemove", m), Ck(Bc, m), m(R);
    }
    function yo() {
      _.state.isVisible && _.hide(),
        _.state.isMounted &&
          (bo(),
          A().forEach(function (R) {
            R._tippy.unmount();
          }),
          C.parentNode && C.parentNode.removeChild(C),
          (Sh = Sh.filter(function (R) {
            return R !== _;
          })),
          (_.state.isMounted = !1),
          ce("onHidden", [_]));
    }
    function V0() {
      _.state.isDestroyed ||
        (_.clearDelayTimeouts(),
        _.unmount(),
        Rn(),
        delete t._tippy,
        (_.state.isDestroyed = !0),
        ce("onDestroy", [_]));
    }
  }
  function oo(t, e) {
    e === void 0 && (e = {});
    var n = Nn.plugins.concat(e.plugins || []);
    _R();
    var r = Object.assign({}, e, { plugins: n }),
      o = hR(t),
      i = o.reduce(function (s, a) {
        var l = a && TR(a, r);
        return l && s.push(l), s;
      }, []);
    return Ic(t) ? i[0] : i;
  }
  (oo.defaultProps = Nn),
    (oo.setDefaultProps = ER),
    (oo.currentInput = Yn),
    Object.assign({}, tk, {
      effect: function (e) {
        var n = e.state,
          r = {
            popper: {
              position: n.options.strategy,
              left: "0",
              top: "0",
              margin: "0",
            },
            arrow: { position: "absolute" },
            reference: {},
          };
        Object.assign(n.elements.popper.style, r.popper),
          (n.styles = r),
          n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
      },
    });
  var NR = {
    name: "sticky",
    defaultValue: !1,
    fn: function (e) {
      var n = e.reference,
        r = e.popper;
      function o() {
        return e.popperInstance ? e.popperInstance.state.elements.reference : n;
      }
      function i(c) {
        return e.props.sticky === !0 || e.props.sticky === c;
      }
      var s = null,
        a = null;
      function l() {
        var c = i("reference") ? o().getBoundingClientRect() : null,
          d = i("popper") ? r.getBoundingClientRect() : null;
        ((c && Lk(s, c)) || (d && Lk(a, d))) &&
          e.popperInstance &&
          e.popperInstance.update(),
          (s = c),
          (a = d),
          e.state.isMounted && requestAnimationFrame(l);
      }
      return {
        onMount: function () {
          e.props.sticky && l();
        },
      };
    },
  };
  function Lk(t, e) {
    return t && e
      ? t.top !== e.top ||
          t.right !== e.right ||
          t.bottom !== e.bottom ||
          t.left !== e.left
      : !0;
  }
  oo.setDefaultProps({ render: Dk });
  let OR = class {
    constructor({
      editor: e,
      element: n,
      view: r,
      tippyOptions: o = {},
      updateDelay: i = 250,
      shouldShow: s,
    }) {
      (this.preventHide = !1),
        (this.shouldShow = ({ view: a, state: l, from: c, to: d }) => {
          const { doc: f, selection: p } = l,
            { empty: h } = p,
            m = !f.textBetween(c, d).length && Si(l.selection),
            g = this.element.contains(document.activeElement);
          return !(!(a.hasFocus() || g) || h || m || !this.editor.isEditable);
        }),
        (this.mousedownHandler = () => {
          this.preventHide = !0;
        }),
        (this.dragstartHandler = () => {
          this.hide();
        }),
        (this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }),
        (this.blurHandler = ({ event: a }) => {
          var l;
          if (this.preventHide) {
            this.preventHide = !1;
            return;
          }
          (a != null &&
            a.relatedTarget &&
            !((l = this.element.parentNode) === null || l === void 0) &&
            l.contains(a.relatedTarget)) ||
            ((a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom &&
              this.hide());
        }),
        (this.tippyBlurHandler = (a) => {
          this.blurHandler({ event: a });
        }),
        (this.handleDebouncedUpdate = (a, l) => {
          const c = !(l != null && l.selection.eq(a.state.selection)),
            d = !(l != null && l.doc.eq(a.state.doc));
          (!c && !d) ||
            (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer),
            (this.updateDebounceTimer = window.setTimeout(() => {
              this.updateHandler(a, c, d, l);
            }, this.updateDelay)));
        }),
        (this.updateHandler = (a, l, c, d) => {
          var f, p, h;
          const { state: m, composing: g } = a,
            { selection: b } = m;
          if (g || (!l && !c)) return;
          this.createTooltip();
          const { ranges: x } = b,
            w = Math.min(...x.map((C) => C.$from.pos)),
            _ = Math.max(...x.map((C) => C.$to.pos));
          if (
            !((f = this.shouldShow) === null || f === void 0
              ? void 0
              : f.call(this, {
                  editor: this.editor,
                  element: this.element,
                  view: a,
                  state: m,
                  oldState: d,
                  from: w,
                  to: _,
                }))
          ) {
            this.hide();
            return;
          }
          (p = this.tippy) === null ||
            p === void 0 ||
            p.setProps({
              getReferenceClientRect:
                ((h = this.tippyOptions) === null || h === void 0
                  ? void 0
                  : h.getReferenceClientRect) ||
                (() => {
                  if (ha(m.selection)) {
                    let C = a.nodeDOM(w);
                    if (C) {
                      const S = C.dataset.nodeViewWrapper
                        ? C
                        : C.querySelector("[data-node-view-wrapper]");
                      if ((S && (C = S.firstChild), C))
                        return C.getBoundingClientRect();
                    }
                  }
                  return Mc(a, w, _);
                }),
            }),
            this.show();
        }),
        (this.editor = e),
        (this.element = n),
        (this.view = r),
        (this.updateDelay = i),
        s && (this.shouldShow = s),
        this.element.addEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.view.dom.addEventListener("dragstart", this.dragstartHandler),
        this.editor.on("focus", this.focusHandler),
        this.editor.on("blur", this.blurHandler),
        (this.tippyOptions = o),
        this.element.remove(),
        (this.element.style.visibility = "visible");
    }
    createTooltip() {
      const { element: e } = this.editor.options,
        n = !!e.parentElement;
      this.tippy ||
        !n ||
        ((this.tippy = oo(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: !0,
          trigger: "manual",
          placement: "top",
          hideOnClick: "toggle",
          ...this.tippyOptions,
        })),
        this.tippy.popper.firstChild &&
          this.tippy.popper.firstChild.addEventListener(
            "blur",
            this.tippyBlurHandler
          ));
    }
    update(e, n) {
      const { state: r } = e,
        o = r.selection.from !== r.selection.to;
      if (this.updateDelay > 0 && o) {
        this.handleDebouncedUpdate(e, n);
        return;
      }
      const i = !(n != null && n.selection.eq(e.state.selection)),
        s = !(n != null && n.doc.eq(e.state.doc));
      this.updateHandler(e, i, s, n);
    }
    show() {
      var e;
      (e = this.tippy) === null || e === void 0 || e.show();
    }
    hide() {
      var e;
      (e = this.tippy) === null || e === void 0 || e.hide();
    }
    destroy() {
      var e, n;
      !((e = this.tippy) === null || e === void 0) &&
        e.popper.firstChild &&
        this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ),
        (n = this.tippy) === null || n === void 0 || n.destroy(),
        this.element.removeEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.view.dom.removeEventListener("dragstart", this.dragstartHandler),
        this.editor.off("focus", this.focusHandler),
        this.editor.off("blur", this.blurHandler);
    }
  };
  const Ik = (t) =>
    new ie({
      key: typeof t.pluginKey == "string" ? new de(t.pluginKey) : t.pluginKey,
      view: (e) => new OR({ view: e, ...t }),
    });
  we.create({
    name: "bubbleMenu",
    addOptions() {
      return {
        element: null,
        tippyOptions: {},
        pluginKey: "bubbleMenu",
        updateDelay: void 0,
        shouldShow: null,
      };
    },
    addProseMirrorPlugins() {
      return this.options.element
        ? [
            Ik({
              pluginKey: this.options.pluginKey,
              editor: this.editor,
              element: this.options.element,
              tippyOptions: this.options.tippyOptions,
              updateDelay: this.options.updateDelay,
              shouldShow: this.options.shouldShow,
            }),
          ]
        : [];
    },
  });
  class RR {
    getTextContent(e) {
      return vc(e, { textSerializers: la(this.editor.schema) });
    }
    constructor({
      editor: e,
      element: n,
      view: r,
      tippyOptions: o = {},
      shouldShow: i,
    }) {
      (this.preventHide = !1),
        (this.shouldShow = ({ view: s, state: a }) => {
          const { selection: l } = a,
            { $anchor: c, empty: d } = l,
            f = c.depth === 1,
            p =
              c.parent.isTextblock &&
              !c.parent.type.spec.code &&
              !c.parent.textContent &&
              c.parent.childCount === 0 &&
              !this.getTextContent(c.parent);
          return !(!s.hasFocus() || !d || !f || !p || !this.editor.isEditable);
        }),
        (this.mousedownHandler = () => {
          this.preventHide = !0;
        }),
        (this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }),
        (this.blurHandler = ({ event: s }) => {
          var a;
          if (this.preventHide) {
            this.preventHide = !1;
            return;
          }
          (s != null &&
            s.relatedTarget &&
            !((a = this.element.parentNode) === null || a === void 0) &&
            a.contains(s.relatedTarget)) ||
            ((s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom &&
              this.hide());
        }),
        (this.tippyBlurHandler = (s) => {
          this.blurHandler({ event: s });
        }),
        (this.editor = e),
        (this.element = n),
        (this.view = r),
        i && (this.shouldShow = i),
        this.element.addEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.editor.on("focus", this.focusHandler),
        this.editor.on("blur", this.blurHandler),
        (this.tippyOptions = o),
        this.element.remove(),
        (this.element.style.visibility = "visible");
    }
    createTooltip() {
      const { element: e } = this.editor.options,
        n = !!e.parentElement;
      this.tippy ||
        !n ||
        ((this.tippy = oo(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: !0,
          trigger: "manual",
          placement: "right",
          hideOnClick: "toggle",
          ...this.tippyOptions,
        })),
        this.tippy.popper.firstChild &&
          this.tippy.popper.firstChild.addEventListener(
            "blur",
            this.tippyBlurHandler
          ));
    }
    update(e, n) {
      var r, o, i;
      const { state: s } = e,
        { doc: a, selection: l } = s,
        { from: c, to: d } = l;
      if (n && n.doc.eq(a) && n.selection.eq(l)) return;
      if (
        (this.createTooltip(),
        !((r = this.shouldShow) === null || r === void 0
          ? void 0
          : r.call(this, {
              editor: this.editor,
              view: e,
              state: s,
              oldState: n,
            })))
      ) {
        this.hide();
        return;
      }
      (o = this.tippy) === null ||
        o === void 0 ||
        o.setProps({
          getReferenceClientRect:
            ((i = this.tippyOptions) === null || i === void 0
              ? void 0
              : i.getReferenceClientRect) || (() => Mc(e, c, d)),
        }),
        this.show();
    }
    show() {
      var e;
      (e = this.tippy) === null || e === void 0 || e.show();
    }
    hide() {
      var e;
      (e = this.tippy) === null || e === void 0 || e.hide();
    }
    destroy() {
      var e, n;
      !((e = this.tippy) === null || e === void 0) &&
        e.popper.firstChild &&
        this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ),
        (n = this.tippy) === null || n === void 0 || n.destroy(),
        this.element.removeEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.editor.off("focus", this.focusHandler),
        this.editor.off("blur", this.blurHandler);
    }
  }
  const Bk = (t) =>
    new ie({
      key: typeof t.pluginKey == "string" ? new de(t.pluginKey) : t.pluginKey,
      view: (e) => new RR({ view: e, ...t }),
    });
  we.create({
    name: "floatingMenu",
    addOptions() {
      return {
        element: null,
        tippyOptions: {},
        pluginKey: "floatingMenu",
        shouldShow: null,
      };
    },
    addProseMirrorPlugins() {
      return this.options.element
        ? [
            Bk({
              pluginKey: this.options.pluginKey,
              editor: this.editor,
              element: this.options.element,
              tippyOptions: this.options.tippyOptions,
              shouldShow: this.options.shouldShow,
            }),
          ]
        : [];
    },
  });
  const DR = u.defineComponent({
    name: "BubbleMenu",
    props: {
      pluginKey: { type: [String, Object], default: "bubbleMenu" },
      editor: { type: Object, required: !0 },
      updateDelay: { type: Number, default: void 0 },
      tippyOptions: { type: Object, default: () => ({}) },
      shouldShow: { type: Function, default: null },
    },
    setup(t, { slots: e }) {
      const n = u.ref(null);
      return (
        u.onMounted(() => {
          const {
            updateDelay: r,
            editor: o,
            pluginKey: i,
            shouldShow: s,
            tippyOptions: a,
          } = t;
          o.registerPlugin(
            Ik({
              updateDelay: r,
              editor: o,
              element: n.value,
              pluginKey: i,
              shouldShow: s,
              tippyOptions: a,
            })
          );
        }),
        u.onBeforeUnmount(() => {
          const { pluginKey: r, editor: o } = t;
          o.unregisterPlugin(r);
        }),
        () => {
          var r;
          return u.h(
            "div",
            { ref: n },
            (r = e.default) === null || r === void 0 ? void 0 : r.call(e)
          );
        }
      );
    },
  });
  function Pk(t) {
    return u.customRef((e, n) => ({
      get() {
        return e(), t;
      },
      set(r) {
        (t = r),
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              n();
            });
          });
      },
    }));
  }
  class Mh extends G_ {
    constructor(e = {}) {
      return (
        super(e),
        (this.contentComponent = null),
        (this.appContext = null),
        (this.reactiveState = Pk(this.view.state)),
        (this.reactiveExtensionStorage = Pk(this.extensionStorage)),
        this.on("beforeTransaction", ({ nextState: n }) => {
          (this.reactiveState.value = n),
            (this.reactiveExtensionStorage.value = this.extensionStorage);
        }),
        u.markRaw(this)
      );
    }
    get state() {
      return this.reactiveState ? this.reactiveState.value : this.view.state;
    }
    get storage() {
      return this.reactiveExtensionStorage
        ? this.reactiveExtensionStorage.value
        : super.storage;
    }
    registerPlugin(e, n) {
      const r = super.registerPlugin(e, n);
      return this.reactiveState && (this.reactiveState.value = r), r;
    }
    unregisterPlugin(e) {
      const n = super.unregisterPlugin(e);
      return this.reactiveState && n && (this.reactiveState.value = n), n;
    }
  }
  const $k = u.defineComponent({
      name: "EditorContent",
      props: { editor: { default: null, type: Object } },
      setup(t) {
        const e = u.ref(),
          n = u.getCurrentInstance();
        return (
          u.watchEffect(() => {
            const r = t.editor;
            r &&
              r.options.element &&
              e.value &&
              u.nextTick(() => {
                if (!e.value || !r.options.element.firstChild) return;
                const o = u.unref(e.value);
                e.value.append(...r.options.element.childNodes),
                  (r.contentComponent = n.ctx._),
                  n &&
                    (r.appContext = { ...n.appContext, provides: n.provides }),
                  r.setOptions({ element: o }),
                  r.createNodeViews();
              });
          }),
          u.onBeforeUnmount(() => {
            const r = t.editor;
            r && ((r.contentComponent = null), (r.appContext = null));
          }),
          { rootEl: e }
        );
      },
      render() {
        return u.h("div", {
          ref: (t) => {
            this.rootEl = t;
          },
        });
      },
    }),
    LR = u.defineComponent({
      name: "FloatingMenu",
      props: {
        pluginKey: { type: null, default: "floatingMenu" },
        editor: { type: Object, required: !0 },
        tippyOptions: { type: Object, default: () => ({}) },
        shouldShow: { type: Function, default: null },
      },
      setup(t, { slots: e }) {
        const n = u.ref(null);
        return (
          u.onMounted(() => {
            const {
              pluginKey: r,
              editor: o,
              tippyOptions: i,
              shouldShow: s,
            } = t;
            o.registerPlugin(
              Bk({
                pluginKey: r,
                editor: o,
                element: n.value,
                tippyOptions: i,
                shouldShow: s,
              })
            );
          }),
          u.onBeforeUnmount(() => {
            const { pluginKey: r, editor: o } = t;
            o.unregisterPlugin(r);
          }),
          () => {
            var r;
            return u.h(
              "div",
              { ref: n },
              (r = e.default) === null || r === void 0 ? void 0 : r.call(e)
            );
          }
        );
      },
    }),
    Fk = u.defineComponent({
      name: "NodeViewContent",
      props: { as: { type: String, default: "div" } },
      render() {
        return u.h(this.as, {
          style: { whiteSpace: "pre-wrap" },
          "data-node-view-content": "",
        });
      },
    }),
    Ii = u.defineComponent({
      name: "NodeViewWrapper",
      props: { as: { type: String, default: "div" } },
      inject: ["onDragStart", "decorationClasses"],
      render() {
        var t, e;
        return u.h(
          this.as,
          {
            class: this.decorationClasses,
            style: { whiteSpace: "normal" },
            "data-node-view-wrapper": "",
            onDragstart: this.onDragStart,
          },
          (e = (t = this.$slots).default) === null || e === void 0
            ? void 0
            : e.call(t)
        );
      },
    }),
    IR = (t = {}) => {
      const e = u.shallowRef();
      return (
        u.onMounted(() => {
          e.value = new Mh(t);
        }),
        u.onBeforeUnmount(() => {
          var n, r, o;
          const i =
              (n = e.value) === null || n === void 0
                ? void 0
                : n.options.element,
            s = i == null ? void 0 : i.cloneNode(!0);
          (r = i == null ? void 0 : i.parentNode) === null ||
            r === void 0 ||
            r.replaceChild(s, i),
            (o = e.value) === null || o === void 0 || o.destroy();
        }),
        e
      );
    };
  class Th {
    constructor(e, { props: n = {}, editor: r }) {
      (this.editor = r),
        (this.component = u.markRaw(e)),
        (this.el = document.createElement("div")),
        (this.props = u.reactive(n)),
        (this.renderedComponent = this.renderComponent());
    }
    get element() {
      return this.renderedComponent.el;
    }
    get ref() {
      var e, n, r, o;
      return !(
        (n =
          (e = this.renderedComponent.vNode) === null || e === void 0
            ? void 0
            : e.component) === null || n === void 0
      ) && n.exposed
        ? this.renderedComponent.vNode.component.exposed
        : (o =
            (r = this.renderedComponent.vNode) === null || r === void 0
              ? void 0
              : r.component) === null || o === void 0
        ? void 0
        : o.proxy;
    }
    renderComponent() {
      let e = u.h(this.component, this.props);
      return (
        this.editor.appContext && (e.appContext = this.editor.appContext),
        typeof document < "u" && this.el && u.render(e, this.el),
        {
          vNode: e,
          destroy: () => {
            this.el && u.render(null, this.el), (this.el = null), (e = null);
          },
          el: this.el ? this.el.firstElementChild : null,
        }
      );
    }
    updateProps(e = {}) {
      Object.entries(e).forEach(([n, r]) => {
        this.props[n] = r;
      }),
        this.renderComponent();
    }
    destroy() {
      this.renderedComponent.destroy();
    }
  }
  const BR = {
    editor: { type: Object, required: !0 },
    node: { type: Object, required: !0 },
    decorations: { type: Object, required: !0 },
    selected: { type: Boolean, required: !0 },
    extension: { type: Object, required: !0 },
    getPos: { type: Function, required: !0 },
    updateAttributes: { type: Function, required: !0 },
    deleteNode: { type: Function, required: !0 },
    view: { type: Object, required: !0 },
    innerDecorations: { type: Object, required: !0 },
    HTMLAttributes: { type: Object, required: !0 },
  };
  class PR extends J_ {
    mount() {
      const e = {
          editor: this.editor,
          node: this.node,
          decorations: this.decorations,
          innerDecorations: this.innerDecorations,
          view: this.view,
          selected: !1,
          extension: this.extension,
          HTMLAttributes: this.HTMLAttributes,
          getPos: () => this.getPos(),
          updateAttributes: (o = {}) => this.updateAttributes(o),
          deleteNode: () => this.deleteNode(),
        },
        n = this.onDragStart.bind(this);
      this.decorationClasses = u.ref(this.getDecorationClasses());
      const r = u.defineComponent({
        extends: { ...this.component },
        props: Object.keys(e),
        template: this.component.template,
        setup: (o) => {
          var i, s;
          return (
            u.provide("onDragStart", n),
            u.provide("decorationClasses", this.decorationClasses),
            (s = (i = this.component).setup) === null || s === void 0
              ? void 0
              : s.call(i, o, { expose: () => {} })
          );
        },
        __scopeId: this.component.__scopeId,
        __cssModules: this.component.__cssModules,
        __name: this.component.__name,
        __file: this.component.__file,
      });
      (this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)),
        this.editor.on("selectionUpdate", this.handleSelectionUpdate),
        (this.renderer = new Th(r, { editor: this.editor, props: e }));
    }
    get dom() {
      if (
        !this.renderer.element ||
        !this.renderer.element.hasAttribute("data-node-view-wrapper")
      )
        throw Error(
          "Please use the NodeViewWrapper component for your node view."
        );
      return this.renderer.element;
    }
    get contentDOM() {
      return this.node.isLeaf
        ? null
        : this.dom.querySelector("[data-node-view-content]");
    }
    handleSelectionUpdate() {
      const { from: e, to: n } = this.editor.state.selection,
        r = this.getPos();
      if (typeof r == "number")
        if (e <= r && n >= r + this.node.nodeSize) {
          if (this.renderer.props.selected) return;
          this.selectNode();
        } else {
          if (!this.renderer.props.selected) return;
          this.deselectNode();
        }
    }
    update(e, n, r) {
      const o = (i) => {
        (this.decorationClasses.value = this.getDecorationClasses()),
          this.renderer.updateProps(i);
      };
      if (typeof this.options.update == "function") {
        const i = this.node,
          s = this.decorations,
          a = this.innerDecorations;
        return (
          (this.node = e),
          (this.decorations = n),
          (this.innerDecorations = r),
          this.options.update({
            oldNode: i,
            oldDecorations: s,
            newNode: e,
            newDecorations: n,
            oldInnerDecorations: a,
            innerDecorations: r,
            updateProps: () =>
              o({ node: e, decorations: n, innerDecorations: r }),
          })
        );
      }
      return e.type !== this.node.type
        ? !1
        : ((e === this.node &&
            this.decorations === n &&
            this.innerDecorations === r) ||
            ((this.node = e),
            (this.decorations = n),
            (this.innerDecorations = r),
            o({ node: e, decorations: n, innerDecorations: r })),
          !0);
    }
    selectNode() {
      this.renderer.updateProps({ selected: !0 }),
        this.renderer.element &&
          this.renderer.element.classList.add("ProseMirror-selectednode");
    }
    deselectNode() {
      this.renderer.updateProps({ selected: !1 }),
        this.renderer.element &&
          this.renderer.element.classList.remove("ProseMirror-selectednode");
    }
    getDecorationClasses() {
      return this.decorations
        .map((e) => e.type.attrs.class)
        .flat()
        .join(" ");
    }
    destroy() {
      this.renderer.destroy(),
        this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    }
  }
  function Bi(t, e) {
    return (n) => {
      if (!n.editor.contentComponent) return {};
      const r = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
      return new PR(r, n, e);
    };
  }
  const Pi = [];
  class $R {
    constructor({
      editor: e,
      element: n,
      view: r,
      tippyOptions: o = {},
      shouldShow: i,
      getRenderContainer: s,
      defaultAnimation: a = !0,
    }) {
      oe(this, "editor");
      oe(this, "element");
      oe(this, "view");
      oe(this, "preventHide", !1);
      oe(this, "tippy");
      oe(this, "tippyOptions");
      oe(this, "getRenderContainer");
      oe(this, "defaultAnimation");
      oe(this, "shouldShow", ({ view: e, state: n, from: r, to: o }) => {
        const { doc: i, selection: s } = n,
          { empty: a } = s,
          l = !i.textBetween(r || 0, o || 0).length && Si(s);
        return !(!e.hasFocus() || a || l);
      });
      oe(this, "mousedownHandler", () => {
        this.preventHide = !0;
      });
      oe(this, "dragstartHandler", () => {
        this.hide();
      });
      oe(this, "blurHandler", ({ event: e }) => {
        var r, o;
        if (this.preventHide) {
          this.preventHide = !1;
          return;
        }
        (e != null &&
          e.relatedTarget &&
          (r = this.element.parentNode) != null &&
          r.contains(e.relatedTarget)) ||
          (this.editor.isEditable &&
            (o = this.shouldShow) != null &&
            o.call(this, { editor: this.editor, state: this.editor.state })) ||
          this.hide();
      });
      oe(this, "addActiveBubbleMenu", () => {
        Pi.findIndex((n) => {
          var r;
          return (
            (n == null ? void 0 : n.id) ===
            ((r = this.tippy) == null ? void 0 : r.id)
          );
        }) < 0 && Pi.push(this.tippy);
      });
      oe(this, "removeActiveBubbleMenu", () => {
        const e = Pi.findIndex((n) => {
          var r;
          return (
            (n == null ? void 0 : n.id) ===
            ((r = this.tippy) == null ? void 0 : r.id)
          );
        });
        e > -1 && Pi.splice(e, 1);
      });
      (this.editor = e),
        (this.element = n),
        (this.view = r),
        (this.getRenderContainer = s),
        (this.defaultAnimation = a),
        i && (this.shouldShow = i),
        this.element.addEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.view.dom.addEventListener("dragstart", this.dragstartHandler),
        (this.tippyOptions = o || {}),
        this.element.remove(),
        (this.element.style.visibility = "visible");
    }
    createTooltip() {
      const { element: e } = this.editor.options,
        n = !!e.parentElement;
      this.tippy ||
        !n ||
        ((this.tippy = oo(e, {
          getReferenceClientRect: null,
          content: this.element,
          interactive: !0,
          trigger: "manual",
          placement: "bottom-start",
          hideOnClick: "toggle",
          plugins: [NR],
          popperOptions: {
            modifiers: [
              {
                name: "customWidth",
                enabled: !0,
                phase: "beforeWrite",
                requires: ["computeStyles"],
                fn({ state: r }) {
                  r.styles.popper.maxWidth = "98%";
                },
              },
            ],
          },
          ...Object.assign(
            {
              zIndex: 999,
              ...(this.defaultAnimation
                ? {
                    animation: "shift-toward-subtle",
                    moveTransition: "transform 0.2s ease-in-out",
                  }
                : {}),
              fixed: !0,
            },
            this.tippyOptions
          ),
        })),
        this.tippy.popper.firstChild &&
          this.tippy.popper.firstChild.addEventListener("blur", (r) => {
            this.blurHandler({ event: r });
          }));
    }
    update(e, n) {
      var v, C, S, N, M, L;
      const { state: r, composing: o } = e,
        { doc: i, selection: s } = r,
        a = n && n.doc.eq(i) && n.selection.eq(s);
      if (o || a) return;
      const { ranges: l } = s,
        c = Math.min(...l.map(($) => $.$from.pos)),
        d = Math.max(...l.map(($) => $.$to.pos)),
        f = e.domAtPos(c).node,
        h = e.nodeDOM(c) || f;
      if (
        !(
          this.editor.isEditable &&
          ((v = this.shouldShow) == null
            ? void 0
            : v.call(this, {
                editor: this.editor,
                view: e,
                node: h,
                state: r,
                oldState: n,
                from: c,
                to: d,
              }))
        )
      ) {
        this.hide();
        return;
      }
      this.createTooltip();
      const g = s.$anchor.pos,
        b =
          (C = this.tippyOptions) != null && C.placement
            ? (S = this.tippyOptions) == null
              ? void 0
              : S.placement
            : ha(s)
            ? Pi.length > 1
              ? "bottom"
              : "top"
            : ((N = this.tippy) != null && N.props.fixed) ||
              Math.abs(g - d) <= Math.abs(g - c)
            ? "bottom-start"
            : "top-start",
        y = Pi.filter(($) => {
          var B;
          return (
            $.id !== ((B = this.tippy) == null ? void 0 : B.id) &&
            $.popperInstance &&
            $.popperInstance.state
          );
        }),
        x = (M = this.tippyOptions) == null ? void 0 : M.offset,
        w = (x == null ? void 0 : x[0]) ?? 0;
      let _ = y.length
        ? y.reduce(($, B, H, Q) => {
            var ce, Ae, Ie, xe, De, He, We, Oe, Be, pt, Je, yt, tt;
            const X = Q[H - 1]
                ? ((De =
                    (xe =
                      (Ie =
                        (Ae =
                          (ce = Q[H - 1]) == null
                            ? void 0
                            : ce.popperInstance) == null
                          ? void 0
                          : Ae.state) == null
                        ? void 0
                        : Ie.modifiersData) == null
                      ? void 0
                      : xe.popperOffsets) == null
                    ? void 0
                    : De.y) ?? 0
                : 0,
              Y =
                ((Be =
                  (Oe =
                    (We =
                      (He = B == null ? void 0 : B.popperInstance) == null
                        ? void 0
                        : He.state) == null
                      ? void 0
                      : We.modifiersData) == null
                    ? void 0
                    : Oe.popperOffsets) == null
                  ? void 0
                  : Be.y) ?? 0,
              Z =
                ((tt =
                  (yt =
                    (Je =
                      (pt = B == null ? void 0 : B.popperInstance) == null
                        ? void 0
                        : pt.state) == null
                      ? void 0
                      : Je.rects) == null
                    ? void 0
                    : yt.popper) == null
                  ? void 0
                  : tt.height) ?? 10;
            return Math.abs(X - Y) <= Z && ($ += Z), $;
          }, 0)
        : (x == null ? void 0 : x[1]) ?? 10;
      _ || (_ = 10),
        (L = this.tippy) == null ||
          L.setProps({
            offset: [w, _],
            placement: b,
            getReferenceClientRect: () => {
              let $ = null;
              return (
                ha(r.selection) &&
                  this.getRenderContainer &&
                  h &&
                  ($ = this.getRenderContainer(h)),
                this.getRenderContainer &&
                  h &&
                  ($ = this.getRenderContainer(h)),
                $ && $.getBoundingClientRect
                  ? $.getBoundingClientRect()
                  : h && h.getBoundingClientRect
                  ? h.getBoundingClientRect()
                  : Mc(e, c, d)
              );
            },
          }),
        this.show();
    }
    show() {
      var e;
      this.addActiveBubbleMenu(), (e = this.tippy) == null || e.show();
    }
    hide() {
      var e;
      this.removeActiveBubbleMenu(), (e = this.tippy) == null || e.hide();
    }
    destroy() {
      var e;
      this.removeActiveBubbleMenu(),
        (e = this.tippy) == null || e.destroy(),
        this.element.removeEventListener("mousedown", this.mousedownHandler, {
          capture: !0,
        }),
        this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    }
  }
  const FR = (t) =>
      new ie({
        key: typeof t.pluginKey == "string" ? new de(t.pluginKey) : t.pluginKey,
        view: (e) => new $R({ view: e, ...t }),
      }),
    Hk = u.defineComponent({
      __name: "BubbleMenu",
      props: {
        pluginKey: { type: [String, Object], default: "bubbleMenu" },
        editor: { type: Object, required: !0 },
        tippyOptions: { type: Object, default: () => ({}) },
        shouldShow: { type: Function, default: null },
        getRenderContainer: { type: Function, default: null },
        defaultAnimation: { type: Boolean, default: !0 },
      },
      setup(t) {
        const e = t,
          n = u.ref(null);
        return (
          u.onMounted(() => {
            const {
              editor: r,
              pluginKey: o,
              shouldShow: i,
              tippyOptions: s,
              getRenderContainer: a,
              defaultAnimation: l,
            } = e;
            r.registerPlugin(
              FR({
                editor: r,
                element: n.value,
                pluginKey: o,
                shouldShow: i,
                tippyOptions: s,
                getRenderContainer: a,
                defaultAnimation: l,
              })
            );
          }),
          u.onBeforeUnmount(() => {
            const { pluginKey: r, editor: o } = e;
            o.unregisterPlugin(r);
          }),
          (r, o) => (
            u.openBlock(),
            u.createElementBlock(
              "div",
              { ref_key: "root", ref: n },
              [u.renderSlot(r.$slots, "default")],
              512
            )
          )
        );
      },
    }),
    HR = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function zR(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        HR,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              { fill: "currentColor", d: "m7 10l5 5l5-5z" },
              null,
              -1
            ),
          ])
      )
    );
  }
  const VR = u.markRaw({ name: "mdi-menu-down", render: zR }),
    UR = ["disabled"],
    $e = u.defineComponent({
      __name: "ToolbarItem",
      props: {
        isActive: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        title: { default: void 0 },
        action: { type: Function, default: void 0 },
        icon: { default: void 0 },
        children: { default: void 0 },
      },
      setup(t) {
        return (e, n) => {
          var r;
          return u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "button",
              {
                class: u.normalizeClass([
                  [
                    { "bg-gray-200/70": e.isActive },
                    { "cursor-not-allowed opacity-70": e.disabled },
                    { "hover:bg-gray-100": !e.disabled },
                  ],
                  "inline-flex items-center space-x-1 p-1.5 rounded-md",
                ]),
                disabled: e.disabled,
                tabindex: "-1",
                onClick: n[0] || (n[0] = (...o) => e.action && e.action(...o)),
              },
              [
                (u.openBlock(),
                u.createBlock(u.resolveDynamicComponent(e.icon))),
                (r = e.children) != null && r.length
                  ? (u.openBlock(), u.createBlock(u.unref(VR), { key: 0 }))
                  : u.createCommentVNode("", !0),
              ],
              10,
              UR
            )),
            [[u.unref(us), e.title]]
          );
        };
      },
    }),
    At = u.defineComponent({
      __name: "ToolbarSubItem",
      props: {
        isActive: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        title: { default: void 0 },
        action: { type: Function, default: void 0 },
        icon: { default: void 0 },
      },
      setup(t) {
        const e = t,
          n = () => {
            var r;
            e.disabled || (r = e.action) == null || r.call(e);
          };
        return (r, o) => (
          u.openBlock(),
          u.createElementBlock(
            "div",
            {
              class: u.normalizeClass([
                [
                  { "!bg-gray-100": r.isActive },
                  { "cursor-not-allowed opacity-70 ": r.disabled },
                  { "hover:bg-gray-100": !r.disabled },
                ],
                "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer",
              ]),
              onClick: n,
            },
            [
              (u.openBlock(),
              u.createBlock(
                u.resolveDynamicComponent(r.icon),
                {
                  class: u.normalizeClass([
                    "bg-gray-100 p-1.5 rounded w-7 h-7",
                    [
                      { "!bg-white": r.isActive },
                      { "group-hover:bg-white": !r.disabled },
                    ],
                  ]),
                },
                null,
                8,
                ["class"]
              )),
              u.createElementVNode(
                "span",
                {
                  class: u.normalizeClass([
                    "text-sm text-gray-600",
                    [
                      { "!text-gray-900 !font-medium": r.isActive },
                      {
                        "group-hover:font-medium group-hover:text-gray-900":
                          !r.disabled,
                      },
                    ],
                  ]),
                },
                u.toDisplayString(r.title),
                3
              ),
            ],
            2
          )
        );
      },
    }),
    jR = { class: "flex flex-col gap-0.5" },
    WR = {
      class:
        "text-sm text-gray-600 group-hover:font-medium group-hover:text-gray-900",
    },
    qR = { key: 0, class: "text-xs text-gray-500" },
    io = u.defineComponent({
      __name: "ToolboxItem",
      props: {
        editor: { default: void 0 },
        title: { default: void 0 },
        description: { default: void 0 },
        action: { type: Function, default: void 0 },
        icon: { default: void 0 },
      },
      setup(t) {
        const e = t,
          n = () => {
            var r;
            (r = e.action) == null || r.call(e);
          };
        return (r, o) => (
          u.openBlock(),
          u.createElementBlock(
            "div",
            {
              class:
                "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer hover:bg-gray-100",
              onClick: n,
            },
            [
              (u.openBlock(),
              u.createBlock(u.resolveDynamicComponent(r.icon), {
                class: "bg-gray-100 p-1.5 rounded w-7 h-7 group-hover:bg-white",
              })),
              u.createElementVNode("div", jR, [
                u.createElementVNode("span", WR, u.toDisplayString(r.title), 1),
                r.description
                  ? (u.openBlock(),
                    u.createElementBlock(
                      "span",
                      qR,
                      u.toDisplayString(r.description),
                      1
                    ))
                  : u.createCommentVNode("", !0),
              ]),
            ]
          )
        );
      },
    }),
    KR = {
      class:
        "bubble-menu bg-white flex items-center rounded-md p-1 border shadow space-x-1",
    },
    GR = Pd(
      u.defineComponent({
        __name: "EditorBubbleMenu",
        props: { editor: { type: Object, required: !0 } },
        setup(t) {
          const e = t,
            n = () => {
              var i;
              return (
                (i = e.editor) == null ? void 0 : i.extensionManager
              ).extensions
                .map((s) => {
                  const { getBubbleMenu: a } = s.options;
                  if (!a) return null;
                  const l = a({ editor: e.editor });
                  return (
                    l.items &&
                      (l.items = l.items.sort(
                        (c, d) => c.priority - d.priority
                      )),
                    l
                  );
                })
                .filter(Boolean);
            },
            r = (o, i) => {
              var s;
              return o.editor.isEditable
                ? (s = i.shouldShow) == null
                  ? void 0
                  : s.call(i, o)
                : !1;
            };
          return (o, i) => (
            u.openBlock(!0),
            u.createElementBlock(
              u.Fragment,
              null,
              u.renderList(
                n(),
                (s, a) => (
                  u.openBlock(),
                  u.createBlock(
                    Hk,
                    {
                      key: a,
                      "plugin-key": s == null ? void 0 : s.pluginKey,
                      "should-show": (l) => r(l, s),
                      editor: t.editor,
                      "tippy-options": { maxWidth: "100%", ...s.tippyOptions },
                      "get-render-container": s.getRenderContainer,
                      "default-animation": s.defaultAnimation,
                    },
                    {
                      default: u.withCtx(() => [
                        u.createElementVNode("div", KR, [
                          s.items
                            ? (u.openBlock(!0),
                              u.createElementBlock(
                                u.Fragment,
                                { key: 0 },
                                u.renderList(
                                  s.items,
                                  (l, c) => (
                                    u.openBlock(),
                                    u.createElementBlock(
                                      u.Fragment,
                                      { key: c },
                                      [
                                        l.component
                                          ? (u.openBlock(),
                                            u.createBlock(
                                              u.resolveDynamicComponent(
                                                l.component
                                              ),
                                              u.mergeProps(
                                                { key: 0, ref_for: !0 },
                                                l.props,
                                                { editor: t.editor }
                                              ),
                                              null,
                                              16,
                                              ["editor"]
                                            ))
                                          : (u.openBlock(),
                                            u.createBlock(
                                              bl,
                                              u.mergeProps(
                                                {
                                                  key: 1,
                                                  editor: t.editor,
                                                  ref_for: !0,
                                                },
                                                l.props
                                              ),
                                              null,
                                              16,
                                              ["editor"]
                                            )),
                                      ],
                                      64
                                    )
                                  )
                                ),
                                128
                              ))
                            : s.component
                            ? (u.openBlock(),
                              u.createBlock(
                                u.resolveDynamicComponent(
                                  s == null ? void 0 : s.component
                                ),
                                { key: 1, editor: t.editor },
                                null,
                                8,
                                ["editor"]
                              ))
                            : u.createCommentVNode("", !0),
                        ]),
                      ]),
                      _: 2,
                    },
                    1032,
                    [
                      "plugin-key",
                      "should-show",
                      "editor",
                      "tippy-options",
                      "get-render-container",
                      "default-animation",
                    ]
                  )
                )
              ),
              128
            )
          );
        },
      }),
      [["__scopeId", "data-v-c5e57b44"]]
    ),
    JR = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function YR(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        JR,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4m-5-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const XR = u.markRaw({ name: "mdi-plus-circle", render: YR }),
    ZR = {
      class:
        "editor-header py-1 space-x-1 px-1 overflow-auto border-t shadow-sm bg-white text-center",
    },
    QR = { class: "h-full inline-flex items-center" },
    e9 = { class: "p-1.5 rounded-md hover:bg-gray-100", tabindex: "-1" },
    t9 = {
      class:
        "relative rounded-md bg-white overflow-hidden shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5",
    },
    n9 = {
      class:
        "relative rounded-md bg-white overflow-hidden shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5",
    },
    r9 = u.defineComponent({
      __name: "EditorHeader",
      props: { editor: { type: Mh, required: !0 } },
      setup(t) {
        const e = t;
        function n() {
          var i;
          return (
            (i = e.editor) == null ? void 0 : i.extensionManager
          ).extensions
            .reduce((s, a) => {
              const { getToolbarItems: l } = a.options;
              if (!l) return s;
              const c = l({ editor: e.editor });
              return Array.isArray(c) ? [...s, ...c] : [...s, c];
            }, [])
            .sort((s, a) => s.priority - a.priority);
        }
        function r() {
          var i;
          return (
            (i = e.editor) == null ? void 0 : i.extensionManager
          ).extensions
            .reduce((s, a) => {
              const { getToolboxItems: l } = a.options;
              if (!l) return s;
              const c = l({ editor: e.editor });
              return Array.isArray(c) ? [...s, ...c] : [...s, c];
            }, [])
            .sort((s, a) => s.priority - a.priority);
        }
        return (o, i) => (
          u.openBlock(),
          u.createElementBlock("div", ZR, [
            u.createElementVNode("div", QR, [
              u.createVNode(u.unref(vo), null, {
                popper: u.withCtx(() => [
                  u.createElementVNode("div", t9, [
                    (u.openBlock(!0),
                    u.createElementBlock(
                      u.Fragment,
                      null,
                      u.renderList(
                        r(),
                        (s, a) => (
                          u.openBlock(),
                          u.createBlock(
                            u.resolveDynamicComponent(s.component),
                            u.mergeProps({ ref_for: !0 }, s.props, {
                              key: a,
                              tabindex: "-1",
                            }),
                            null,
                            16
                          )
                        )
                      ),
                      128
                    )),
                  ]),
                ]),
                default: u.withCtx(() => [
                  u.createElementVNode("button", e9, [
                    u.createVNode(u.unref(XR), { class: "text-[#4CCBA0]" }),
                  ]),
                ]),
                _: 1,
              }),
              i[0] ||
                (i[0] = u.createElementVNode(
                  "div",
                  { class: "h-5 bg-gray-100 w-[1px] !mx-1" },
                  null,
                  -1
                )),
              (u.openBlock(!0),
              u.createElementBlock(
                u.Fragment,
                null,
                u.renderList(n(), (s, a) => {
                  var l;
                  return (
                    u.openBlock(),
                    u.createElementBlock("div", { key: a }, [
                      (l = s.children) != null && l.length
                        ? (u.openBlock(),
                          u.createBlock(
                            u.unref(vo),
                            {
                              key: 1,
                              class: "inline-flex",
                              tabindex: "-1",
                              triggers: ["click"],
                              "popper-triggers": ["click"],
                            },
                            {
                              popper: u.withCtx(() => [
                                u.createElementVNode("div", n9, [
                                  (u.openBlock(!0),
                                  u.createElementBlock(
                                    u.Fragment,
                                    null,
                                    u.renderList(
                                      s.children,
                                      (c, d) => (
                                        u.openBlock(),
                                        u.createBlock(
                                          u.resolveDynamicComponent(
                                            c.component
                                          ),
                                          u.mergeProps(
                                            { ref_for: !0 },
                                            c.props,
                                            { key: d, tabindex: "-1" }
                                          ),
                                          null,
                                          16
                                        )
                                      )
                                    ),
                                    128
                                  )),
                                ]),
                              ]),
                              default: u.withCtx(() => [
                                (u.openBlock(),
                                u.createBlock(
                                  u.resolveDynamicComponent(s.component),
                                  u.mergeProps({ ref_for: !0 }, s.props, {
                                    children: s.children,
                                    tabindex: "-1",
                                  }),
                                  null,
                                  16,
                                  ["children"]
                                )),
                              ]),
                              _: 2,
                            },
                            1024
                          ))
                        : (u.openBlock(),
                          u.createBlock(
                            u.resolveDynamicComponent(s.component),
                            u.mergeProps({ key: 0, ref_for: !0 }, s.props, {
                              tabindex: "-1",
                            }),
                            null,
                            16
                          )),
                    ])
                  );
                }),
                128
              )),
            ]),
          ])
        );
      },
    }),
    o9 = { key: 0, class: "halo-rich-text-editor flex flex-col" },
    i9 = { class: "overflow-y-auto flex-1 min-h-0 shrink bg-white relative" },
    s9 = { key: 0, class: "editor-header-extra" },
    a9 = { class: "flex-none" },
    zk = u.defineComponent({
      __name: "Editor",
      props: {
        editor: { type: Object, required: !0 },
        contentStyles: { type: Object, required: !1, default: () => ({}) },
        locale: { type: String, required: !1, default: "zh-CN" },
      },
      setup(t) {
        const e = t;
        return (
          u.watch(
            () => e.locale,
            () => {
              T.global.locale.value = e.locale;
            },
            { immediate: !0 }
          ),
          (n, r) =>
            t.editor
              ? (u.openBlock(),
                u.createElementBlock("div", o9, [
                  u.createVNode(GR, { editor: t.editor }, null, 8, ["editor"]),
                  u.createElementVNode("div", i9, [
                    n.$slots.content
                      ? (u.openBlock(),
                        u.createElementBlock("div", s9, [
                          u.renderSlot(n.$slots, "content"),
                        ]))
                      : u.createCommentVNode("", !0),
                    u.createVNode(
                      u.unref($k),
                      {
                        editor: t.editor,
                        style: u.normalizeStyle(t.contentStyles),
                        class: "editor-content markdown-body relative",
                      },
                      null,
                      8,
                      ["editor", "style"]
                    ),
                  ]),
                  u.createElementVNode("div", a9, [
                    u.createVNode(r9, { editor: t.editor }, null, 8, [
                      "editor",
                    ]),
                  ]),
                ]))
              : u.createCommentVNode("", !0)
        );
      },
    }),
    Vk = Pe.create({ name: "doc", topNode: !0, content: "block+" }),
    Uk = we.create({
      name: "dropCursor",
      addOptions() {
        return { color: "currentColor", width: 1, class: void 0 };
      },
      addProseMirrorPlugins() {
        return [Jg(this.options)];
      },
    }),
    jk = Pe.create({
      name: "hardBreak",
      addOptions() {
        return { keepMarks: !0, HTMLAttributes: {} };
      },
      inline: !0,
      group: "inline",
      selectable: !1,
      linebreakReplacement: !0,
      parseHTML() {
        return [{ tag: "br" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["br", se(this.options.HTMLAttributes, t)];
      },
      renderText() {
        return `
`;
      },
      addCommands() {
        return {
          setHardBreak:
            () =>
            ({ commands: t, chain: e, state: n, editor: r }) =>
              t.first([
                () => t.exitCode(),
                () =>
                  t.command(() => {
                    const { selection: o, storedMarks: i } = n;
                    if (o.$from.parent.type.spec.isolating) return !1;
                    const { keepMarks: s } = this.options,
                      { splittableMarks: a } = r.extensionManager,
                      l = i || (o.$to.parentOffset && o.$from.marks());
                    return e()
                      .insertContent({ type: this.name })
                      .command(({ tr: c, dispatch: d }) => {
                        if (d && l && s) {
                          const f = l.filter((p) => a.includes(p.type.name));
                          c.ensureMarks(f);
                        }
                        return !0;
                      })
                      .run();
                  }),
              ]),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak(),
        };
      },
    }),
    Wk = Pe.create({
      name: "horizontalRule",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["hr", se(this.options.HTMLAttributes, t)];
      },
      addCommands() {
        return {
          setHorizontalRule:
            () =>
            ({ chain: t, state: e }) => {
              const { selection: n } = e,
                { $from: r, $to: o } = n,
                i = t();
              return (
                r.parentOffset === 0
                  ? i.insertContentAt(
                      { from: Math.max(r.pos - 1, 0), to: o.pos },
                      { type: this.name }
                    )
                  : ha(n)
                  ? i.insertContentAt(o.pos, { type: this.name })
                  : i.insertContent({ type: this.name }),
                i
                  .command(({ tr: s, dispatch: a }) => {
                    var l;
                    if (a) {
                      const { $to: c } = s.selection,
                        d = c.end();
                      if (c.nodeAfter)
                        c.nodeAfter.isTextblock
                          ? s.setSelection(U.create(s.doc, c.pos + 1))
                          : c.nodeAfter.isBlock
                          ? s.setSelection(K.create(s.doc, c.pos))
                          : s.setSelection(U.create(s.doc, c.pos));
                      else {
                        const f =
                          (l = c.parent.type.contentMatch.defaultType) ===
                            null || l === void 0
                            ? void 0
                            : l.create();
                        f &&
                          (s.insert(d, f),
                          s.setSelection(U.create(s.doc, d + 1)));
                      }
                      s.scrollIntoView();
                    }
                    return !0;
                  })
                  .run()
              );
            },
        };
      },
      addInputRules() {
        return [Ti({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })];
      },
    }),
    qk = we.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something …",
          showOnlyWhenEditable: !0,
          showOnlyCurrent: !0,
          includeChildren: !1,
        };
      },
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("placeholder"),
            props: {
              decorations: ({ doc: t, selection: e }) => {
                const n =
                    this.editor.isEditable ||
                    !this.options.showOnlyWhenEditable,
                  { anchor: r } = e,
                  o = [];
                if (!n) return null;
                const i = this.editor.isEmpty;
                return (
                  t.descendants((s, a) => {
                    const l = r >= a && r <= a + s.nodeSize,
                      c = !s.isLeaf && pa(s);
                    if ((l || !this.options.showOnlyCurrent) && c) {
                      const d = [this.options.emptyNodeClass];
                      i && d.push(this.options.emptyEditorClass);
                      const f = Te.node(a, a + s.nodeSize, {
                        class: d.join(" "),
                        "data-placeholder":
                          typeof this.options.placeholder == "function"
                            ? this.options.placeholder({
                                editor: this.editor,
                                node: s,
                                pos: a,
                                hasAnchor: l,
                              })
                            : this.options.placeholder,
                      });
                      o.push(f);
                    }
                    return this.options.includeChildren;
                  }),
                  ue.create(t, o)
                );
              },
            },
          }),
        ];
      },
    }),
    l9 = /^\s*>\s$/,
    c9 = Pe.create({
      name: "blockquote",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      content: "block+",
      group: "block",
      defining: !0,
      parseHTML() {
        return [{ tag: "blockquote" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["blockquote", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setBlockquote:
            () =>
            ({ commands: t }) =>
              t.wrapIn(this.name),
          toggleBlockquote:
            () =>
            ({ commands: t }) =>
              t.toggleWrap(this.name),
          unsetBlockquote:
            () =>
            ({ commands: t }) =>
              t.lift(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() };
      },
      addInputRules() {
        return [Wo({ find: l9, type: this.type })];
      },
    }),
    u9 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function d9(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        u9,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m10 7l-2 4h3v6H5v-6l2-4zm8 0l-2 4h3v6h-6v-6l2-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const f9 = u.markRaw({ name: "mdi-format-quote-open", render: d9 }),
    Kk = c9.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 90,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("blockquote"),
                icon: u.markRaw(f9),
                title: T.global.t("editor.common.quote"),
                action: () => {
                  e.commands.toggleBlockquote();
                },
              },
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && n.parentElement && n.tagName !== "BLOCKQUOTE"; )
                  n = n.parentElement;
                return { el: n };
              },
            };
          },
        };
      },
    }),
    p9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
    h9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
    m9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
    g9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
    b9 = vt.create({
      name: "bold",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "strong" },
          {
            tag: "b",
            getAttrs: (t) => t.style.fontWeight !== "normal" && null,
          },
          {
            style: "font-weight=400",
            clearMark: (t) => t.type.name === this.name,
          },
          {
            style: "font-weight",
            getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["strong", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setBold:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleBold:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetBold:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold(),
        };
      },
      addInputRules() {
        return [
          no({ find: p9, type: this.type }),
          no({ find: m9, type: this.type }),
        ];
      },
      addPasteRules() {
        return [
          yr({ find: h9, type: this.type }),
          yr({ find: g9, type: this.type }),
        ];
      },
    }),
    y9 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function _9(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        y9,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13.5 15.5H10v-3h3.5A1.5 1.5 0 0 1 15 14a1.5 1.5 0 0 1-1.5 1.5m-3.5-9h3A1.5 1.5 0 0 1 14.5 8A1.5 1.5 0 0 1 13 9.5h-3m5.6 1.29c.97-.68 1.65-1.79 1.65-2.79c0-2.26-1.75-4-4-4H7v14h7.04c2.1 0 3.71-1.7 3.71-3.79c0-1.52-.86-2.82-2.15-3.42",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Gk = u.markRaw({ name: "mdi-format-bold", render: _9 }),
    Jk = b9.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 40,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("bold"),
                icon: u.markRaw(Gk),
                title: T.global.t("editor.common.bold"),
                action: () => {
                  e.chain().focus().toggleBold().run();
                },
              },
            };
          },
        };
      },
    }),
    k9 = "listItem",
    Yk = "textStyle",
    Xk = /^\s*([-+*])\s$/,
    w9 = Pe.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: !1,
          keepAttributes: !1,
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [{ tag: "ul" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["ul", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          toggleBulletList:
            () =>
            ({ commands: t, chain: e }) =>
              this.options.keepAttributes
                ? e()
                    .toggleList(
                      this.name,
                      this.options.itemTypeName,
                      this.options.keepMarks
                    )
                    .updateAttributes(k9, this.editor.getAttributes(Yk))
                    .run()
                : t.toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  ),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() };
      },
      addInputRules() {
        let t = Wo({ find: Xk, type: this.type });
        return (
          (this.options.keepMarks || this.options.keepAttributes) &&
            (t = Wo({
              find: Xk,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: () => this.editor.getAttributes(Yk),
              editor: this.editor,
            })),
          [t]
        );
      },
    }),
    Zk = Pe.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList",
        };
      },
      content: "paragraph block*",
      defining: !0,
      parseHTML() {
        return [{ tag: "li" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["li", se(this.options.HTMLAttributes, t), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
        };
      },
    }),
    x9 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function C9(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        x9,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M7 5h14v2H7zm0 8v-2h14v2zM4 4.5A1.5 1.5 0 0 1 5.5 6A1.5 1.5 0 0 1 4 7.5A1.5 1.5 0 0 1 2.5 6A1.5 1.5 0 0 1 4 4.5m0 6A1.5 1.5 0 0 1 5.5 12A1.5 1.5 0 0 1 4 13.5A1.5 1.5 0 0 1 2.5 12A1.5 1.5 0 0 1 4 10.5M7 19v-2h14v2zm-3-2.5A1.5 1.5 0 0 1 5.5 18A1.5 1.5 0 0 1 4 19.5A1.5 1.5 0 0 1 2.5 18A1.5 1.5 0 0 1 4 16.5",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Qk = u.markRaw({ name: "mdi-format-list-bulleted", render: C9 }),
    e3 = w9.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 130,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("bulletList"),
                icon: u.markRaw(Qk),
                title: T.global.t("editor.common.bullet_list"),
                action: () => e.chain().focus().toggleBulletList().run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 130,
              icon: u.markRaw(Qk),
              title: "editor.common.bullet_list",
              keywords: ["bulletlist", "wuxuliebiao"],
              command: ({ editor: e, range: n }) => {
                e.chain().focus().deleteRange(n).toggleBulletList().run();
              },
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && n.tagName !== "LI"; ) n = n.parentElement;
                return { el: n, dragDomOffset: { x: -12 } };
              },
            };
          },
        };
      },
      addExtensions() {
        return [Zk];
      },
    }),
    v9 = /(^|[^`])`([^`]+)`(?!`)/,
    E9 = /(^|[^`])`([^`]+)`(?!`)/g,
    A9 = vt.create({
      name: "code",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      excludes: "_",
      code: !0,
      exitable: !0,
      parseHTML() {
        return [{ tag: "code" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["code", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setCode:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleCode:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetCode:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-e": () => this.editor.commands.toggleCode() };
      },
      addInputRules() {
        return [no({ find: v9, type: this.type })];
      },
      addPasteRules() {
        return [yr({ find: E9, type: this.type })];
      },
    }),
    S9 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function M9(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        S9,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m14.6 16.6l4.6-4.6l-4.6-4.6L16 6l6 6l-6 6zm-5.2 0L4.8 12l4.6-4.6L8 6l-6 6l6 6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const t3 = u.markRaw({ name: "mdi-code-tags", render: M9 }),
    n3 = A9.extend({
      exitable: !0,
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 100,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("code"),
                icon: u.markRaw(t3),
                title: T.global.t("editor.common.code"),
                action: () => e.chain().focus().toggleCode().run(),
              },
            };
          },
        };
      },
    }),
    T9 = (t) => {
      if (!t.children.length) return;
      const e = t.querySelectorAll("span");
      e &&
        e.forEach((n) => {
          var r, o;
          const i = n.getAttribute("style"),
            s =
              (o =
                (r = n.parentElement) === null || r === void 0
                  ? void 0
                  : r.closest("span")) === null || o === void 0
                ? void 0
                : o.getAttribute("style");
          n.setAttribute("style", `${s};${i}`);
        });
    },
    N9 = vt.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return { HTMLAttributes: {}, mergeNestedSpanStyles: !1 };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (t) =>
              t.hasAttribute("style")
                ? (this.options.mergeNestedSpanStyles && T9(t), {})
                : !1,
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["span", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle:
            () =>
            ({ tr: t }) => {
              const { selection: e } = t;
              return (
                t.doc.nodesBetween(e.from, e.to, (n, r) => {
                  if (n.isTextblock) return !0;
                  n.marks
                    .filter((o) => o.type === this.type)
                    .some((o) => Object.values(o.attrs).some((i) => !!i)) ||
                    t.removeMark(r, r + n.nodeSize, this.type);
                }),
                !0
              );
            },
        };
      },
    }),
    O9 = we.create({
      name: "color",
      addOptions() {
        return { types: ["textStyle"] };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (t) => {
                  var e;
                  return (e = t.style.color) === null || e === void 0
                    ? void 0
                    : e.replace(/['"]+/g, "");
                },
                renderHTML: (t) =>
                  t.color ? { style: `color: ${t.color}` } : {},
              },
            },
          },
        ];
      },
      addCommands() {
        return {
          setColor:
            (t) =>
            ({ chain: e }) =>
              e().setMark("textStyle", { color: t }).run(),
          unsetColor:
            () =>
            ({ chain: t }) =>
              t()
                .setMark("textStyle", { color: null })
                .removeEmptyTextStyle()
                .run(),
        };
      },
    }),
    Nh = N9.extend({ priority: 110 }),
    R9 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function D9(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        R9,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                d: "M9.624 11.998L12 5.665l2.375 6.333m-3.375-9l-5.5 14h2.25l1.125-3h6.25l1.125 3h2.25l-5.5-14h-2z",
                fill: "currentColor",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const r3 = u.markRaw({ name: "mdi-format-color", render: D9 }),
    L9 = "";
  function $i(t, e) {
    e === void 0 && (e = {});
    var n = e.insertAt;
    if (!(!t || typeof document > "u")) {
      var r = document.head || document.getElementsByTagName("head")[0],
        o = document.createElement("style");
      (o.type = "text/css"),
        n === "top" && r.firstChild
          ? r.insertBefore(o, r.firstChild)
          : r.appendChild(o),
        o.styleSheet
          ? (o.styleSheet.cssText = t)
          : o.appendChild(document.createTextNode(t));
    }
  }
  const Fi = function (t, e) {
      const { componentPrefix: n = L9 } = e || {};
      t.component(`${n}${this.name}`, this);
    },
    Oh = {};
  var Ca = {
    name: "Checkboard",
    props: {
      size: { type: [Number, String], default: 8 },
      white: { type: String, default: "#fff" },
      grey: { type: String, default: "#e6e6e6" },
    },
    computed: {
      bgStyle() {
        return {
          "background-image": `url(${B9(this.white, this.grey, this.size)})`,
        };
      },
    },
  };
  function I9(t, e, n) {
    if (typeof document > "u") return null;
    const r = document.createElement("canvas");
    r.width = r.height = n * 2;
    const o = r.getContext("2d");
    return o
      ? ((o.fillStyle = t),
        o.fillRect(0, 0, r.width, r.height),
        (o.fillStyle = e),
        o.fillRect(0, 0, n, n),
        o.translate(n, n),
        o.fillRect(0, 0, n, n),
        r.toDataURL())
      : null;
  }
  function B9(t, e, n) {
    const r = `${t},${e},${n}`;
    if (Oh[r]) return Oh[r];
    const o = I9(t, e, n);
    return (Oh[r] = o), o;
  }
  function P9(t, e, n, r, o, i) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        { class: "vc-checkerboard", style: u.normalizeStyle(i.bgStyle) },
        null,
        4
      )
    );
  }
  var $9 =
    ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
  $i($9),
    (Ca.render = P9),
    (Ca.__file = "src/components/checkboard/checkboard.vue"),
    (Ca.install = Fi);
  var Pc = {
    name: "Alpha",
    components: { Checkboard: Ca },
    props: { value: Object, onChange: Function },
    computed: {
      colors() {
        return this.value;
      },
      gradientColor() {
        const { rgba: t } = this.colors,
          e = [t.r, t.g, t.b].join(",");
        return `linear-gradient(to right, rgba(${e}, 0) 0%, rgba(${e}, 1) 100%)`;
      },
    },
    methods: {
      handleChange(t, e) {
        !e && t.preventDefault();
        const { container: n } = this.$refs;
        if (!n) return;
        const r = n.clientWidth,
          o = n.getBoundingClientRect().left + window.pageXOffset,
          s = (t.pageX || (t.touches ? t.touches[0].pageX : 0)) - o;
        let a;
        s < 0
          ? (a = 0)
          : s > r
          ? (a = 1)
          : (a = Math.round((s * 100) / r) / 100),
          this.colors.a !== a &&
            this.$emit("change", {
              h: this.colors.hsl.h,
              s: this.colors.hsl.s,
              l: this.colors.hsl.l,
              a,
              source: "rgba",
            });
      },
      handleMouseDown(t) {
        this.handleChange(t, !0),
          window.addEventListener("mousemove", this.handleChange),
          window.addEventListener("mouseup", this.handleMouseUp);
      },
      handleMouseUp() {
        this.unbindEventListeners();
      },
      unbindEventListeners() {
        window.removeEventListener("mousemove", this.handleChange),
          window.removeEventListener("mouseup", this.handleMouseUp);
      },
    },
  };
  const F9 = { class: "vc-alpha" },
    H9 = { class: "vc-alpha-checkboard-wrap" },
    z9 = [u.createElementVNode("div", { class: "vc-alpha-picker" }, null, -1)];
  function V9(t, e, n, r, o, i) {
    const s = u.resolveComponent("Checkboard");
    return (
      u.openBlock(),
      u.createElementBlock("div", F9, [
        u.createElementVNode("div", H9, [u.createVNode(s)]),
        u.createElementVNode(
          "div",
          {
            class: "vc-alpha-gradient",
            style: u.normalizeStyle({ background: i.gradientColor }),
          },
          null,
          4
        ),
        u.createElementVNode(
          "div",
          {
            ref: "container",
            class: "vc-alpha-container",
            onMousedown:
              e[0] ||
              (e[0] = (...a) => i.handleMouseDown && i.handleMouseDown(...a)),
            onTouchmove:
              e[1] || (e[1] = (...a) => i.handleChange && i.handleChange(...a)),
            onTouchstart:
              e[2] || (e[2] = (...a) => i.handleChange && i.handleChange(...a)),
          },
          [
            u.createElementVNode(
              "div",
              {
                class: "vc-alpha-pointer",
                style: u.normalizeStyle({ left: `${i.colors.a * 100}%` }),
              },
              z9,
              4
            ),
          ],
          544
        ),
      ])
    );
  }
  var U9 =
    ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
  $i(U9),
    (Pc.render = V9),
    (Pc.__file = "src/components/alpha/alpha.vue"),
    (Pc.install = Fi);
  function ut(t, e) {
    j9(t) && (t = "100%");
    var n = W9(t);
    return (
      (t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t)))),
      n && (t = parseInt(String(t * e), 10) / 100),
      Math.abs(t - e) < 1e-6
        ? 1
        : (e === 360
            ? (t = (t < 0 ? (t % e) + e : t % e) / parseFloat(String(e)))
            : (t = (t % e) / parseFloat(String(e))),
          t)
    );
  }
  function $c(t) {
    return Math.min(1, Math.max(0, t));
  }
  function j9(t) {
    return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
  }
  function W9(t) {
    return typeof t == "string" && t.indexOf("%") !== -1;
  }
  function o3(t) {
    return (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
  }
  function Fc(t) {
    return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
  }
  function Jo(t) {
    return t.length === 1 ? "0" + t : String(t);
  }
  function q9(t, e, n) {
    return { r: ut(t, 255) * 255, g: ut(e, 255) * 255, b: ut(n, 255) * 255 };
  }
  function i3(t, e, n) {
    (t = ut(t, 255)), (e = ut(e, 255)), (n = ut(n, 255));
    var r = Math.max(t, e, n),
      o = Math.min(t, e, n),
      i = 0,
      s = 0,
      a = (r + o) / 2;
    if (r === o) (s = 0), (i = 0);
    else {
      var l = r - o;
      switch (((s = a > 0.5 ? l / (2 - r - o) : l / (r + o)), r)) {
        case t:
          i = (e - n) / l + (e < n ? 6 : 0);
          break;
        case e:
          i = (n - t) / l + 2;
          break;
        case n:
          i = (t - e) / l + 4;
          break;
      }
      i /= 6;
    }
    return { h: i, s, l: a };
  }
  function Rh(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 0.16666666666666666
        ? t + (e - t) * (6 * n)
        : n < 0.5
        ? e
        : n < 0.6666666666666666
        ? t + (e - t) * (0.6666666666666666 - n) * 6
        : t
    );
  }
  function K9(t, e, n) {
    var r, o, i;
    if (((t = ut(t, 360)), (e = ut(e, 100)), (n = ut(n, 100)), e === 0))
      (o = n), (i = n), (r = n);
    else {
      var s = n < 0.5 ? n * (1 + e) : n + e - n * e,
        a = 2 * n - s;
      (r = Rh(a, s, t + 0.3333333333333333)),
        (o = Rh(a, s, t)),
        (i = Rh(a, s, t - 0.3333333333333333));
    }
    return { r: r * 255, g: o * 255, b: i * 255 };
  }
  function s3(t, e, n) {
    (t = ut(t, 255)), (e = ut(e, 255)), (n = ut(n, 255));
    var r = Math.max(t, e, n),
      o = Math.min(t, e, n),
      i = 0,
      s = r,
      a = r - o,
      l = r === 0 ? 0 : a / r;
    if (r === o) i = 0;
    else {
      switch (r) {
        case t:
          i = (e - n) / a + (e < n ? 6 : 0);
          break;
        case e:
          i = (n - t) / a + 2;
          break;
        case n:
          i = (t - e) / a + 4;
          break;
      }
      i /= 6;
    }
    return { h: i, s: l, v: s };
  }
  function G9(t, e, n) {
    (t = ut(t, 360) * 6), (e = ut(e, 100)), (n = ut(n, 100));
    var r = Math.floor(t),
      o = t - r,
      i = n * (1 - e),
      s = n * (1 - o * e),
      a = n * (1 - (1 - o) * e),
      l = r % 6,
      c = [n, s, i, i, a, n][l],
      d = [a, n, n, s, i, i][l],
      f = [i, i, a, n, n, s][l];
    return { r: c * 255, g: d * 255, b: f * 255 };
  }
  function a3(t, e, n, r) {
    var o = [
      Jo(Math.round(t).toString(16)),
      Jo(Math.round(e).toString(16)),
      Jo(Math.round(n).toString(16)),
    ];
    return r &&
      o[0].startsWith(o[0].charAt(1)) &&
      o[1].startsWith(o[1].charAt(1)) &&
      o[2].startsWith(o[2].charAt(1))
      ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0)
      : o.join("");
  }
  function J9(t, e, n, r, o) {
    var i = [
      Jo(Math.round(t).toString(16)),
      Jo(Math.round(e).toString(16)),
      Jo(Math.round(n).toString(16)),
      Jo(Y9(r)),
    ];
    return o &&
      i[0].startsWith(i[0].charAt(1)) &&
      i[1].startsWith(i[1].charAt(1)) &&
      i[2].startsWith(i[2].charAt(1)) &&
      i[3].startsWith(i[3].charAt(1))
      ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0)
      : i.join("");
  }
  function Y9(t) {
    return Math.round(parseFloat(t) * 255).toString(16);
  }
  function l3(t) {
    return Wt(t) / 255;
  }
  function Wt(t) {
    return parseInt(t, 16);
  }
  function X9(t) {
    return { r: t >> 16, g: (t & 65280) >> 8, b: t & 255 };
  }
  var Dh = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32",
  };
  function Z9(t) {
    var e = { r: 0, g: 0, b: 0 },
      n = 1,
      r = null,
      o = null,
      i = null,
      s = !1,
      a = !1;
    return (
      typeof t == "string" && (t = tD(t)),
      typeof t == "object" &&
        (kr(t.r) && kr(t.g) && kr(t.b)
          ? ((e = q9(t.r, t.g, t.b)),
            (s = !0),
            (a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb"))
          : kr(t.h) && kr(t.s) && kr(t.v)
          ? ((r = Fc(t.s)),
            (o = Fc(t.v)),
            (e = G9(t.h, r, o)),
            (s = !0),
            (a = "hsv"))
          : kr(t.h) &&
            kr(t.s) &&
            kr(t.l) &&
            ((r = Fc(t.s)),
            (i = Fc(t.l)),
            (e = K9(t.h, r, i)),
            (s = !0),
            (a = "hsl")),
        Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)),
      (n = o3(n)),
      {
        ok: s,
        format: t.format || a,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: n,
      }
    );
  }
  var Q9 = "[-\\+]?\\d+%?",
    eD = "[-\\+]?\\d*\\.\\d+%?",
    so = "(?:".concat(eD, ")|(?:").concat(Q9, ")"),
    Lh = "[\\s|\\(]+("
      .concat(so, ")[,|\\s]+(")
      .concat(so, ")[,|\\s]+(")
      .concat(so, ")\\s*\\)?"),
    Ih = "[\\s|\\(]+("
      .concat(so, ")[,|\\s]+(")
      .concat(so, ")[,|\\s]+(")
      .concat(so, ")[,|\\s]+(")
      .concat(so, ")\\s*\\)?"),
    On = {
      CSS_UNIT: new RegExp(so),
      rgb: new RegExp("rgb" + Lh),
      rgba: new RegExp("rgba" + Ih),
      hsl: new RegExp("hsl" + Lh),
      hsla: new RegExp("hsla" + Ih),
      hsv: new RegExp("hsv" + Lh),
      hsva: new RegExp("hsva" + Ih),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    };
  function tD(t) {
    if (((t = t.trim().toLowerCase()), t.length === 0)) return !1;
    var e = !1;
    if (Dh[t]) (t = Dh[t]), (e = !0);
    else if (t === "transparent")
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    var n = On.rgb.exec(t);
    return n
      ? { r: n[1], g: n[2], b: n[3] }
      : ((n = On.rgba.exec(t)),
        n
          ? { r: n[1], g: n[2], b: n[3], a: n[4] }
          : ((n = On.hsl.exec(t)),
            n
              ? { h: n[1], s: n[2], l: n[3] }
              : ((n = On.hsla.exec(t)),
                n
                  ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                  : ((n = On.hsv.exec(t)),
                    n
                      ? { h: n[1], s: n[2], v: n[3] }
                      : ((n = On.hsva.exec(t)),
                        n
                          ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                          : ((n = On.hex8.exec(t)),
                            n
                              ? {
                                  r: Wt(n[1]),
                                  g: Wt(n[2]),
                                  b: Wt(n[3]),
                                  a: l3(n[4]),
                                  format: e ? "name" : "hex8",
                                }
                              : ((n = On.hex6.exec(t)),
                                n
                                  ? {
                                      r: Wt(n[1]),
                                      g: Wt(n[2]),
                                      b: Wt(n[3]),
                                      format: e ? "name" : "hex",
                                    }
                                  : ((n = On.hex4.exec(t)),
                                    n
                                      ? {
                                          r: Wt(n[1] + n[1]),
                                          g: Wt(n[2] + n[2]),
                                          b: Wt(n[3] + n[3]),
                                          a: l3(n[4] + n[4]),
                                          format: e ? "name" : "hex8",
                                        }
                                      : ((n = On.hex3.exec(t)),
                                        n
                                          ? {
                                              r: Wt(n[1] + n[1]),
                                              g: Wt(n[2] + n[2]),
                                              b: Wt(n[3] + n[3]),
                                              format: e ? "name" : "hex",
                                            }
                                          : !1)))))))));
  }
  function kr(t) {
    return !!On.CSS_UNIT.exec(String(t));
  }
  var nD = (function () {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t) return e;
      typeof e == "number" && (e = X9(e)), (this.originalInput = e);
      var o = Z9(e);
      (this.originalInput = e),
        (this.r = o.r),
        (this.g = o.g),
        (this.b = o.b),
        (this.a = o.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (r = n.format) !== null && r !== void 0 ? r : o.format),
        (this.gradientType = n.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = o.ok);
    }
    return (
      (t.prototype.isDark = function () {
        return this.getBrightness() < 128;
      }),
      (t.prototype.isLight = function () {
        return !this.isDark();
      }),
      (t.prototype.getBrightness = function () {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
      }),
      (t.prototype.getLuminance = function () {
        var e = this.toRgb(),
          n,
          r,
          o,
          i = e.r / 255,
          s = e.g / 255,
          a = e.b / 255;
        return (
          i <= 0.03928
            ? (n = i / 12.92)
            : (n = Math.pow((i + 0.055) / 1.055, 2.4)),
          s <= 0.03928
            ? (r = s / 12.92)
            : (r = Math.pow((s + 0.055) / 1.055, 2.4)),
          a <= 0.03928
            ? (o = a / 12.92)
            : (o = Math.pow((a + 0.055) / 1.055, 2.4)),
          0.2126 * n + 0.7152 * r + 0.0722 * o
        );
      }),
      (t.prototype.getAlpha = function () {
        return this.a;
      }),
      (t.prototype.setAlpha = function (e) {
        return (
          (this.a = o3(e)), (this.roundA = Math.round(100 * this.a) / 100), this
        );
      }),
      (t.prototype.isMonochrome = function () {
        var e = this.toHsl().s;
        return e === 0;
      }),
      (t.prototype.toHsv = function () {
        var e = s3(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
      }),
      (t.prototype.toHsvString = function () {
        var e = s3(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          o = Math.round(e.v * 100);
        return this.a === 1
          ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(o, "%)")
          : "hsva("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(o, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHsl = function () {
        var e = i3(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
      }),
      (t.prototype.toHslString = function () {
        var e = i3(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          o = Math.round(e.l * 100);
        return this.a === 1
          ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(o, "%)")
          : "hsla("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(o, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHex = function (e) {
        return e === void 0 && (e = !1), a3(this.r, this.g, this.b, e);
      }),
      (t.prototype.toHexString = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex(e);
      }),
      (t.prototype.toHex8 = function (e) {
        return e === void 0 && (e = !1), J9(this.r, this.g, this.b, this.a, e);
      }),
      (t.prototype.toHex8String = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex8(e);
      }),
      (t.prototype.toHexShortString = function (e) {
        return (
          e === void 0 && (e = !1),
          this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        );
      }),
      (t.prototype.toRgb = function () {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a,
        };
      }),
      (t.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          n = Math.round(this.g),
          r = Math.round(this.b);
        return this.a === 1
          ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")")
          : "rgba("
              .concat(e, ", ")
              .concat(n, ", ")
              .concat(r, ", ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toPercentageRgb = function () {
        var e = function (n) {
          return "".concat(Math.round(ut(n, 255) * 100), "%");
        };
        return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a };
      }),
      (t.prototype.toPercentageRgbString = function () {
        var e = function (n) {
          return Math.round(ut(n, 255) * 100);
        };
        return this.a === 1
          ? "rgb("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%)")
          : "rgba("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toName = function () {
        if (this.a === 0) return "transparent";
        if (this.a < 1) return !1;
        for (
          var e = "#" + a3(this.r, this.g, this.b, !1),
            n = 0,
            r = Object.entries(Dh);
          n < r.length;
          n++
        ) {
          var o = r[n],
            i = o[0],
            s = o[1];
          if (e === s) return i;
        }
        return !1;
      }),
      (t.prototype.toString = function (e) {
        var n = !!e;
        e = e ?? this.format;
        var r = !1,
          o = this.a < 1 && this.a >= 0,
          i = !n && o && (e.startsWith("hex") || e === "name");
        return i
          ? e === "name" && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === "rgb" && (r = this.toRgbString()),
            e === "prgb" && (r = this.toPercentageRgbString()),
            (e === "hex" || e === "hex6") && (r = this.toHexString()),
            e === "hex3" && (r = this.toHexString(!0)),
            e === "hex4" && (r = this.toHex8String(!0)),
            e === "hex8" && (r = this.toHex8String()),
            e === "name" && (r = this.toName()),
            e === "hsl" && (r = this.toHslString()),
            e === "hsv" && (r = this.toHsvString()),
            r || this.toHexString());
      }),
      (t.prototype.toNumber = function () {
        return (
          (Math.round(this.r) << 16) +
          (Math.round(this.g) << 8) +
          Math.round(this.b)
        );
      }),
      (t.prototype.clone = function () {
        return new t(this.toString());
      }),
      (t.prototype.lighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l += e / 100), (n.l = $c(n.l)), new t(n);
      }),
      (t.prototype.brighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toRgb();
        return (
          (n.r = Math.max(
            0,
            Math.min(255, n.r - Math.round(255 * -(e / 100)))
          )),
          (n.g = Math.max(
            0,
            Math.min(255, n.g - Math.round(255 * -(e / 100)))
          )),
          (n.b = Math.max(
            0,
            Math.min(255, n.b - Math.round(255 * -(e / 100)))
          )),
          new t(n)
        );
      }),
      (t.prototype.darken = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l -= e / 100), (n.l = $c(n.l)), new t(n);
      }),
      (t.prototype.tint = function (e) {
        return e === void 0 && (e = 10), this.mix("white", e);
      }),
      (t.prototype.shade = function (e) {
        return e === void 0 && (e = 10), this.mix("black", e);
      }),
      (t.prototype.desaturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s -= e / 100), (n.s = $c(n.s)), new t(n);
      }),
      (t.prototype.saturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s += e / 100), (n.s = $c(n.s)), new t(n);
      }),
      (t.prototype.greyscale = function () {
        return this.desaturate(100);
      }),
      (t.prototype.spin = function (e) {
        var n = this.toHsl(),
          r = (n.h + e) % 360;
        return (n.h = r < 0 ? 360 + r : r), new t(n);
      }),
      (t.prototype.mix = function (e, n) {
        n === void 0 && (n = 50);
        var r = this.toRgb(),
          o = new t(e).toRgb(),
          i = n / 100,
          s = {
            r: (o.r - r.r) * i + r.r,
            g: (o.g - r.g) * i + r.g,
            b: (o.b - r.b) * i + r.b,
            a: (o.a - r.a) * i + r.a,
          };
        return new t(s);
      }),
      (t.prototype.analogous = function (e, n) {
        e === void 0 && (e = 6), n === void 0 && (n = 30);
        var r = this.toHsl(),
          o = 360 / n,
          i = [this];
        for (r.h = (r.h - ((o * e) >> 1) + 720) % 360; --e; )
          (r.h = (r.h + o) % 360), i.push(new t(r));
        return i;
      }),
      (t.prototype.complement = function () {
        var e = this.toHsl();
        return (e.h = (e.h + 180) % 360), new t(e);
      }),
      (t.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6);
        for (
          var n = this.toHsv(), r = n.h, o = n.s, i = n.v, s = [], a = 1 / e;
          e--;

        )
          s.push(new t({ h: r, s: o, v: i })), (i = (i + a) % 1);
        return s;
      }),
      (t.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          n = e.h;
        return [
          this,
          new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
          new t({ h: (n + 216) % 360, s: e.s, l: e.l }),
        ];
      }),
      (t.prototype.onBackground = function (e) {
        var n = this.toRgb(),
          r = new t(e).toRgb(),
          o = n.a + r.a * (1 - n.a);
        return new t({
          r: (n.r * n.a + r.r * r.a * (1 - n.a)) / o,
          g: (n.g * n.a + r.g * r.a * (1 - n.a)) / o,
          b: (n.b * n.a + r.b * r.a * (1 - n.a)) / o,
          a: o,
        });
      }),
      (t.prototype.triad = function () {
        return this.polyad(3);
      }),
      (t.prototype.tetrad = function () {
        return this.polyad(4);
      }),
      (t.prototype.polyad = function (e) {
        for (
          var n = this.toHsl(), r = n.h, o = [this], i = 360 / e, s = 1;
          s < e;
          s++
        )
          o.push(new t({ h: (r + s * i) % 360, s: n.s, l: n.l }));
        return o;
      }),
      (t.prototype.equals = function (e) {
        return this.toRgbString() === new t(e).toRgbString();
      }),
      t
    );
  })();
  function ao(...t) {
    return new nD(...t);
  }
  function Bh(t, e) {
    const n = t && t.a;
    let r;
    t && t.hsl
      ? (r = ao(t.hsl))
      : t && t.hex && t.hex.length > 0
      ? (r = ao(t.hex))
      : t && t.hsv
      ? (r = ao(t.hsv))
      : t && t.rgba
      ? (r = ao(t.rgba))
      : t && t.rgb
      ? (r = ao(t.rgb))
      : (r = ao(t)),
      r && (r._a === void 0 || r._a === null) && r.setAlpha(n || r.getAlpha());
    const o = r.toHsl(),
      i = r.toHsv();
    return (
      o.s === 0 && (i.h = o.h = t.h || (t.hsl && t.hsl.h) || e || 0),
      i.v < 0.0164 &&
        ((i.h = t.h || (t.hsv && t.hsv.h) || 0),
        (i.s = t.s || (t.hsv && t.hsv.s) || 0)),
      o.l < 0.01 &&
        ((o.h = t.h || (t.hsl && t.hsl.h) || 0),
        (o.s = t.s || (t.hsl && t.hsl.s) || 0)),
      {
        hsl: o,
        hex: r.toHexString().toUpperCase(),
        hex8: r.toHex8String().toUpperCase(),
        rgba: r.toRgb(),
        hsv: i,
        oldHue: t.h || e || o.h,
        source: t.source,
        a: r.getAlpha(),
      }
    );
  }
  var rD = {
      model: { prop: "modelValue", event: "update:modelValue" },
      props: ["modelValue"],
      data() {
        return { val: Bh(this.modelValue) };
      },
      computed: {
        colors: {
          get() {
            return this.val;
          },
          set(t) {
            (this.val = t), this.$emit("update:modelValue", t);
          },
        },
      },
      watch: {
        modelValue(t) {
          this.val = Bh(t);
        },
      },
      methods: {
        colorChange(t, e) {
          (this.oldHue = this.colors.hsl.h),
            (this.colors = Bh(t, e || this.oldHue));
        },
        isValidHex(t) {
          return ao(t).isValid;
        },
        simpleCheckForValidColor(t) {
          const e = ["r", "g", "b", "a", "h", "s", "l", "v"];
          let n = 0,
            r = 0;
          for (let o = 0; o < e.length; o++) {
            const i = e[o];
            t[i] && (n++, isNaN(t[i]) || r++);
          }
          if (n === r) return t;
        },
        paletteUpperCase(t) {
          return t.map((e) => e.toUpperCase());
        },
        isTransparent(t) {
          return ao(t).getAlpha() === 0;
        },
      },
    },
    Hc = {
      name: "EditableInput",
      props: {
        label: String,
        labelText: String,
        desc: String,
        value: [String, Number],
        max: Number,
        min: Number,
        arrowOffset: { type: Number, default: 1 },
      },
      computed: {
        val: {
          get() {
            return this.value;
          },
          set(t) {
            if (this.max !== void 0 && +t > this.max)
              this.$refs.input.value = this.max;
            else return t;
          },
        },
        labelId() {
          return `input__label__${this.label}__${Math.random()
            .toString()
            .slice(2, 5)}`;
        },
        labelSpanText() {
          return this.labelText || this.label;
        },
      },
      methods: {
        update(t) {
          this.handleChange(t.target.value);
        },
        handleChange(t) {
          const e = {};
          (e[this.label] = t),
            e.hex === void 0 && e["#"] === void 0
              ? this.$emit("change", e)
              : t.length > 5 && this.$emit("change", e);
        },
        handleKeyDown(t) {
          let { val: e } = this;
          const n = Number(e);
          if (n) {
            const r = this.arrowOffset || 1;
            t.keyCode === 38 &&
              ((e = n + r), this.handleChange(e), t.preventDefault()),
              t.keyCode === 40 &&
                ((e = n - r), this.handleChange(e), t.preventDefault());
          }
        },
      },
    };
  const oD = { class: "vc-editable-input" },
    iD = ["aria-labelledby"],
    sD = ["id", "for"],
    aD = { class: "vc-input__desc" };
  function lD(t, e, n, r, o, i) {
    return (
      u.openBlock(),
      u.createElementBlock("div", oD, [
        u.withDirectives(
          u.createElementVNode(
            "input",
            {
              ref: "input",
              "onUpdate:modelValue": e[0] || (e[0] = (s) => (i.val = s)),
              "aria-labelledby": i.labelId,
              class: "vc-input__input",
              onKeydown:
                e[1] ||
                (e[1] = (...s) => i.handleKeyDown && i.handleKeyDown(...s)),
              onInput: e[2] || (e[2] = (...s) => i.update && i.update(...s)),
            },
            null,
            40,
            iD
          ),
          [[u.vModelText, i.val]]
        ),
        u.createElementVNode(
          "span",
          { id: i.labelId, for: n.label, class: "vc-input__label" },
          u.toDisplayString(i.labelSpanText),
          9,
          sD
        ),
        u.createElementVNode("span", aD, u.toDisplayString(n.desc), 1),
      ])
    );
  }
  var cD =
    ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
  $i(cD),
    (Hc.render = lD),
    (Hc.__file = "src/components/editable-input/editable-input.vue"),
    (Hc.install = Fi);
  function Ph(t, e, n) {
    return e < n ? (t < e ? e : t > n ? n : t) : t < n ? n : t > e ? e : t;
  }
  var zc = {
    name: "Saturation",
    props: { value: Object },
    computed: {
      colors() {
        return this.value;
      },
      bgColor() {
        return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
      },
      pointerTop() {
        return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
      },
      pointerLeft() {
        return `${this.colors.hsv.s * 100}%`;
      },
    },
    methods: {
      handleChange(t, e) {
        !e && t.preventDefault();
        const { container: n } = this.$refs;
        if (!n) return;
        const r = n.clientWidth,
          o = n.clientHeight,
          i = n.getBoundingClientRect().left + window.pageXOffset,
          s = n.getBoundingClientRect().top + window.pageYOffset,
          a = t.pageX || (t.touches ? t.touches[0].pageX : 0),
          l = t.pageY || (t.touches ? t.touches[0].pageY : 0),
          c = Ph(a - i, 0, r),
          d = Ph(l - s, 0, o),
          f = c / r,
          p = Ph(-(d / o) + 1, 0, 1);
        this.onChange({
          h: this.colors.hsv.h,
          s: f,
          v: p,
          a: this.colors.hsv.a,
          source: "hsva",
        });
      },
      onChange(t) {
        this.$emit("change", t);
      },
      handleMouseDown(t) {
        window.addEventListener("mousemove", this.handleChange),
          window.addEventListener("mouseup", this.handleChange),
          window.addEventListener("mouseup", this.handleMouseUp);
      },
      handleMouseUp(t) {
        this.unbindEventListeners();
      },
      unbindEventListeners() {
        window.removeEventListener("mousemove", this.handleChange),
          window.removeEventListener("mouseup", this.handleChange),
          window.removeEventListener("mouseup", this.handleMouseUp);
      },
    },
  };
  const uD = u.createElementVNode(
      "div",
      { class: "vc-saturation--white" },
      null,
      -1
    ),
    dD = u.createElementVNode(
      "div",
      { class: "vc-saturation--black" },
      null,
      -1
    ),
    fD = [
      u.createElementVNode("div", { class: "vc-saturation-circle" }, null, -1),
    ];
  function pD(t, e, n, r, o, i) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        {
          ref: "container",
          class: "vc-saturation",
          style: u.normalizeStyle({ background: i.bgColor }),
          onMousedown:
            e[0] ||
            (e[0] = (...s) => i.handleMouseDown && i.handleMouseDown(...s)),
          onTouchmove:
            e[1] || (e[1] = (...s) => i.handleChange && i.handleChange(...s)),
          onTouchstart:
            e[2] || (e[2] = (...s) => i.handleChange && i.handleChange(...s)),
        },
        [
          uD,
          dD,
          u.createElementVNode(
            "div",
            {
              class: "vc-saturation-pointer",
              style: u.normalizeStyle({
                top: i.pointerTop,
                left: i.pointerLeft,
              }),
            },
            fD,
            4
          ),
        ],
        36
      )
    );
  }
  var hD =
    ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
  $i(hD),
    (zc.render = pD),
    (zc.__file = "src/components/saturation/saturation.vue"),
    (zc.install = Fi);
  var Vc = {
    name: "Hue",
    props: {
      value: Object,
      direction: { type: String, default: "horizontal" },
    },
    data() {
      return { oldHue: 0, pullDirection: "" };
    },
    computed: {
      colors() {
        return this.value;
      },
      directionClass() {
        return {
          "vc-hue--horizontal": this.direction === "horizontal",
          "vc-hue--vertical": this.direction === "vertical",
        };
      },
      pointerTop() {
        return this.direction === "vertical"
          ? this.colors.hsl.h === 0 && this.pullDirection === "right"
            ? 0
            : `${-((this.colors.hsl.h * 100) / 360) + 100}%`
          : 0;
      },
      pointerLeft() {
        return this.direction === "vertical"
          ? 0
          : this.colors.hsl.h === 0 && this.pullDirection === "right"
          ? "100%"
          : `${(this.colors.hsl.h * 100) / 360}%`;
      },
    },
    watch: {
      value: {
        handler(t, e) {
          const { h: n } = t.hsl;
          n !== 0 && n - this.oldHue > 0 && (this.pullDirection = "right"),
            n !== 0 && n - this.oldHue < 0 && (this.pullDirection = "left"),
            (this.oldHue = n);
        },
        deep: !0,
        immediate: !0,
      },
    },
    methods: {
      handleChange(t, e) {
        !e && t.preventDefault();
        const { container: n } = this.$refs;
        if (!n) return;
        const r = n.clientWidth,
          o = n.clientHeight,
          i = n.getBoundingClientRect().left + window.pageXOffset,
          s = n.getBoundingClientRect().top + window.pageYOffset,
          a = t.pageX || (t.touches ? t.touches[0].pageX : 0),
          l = t.pageY || (t.touches ? t.touches[0].pageY : 0),
          c = a - i,
          d = l - s;
        let f, p;
        this.direction === "vertical"
          ? (d < 0
              ? (f = 360)
              : d > o
              ? (f = 0)
              : ((p = -((d * 100) / o) + 100), (f = (360 * p) / 100)),
            this.colors.hsl.h !== f &&
              this.$emit("change", {
                h: f,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl",
              }))
          : (c < 0
              ? (f = 0)
              : c > r
              ? (f = 360)
              : ((p = (c * 100) / r), (f = (360 * p) / 100)),
            this.colors.hsl.h !== f &&
              this.$emit("change", {
                h: f,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl",
              }));
      },
      handleMouseDown(t) {
        this.handleChange(t, !0),
          window.addEventListener("mousemove", this.handleChange),
          window.addEventListener("mouseup", this.handleChange),
          window.addEventListener("mouseup", this.handleMouseUp);
      },
      handleMouseUp(t) {
        this.unbindEventListeners();
      },
      unbindEventListeners() {
        window.removeEventListener("mousemove", this.handleChange),
          window.removeEventListener("mouseup", this.handleChange),
          window.removeEventListener("mouseup", this.handleMouseUp);
      },
    },
  };
  const mD = ["aria-valuenow"],
    gD = [u.createElementVNode("div", { class: "vc-hue-picker" }, null, -1)];
  function bD(t, e, n, r, o, i) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        { class: u.normalizeClass(["vc-hue", [i.directionClass]]) },
        [
          u.createElementVNode(
            "div",
            {
              ref: "container",
              class: "vc-hue-container",
              role: "slider",
              "aria-valuenow": i.colors.hsl.h,
              "aria-valuemin": "0",
              "aria-valuemax": "360",
              onMousedown:
                e[0] ||
                (e[0] = (...s) => i.handleMouseDown && i.handleMouseDown(...s)),
              onTouchmove:
                e[1] ||
                (e[1] = (...s) => i.handleChange && i.handleChange(...s)),
              onTouchstart:
                e[2] ||
                (e[2] = (...s) => i.handleChange && i.handleChange(...s)),
            },
            [
              u.createElementVNode(
                "div",
                {
                  class: "vc-hue-pointer",
                  style: u.normalizeStyle({
                    top: i.pointerTop,
                    left: i.pointerLeft,
                  }),
                  role: "presentation",
                },
                gD,
                4
              ),
            ],
            40,
            mD
          ),
        ],
        2
      )
    );
  }
  var yD =
    ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
  $i(yD),
    (Vc.render = bD),
    (Vc.__file = "src/components/hue/hue.vue"),
    (Vc.install = Fi);
  const _D = [
    "#D0021B",
    "#F5A623",
    "#F8E71C",
    "#8B572A",
    "#7ED321",
    "#417505",
    "#BD10E0",
    "#9013FE",
    "#4A90E2",
    "#50E3C2",
    "#B8E986",
    "#000000",
    "#4A4A4A",
    "#9B9B9B",
    "#FFFFFF",
    "rgba(0,0,0,0)",
  ];
  var Uc = {
    name: "Sketch",
    components: {
      Saturation: zc,
      Hue: Vc,
      Alpha: Pc,
      EdIn: Hc,
      Checkboard: Ca,
    },
    mixins: [rD],
    props: {
      presetColors: {
        type: Array,
        default() {
          return _D;
        },
      },
      disableAlpha: { type: Boolean, default: !1 },
      disableFields: { type: Boolean, default: !1 },
    },
    computed: {
      hex() {
        let t;
        return (
          this.colors.a < 1 ? (t = this.colors.hex8) : (t = this.colors.hex),
          t.replace("#", "")
        );
      },
      activeColor() {
        const { rgba: t } = this.colors;
        return `rgba(${[t.r, t.g, t.b, t.a].join(",")})`;
      },
    },
    methods: {
      handlePreset(t) {
        this.colorChange(t);
      },
      childChange(t) {
        this.colorChange(t);
      },
      inputChange(t) {
        t &&
          (t.hex
            ? this.isValidHex(t.hex) &&
              this.colorChange({ hex: t.hex, source: "hex" })
            : (t.r || t.g || t.b || t.a) &&
              this.colorChange({
                r: t.r || this.colors.rgba.r,
                g: t.g || this.colors.rgba.g,
                b: t.b || this.colors.rgba.b,
                a: t.a || this.colors.rgba.a,
                source: "rgba",
              }));
      },
    },
  };
  const kD = { class: "vc-sketch-saturation-wrap" },
    wD = { class: "vc-sketch-controls" },
    xD = { class: "vc-sketch-sliders" },
    CD = { class: "vc-sketch-hue-wrap" },
    vD = { key: 0, class: "vc-sketch-alpha-wrap" },
    ED = { class: "vc-sketch-color-wrap" },
    AD = ["aria-label"],
    SD = { key: 0, class: "vc-sketch-field" },
    MD = { class: "vc-sketch-field--double" },
    TD = { class: "vc-sketch-field--single" },
    ND = { class: "vc-sketch-field--single" },
    OD = { class: "vc-sketch-field--single" },
    RD = { key: 0, class: "vc-sketch-field--single" },
    DD = {
      class: "vc-sketch-presets",
      role: "group",
      "aria-label": "A color preset, pick one to set as current color",
    },
    LD = ["aria-label", "onClick"],
    ID = ["aria-label", "onClick"];
  function BD(t, e, n, r, o, i) {
    const s = u.resolveComponent("Saturation"),
      a = u.resolveComponent("Hue"),
      l = u.resolveComponent("Alpha"),
      c = u.resolveComponent("Checkboard"),
      d = u.resolveComponent("EdIn");
    return (
      u.openBlock(),
      u.createElementBlock(
        "div",
        {
          role: "application",
          "aria-label": "Sketch color picker",
          class: u.normalizeClass([
            "vc-sketch",
            [n.disableAlpha ? "vc-sketch__disable-alpha" : ""],
          ]),
        },
        [
          u.createElementVNode("div", kD, [
            u.createVNode(
              s,
              { value: t.colors, onChange: i.childChange },
              null,
              8,
              ["value", "onChange"]
            ),
          ]),
          u.createElementVNode("div", wD, [
            u.createElementVNode("div", xD, [
              u.createElementVNode("div", CD, [
                u.createVNode(
                  a,
                  { value: t.colors, onChange: i.childChange },
                  null,
                  8,
                  ["value", "onChange"]
                ),
              ]),
              n.disableAlpha
                ? u.createCommentVNode("v-if", !0)
                : (u.openBlock(),
                  u.createElementBlock("div", vD, [
                    u.createVNode(
                      l,
                      { value: t.colors, onChange: i.childChange },
                      null,
                      8,
                      ["value", "onChange"]
                    ),
                  ])),
            ]),
            u.createElementVNode("div", ED, [
              u.createElementVNode(
                "div",
                {
                  "aria-label": `Current color is ${i.activeColor}`,
                  class: "vc-sketch-active-color",
                  style: u.normalizeStyle({ background: i.activeColor }),
                },
                null,
                12,
                AD
              ),
              u.createVNode(c),
            ]),
          ]),
          n.disableFields
            ? u.createCommentVNode("v-if", !0)
            : (u.openBlock(),
              u.createElementBlock("div", SD, [
                u.createCommentVNode(" rgba "),
                u.createElementVNode("div", MD, [
                  u.createVNode(
                    d,
                    { label: "hex", value: i.hex, onChange: i.inputChange },
                    null,
                    8,
                    ["value", "onChange"]
                  ),
                ]),
                u.createElementVNode("div", TD, [
                  u.createVNode(
                    d,
                    {
                      label: "r",
                      value: t.colors.rgba.r,
                      onChange: i.inputChange,
                    },
                    null,
                    8,
                    ["value", "onChange"]
                  ),
                ]),
                u.createElementVNode("div", ND, [
                  u.createVNode(
                    d,
                    {
                      label: "g",
                      value: t.colors.rgba.g,
                      onChange: i.inputChange,
                    },
                    null,
                    8,
                    ["value", "onChange"]
                  ),
                ]),
                u.createElementVNode("div", OD, [
                  u.createVNode(
                    d,
                    {
                      label: "b",
                      value: t.colors.rgba.b,
                      onChange: i.inputChange,
                    },
                    null,
                    8,
                    ["value", "onChange"]
                  ),
                ]),
                n.disableAlpha
                  ? u.createCommentVNode("v-if", !0)
                  : (u.openBlock(),
                    u.createElementBlock("div", RD, [
                      u.createVNode(
                        d,
                        {
                          label: "a",
                          value: t.colors.a,
                          "arrow-offset": 0.01,
                          max: 1,
                          onChange: i.inputChange,
                        },
                        null,
                        8,
                        ["value", "arrow-offset", "onChange"]
                      ),
                    ])),
              ])),
          u.createElementVNode("div", DD, [
            (u.openBlock(!0),
            u.createElementBlock(
              u.Fragment,
              null,
              u.renderList(
                n.presetColors,
                (f) => (
                  u.openBlock(),
                  u.createElementBlock(
                    u.Fragment,
                    null,
                    [
                      t.isTransparent(f)
                        ? (u.openBlock(),
                          u.createElementBlock(
                            "div",
                            {
                              key: f,
                              "aria-label": `Color:${f}`,
                              class: "vc-sketch-presets-color",
                              onClick: (p) => i.handlePreset(f),
                            },
                            [u.createVNode(c)],
                            8,
                            ID
                          ))
                        : (u.openBlock(),
                          u.createElementBlock(
                            "div",
                            {
                              key: `!${f}`,
                              class: "vc-sketch-presets-color",
                              "aria-label": `Color:${f}`,
                              style: u.normalizeStyle({ background: f }),
                              onClick: (p) => i.handlePreset(f),
                            },
                            null,
                            12,
                            LD
                          )),
                    ],
                    64
                  )
                )
              ),
              256
            )),
          ]),
        ],
        2
      )
    );
  }
  var PD =
    ".vc-sketch{background:#fff;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.15),0 8px 16px rgba(0,0,0,.15);box-sizing:initial;padding:10px 10px 0;position:relative;width:200px}.vc-sketch-saturation-wrap{overflow:hidden;padding-bottom:75%;position:relative;width:100%}.vc-sketch-controls{display:flex}.vc-sketch-sliders{flex:1;padding:4px 0}.vc-sketch-sliders .vc-alpha-gradient,.vc-sketch-sliders .vc-hue{border-radius:2px}.vc-sketch-alpha-wrap,.vc-sketch-hue-wrap{height:10px;position:relative}.vc-sketch-alpha-wrap{margin-top:4px;overflow:hidden}.vc-sketch-color-wrap{border-radius:3px;height:24px;margin-left:4px;margin-top:4px;position:relative;width:24px}.vc-sketch-active-color{border-radius:2px;bottom:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15),inset 0 0 4px rgba(0,0,0,.25);left:0;position:absolute;right:0;top:0;z-index:2}.vc-sketch-color-wrap .vc-checkerboard{background-size:auto}.vc-sketch-field{display:flex;padding-top:4px}.vc-sketch-field .vc-input__input{border:none;box-shadow:inset 0 0 0 1px #ccc;font-size:10px;padding:4px 0 3px 10%;width:90%}.vc-sketch-field .vc-input__label{color:#222;display:block;font-size:11px;padding-bottom:4px;padding-top:3px;text-align:center;text-transform:capitalize}.vc-sketch-field--single{flex:1;padding-left:6px}.vc-sketch-field--double{flex:2}.vc-sketch-presets{border-top:1px solid #eee;margin-left:-10px;margin-right:-10px;padding-left:10px;padding-top:10px}.vc-sketch-presets-color{cursor:pointer;display:inline-block;height:16px;margin:0 10px 10px 0;overflow:hidden;position:relative;vertical-align:top;width:16px}.vc-sketch-presets-color,.vc-sketch-presets-color .vc-checkerboard{border-radius:3px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)}.vc-sketch__disable-alpha .vc-sketch-color-wrap{height:10px}";
  $i(PD),
    (Uc.render = BD),
    (Uc.__file = "src/components/sketch/sketch.vue"),
    (Uc.install = Fi);
  function $D(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  }
  var $h = {},
    Fh = {},
    jc = { exports: {} },
    c3;
  function FD() {
    if (c3) return jc.exports;
    c3 = 1;
    var t = String,
      e = function () {
        return {
          isColorSupported: !1,
          reset: t,
          bold: t,
          dim: t,
          italic: t,
          underline: t,
          inverse: t,
          hidden: t,
          strikethrough: t,
          black: t,
          red: t,
          green: t,
          yellow: t,
          blue: t,
          magenta: t,
          cyan: t,
          white: t,
          gray: t,
          bgBlack: t,
          bgRed: t,
          bgGreen: t,
          bgYellow: t,
          bgBlue: t,
          bgMagenta: t,
          bgCyan: t,
          bgWhite: t,
        };
      };
    return (jc.exports = e()), (jc.exports.createColors = e), jc.exports;
  }
  var u3;
  function HD() {
    return (
      u3 ||
        ((u3 = 1),
        (function (t) {
          var e = {
            LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
            COREPACK_ROOT:
              "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
            WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
            npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
            TERM_PROGRAM: "vscode",
            npm_package_scripts_prettier:
              "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
            npm_package_dependencies__tiptap_extension_link: "^2.11.2",
            npm_package_scripts_test_unit_coverage:
              "vitest run --environment jsdom --coverage",
            NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
            ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
            WASMER_DIR: "/Users/ryanwang/.wasmer",
            _P9K_TTY: "/dev/ttys005",
            npm_package_homepage:
              "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
            npm_package_dependencies__tiptap_vue_3: "^2.11.2",
            INIT_CWD:
              "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
            SHELL: "/bin/zsh",
            TERM: "xterm-256color",
            npm_package_unpkg: "./dist/rich-text-editor.iife.js",
            npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
            npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
            TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
            CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
            npm_package_dependencies_linkifyjs: "^4.1.3",
            npm_package_scripts_lint:
              "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
            npm_package_scripts_release: "release-it",
            TERM_PROGRAM_VERSION: "0.48.7",
            npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
            npm_package_dependencies_floating_vue: "^5.2.2",
            npm_package_scripts_dev: "vite",
            MallocNanoZone: "0",
            ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
            CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
            ZDOTDIR: "/Users/ryanwang",
            npm_package_dependencies__tiptap_extension_document: "^2.11.2",
            npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
            SDKMAN_PLATFORM: "darwinarm64",
            npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
            npm_config_registry: "https://registry.npmjs.org/",
            ZSH: "/Users/ryanwang/.oh-my-zsh",
            PNPM_HOME: "/Users/ryanwang/Library/pnpm",
            npm_package_repository_url: "https://github.com/halo-dev/halo.git",
            npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
            npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
            npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
            npm_package_scripts_test_unit_ui:
              "vitest --environment jsdom --watch --ui",
            npm_package_dependencies__tiptap_pm: "^2.11.2",
            USER: "ryanwang",
            DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
            npm_package_description: "Default editor for Halo",
            LS_COLORS:
              "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
            npm_package_license: "GPL-3.0",
            COMMAND_MODE: "unix2003",
            npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
            SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
            npm_package_exports___import: "./dist/rich-text-editor.es.js",
            PNPM_SCRIPT_SRC_DIR:
              "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
            npm_package_repository_directory: "ui/packages/editor",
            npm_package_dependencies__tiptap_extension_history: "^2.11.2",
            npm_config_strict_peer_dependencies: "",
            SSH_AUTH_SOCK:
              "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
            __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
            npm_execpath:
              "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
            PAGER: "less",
            npm_package_module: "./dist/rich-text-editor.es.js",
            npm_package_dependencies__tiptap_extension_text: "^2.11.2",
            LSCOLORS: "Gxfxcxdxbxegedabagacad",
            npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
            npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
            npm_config_frozen_lockfile: "",
            npm_package_dependencies__tiptap_extension_horizontal_rule:
              "^2.11.2",
            npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
            npm_package_devDependencies__types_linkifyjs: "^2.1.7",
            PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
            MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
            npm_package_devDependencies_release_it: "^16.1.5",
            npm_package_scripts_typecheck:
              "vue-tsc --noEmit -p tsconfig.app.json --composite false",
            npm_package_peerDependencies_vue: "^3.5.13",
            __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
            USER_ZDOTDIR: "/Users/ryanwang",
            COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
            npm_package_author: "@halo-dev",
            npm_package_dependencies__ckpack_vue_color: "^1.5.0",
            npm_config_auto_install_peers: "true",
            PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
            npm_command: "run-script",
            JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
            VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
            npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
            npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
            EDITOR: "nvim",
            P9K_SSH: "0",
            npm_lifecycle_event: "build",
            LANG: "en_US.UTF-8",
            P9K_TTY: "old",
            npm_package_name: "@halo-dev/richtext-editor",
            npm_package_repository_type: "git",
            npm_package_types: "./dist/index.d.ts",
            npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
            npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
            npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
            npm_package_dependencies__tiptap_suggestion: "^2.11.2",
            NODE_PATH:
              "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
            npm_package_exports___types: "./dist/index.d.ts",
            npm_package_scripts_build:
              "vite build --config ./vite.lib.config.ts",
            XPC_FLAGS: "0x0",
            VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
            npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
            npm_package_dependencies_tippy_js: "^6.3.7",
            npm_package_main: "./dist/rich-text-editor.iife.js",
            npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
            npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
            npm_config_node_gyp:
              "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
            XPC_SERVICE_NAME: "0",
            npm_package_version: "2.20.0",
            npm_package_devDependencies__iconify_json: "^2.2.117",
            VSCODE_INJECTION: "1",
            npm_package_dependencies__tiptap_core: "^2.11.2",
            npm_package_dependencies__tiptap_extension_code: "^2.11.2",
            HOME: "/Users/ryanwang",
            SHLVL: "2",
            npm_package_exports___dist_style_css: "./dist/style.css",
            VSCODE_GIT_ASKPASS_MAIN:
              "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
            npm_package_dependencies__tiptap_extension_image: "^2.11.2",
            npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
            npm_package_dependencies_github_markdown_css: "^5.2.0",
            npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
            npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
            LOGNAME: "ryanwang",
            LESS: "-R",
            SDKMAN_DIR: "/Users/ryanwang/.sdkman",
            npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
            VSCODE_GIT_IPC_HANDLE:
              "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
            npm_package_dependencies__tiptap_extension_table: "^2.11.2",
            npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
            BUN_INSTALL: "/Users/ryanwang/.bun",
            npm_package_scripts_test_unit_watch:
              "vitest --environment jsdom --watch",
            npm_package_dependencies__tiptap_extension_color: "^2.11.2",
            npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
            npm_config_user_agent:
              "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
            SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
            GIT_ASKPASS:
              "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
            VSCODE_GIT_ASKPASS_NODE:
              "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
            _P9K_SSH_TTY: "/dev/ttys005",
            npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
            npm_package_files_0: "dist",
            npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
            OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
            COLORTERM: "truecolor",
            npm_node_execpath:
              "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
            NODE_ENV: "production",
          };
          Object.defineProperty(t, "__esModule", { value: !0 });
          function n(c, d) {
            for (var f in d)
              Object.defineProperty(c, f, { enumerable: !0, get: d[f] });
          }
          n(t, { dim: () => a, default: () => l });
          const r = o(FD());
          function o(c) {
            return c && c.__esModule ? c : { default: c };
          }
          let i = new Set();
          function s(c, d, f) {
            (typeof process < "u" && e.JEST_WORKER_ID) ||
              (f && i.has(f)) ||
              (f && i.add(f),
              console.warn(""),
              d.forEach((p) => console.warn(c, "-", p)));
          }
          function a(c) {
            return r.default.dim(c);
          }
          const l = {
            info(c, d) {
              s(
                r.default.bold(r.default.cyan("info")),
                ...(Array.isArray(c) ? [c] : [d, c])
              );
            },
            warn(c, d) {
              s(
                r.default.bold(r.default.yellow("warn")),
                ...(Array.isArray(c) ? [c] : [d, c])
              );
            },
            risk(c, d) {
              s(
                r.default.bold(r.default.magenta("risk")),
                ...(Array.isArray(c) ? [c] : [d, c])
              );
            },
          };
        })(Fh)),
      Fh
    );
  }
  var d3;
  function zD() {
    return (
      d3 ||
        ((d3 = 1),
        (function (t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            Object.defineProperty(t, "default", {
              enumerable: !0,
              get: () => o,
            });
          const e = n(HD());
          function n(i) {
            return i && i.__esModule ? i : { default: i };
          }
          function r({ version: i, from: s, to: a }) {
            e.default.warn(`${s}-color-renamed`, [
              `As of Tailwind CSS ${i}, \`${s}\` has been renamed to \`${a}\`.`,
              "Update your configuration file to silence this warning.",
            ]);
          }
          const o = {
            inherit: "inherit",
            current: "currentColor",
            transparent: "transparent",
            black: "#000",
            white: "#fff",
            slate: {
              50: "#f8fafc",
              100: "#f1f5f9",
              200: "#e2e8f0",
              300: "#cbd5e1",
              400: "#94a3b8",
              500: "#64748b",
              600: "#475569",
              700: "#334155",
              800: "#1e293b",
              900: "#0f172a",
              950: "#020617",
            },
            gray: {
              50: "#f9fafb",
              100: "#f3f4f6",
              200: "#e5e7eb",
              300: "#d1d5db",
              400: "#9ca3af",
              500: "#6b7280",
              600: "#4b5563",
              700: "#374151",
              800: "#1f2937",
              900: "#111827",
              950: "#030712",
            },
            zinc: {
              50: "#fafafa",
              100: "#f4f4f5",
              200: "#e4e4e7",
              300: "#d4d4d8",
              400: "#a1a1aa",
              500: "#71717a",
              600: "#52525b",
              700: "#3f3f46",
              800: "#27272a",
              900: "#18181b",
              950: "#09090b",
            },
            neutral: {
              50: "#fafafa",
              100: "#f5f5f5",
              200: "#e5e5e5",
              300: "#d4d4d4",
              400: "#a3a3a3",
              500: "#737373",
              600: "#525252",
              700: "#404040",
              800: "#262626",
              900: "#171717",
              950: "#0a0a0a",
            },
            stone: {
              50: "#fafaf9",
              100: "#f5f5f4",
              200: "#e7e5e4",
              300: "#d6d3d1",
              400: "#a8a29e",
              500: "#78716c",
              600: "#57534e",
              700: "#44403c",
              800: "#292524",
              900: "#1c1917",
              950: "#0c0a09",
            },
            red: {
              50: "#fef2f2",
              100: "#fee2e2",
              200: "#fecaca",
              300: "#fca5a5",
              400: "#f87171",
              500: "#ef4444",
              600: "#dc2626",
              700: "#b91c1c",
              800: "#991b1b",
              900: "#7f1d1d",
              950: "#450a0a",
            },
            orange: {
              50: "#fff7ed",
              100: "#ffedd5",
              200: "#fed7aa",
              300: "#fdba74",
              400: "#fb923c",
              500: "#f97316",
              600: "#ea580c",
              700: "#c2410c",
              800: "#9a3412",
              900: "#7c2d12",
              950: "#431407",
            },
            amber: {
              50: "#fffbeb",
              100: "#fef3c7",
              200: "#fde68a",
              300: "#fcd34d",
              400: "#fbbf24",
              500: "#f59e0b",
              600: "#d97706",
              700: "#b45309",
              800: "#92400e",
              900: "#78350f",
              950: "#451a03",
            },
            yellow: {
              50: "#fefce8",
              100: "#fef9c3",
              200: "#fef08a",
              300: "#fde047",
              400: "#facc15",
              500: "#eab308",
              600: "#ca8a04",
              700: "#a16207",
              800: "#854d0e",
              900: "#713f12",
              950: "#422006",
            },
            lime: {
              50: "#f7fee7",
              100: "#ecfccb",
              200: "#d9f99d",
              300: "#bef264",
              400: "#a3e635",
              500: "#84cc16",
              600: "#65a30d",
              700: "#4d7c0f",
              800: "#3f6212",
              900: "#365314",
              950: "#1a2e05",
            },
            green: {
              50: "#f0fdf4",
              100: "#dcfce7",
              200: "#bbf7d0",
              300: "#86efac",
              400: "#4ade80",
              500: "#22c55e",
              600: "#16a34a",
              700: "#15803d",
              800: "#166534",
              900: "#14532d",
              950: "#052e16",
            },
            emerald: {
              50: "#ecfdf5",
              100: "#d1fae5",
              200: "#a7f3d0",
              300: "#6ee7b7",
              400: "#34d399",
              500: "#10b981",
              600: "#059669",
              700: "#047857",
              800: "#065f46",
              900: "#064e3b",
              950: "#022c22",
            },
            teal: {
              50: "#f0fdfa",
              100: "#ccfbf1",
              200: "#99f6e4",
              300: "#5eead4",
              400: "#2dd4bf",
              500: "#14b8a6",
              600: "#0d9488",
              700: "#0f766e",
              800: "#115e59",
              900: "#134e4a",
              950: "#042f2e",
            },
            cyan: {
              50: "#ecfeff",
              100: "#cffafe",
              200: "#a5f3fc",
              300: "#67e8f9",
              400: "#22d3ee",
              500: "#06b6d4",
              600: "#0891b2",
              700: "#0e7490",
              800: "#155e75",
              900: "#164e63",
              950: "#083344",
            },
            sky: {
              50: "#f0f9ff",
              100: "#e0f2fe",
              200: "#bae6fd",
              300: "#7dd3fc",
              400: "#38bdf8",
              500: "#0ea5e9",
              600: "#0284c7",
              700: "#0369a1",
              800: "#075985",
              900: "#0c4a6e",
              950: "#082f49",
            },
            blue: {
              50: "#eff6ff",
              100: "#dbeafe",
              200: "#bfdbfe",
              300: "#93c5fd",
              400: "#60a5fa",
              500: "#3b82f6",
              600: "#2563eb",
              700: "#1d4ed8",
              800: "#1e40af",
              900: "#1e3a8a",
              950: "#172554",
            },
            indigo: {
              50: "#eef2ff",
              100: "#e0e7ff",
              200: "#c7d2fe",
              300: "#a5b4fc",
              400: "#818cf8",
              500: "#6366f1",
              600: "#4f46e5",
              700: "#4338ca",
              800: "#3730a3",
              900: "#312e81",
              950: "#1e1b4b",
            },
            violet: {
              50: "#f5f3ff",
              100: "#ede9fe",
              200: "#ddd6fe",
              300: "#c4b5fd",
              400: "#a78bfa",
              500: "#8b5cf6",
              600: "#7c3aed",
              700: "#6d28d9",
              800: "#5b21b6",
              900: "#4c1d95",
              950: "#2e1065",
            },
            purple: {
              50: "#faf5ff",
              100: "#f3e8ff",
              200: "#e9d5ff",
              300: "#d8b4fe",
              400: "#c084fc",
              500: "#a855f7",
              600: "#9333ea",
              700: "#7e22ce",
              800: "#6b21a8",
              900: "#581c87",
              950: "#3b0764",
            },
            fuchsia: {
              50: "#fdf4ff",
              100: "#fae8ff",
              200: "#f5d0fe",
              300: "#f0abfc",
              400: "#e879f9",
              500: "#d946ef",
              600: "#c026d3",
              700: "#a21caf",
              800: "#86198f",
              900: "#701a75",
              950: "#4a044e",
            },
            pink: {
              50: "#fdf2f8",
              100: "#fce7f3",
              200: "#fbcfe8",
              300: "#f9a8d4",
              400: "#f472b6",
              500: "#ec4899",
              600: "#db2777",
              700: "#be185d",
              800: "#9d174d",
              900: "#831843",
              950: "#500724",
            },
            rose: {
              50: "#fff1f2",
              100: "#ffe4e6",
              200: "#fecdd3",
              300: "#fda4af",
              400: "#fb7185",
              500: "#f43f5e",
              600: "#e11d48",
              700: "#be123c",
              800: "#9f1239",
              900: "#881337",
              950: "#4c0519",
            },
            get lightBlue() {
              return (
                r({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky
              );
            },
            get warmGray() {
              return (
                r({ version: "v3.0", from: "warmGray", to: "stone" }),
                this.stone
              );
            },
            get trueGray() {
              return (
                r({ version: "v3.0", from: "trueGray", to: "neutral" }),
                this.neutral
              );
            },
            get coolGray() {
              return (
                r({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray
              );
            },
            get blueGray() {
              return (
                r({ version: "v3.0", from: "blueGray", to: "slate" }),
                this.slate
              );
            },
          };
        })($h)),
      $h
    );
  }
  var Hh, f3;
  function VD() {
    if (f3) return Hh;
    f3 = 1;
    let t = zD();
    return (Hh = (t.__esModule ? t : { default: t }).default), Hh;
  }
  var UD = VD();
  const p3 = $D(UD),
    jD = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function WD(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        jD,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M8.59 16.58L13.17 12L8.59 7.41L10 6l6 6l-6 6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const qD = u.markRaw({ name: "mdi-chevron-right", render: WD }),
    KD = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function GD(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        KD,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M17.5 12a1.5 1.5 0 0 1-1.5-1.5A1.5 1.5 0 0 1 17.5 9a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m-3-4A1.5 1.5 0 0 1 13 6.5A1.5 1.5 0 0 1 14.5 5A1.5 1.5 0 0 1 16 6.5A1.5 1.5 0 0 1 14.5 8m-5 0A1.5 1.5 0 0 1 8 6.5A1.5 1.5 0 0 1 9.5 5A1.5 1.5 0 0 1 11 6.5A1.5 1.5 0 0 1 9.5 8m-3 4A1.5 1.5 0 0 1 5 10.5A1.5 1.5 0 0 1 6.5 9A1.5 1.5 0 0 1 8 10.5A1.5 1.5 0 0 1 6.5 12M12 3a9 9 0 0 0-9 9a9 9 0 0 0 9 9a1.5 1.5 0 0 0 1.5-1.5c0-.39-.15-.74-.39-1c-.23-.27-.38-.62-.38-1a1.5 1.5 0 0 1 1.5-1.5H16a5 5 0 0 0 5-5c0-4.42-4.03-8-9-8",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const JD = u.markRaw({ name: "mdi-palette", render: GD }),
    YD = { class: "grid grid-cols-9 gap-1.5 p-2 pt-1" },
    XD = ["title", "onClick"],
    ZD = { class: "p-1" },
    QD = {
      class:
        "flex items-center rounded cursor-pointer hover:bg-gray-100 p-1 justify-between",
    },
    eL = { class: "inline-flex items-center gap-2" },
    tL = { class: "text-xs text-gray-600" },
    Wc = u.defineComponent({
      __name: "ColorPickerDropdown",
      props: { modelValue: { default: void 0 } },
      emits: ["update:modelValue"],
      setup(t, { emit: e }) {
        const n = e;
        function r() {
          const s = [],
            a = Object.keys(p3).reduce(
              (l, c) => (
                [
                  "gray",
                  "red",
                  "orange",
                  "yellow",
                  "green",
                  "blue",
                  "purple",
                  "pink",
                ].includes(c) && (l[c] = p3[c]),
                l
              ),
              {}
            );
          for (const l in a) {
            const c = a[l],
              p = Object.entries(c)
                .filter(([h]) => parseInt(h) >= 100 && parseInt(h) <= 900)
                .sort((h, m) => parseInt(m[0]) - parseInt(h[0]))
                .map(([h, m]) => ({ color: m, name: `${l} ${h}` }));
            s.push(...p);
          }
          return s;
        }
        function o(s) {
          n("update:modelValue", s);
        }
        function i(s) {
          o(s.hex);
        }
        return (s, a) => (
          u.openBlock(),
          u.createBlock(
            u.unref(vo),
            { class: "inline-flex items-center" },
            {
              popper: u.withCtx(() => [
                u.renderSlot(s.$slots, "prefix"),
                u.createElementVNode("div", YD, [
                  (u.openBlock(!0),
                  u.createElementBlock(
                    u.Fragment,
                    null,
                    u.renderList(
                      r(),
                      (l) => (
                        u.openBlock(),
                        u.createElementBlock(
                          "div",
                          {
                            key: l.color,
                            style: u.normalizeStyle({
                              backgroundColor: l.color,
                            }),
                            class:
                              "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                            title: l.name,
                            onClick: (c) => o(l.color),
                          },
                          null,
                          12,
                          XD
                        )
                      )
                    ),
                    128
                  )),
                ]),
                u.createVNode(
                  u.unref(vo),
                  { placement: "right" },
                  {
                    popper: u.withCtx(() => [
                      u.createVNode(u.unref(Uc), {
                        "model-value": "#000",
                        "onUpdate:modelValue": i,
                      }),
                    ]),
                    default: u.withCtx(() => [
                      u.createElementVNode("div", ZD, [
                        u.createElementVNode("div", QD, [
                          u.createElementVNode("div", eL, [
                            u.createVNode(u.unref(JD)),
                            u.createElementVNode(
                              "span",
                              tL,
                              u.toDisplayString(
                                u
                                  .unref(T)
                                  .global.t(
                                    "editor.components.color_picker.more_color"
                                  )
                              ),
                              1
                            ),
                          ]),
                          u.createElementVNode("div", null, [
                            u.createVNode(u.unref(qD)),
                          ]),
                        ]),
                      ]),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              default: u.withCtx(() => [u.renderSlot(s.$slots, "default")]),
              _: 3,
            }
          )
        );
      },
    }),
    nL = { class: "p-1" },
    rL = { class: "text-xs text-gray-600" },
    oL = u.defineComponent({
      __name: "ColorToolbarItem",
      props: {
        editor: { default: void 0 },
        isActive: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        title: { default: void 0 },
        action: { type: Function, default: void 0 },
        icon: { default: void 0 },
      },
      setup(t) {
        const e = t;
        function n(o) {
          var i;
          o && ((i = e.editor) == null || i.chain().focus().setColor(o).run());
        }
        function r() {
          var o;
          (o = e.editor) == null || o.chain().focus().unsetColor().run();
        }
        return (o, i) => (
          u.openBlock(),
          u.createBlock(
            Wc,
            { "onUpdate:modelValue": n },
            {
              prefix: u.withCtx(() => [
                u.createElementVNode("div", nL, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: r,
                    },
                    [
                      i[0] ||
                        (i[0] = u.createElementVNode(
                          "div",
                          {
                            class:
                              "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black",
                          },
                          null,
                          -1
                        )),
                      u.createElementVNode(
                        "span",
                        rL,
                        u.toDisplayString(
                          u
                            .unref(T)
                            .global.t("editor.common.button.restore_default")
                        ),
                        1
                      ),
                    ]
                  ),
                ]),
              ]),
              default: u.withCtx(() => [
                u.createVNode(
                  u.unref($e),
                  u.normalizeProps(u.guardReactiveProps(e)),
                  null,
                  16
                ),
              ]),
              _: 1,
            }
          )
        );
      },
    }),
    h3 = O9.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 81,
              component: u.markRaw(oL),
              props: {
                editor: e,
                isActive: !1,
                icon: u.markRaw(r3),
                title: T.global.t("editor.common.color"),
              },
            };
          },
        };
      },
      addExtensions() {
        return [Nh];
      },
    }),
    iL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function sL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        iL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M2 4v3h5v12h3V7h5V4zm19 5h-9v3h3v7h3v-7h3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const aL = u.markRaw({ name: "mdi-format-size", render: sL }),
    m3 = we.create({
      name: "fontSize",
      addOptions() {
        return {
          types: ["textStyle"],
          getToolbarItems({ editor: t }) {
            return {
              priority: 31,
              component: u.markRaw($e),
              props: { editor: t, isActive: !1, icon: u.markRaw(aL) },
              children: [
                {
                  priority: 0,
                  component: u.markRaw(At),
                  props: {
                    editor: t,
                    isActive: !1,
                    title: T.global.t("editor.common.text.default"),
                    action: () => t.chain().focus().unsetFontSize().run(),
                  },
                },
                ...[8, 10, 12, 14, 16, 18, 20, 24, 30, 36, 48, 60, 72].map(
                  (e) => ({
                    priority: e,
                    component: u.markRaw(At),
                    props: {
                      editor: t,
                      isActive: !1,
                      title: `${e} px`,
                      action: () => t.chain().focus().setFontSize(e).run(),
                    },
                  })
                ),
              ],
            };
          },
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontSize: {
                default: null,
                parseHTML: (t) => t.style.fontSize || "",
                renderHTML: (t) =>
                  t.fontSize
                    ? {
                        style: `font-size: ${t.fontSize
                          .toString()
                          .replace("px", "")}px`,
                      }
                    : t,
              },
            },
          },
        ];
      },
      addCommands() {
        return {
          setFontSize:
            (t) =>
            ({ chain: e }) =>
              e().setMark("textStyle", { fontSize: t }).run(),
          unsetFontSize:
            () =>
            ({ chain: t }) =>
              t()
                .setMark("textStyle", { fontSize: null })
                .removeEmptyTextStyle()
                .run(),
        };
      },
      addExtensions() {
        return [Nh];
      },
    });
  function g3(t) {
    return encodeURIComponent(
      String(t).trim().toLowerCase().replace(/\s+/g, "-")
    );
  }
  const b3 = (t, e) => {
      const n = g3(t);
      let r = n;
      for (; e.includes(r); ) {
        const i = r.replace(n, "").match(/-(\d+)$/);
        i ? (r = `${n}-${Number(i[1]) + 1}`) : (r = `${n}-1`);
      }
      return r;
    },
    Hi = (t) => (e) => {
      if (t.depth)
        for (let r = t.depth; r > 0; r--)
          return e.delete(t.before(r), t.after(r)).scrollIntoView(), !0;
      else {
        const r = t.parent;
        if (!r.isTextblock && r.nodeSize)
          return e.setSelection(K.create(t.doc, t.pos)).deleteSelection(), !0;
      }
      const n = t.pos;
      return n ? (e.delete(n, n + t.node().nodeSize), !0) : !1;
    },
    Yo = (t, e) => {
      const { state: n } = e,
        r = n.selection.$anchor,
        o = !1;
      if (r.depth) {
        for (let i = r.depth; i > 0; i--)
          if (r.node(i).type.name === t)
            return (
              e.dispatchTransaction &&
                e.dispatchTransaction(
                  n.tr.delete(r.before(i), r.after(i)).scrollIntoView()
                ),
              !0
            );
      } else {
        const i = n.selection.node;
        if (i && i.type.name === t)
          return e.chain().deleteSelection().run(), !0;
      }
      {
        const i = r.pos;
        if (i) {
          const s = n.tr.doc.nodeAt(i);
          if (s && s.type.name === t)
            return (
              e.dispatchTransaction &&
                e.dispatchTransaction(n.tr.delete(i, i + s.nodeSize)),
              !0
            );
        }
      }
      return o;
    },
    zh = (t) =>
      t.extensionManager.extensions
        .filter((r) => {
          const o = { name: r.name, options: r.options, storage: r.storage },
            i = re(j(r, "group", o));
          return typeof i != "string" ? !1 : i.split(" ").includes("list");
        })
        .some((r) => Et(t.state, r.name)),
    y3 = (t) => lL(t) || cL(t),
    lL = (t) => {
      var r;
      const e = (r = t.type.createAndFill()) == null ? void 0 : r.toJSON(),
        n = t.toJSON();
      return JSON.stringify(e) === JSON.stringify(n);
    },
    cL = (t) =>
      t.type.name !== "paragraph" || t.childCount > 0
        ? !1
        : t.textContent.length === 0,
    uL = Pe.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return { HTMLAttributes: {} };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [{ tag: "p" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["p", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setParagraph:
            () =>
            ({ commands: t }) =>
              t.setNode(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
      },
    }),
    dL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function fL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        dL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "none",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "m3 8l3-3l3 3m-6 8l3 3l3-3M6 5v14m7-13h7m-7 6h7m-7 6h7",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const pL = u.markRaw({ name: "tabler-line-height", render: fL }),
    Xo = uL.extend({
      addAttributes() {
        return {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight,
            renderHTML: (t) => {
              const e = t.lineHeight;
              return e ? { style: `line-height: ${e}` } : {};
            },
          },
        };
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && n.tagName !== "P"; ) n = n.parentElement;
                return { el: n, dragDomOffset: { y: -1 } };
              },
              allowPropagationDownward: !0,
            };
          },
          getToolbarItems({ editor: e }) {
            var n;
            return {
              priority: 220,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: !!(
                  (n = e.getAttributes(Xo.name)) != null && n.lineHeight
                ),
                icon: u.markRaw(pL),
                title: T.global.t("editor.common.line_height"),
              },
              children: [0, 1, 1.5, 2, 2.5, 3].map((r) => {
                var o;
                return {
                  priority: r,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive:
                      ((o = e.getAttributes(Xo.name)) == null
                        ? void 0
                        : o.lineHeight) === r,
                    title: r
                      ? String(r)
                      : T.global.t("editor.common.text.default"),
                    action: () =>
                      e
                        .chain()
                        .focus()
                        .updateAttributes(Xo.name, { lineHeight: r })
                        .run(),
                  },
                };
              }),
            };
          },
        };
      },
      addKeyboardShortcuts() {
        return {
          Backspace: ({ editor: t }) => {
            const { state: e, view: n } = t,
              { selection: r } = e;
            if (zh(t) || !Et(e, Xo.name) || !(r instanceof U) || !r.empty)
              return !1;
            const { $from: o } = r;
            if (o.parentOffset !== 0) return !1;
            const i = o.before(o.depth);
            return y3(o.parent)
              ? hL(o, i, e, n.dispatch)
              : i === 0
              ? !1
              : mL(o, i, e, n.dispatch);
          },
        };
      },
    });
  function hL(t, e, n, r) {
    const { tr: o } = n;
    return Hi(t)(o) && r
      ? (e !== 0 && o.setSelection(U.near(o.doc.resolve(e - 1), -1)), r(o), !0)
      : !1;
  }
  function mL(t, e, n, r) {
    const { tr: o } = n;
    if (!r) return !1;
    const s = t.doc.resolve(e).nodeBefore;
    return !s || !s.type.isBlock || s.type.isText || s.type.name === Xo.name
      ? !1
      : Hi(t.doc.resolve(e - 1))(o)
      ? (r(o), !0)
      : !1;
  }
  const gL = Pe.create({
      name: "heading",
      addOptions() {
        return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
      },
      content: "inline*",
      group: "block",
      defining: !0,
      addAttributes() {
        return { level: { default: 1, rendered: !1 } };
      },
      parseHTML() {
        return this.options.levels.map((t) => ({
          tag: `h${t}`,
          attrs: { level: t },
        }));
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        return [
          `h${
            this.options.levels.includes(t.attrs.level)
              ? t.attrs.level
              : this.options.levels[0]
          }`,
          se(this.options.HTMLAttributes, e),
          0,
        ];
      },
      addCommands() {
        return {
          setHeading:
            (t) =>
            ({ commands: e }) =>
              this.options.levels.includes(t.level)
                ? e.setNode(this.name, t)
                : !1,
          toggleHeading:
            (t) =>
            ({ commands: e }) =>
              this.options.levels.includes(t.level)
                ? e.toggleNode(this.name, "paragraph", t)
                : !1,
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce(
          (t, e) => ({
            ...t,
            [`Mod-Alt-${e}`]: () =>
              this.editor.commands.toggleHeading({ level: e }),
          }),
          {}
        );
      },
      addInputRules() {
        return this.options.levels.map((t) =>
          Tc({
            find: new RegExp(
              `^(#{${Math.min(...this.options.levels)},${t}})\\s$`
            ),
            type: this.type,
            getAttributes: { level: t },
          })
        );
      },
    }),
    bL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function yL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        bL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm11 14v-2h2V6.31l-2.5 1.44V5.44L16 4h2v12h2v2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const _3 = u.markRaw({ name: "mdi-format-header-1", render: yL }),
    _L = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function kL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        _L,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm18 14h-6a2 2 0 0 1-2-2c0-.53.2-1 .54-1.36l4.87-5.23c.37-.36.59-.86.59-1.41a2 2 0 0 0-2-2a2 2 0 0 0-2 2h-2a4 4 0 0 1 4-4a4 4 0 0 1 4 4c0 1.1-.45 2.1-1.17 2.83L15 16h6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const k3 = u.markRaw({ name: "mdi-format-header-2", render: kL }),
    wL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function xL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        wL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-1h2v1h4v-4h-4v-2h4V6h-4v1h-2V6a2 2 0 0 1 2-2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const w3 = u.markRaw({ name: "mdi-format-header-3", render: xL }),
    CL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function vL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        CL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm15 14v-5h-5v-2l5-7h2v7h1v2h-1v5zm0-7V7.42L15.45 11z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const x3 = u.markRaw({ name: "mdi-format-header-4", render: vL }),
    EL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function AL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        EL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h5v2h-5v4h2a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2a2 2 0 0 1-2-2v-1h2v1h2a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const C3 = u.markRaw({ name: "mdi-format-header-5", render: AL }),
    SL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function ML(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        SL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v1h-2V6h-4v4h4a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 8v4h4v-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const v3 = u.markRaw({ name: "mdi-format-header-6", render: ML }),
    TL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function NL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        TL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm10 4h2.31l.32-3h2l-.32 3h2l.32-3h2l-.32 3H23v2h-1.9l-.2 2H23v2h-2.31l-.32 3h-2l.32-3h-2l-.32 3h-2l.32-3H13v-2h1.9l.2-2H13zm4.1 2l-.2 2h2l.2-2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const OL = u.markRaw({ name: "mdi-format-header-pound", render: NL }),
    RL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function DL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        RL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13 4a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2v6H9V4zm0 6a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2v4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const E3 = u.markRaw({ name: "mdi-format-paragraph", render: DL }),
    qc = gL.extend({
      renderHTML({ node: t, HTMLAttributes: e }) {
        return [
          `h${
            this.options.levels.includes(t.attrs.level)
              ? t.attrs.level
              : this.options.levels[0]
          }`,
          se(this.options.HTMLAttributes, e),
          0,
        ];
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 30,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("paragraph") || e.isActive("heading"),
                icon: u.markRaw(OL),
              },
              children: [
                {
                  priority: 10,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("paragraph"),
                    icon: u.markRaw(E3),
                    title: T.global.t("editor.common.heading.paragraph"),
                    action: () => e.chain().focus().setParagraph().run(),
                  },
                },
                {
                  priority: 20,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 1 }),
                    icon: u.markRaw(_3),
                    title: T.global.t("editor.common.heading.header1"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 1 }).run(),
                  },
                },
                {
                  priority: 30,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 2 }),
                    icon: u.markRaw(k3),
                    title: T.global.t("editor.common.heading.header2"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 2 }).run(),
                  },
                },
                {
                  priority: 40,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 3 }),
                    icon: u.markRaw(w3),
                    title: T.global.t("editor.common.heading.header3"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 3 }).run(),
                  },
                },
                {
                  priority: 50,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 4 }),
                    icon: u.markRaw(x3),
                    title: T.global.t("editor.common.heading.header4"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 4 }).run(),
                  },
                },
                {
                  priority: 60,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 5 }),
                    icon: u.markRaw(C3),
                    title: T.global.t("editor.common.heading.header5"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 5 }).run(),
                  },
                },
                {
                  priority: 70,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive("heading", { level: 6 }),
                    icon: u.markRaw(v3),
                    title: T.global.t("editor.common.heading.header6"),
                    action: () =>
                      e.chain().focus().toggleHeading({ level: 6 }).run(),
                  },
                },
              ],
            };
          },
          getCommandMenuItems() {
            return [
              {
                priority: 10,
                icon: u.markRaw(E3),
                title: "editor.common.heading.paragraph",
                keywords: ["paragraph", "text", "putongwenben"],
                command: ({ editor: e, range: n }) => {
                  e.chain().focus().deleteRange(n).setParagraph().run();
                },
              },
              {
                priority: 20,
                icon: u.markRaw(_3),
                title: "editor.common.heading.header1",
                keywords: ["h1", "header1", "1", "yijibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 1 })
                    .run();
                },
              },
              {
                priority: 30,
                icon: u.markRaw(k3),
                title: "editor.common.heading.header2",
                keywords: ["h2", "header2", "2", "erjibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 2 })
                    .run();
                },
              },
              {
                priority: 40,
                icon: u.markRaw(w3),
                title: "editor.common.heading.header3",
                keywords: ["h3", "header3", "3", "sanjibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 3 })
                    .run();
                },
              },
              {
                priority: 50,
                icon: u.markRaw(x3),
                title: "editor.common.heading.header4",
                keywords: ["h4", "header4", "4", "sijibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 4 })
                    .run();
                },
              },
              {
                priority: 60,
                icon: u.markRaw(C3),
                title: "editor.common.heading.header5",
                keywords: ["h5", "header5", "5", "wujibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 5 })
                    .run();
                },
              },
              {
                priority: 70,
                icon: u.markRaw(v3),
                title: "editor.common.heading.header6",
                keywords: ["h6", "header6", "6", "liujibiaoti"],
                command: ({ editor: e, range: n }) => {
                  e.chain()
                    .focus()
                    .deleteRange(n)
                    .setNode("heading", { level: 6 })
                    .run();
                },
              },
            ];
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                const n = ["H1", "H2", "H3", "H4", "H5", "H6"];
                let r = e;
                for (; r && !n.includes(r.tagName); ) r = r.parentElement;
                if (!r) return { el: e };
                let o;
                switch (r == null ? void 0 : r.tagName) {
                  case "H1":
                    o = 10;
                    break;
                  case "H2":
                    o = 2;
                    break;
                  case "H3":
                    o = 0;
                    break;
                  case "H4":
                    o = -3;
                    break;
                  case "H5":
                    o = -5;
                    break;
                  case "H6":
                    o = -5;
                    break;
                  default:
                    o = 0;
                    break;
                }
                return { el: r, dragDomOffset: { y: o } };
              },
            };
          },
        };
      },
      addExtensions() {
        return [Xo];
      },
      addProseMirrorPlugins() {
        let t;
        return [
          new ie({
            key: new de("generate-heading-id"),
            appendTransaction: (e, n, r) => {
              if (
                e.some((i) => {
                  const s = this.editor.view.composing;
                  if (t !== void 0 && !s) return (t = void 0), !0;
                  if (i.docChanged) {
                    if (i.getMeta("paste")) return !0;
                    t = s;
                    const a = i.selection,
                      { $from: l } = a;
                    return l.parent.type.name === qc.name && !s;
                  }
                  return !1;
                })
              ) {
                const i = r.tr,
                  s = [];
                return (
                  r.doc.descendants((a, l) => {
                    if (a.type.name === qc.name) {
                      const c = b3(a.textContent, s);
                      i.step(new $r(l, "id", c)), s.push(c);
                    }
                  }),
                  i
                );
              }
            },
          }),
        ];
      },
    }),
    LL = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/,
    IL = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g,
    BL = vt.create({
      name: "highlight",
      addOptions() {
        return { multicolor: !1, HTMLAttributes: {} };
      },
      addAttributes() {
        return this.options.multicolor
          ? {
              color: {
                default: null,
                parseHTML: (t) =>
                  t.getAttribute("data-color") || t.style.backgroundColor,
                renderHTML: (t) =>
                  t.color
                    ? {
                        "data-color": t.color,
                        style: `background-color: ${t.color}; color: inherit`,
                      }
                    : {},
              },
            }
          : {};
      },
      parseHTML() {
        return [{ tag: "mark" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["mark", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setHighlight:
            (t) =>
            ({ commands: e }) =>
              e.setMark(this.name, t),
          toggleHighlight:
            (t) =>
            ({ commands: e }) =>
              e.toggleMark(this.name, t),
          unsetHighlight:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Shift-h": () => this.editor.commands.toggleHighlight() };
      },
      addInputRules() {
        return [no({ find: LL, type: this.type })];
      },
      addPasteRules() {
        return [yr({ find: IL, type: this.type })];
      },
    }),
    PL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function $L(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        PL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m4 17l2.75-2.75l-.03-.02c-.58-.59-.58-1.54 0-2.12l4.74-4.74l4.24 4.24l-4.74 4.74c-.57.58-1.5.58-2.09.02l-.63.63zM15.91 2.91c.59-.58 1.54-.58 2.12 0l2.13 2.12c.58.59.58 1.54 0 2.13l-3.3 3.29l-4.24-4.24z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const A3 = u.markRaw({ name: "mdi-format-color-highlight", render: $L }),
    FL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function HL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        FL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16.5 8C14 8 12 10 12 12.5s2 4.5 4.5 4.5s4.5-2 4.5-4.5S19 8 16.5 8m0 7.5c-1.7 0-3-1.3-3-3c0-.6.2-1.1.4-1.5l4.1 4.1c-.4.2-.9.4-1.5.4m2.6-1.5L15 9.9c.4-.3.9-.4 1.5-.4c1.7 0 3 1.3 3 3c0 .6-.2 1.1-.4 1.5m-7-6.3l-1.5-1.5l3.3-3.3c.6-.6 1.5-.6 2.1 0L18.2 5c.4.4.5.8.4 1.3c-.6-.2-1.3-.3-2-.3c-1.8 0-3.3.7-4.5 1.7m-1.6 7.2L9 16.3c-.6.6-1.5.6-2.1 0l-.7.7H2l2.8-2.8c-.6-.6-.6-1.5 0-2.1l4.7-4.7L11.1 9c-.7 1-1.1 2.2-1.1 3.5c0 .8.2 1.6.5 2.4",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const S3 = u.markRaw({ name: "mdi-format-color-marker-cancel", render: HL }),
    zL = { class: "p-1" },
    VL = { class: "inline-flex items-center gap-2" },
    UL = { class: "text-xs text-gray-600" },
    jL = { class: "p-1" },
    WL = { class: "text-xs text-gray-600" },
    qL = u.defineComponent({
      __name: "HighlightToolbarItem",
      props: {
        editor: { default: void 0 },
        isActive: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        title: { default: void 0 },
        action: { type: Function, default: void 0 },
        icon: { default: void 0 },
      },
      setup(t) {
        const e = t;
        function n(o) {
          var i;
          (i = e.editor) == null ||
            i
              .chain()
              .focus()
              .setHighlight(o ? { color: o } : void 0)
              .run();
        }
        function r() {
          var o;
          (o = e.editor) == null || o.chain().focus().unsetHighlight().run();
        }
        return (o, i) => (
          u.openBlock(),
          u.createBlock(
            Wc,
            { "onUpdate:modelValue": n },
            {
              prefix: u.withCtx(() => [
                u.createElementVNode("div", zL, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: r,
                    },
                    [
                      u.createElementVNode("div", VL, [
                        u.createVNode(u.unref(S3)),
                        u.createElementVNode(
                          "span",
                          UL,
                          u.toDisplayString(
                            u
                              .unref(T)
                              .global.t("editor.extensions.highlight.unset")
                          ),
                          1
                        ),
                      ]),
                    ]
                  ),
                ]),
                u.createElementVNode("div", jL, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: i[1] || (i[1] = (s) => n()),
                    },
                    [
                      i[2] ||
                        (i[2] = u.createElementVNode(
                          "div",
                          {
                            class:
                              "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                            style: { "background-color": "#fff8c5" },
                          },
                          null,
                          -1
                        )),
                      u.createElementVNode(
                        "span",
                        WL,
                        u.toDisplayString(
                          u
                            .unref(T)
                            .global.t("editor.common.button.restore_default")
                        ),
                        1
                      ),
                    ]
                  ),
                ]),
              ]),
              default: u.withCtx(() => [
                u.createVNode(
                  u.unref($e),
                  u.mergeProps(e, { onClick: i[0] || (i[0] = (s) => n()) }),
                  null,
                  16
                ),
              ]),
              _: 1,
            }
          )
        );
      },
    }),
    M3 = BL.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 80,
              component: u.markRaw(qL),
              props: {
                editor: e,
                isActive: e.isActive("highlight"),
                icon: u.markRaw(A3),
                title: T.global.t("editor.common.highlight"),
              },
            };
          },
        };
      },
    }).configure({ multicolor: !0 }),
    KL = we.create({
      name: "history",
      addOptions() {
        return { depth: 100, newGroupDelay: 500 };
      },
      addCommands() {
        return {
          undo:
            () =>
            ({ state: t, dispatch: e }) =>
              Hs(t, e),
          redo:
            () =>
            ({ state: t, dispatch: e }) =>
              zs(t, e),
        };
      },
      addProseMirrorPlugins() {
        return [gb(this.options)];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          "Mod-я": () => this.editor.commands.undo(),
          "Shift-Mod-я": () => this.editor.commands.redo(),
        };
      },
    }),
    GL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function JL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        GL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10.5 7A6.5 6.5 0 0 0 4 13.5a6.5 6.5 0 0 0 6.5 6.5H14v-2h-3.5C8 18 6 16 6 13.5S8 9 10.5 9h5.67l-3.08 3.09l1.41 1.41L20 8l-5.5-5.5l-1.42 1.41L16.17 7zM18 18h-2v2h2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const YL = u.markRaw({ name: "mdi-redo-variant", render: JL }),
    XL = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function ZL(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        XL,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13.5 7a6.5 6.5 0 0 1 6.5 6.5a6.5 6.5 0 0 1-6.5 6.5H10v-2h3.5c2.5 0 4.5-2 4.5-4.5S16 9 13.5 9H7.83l3.08 3.09L9.5 13.5L4 8l5.5-5.5l1.42 1.41L7.83 7zM6 18h2v2H6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const QL = u.markRaw({ name: "mdi-undo-variant", render: ZL }),
    T3 = KL.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return [
              {
                priority: 10,
                component: u.markRaw($e),
                props: {
                  editor: e,
                  isActive: !1,
                  icon: u.markRaw(QL),
                  title: T.global.t("editor.menus.undo"),
                  action: () => e.chain().undo().focus().run(),
                },
              },
              {
                priority: 20,
                component: u.markRaw($e),
                props: {
                  editor: e,
                  isActive: !1,
                  icon: u.markRaw(YL),
                  title: T.global.t("editor.menus.redo"),
                  action: () => e.chain().redo().focus().run(),
                },
              },
            ];
          },
        };
      },
    }),
    e7 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
    t7 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
    n7 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
    r7 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
    o7 = vt.create({
      name: "italic",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "em" },
          { tag: "i", getAttrs: (t) => t.style.fontStyle !== "normal" && null },
          {
            style: "font-style=normal",
            clearMark: (t) => t.type.name === this.name,
          },
          { style: "font-style=italic" },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["em", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setItalic:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleItalic:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetItalic:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic(),
        };
      },
      addInputRules() {
        return [
          no({ find: e7, type: this.type }),
          no({ find: n7, type: this.type }),
        ];
      },
      addPasteRules() {
        return [
          yr({ find: t7, type: this.type }),
          yr({ find: r7, type: this.type }),
        ];
      },
    }),
    i7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function s7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        i7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const N3 = u.markRaw({ name: "mdi-format-italic", render: s7 }),
    O3 = o7.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 50,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("italic"),
                icon: u.markRaw(N3),
                title: T.global.t("editor.common.italic"),
                action: () => e.chain().focus().toggleItalic().run(),
              },
            };
          },
        };
      },
    }),
    a7 =
      "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
    l7 =
      "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2",
    zi = (t, e) => {
      for (const n in e) t[n] = e[n];
      return t;
    },
    Vh = "numeric",
    Uh = "ascii",
    jh = "alpha",
    va = "asciinumeric",
    Ea = "alphanumeric",
    Wh = "domain",
    R3 = "emoji",
    c7 = "scheme",
    u7 = "slashscheme",
    qh = "whitespace";
  function d7(t, e) {
    return t in e || (e[t] = []), e[t];
  }
  function Zo(t, e, n) {
    e[Vh] && ((e[va] = !0), (e[Ea] = !0)),
      e[Uh] && ((e[va] = !0), (e[jh] = !0)),
      e[va] && (e[Ea] = !0),
      e[jh] && (e[Ea] = !0),
      e[Ea] && (e[Wh] = !0),
      e[R3] && (e[Wh] = !0);
    for (const r in e) {
      const o = d7(r, n);
      o.indexOf(t) < 0 && o.push(t);
    }
  }
  function f7(t, e) {
    const n = {};
    for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
    return n;
  }
  function Ft(t = null) {
    (this.j = {}), (this.jr = []), (this.jd = null), (this.t = t);
  }
  (Ft.groups = {}),
    (Ft.prototype = {
      accepts() {
        return !!this.t;
      },
      go(t) {
        const e = this,
          n = e.j[t];
        if (n) return n;
        for (let r = 0; r < e.jr.length; r++) {
          const o = e.jr[r][0],
            i = e.jr[r][1];
          if (i && o.test(t)) return i;
        }
        return e.jd;
      },
      has(t, e = !1) {
        return e ? t in this.j : !!this.go(t);
      },
      ta(t, e, n, r) {
        for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
      },
      tr(t, e, n, r) {
        r = r || Ft.groups;
        let o;
        return (
          e && e.j ? (o = e) : ((o = new Ft(e)), n && r && Zo(e, n, r)),
          this.jr.push([t, o]),
          o
        );
      },
      ts(t, e, n, r) {
        let o = this;
        const i = t.length;
        if (!i) return o;
        for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
        return o.tt(t[i - 1], e, n, r);
      },
      tt(t, e, n, r) {
        r = r || Ft.groups;
        const o = this;
        if (e && e.j) return (o.j[t] = e), e;
        const i = e;
        let s,
          a = o.go(t);
        if (
          (a
            ? ((s = new Ft()),
              zi(s.j, a.j),
              s.jr.push.apply(s.jr, a.jr),
              (s.jd = a.jd),
              (s.t = a.t))
            : (s = new Ft()),
          i)
        ) {
          if (r)
            if (s.t && typeof s.t == "string") {
              const l = zi(f7(s.t, r), n);
              Zo(i, l, r);
            } else n && Zo(i, n, r);
          s.t = i;
        }
        return (o.j[t] = s), s;
      },
    });
  const ae = (t, e, n, r, o) => t.ta(e, n, r, o),
    je = (t, e, n, r, o) => t.tr(e, n, r, o),
    D3 = (t, e, n, r, o) => t.ts(e, n, r, o),
    F = (t, e, n, r, o) => t.tt(e, n, r, o),
    wr = "WORD",
    Kh = "UWORD",
    L3 = "ASCIINUMERICAL",
    I3 = "ALPHANUMERICAL",
    Aa = "LOCALHOST",
    Gh = "TLD",
    Jh = "UTLD",
    Kc = "SCHEME",
    Vi = "SLASH_SCHEME",
    Yh = "NUM",
    Xh = "WS",
    Zh = "NL",
    Sa = "OPENBRACE",
    Ma = "CLOSEBRACE",
    Gc = "OPENBRACKET",
    Jc = "CLOSEBRACKET",
    Yc = "OPENPAREN",
    Xc = "CLOSEPAREN",
    Zc = "OPENANGLEBRACKET",
    Qc = "CLOSEANGLEBRACKET",
    eu = "FULLWIDTHLEFTPAREN",
    tu = "FULLWIDTHRIGHTPAREN",
    nu = "LEFTCORNERBRACKET",
    ru = "RIGHTCORNERBRACKET",
    ou = "LEFTWHITECORNERBRACKET",
    iu = "RIGHTWHITECORNERBRACKET",
    su = "FULLWIDTHLESSTHAN",
    au = "FULLWIDTHGREATERTHAN",
    lu = "AMPERSAND",
    Qh = "APOSTROPHE",
    cu = "ASTERISK",
    lo = "AT",
    uu = "BACKSLASH",
    du = "BACKTICK",
    fu = "CARET",
    co = "COLON",
    e0 = "COMMA",
    pu = "DOLLAR",
    Xn = "DOT",
    hu = "EQUALS",
    t0 = "EXCLAMATION",
    fn = "HYPHEN",
    Ta = "PERCENT",
    mu = "PIPE",
    gu = "PLUS",
    bu = "POUND",
    Na = "QUERY",
    n0 = "QUOTE",
    B3 = "FULLWIDTHMIDDLEDOT",
    r0 = "SEMI",
    Zn = "SLASH",
    Oa = "TILDE",
    yu = "UNDERSCORE",
    P3 = "EMOJI",
    _u = "SYM";
  var $3 = Object.freeze({
    __proto__: null,
    WORD: wr,
    UWORD: Kh,
    ASCIINUMERICAL: L3,
    ALPHANUMERICAL: I3,
    LOCALHOST: Aa,
    TLD: Gh,
    UTLD: Jh,
    SCHEME: Kc,
    SLASH_SCHEME: Vi,
    NUM: Yh,
    WS: Xh,
    NL: Zh,
    OPENBRACE: Sa,
    CLOSEBRACE: Ma,
    OPENBRACKET: Gc,
    CLOSEBRACKET: Jc,
    OPENPAREN: Yc,
    CLOSEPAREN: Xc,
    OPENANGLEBRACKET: Zc,
    CLOSEANGLEBRACKET: Qc,
    FULLWIDTHLEFTPAREN: eu,
    FULLWIDTHRIGHTPAREN: tu,
    LEFTCORNERBRACKET: nu,
    RIGHTCORNERBRACKET: ru,
    LEFTWHITECORNERBRACKET: ou,
    RIGHTWHITECORNERBRACKET: iu,
    FULLWIDTHLESSTHAN: su,
    FULLWIDTHGREATERTHAN: au,
    AMPERSAND: lu,
    APOSTROPHE: Qh,
    ASTERISK: cu,
    AT: lo,
    BACKSLASH: uu,
    BACKTICK: du,
    CARET: fu,
    COLON: co,
    COMMA: e0,
    DOLLAR: pu,
    DOT: Xn,
    EQUALS: hu,
    EXCLAMATION: t0,
    HYPHEN: fn,
    PERCENT: Ta,
    PIPE: mu,
    PLUS: gu,
    POUND: bu,
    QUERY: Na,
    QUOTE: n0,
    FULLWIDTHMIDDLEDOT: B3,
    SEMI: r0,
    SLASH: Zn,
    TILDE: Oa,
    UNDERSCORE: yu,
    EMOJI: P3,
    SYM: _u,
  });
  const xr = /[a-z]/,
    Ra = new RegExp("\\p{L}", "u"),
    o0 = new RegExp("\\p{Emoji}", "u"),
    Cr = /\d/,
    i0 = /\s/,
    F3 = "\r",
    s0 = `
`,
    p7 = "️",
    h7 = "‍",
    a0 = "￼";
  let ku = null,
    wu = null;
  function m7(t = []) {
    const e = {};
    Ft.groups = e;
    const n = new Ft();
    ku == null && (ku = z3(a7)),
      wu == null && (wu = z3(l7)),
      F(n, "'", Qh),
      F(n, "{", Sa),
      F(n, "}", Ma),
      F(n, "[", Gc),
      F(n, "]", Jc),
      F(n, "(", Yc),
      F(n, ")", Xc),
      F(n, "<", Zc),
      F(n, ">", Qc),
      F(n, "（", eu),
      F(n, "）", tu),
      F(n, "「", nu),
      F(n, "」", ru),
      F(n, "『", ou),
      F(n, "』", iu),
      F(n, "＜", su),
      F(n, "＞", au),
      F(n, "&", lu),
      F(n, "*", cu),
      F(n, "@", lo),
      F(n, "`", du),
      F(n, "^", fu),
      F(n, ":", co),
      F(n, ",", e0),
      F(n, "$", pu),
      F(n, ".", Xn),
      F(n, "=", hu),
      F(n, "!", t0),
      F(n, "-", fn),
      F(n, "%", Ta),
      F(n, "|", mu),
      F(n, "+", gu),
      F(n, "#", bu),
      F(n, "?", Na),
      F(n, '"', n0),
      F(n, "/", Zn),
      F(n, ";", r0),
      F(n, "~", Oa),
      F(n, "_", yu),
      F(n, "\\", uu),
      F(n, "・", B3);
    const r = je(n, Cr, Yh, { [Vh]: !0 });
    je(r, Cr, r);
    const o = je(r, xr, L3, { [va]: !0 }),
      i = je(r, Ra, I3, { [Ea]: !0 }),
      s = je(n, xr, wr, { [Uh]: !0 });
    je(s, Cr, o), je(s, xr, s), je(o, Cr, o), je(o, xr, o);
    const a = je(n, Ra, Kh, { [jh]: !0 });
    je(a, xr),
      je(a, Cr, i),
      je(a, Ra, a),
      je(i, Cr, i),
      je(i, xr),
      je(i, Ra, i);
    const l = F(n, s0, Zh, { [qh]: !0 }),
      c = F(n, F3, Xh, { [qh]: !0 }),
      d = je(n, i0, Xh, { [qh]: !0 });
    F(n, a0, d),
      F(c, s0, l),
      F(c, a0, d),
      je(c, i0, d),
      F(d, F3),
      F(d, s0),
      je(d, i0, d),
      F(d, a0, d);
    const f = je(n, o0, P3, { [R3]: !0 });
    F(f, "#"), je(f, o0, f), F(f, p7, f);
    const p = F(f, h7);
    F(p, "#"), je(p, o0, f);
    const h = [
        [xr, s],
        [Cr, o],
      ],
      m = [
        [xr, null],
        [Ra, a],
        [Cr, i],
      ];
    for (let g = 0; g < ku.length; g++) uo(n, ku[g], Gh, wr, h);
    for (let g = 0; g < wu.length; g++) uo(n, wu[g], Jh, Kh, m);
    Zo(Gh, { tld: !0, ascii: !0 }, e),
      Zo(Jh, { utld: !0, alpha: !0 }, e),
      uo(n, "file", Kc, wr, h),
      uo(n, "mailto", Kc, wr, h),
      uo(n, "http", Vi, wr, h),
      uo(n, "https", Vi, wr, h),
      uo(n, "ftp", Vi, wr, h),
      uo(n, "ftps", Vi, wr, h),
      Zo(Kc, { scheme: !0, ascii: !0 }, e),
      Zo(Vi, { slashscheme: !0, ascii: !0 }, e),
      (t = t.sort((g, b) => (g[0] > b[0] ? 1 : -1)));
    for (let g = 0; g < t.length; g++) {
      const b = t[g][0],
        x = t[g][1] ? { [c7]: !0 } : { [u7]: !0 };
      b.indexOf("-") >= 0
        ? (x[Wh] = !0)
        : xr.test(b)
        ? Cr.test(b)
          ? (x[va] = !0)
          : (x[Uh] = !0)
        : (x[Vh] = !0),
        D3(n, b, b, x);
    }
    return (
      D3(n, "localhost", Aa, { ascii: !0 }),
      (n.jd = new Ft(_u)),
      { start: n, tokens: zi({ groups: e }, $3) }
    );
  }
  function H3(t, e) {
    const n = g7(e.replace(/[A-Z]/g, (a) => a.toLowerCase())),
      r = n.length,
      o = [];
    let i = 0,
      s = 0;
    for (; s < r; ) {
      let a = t,
        l = null,
        c = 0,
        d = null,
        f = -1,
        p = -1;
      for (; s < r && (l = a.go(n[s])); )
        (a = l),
          a.accepts()
            ? ((f = 0), (p = 0), (d = a))
            : f >= 0 && ((f += n[s].length), p++),
          (c += n[s].length),
          (i += n[s].length),
          s++;
      (i -= f),
        (s -= p),
        (c -= f),
        o.push({ t: d.t, v: e.slice(i - c, i), s: i - c, e: i });
    }
    return o;
  }
  function g7(t) {
    const e = [],
      n = t.length;
    let r = 0;
    for (; r < n; ) {
      let o = t.charCodeAt(r),
        i,
        s =
          o < 55296 ||
          o > 56319 ||
          r + 1 === n ||
          (i = t.charCodeAt(r + 1)) < 56320 ||
          i > 57343
            ? t[r]
            : t.slice(r, r + 2);
      e.push(s), (r += s.length);
    }
    return e;
  }
  function uo(t, e, n, r, o) {
    let i;
    const s = e.length;
    for (let a = 0; a < s - 1; a++) {
      const l = e[a];
      t.j[l]
        ? (i = t.j[l])
        : ((i = new Ft(r)), (i.jr = o.slice()), (t.j[l] = i)),
        (t = i);
    }
    return (i = new Ft(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
  }
  function z3(t) {
    const e = [],
      n = [];
    let r = 0,
      o = "0123456789";
    for (; r < t.length; ) {
      let i = 0;
      for (; o.indexOf(t[r + i]) >= 0; ) i++;
      if (i > 0) {
        e.push(n.join(""));
        for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--) n.pop();
        r += i;
      } else n.push(t[r]), r++;
    }
    return e;
  }
  const Da = {
    defaultProtocol: "http",
    events: null,
    format: V3,
    formatHref: V3,
    nl2br: !1,
    tagName: "a",
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null,
  };
  function l0(t, e = null) {
    let n = zi({}, Da);
    t && (n = zi(n, t instanceof l0 ? t.o : t));
    const r = n.ignoreTags,
      o = [];
    for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
    (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
  }
  l0.prototype = {
    o: Da,
    ignoreTags: [],
    defaultRender(t) {
      return t;
    },
    check(t) {
      return this.get("validate", t.toString(), t);
    },
    get(t, e, n) {
      const r = e != null;
      let o = this.o[t];
      return (
        o &&
        (typeof o == "object"
          ? ((o = n.t in o ? o[n.t] : Da[t]),
            typeof o == "function" && r && (o = o(e, n)))
          : typeof o == "function" && r && (o = o(e, n.t, n)),
        o)
      );
    },
    getObj(t, e, n) {
      let r = this.o[t];
      return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
    },
    render(t) {
      const e = t.render(this);
      return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
    },
  };
  function V3(t) {
    return t;
  }
  function U3(t, e) {
    (this.t = "token"), (this.v = t), (this.tk = e);
  }
  U3.prototype = {
    isLink: !1,
    toString() {
      return this.v;
    },
    toHref(t) {
      return this.toString();
    },
    toFormattedString(t) {
      const e = this.toString(),
        n = t.get("truncate", e, this),
        r = t.get("format", e, this);
      return n && r.length > n ? r.substring(0, n) + "…" : r;
    },
    toFormattedHref(t) {
      return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
    },
    startIndex() {
      return this.tk[0].s;
    },
    endIndex() {
      return this.tk[this.tk.length - 1].e;
    },
    toObject(t = Da.defaultProtocol) {
      return {
        type: this.t,
        value: this.toString(),
        isLink: this.isLink,
        href: this.toHref(t),
        start: this.startIndex(),
        end: this.endIndex(),
      };
    },
    toFormattedObject(t) {
      return {
        type: this.t,
        value: this.toFormattedString(t),
        isLink: this.isLink,
        href: this.toFormattedHref(t),
        start: this.startIndex(),
        end: this.endIndex(),
      };
    },
    validate(t) {
      return t.get("validate", this.toString(), this);
    },
    render(t) {
      const e = this,
        n = this.toHref(t.get("defaultProtocol")),
        r = t.get("formatHref", n, this),
        o = t.get("tagName", n, e),
        i = this.toFormattedString(t),
        s = {},
        a = t.get("className", n, e),
        l = t.get("target", n, e),
        c = t.get("rel", n, e),
        d = t.getObj("attributes", n, e),
        f = t.getObj("events", n, e);
      return (
        (s.href = r),
        a && (s.class = a),
        l && (s.target = l),
        c && (s.rel = c),
        d && zi(s, d),
        { tagName: o, attributes: s, content: i, eventListeners: f }
      );
    },
  };
  function xu(t, e) {
    class n extends U3 {
      constructor(o, i) {
        super(o, i), (this.t = t);
      }
    }
    for (const r in e) n.prototype[r] = e[r];
    return (n.t = t), n;
  }
  const j3 = xu("email", {
      isLink: !0,
      toHref() {
        return "mailto:" + this.toString();
      },
    }),
    W3 = xu("text"),
    b7 = xu("nl"),
    Cu = xu("url", {
      isLink: !0,
      toHref(t = Da.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${t}://${this.v}`;
      },
      hasProtocol() {
        const t = this.tk;
        return t.length >= 2 && t[0].t !== Aa && t[1].t === co;
      },
    }),
    pn = (t) => new Ft(t);
  function y7({ groups: t }) {
    const e = t.domain.concat([
        lu,
        cu,
        lo,
        uu,
        du,
        fu,
        pu,
        hu,
        fn,
        Yh,
        Ta,
        mu,
        gu,
        bu,
        Zn,
        _u,
        Oa,
        yu,
      ]),
      n = [
        co,
        e0,
        Xn,
        t0,
        Ta,
        Na,
        n0,
        r0,
        Zc,
        Qc,
        Sa,
        Ma,
        Jc,
        Gc,
        Yc,
        Xc,
        eu,
        tu,
        nu,
        ru,
        ou,
        iu,
        su,
        au,
      ],
      r = [
        lu,
        Qh,
        cu,
        uu,
        du,
        fu,
        pu,
        hu,
        fn,
        Sa,
        Ma,
        Ta,
        mu,
        gu,
        bu,
        Na,
        Zn,
        _u,
        Oa,
        yu,
      ],
      o = pn(),
      i = F(o, Oa);
    ae(i, r, i), ae(i, t.domain, i);
    const s = pn(),
      a = pn(),
      l = pn();
    ae(o, t.domain, s),
      ae(o, t.scheme, a),
      ae(o, t.slashscheme, l),
      ae(s, r, i),
      ae(s, t.domain, s);
    const c = F(s, lo);
    F(i, lo, c), F(a, lo, c), F(l, lo, c);
    const d = F(i, Xn);
    ae(d, r, i), ae(d, t.domain, i);
    const f = pn();
    ae(c, t.domain, f), ae(f, t.domain, f);
    const p = F(f, Xn);
    ae(p, t.domain, f);
    const h = pn(j3);
    ae(p, t.tld, h), ae(p, t.utld, h), F(c, Aa, h);
    const m = F(f, fn);
    F(m, fn, m),
      ae(m, t.domain, f),
      ae(h, t.domain, f),
      F(h, Xn, p),
      F(h, fn, m);
    const g = F(h, co);
    ae(g, t.numeric, j3);
    const b = F(s, fn),
      y = F(s, Xn);
    F(b, fn, b), ae(b, t.domain, s), ae(y, r, i), ae(y, t.domain, s);
    const x = pn(Cu);
    ae(y, t.tld, x),
      ae(y, t.utld, x),
      ae(x, t.domain, s),
      ae(x, r, i),
      F(x, Xn, y),
      F(x, fn, b),
      F(x, lo, c);
    const w = F(x, co),
      _ = pn(Cu);
    ae(w, t.numeric, _);
    const v = pn(Cu),
      C = pn();
    ae(v, e, v),
      ae(v, n, C),
      ae(C, e, v),
      ae(C, n, C),
      F(x, Zn, v),
      F(_, Zn, v);
    const S = F(a, co),
      N = F(l, co),
      M = F(N, Zn),
      L = F(M, Zn);
    ae(a, t.domain, s),
      F(a, Xn, y),
      F(a, fn, b),
      ae(l, t.domain, s),
      F(l, Xn, y),
      F(l, fn, b),
      ae(S, t.domain, v),
      F(S, Zn, v),
      F(S, Na, v),
      ae(L, t.domain, v),
      ae(L, e, v),
      F(L, Zn, v);
    const $ = [
      [Sa, Ma],
      [Gc, Jc],
      [Yc, Xc],
      [Zc, Qc],
      [eu, tu],
      [nu, ru],
      [ou, iu],
      [su, au],
    ];
    for (let B = 0; B < $.length; B++) {
      const [H, Q] = $[B],
        X = F(v, H);
      F(C, H, X), F(X, Q, v);
      const Y = pn(Cu);
      ae(X, e, Y);
      const Z = pn();
      ae(X, n),
        ae(Y, e, Y),
        ae(Y, n, Z),
        ae(Z, e, Y),
        ae(Z, n, Z),
        F(Y, Q, v),
        F(Z, Q, v);
    }
    return F(o, Aa, x), F(o, Zh, b7), { start: o, tokens: $3 };
  }
  function _7(t, e, n) {
    let r = n.length,
      o = 0,
      i = [],
      s = [];
    for (; o < r; ) {
      let a = t,
        l = null,
        c = null,
        d = 0,
        f = null,
        p = -1;
      for (; o < r && !(l = a.go(n[o].t)); ) s.push(n[o++]);
      for (; o < r && (c = l || a.go(n[o].t)); )
        (l = null),
          (a = c),
          a.accepts() ? ((p = 0), (f = a)) : p >= 0 && p++,
          o++,
          d++;
      if (p < 0) (o -= d), o < r && (s.push(n[o]), o++);
      else {
        s.length > 0 && (i.push(c0(W3, e, s)), (s = [])), (o -= p), (d -= p);
        const h = f.t,
          m = n.slice(o - d, o);
        i.push(c0(h, e, m));
      }
    }
    return s.length > 0 && i.push(c0(W3, e, s)), i;
  }
  function c0(t, e, n) {
    const r = n[0].s,
      o = n[n.length - 1].e,
      i = e.slice(r, o);
    return new t(i, n);
  }
  const k7 = (typeof console < "u" && console && console.warn) || (() => {}),
    w7 =
      "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
    Le = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: !1,
    };
  function x7() {
    return (
      (Ft.groups = {}),
      (Le.scanner = null),
      (Le.parser = null),
      (Le.tokenQueue = []),
      (Le.pluginQueue = []),
      (Le.customSchemes = []),
      (Le.initialized = !1),
      Le
    );
  }
  function q3(t, e = !1) {
    if (
      (Le.initialized &&
        k7(
          `linkifyjs: already initialized - will not register custom scheme "${t}" ${w7}`
        ),
      !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    )
      throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    Le.customSchemes.push([t, e]);
  }
  function C7() {
    Le.scanner = m7(Le.customSchemes);
    for (let t = 0; t < Le.tokenQueue.length; t++)
      Le.tokenQueue[t][1]({ scanner: Le.scanner });
    Le.parser = y7(Le.scanner.tokens);
    for (let t = 0; t < Le.pluginQueue.length; t++)
      Le.pluginQueue[t][1]({ scanner: Le.scanner, parser: Le.parser });
    return (Le.initialized = !0), Le;
  }
  function u0(t) {
    return (
      Le.initialized || C7(), _7(Le.parser.start, t, H3(Le.scanner.start, t))
    );
  }
  u0.scan = H3;
  function K3(t, e = null, n = null) {
    if (e && typeof e == "object") {
      if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
      (n = e), (e = null);
    }
    const r = new l0(n),
      o = u0(t),
      i = [];
    for (let s = 0; s < o.length; s++) {
      const a = o[s];
      a.isLink &&
        (!e || a.t === e) &&
        r.check(a) &&
        i.push(a.toFormattedObject(r));
    }
    return i;
  }
  function v7(t) {
    return t.length === 1
      ? t[0].isLink
      : t.length === 3 && t[1].isLink
      ? ["()", "[]"].includes(t[0].value + t[2].value)
      : !1;
  }
  function E7(t) {
    return new ie({
      key: new de("autolink"),
      appendTransaction: (e, n, r) => {
        const o = e.some((c) => c.docChanged) && !n.doc.eq(r.doc),
          i = e.some((c) => c.getMeta("preventAutolink"));
        if (!o || i) return;
        const { tr: s } = r,
          a = M_(n.doc, [...e]);
        if (
          (D_(a).forEach(({ newRange: c }) => {
            const d = N_(r.doc, c, (h) => h.isTextblock);
            let f, p;
            if (
              (d.length > 1
                ? ((f = d[0]),
                  (p = r.doc.textBetween(
                    f.pos,
                    f.pos + f.node.nodeSize,
                    void 0,
                    " "
                  )))
                : d.length &&
                  r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") &&
                  ((f = d[0]),
                  (p = r.doc.textBetween(f.pos, c.to, void 0, " "))),
              f && p)
            ) {
              const h = p.split(" ").filter((y) => y !== "");
              if (h.length <= 0) return !1;
              const m = h[h.length - 1],
                g = f.pos + p.lastIndexOf(m);
              if (!m) return !1;
              const b = u0(m).map((y) => y.toObject(t.defaultProtocol));
              if (!v7(b)) return !1;
              b.filter((y) => y.isLink)
                .map((y) => ({
                  ...y,
                  from: g + y.start + 1,
                  to: g + y.end + 1,
                }))
                .filter((y) =>
                  r.schema.marks.code
                    ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code)
                    : !0
                )
                .filter((y) => t.validate(y.value))
                .filter((y) => t.shouldAutoLink(y.value))
                .forEach((y) => {
                  Ec(y.from, y.to, r.doc).some((x) => x.mark.type === t.type) ||
                    s.addMark(y.from, y.to, t.type.create({ href: y.href }));
                });
            }
          }),
          !!s.steps.length)
        )
          return s;
      },
    });
  }
  function A7(t) {
    return new ie({
      key: new de("handleClickLink"),
      props: {
        handleClick: (e, n, r) => {
          var o, i;
          if (r.button !== 0 || !e.editable) return !1;
          let s = r.target;
          const a = [];
          for (; s.nodeName !== "DIV"; ) a.push(s), (s = s.parentNode);
          if (!a.find((p) => p.nodeName === "A")) return !1;
          const l = ch(e.state, t.type.name),
            c = r.target,
            d =
              (o = c == null ? void 0 : c.href) !== null && o !== void 0
                ? o
                : l.href,
            f =
              (i = c == null ? void 0 : c.target) !== null && i !== void 0
                ? i
                : l.target;
          return c && d ? (window.open(d, f), !0) : !1;
        },
      },
    });
  }
  function S7(t) {
    return new ie({
      key: new de("handlePasteLink"),
      props: {
        handlePaste: (e, n, r) => {
          const { state: o } = e,
            { selection: i } = o,
            { empty: s } = i;
          if (s) return !1;
          let a = "";
          r.content.forEach((c) => {
            a += c.textContent;
          });
          const l = K3(a, { defaultProtocol: t.defaultProtocol }).find(
            (c) => c.isLink && c.value === a
          );
          return !a || !l
            ? !1
            : t.editor.commands.setMark(t.type, { href: l.href });
        },
      },
    });
  }
  const M7 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
  function Qo(t, e) {
    const n = [
      "http",
      "https",
      "ftp",
      "ftps",
      "mailto",
      "tel",
      "callto",
      "sms",
      "cid",
      "xmpp",
    ];
    return (
      e &&
        e.forEach((r) => {
          const o = typeof r == "string" ? r : r.scheme;
          o && n.push(o);
        }),
      !t ||
        t
          .replace(M7, "")
          .match(
            new RegExp(
              `^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
              "i"
            )
          )
    );
  }
  const vu = vt
      .create({
        name: "link",
        priority: 1e3,
        keepOnSplit: !1,
        exitable: !0,
        onCreate() {
          this.options.validate &&
            !this.options.shouldAutoLink &&
            ((this.options.shouldAutoLink = this.options.validate),
            console.warn(
              "The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead."
            )),
            this.options.protocols.forEach((t) => {
              if (typeof t == "string") {
                q3(t);
                return;
              }
              q3(t.scheme, t.optionalSlashes);
            });
        },
        onDestroy() {
          x7();
        },
        inclusive() {
          return this.options.autolink;
        },
        addOptions() {
          return {
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            defaultProtocol: "http",
            HTMLAttributes: {
              target: "_blank",
              rel: "noopener noreferrer nofollow",
              class: null,
            },
            isAllowedUri: (t, e) => !!Qo(t, e.protocols),
            validate: (t) => !!t,
            shouldAutoLink: (t) => !!t,
          };
        },
        addAttributes() {
          return {
            href: {
              default: null,
              parseHTML(t) {
                return t.getAttribute("href");
              },
            },
            target: { default: this.options.HTMLAttributes.target },
            rel: { default: this.options.HTMLAttributes.rel },
            class: { default: this.options.HTMLAttributes.class },
          };
        },
        parseHTML() {
          return [
            {
              tag: "a[href]",
              getAttrs: (t) => {
                const e = t.getAttribute("href");
                return !e ||
                  !this.options.isAllowedUri(e, {
                    defaultValidate: (n) => !!Qo(n, this.options.protocols),
                    protocols: this.options.protocols,
                    defaultProtocol: this.options.defaultProtocol,
                  })
                  ? !1
                  : null;
              },
            },
          ];
        },
        renderHTML({ HTMLAttributes: t }) {
          return this.options.isAllowedUri(t.href, {
            defaultValidate: (e) => !!Qo(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol,
          })
            ? ["a", se(this.options.HTMLAttributes, t), 0]
            : ["a", se(this.options.HTMLAttributes, { ...t, href: "" }), 0];
        },
        addCommands() {
          return {
            setLink:
              (t) =>
              ({ chain: e }) => {
                const { href: n } = t;
                return this.options.isAllowedUri(n, {
                  defaultValidate: (r) => !!Qo(r, this.options.protocols),
                  protocols: this.options.protocols,
                  defaultProtocol: this.options.defaultProtocol,
                })
                  ? e()
                      .setMark(this.name, t)
                      .setMeta("preventAutolink", !0)
                      .run()
                  : !1;
              },
            toggleLink:
              (t) =>
              ({ chain: e }) => {
                const { href: n } = t;
                return this.options.isAllowedUri(n, {
                  defaultValidate: (r) => !!Qo(r, this.options.protocols),
                  protocols: this.options.protocols,
                  defaultProtocol: this.options.defaultProtocol,
                })
                  ? e()
                      .toggleMark(this.name, t, { extendEmptyMarkRange: !0 })
                      .setMeta("preventAutolink", !0)
                      .run()
                  : !1;
              },
            unsetLink:
              () =>
              ({ chain: t }) =>
                t()
                  .unsetMark(this.name, { extendEmptyMarkRange: !0 })
                  .setMeta("preventAutolink", !0)
                  .run(),
          };
        },
        addPasteRules() {
          return [
            yr({
              find: (t) => {
                const e = [];
                if (t) {
                  const { protocols: n, defaultProtocol: r } = this.options,
                    o = K3(t).filter(
                      (i) =>
                        i.isLink &&
                        this.options.isAllowedUri(i.value, {
                          defaultValidate: (s) => !!Qo(s, n),
                          protocols: n,
                          defaultProtocol: r,
                        })
                    );
                  o.length &&
                    o.forEach((i) =>
                      e.push({
                        text: i.value,
                        data: { href: i.href },
                        index: i.start,
                      })
                    );
                }
                return e;
              },
              type: this.type,
              getAttributes: (t) => {
                var e;
                return {
                  href: (e = t.data) === null || e === void 0 ? void 0 : e.href,
                };
              },
            }),
          ];
        },
        addProseMirrorPlugins() {
          const t = [],
            { protocols: e, defaultProtocol: n } = this.options;
          return (
            this.options.autolink &&
              t.push(
                E7({
                  type: this.type,
                  defaultProtocol: this.options.defaultProtocol,
                  validate: (r) =>
                    this.options.isAllowedUri(r, {
                      defaultValidate: (o) => !!Qo(o, e),
                      protocols: e,
                      defaultProtocol: n,
                    }),
                  shouldAutoLink: this.options.shouldAutoLink,
                })
              ),
            this.options.openOnClick === !0 && t.push(A7({ type: this.type })),
            this.options.linkOnPaste &&
              t.push(
                S7({
                  editor: this.editor,
                  defaultProtocol: this.options.defaultProtocol,
                  type: this.type,
                })
              ),
            t
          );
        },
      })
      .extend({
        addOptions() {
          var t;
          return {
            ...((t = this.parent) == null ? void 0 : t.call(this)),
            HTMLAttributes: { rel: null },
          };
        },
        addPasteRules() {
          return [];
        },
      }),
    La = (t, e) => {
      const { $from: n } = e.selection,
        r = Ke(t, e.schema);
      let o = null,
        i = n.depth,
        s = n.pos,
        a = null;
      for (; i > 0 && a === null; )
        (o = n.node(i)), o.type === r ? (a = i) : ((i -= 1), (s -= 1));
      return a === null ? null : { $pos: e.doc.resolve(s), depth: a };
    },
    d0 = (t, e) => {
      const n = La(t, e);
      if (!n) return !1;
      const [, r] = I_(e, t, n.$pos.pos + 4);
      return r;
    },
    G3 = (t, e, n) => {
      const { $anchor: r } = t.selection,
        o = Math.max(0, r.pos - 2),
        i = t.doc.resolve(o).node();
      return !(!i || !n.includes(i.type.name));
    },
    J3 = (t, e) => {
      var n;
      const { $anchor: r } = e.selection,
        o = e.doc.resolve(r.pos - 2);
      return !(
        o.index() === 0 ||
        ((n = o.nodeBefore) === null || n === void 0 ? void 0 : n.type.name) !==
          t
      );
    },
    Y3 = (t, e, n) => {
      if (!n) return !1;
      const r = Ke(t, e.schema);
      let o = !1;
      return (
        n.descendants((i) => {
          i.type === r && (o = !0);
        }),
        o
      );
    },
    f0 = (t, e, n) => {
      if (t.commands.undoInputRule()) return !0;
      if (t.state.selection.from !== t.state.selection.to) return !1;
      if (!Ut(t.state, e) && G3(t.state, e, n)) {
        const { $anchor: a } = t.state.selection,
          l = t.state.doc.resolve(a.before() - 1),
          c = [];
        l.node().descendants((p, h) => {
          p.type.name === e && c.push({ node: p, pos: h });
        });
        const d = c.at(-1);
        if (!d) return !1;
        const f = t.state.doc.resolve(l.start() + d.pos + 1);
        return t
          .chain()
          .cut({ from: a.start() - 1, to: a.end() + 1 }, f.end())
          .joinForward()
          .run();
      }
      if (!Ut(t.state, e) || !P_(t.state)) return !1;
      const r = La(e, t.state);
      if (!r) return !1;
      const i = t.state.doc.resolve(r.$pos.pos - 2).node(r.depth),
        s = Y3(e, t.state, i);
      return J3(e, t.state) && !s
        ? t.commands.joinItemBackward()
        : t.chain().liftListItem(e).run();
    },
    X3 = (t, e) => {
      const n = d0(t, e),
        r = La(t, e);
      return !r || !n ? !1 : n > r.depth;
    },
    Z3 = (t, e) => {
      const n = d0(t, e),
        r = La(t, e);
      return !r || !n ? !1 : n < r.depth;
    },
    p0 = (t, e) => {
      if (!Ut(t.state, e) || !B_(t.state, e)) return !1;
      const { selection: n } = t.state,
        { $from: r, $to: o } = n;
      return !n.empty && r.sameParent(o)
        ? !1
        : X3(e, t.state)
        ? t
            .chain()
            .focus(t.state.selection.from + 4)
            .lift(e)
            .joinBackward()
            .run()
        : Z3(e, t.state)
        ? t.chain().joinForward().joinBackward().run()
        : t.commands.joinItemForward();
    };
  var T7 = Object.freeze({
    __proto__: null,
    findListItemPos: La,
    getNextListDepth: d0,
    handleBackspace: f0,
    handleDelete: p0,
    hasListBefore: G3,
    hasListItemAfter: (t, e) => {
      var n;
      const { $anchor: r } = e.selection,
        o = e.doc.resolve(r.pos - r.parentOffset - 2);
      return !(
        o.index() === o.parent.childCount - 1 ||
        ((n = o.nodeAfter) === null || n === void 0 ? void 0 : n.type.name) !==
          t
      );
    },
    hasListItemBefore: J3,
    listItemHasSubList: Y3,
    nextListIsDeeper: X3,
    nextListIsHigher: Z3,
  });
  const N7 = we
      .create({
        name: "listKeymap",
        addOptions() {
          return {
            listTypes: [
              {
                itemName: "listItem",
                wrapperNames: ["bulletList", "orderedList"],
              },
              { itemName: "taskItem", wrapperNames: ["taskList"] },
            ],
          };
        },
        addKeyboardShortcuts() {
          return {
            Delete: ({ editor: t }) => {
              let e = !1;
              return (
                this.options.listTypes.forEach(({ itemName: n }) => {
                  t.state.schema.nodes[n] !== void 0 && p0(t, n) && (e = !0);
                }),
                e
              );
            },
            "Mod-Delete": ({ editor: t }) => {
              let e = !1;
              return (
                this.options.listTypes.forEach(({ itemName: n }) => {
                  t.state.schema.nodes[n] !== void 0 && p0(t, n) && (e = !0);
                }),
                e
              );
            },
            Backspace: ({ editor: t }) => {
              let e = !1;
              return (
                this.options.listTypes.forEach(
                  ({ itemName: n, wrapperNames: r }) => {
                    t.state.schema.nodes[n] !== void 0 &&
                      f0(t, n, r) &&
                      (e = !0);
                  }
                ),
                e
              );
            },
            "Mod-Backspace": ({ editor: t }) => {
              let e = !1;
              return (
                this.options.listTypes.forEach(
                  ({ itemName: n, wrapperNames: r }) => {
                    t.state.schema.nodes[n] !== void 0 &&
                      f0(t, n, r) &&
                      (e = !0);
                  }
                ),
                e
              );
            },
          };
        },
      })
      .extend({
        addKeyboardShortcuts() {
          const t = (e) => {
            let n = !1;
            return e.state.selection.empty
              ? (this.options.listTypes.forEach(
                  ({ itemName: r, wrapperNames: o }) => {
                    T7.handleBackspace(e, r, o) && (n = !0);
                  }
                ),
                n)
              : !1;
          };
          return {
            Backspace: ({ editor: e }) => t(e),
            "Mod-Backspace": ({ editor: e }) => t(e),
          };
        },
      }),
    O7 = "listItem",
    Q3 = "textStyle",
    ew = /^(\d+)\.\s$/,
    R7 = Pe.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: !1,
          keepAttributes: !1,
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (t) =>
              t.hasAttribute("start")
                ? parseInt(t.getAttribute("start") || "", 10)
                : 1,
          },
          type: { default: void 0, parseHTML: (t) => t.getAttribute("type") },
        };
      },
      parseHTML() {
        return [{ tag: "ol" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        const { start: e, ...n } = t;
        return e === 1
          ? ["ol", se(this.options.HTMLAttributes, n), 0]
          : ["ol", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          toggleOrderedList:
            () =>
            ({ commands: t, chain: e }) =>
              this.options.keepAttributes
                ? e()
                    .toggleList(
                      this.name,
                      this.options.itemTypeName,
                      this.options.keepMarks
                    )
                    .updateAttributes(O7, this.editor.getAttributes(Q3))
                    .run()
                : t.toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  ),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
        };
      },
      addInputRules() {
        let t = Wo({
          find: ew,
          type: this.type,
          getAttributes: (e) => ({ start: +e[1] }),
          joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
        });
        return (
          (this.options.keepMarks || this.options.keepAttributes) &&
            (t = Wo({
              find: ew,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: (e) => ({
                start: +e[1],
                ...this.editor.getAttributes(Q3),
              }),
              joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
              editor: this.editor,
            })),
          [t]
        );
      },
    }),
    D7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function L7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        D7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M7 13v-2h14v2zm0 6v-2h14v2zM7 7V5h14v2zM3 8V5H2V4h2v4zm-1 9v-1h3v4H2v-1h2v-.5H3v-1h1V17zm2.25-7a.75.75 0 0 1 .75.75c0 .2-.08.39-.21.52L3.12 13H5v1H2v-.92L4 11H2v-1z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const tw = u.markRaw({ name: "mdi-format-list-numbered", render: L7 }),
    nw = R7.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 140,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("orderedList"),
                icon: u.markRaw(tw),
                title: T.global.t("editor.common.ordered_list"),
                action: () => e.chain().focus().toggleOrderedList().run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 140,
              icon: u.markRaw(tw),
              title: "editor.common.ordered_list",
              keywords: ["orderedlist", "youxuliebiao"],
              command: ({ editor: e, range: n }) => {
                e.chain().focus().deleteRange(n).toggleOrderedList().run();
              },
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && n.tagName !== "LI"; ) n = n.parentElement;
                return { el: n, dragDomOffset: { x: -16, y: -1 } };
              },
            };
          },
        };
      },
      addExtensions() {
        return [Zk];
      },
    }),
    I7 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
    B7 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
    P7 = vt.create({
      name: "strike",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "s" },
          { tag: "del" },
          { tag: "strike" },
          {
            style: "text-decoration",
            consuming: !1,
            getAttrs: (t) => (t.includes("line-through") ? {} : !1),
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["s", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setStrike:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleStrike:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetStrike:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() };
      },
      addInputRules() {
        return [no({ find: I7, type: this.type })];
      },
      addPasteRules() {
        return [yr({ find: B7, type: this.type })];
      },
    }),
    $7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function F7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        $7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 14h18v-2H3m2-8v3h5v3h4V7h5V4m-9 15h4v-3h-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const rw = u.markRaw({ name: "mdi-format-strikethrough", render: F7 }),
    ow = P7.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 70,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("strike"),
                icon: u.markRaw(rw),
                title: T.global.t("editor.common.strike"),
                action: () => e.chain().focus().toggleStrike().run(),
              },
            };
          },
        };
      },
    }),
    H7 = vt.create({
      name: "subscript",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "sub" },
          {
            style: "vertical-align",
            getAttrs(t) {
              return t !== "sub" ? !1 : null;
            },
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["sub", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setSubscript:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleSubscript:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetSubscript:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-,": () => this.editor.commands.toggleSubscript() };
      },
    }),
    z7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function V7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        z7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zm5.85 13.62h-4.88v-1l.89-.8c.76-.65 1.32-1.19 1.7-1.63c.37-.44.56-.85.57-1.24a.9.9 0 0 0-.27-.7c-.18-.16-.47-.28-.86-.28c-.31 0-.58.06-.84.18l-.66.38l-.45-1.17c.27-.21.59-.39.98-.53s.82-.24 1.29-.24c.78.04 1.38.25 1.78.66s.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.47-.76.92-1.27 1.36l-.64.52v.02h2.58z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const iw = u.markRaw({ name: "mdi-format-subscript", render: V7 }),
    sw = H7.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 120,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("subscript"),
                icon: u.markRaw(iw),
                title: T.global.t("editor.common.subscript"),
                action: () => e.chain().focus().toggleSubscript().run(),
              },
            };
          },
        };
      },
    }),
    U7 = vt.create({
      name: "superscript",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "sup" },
          {
            style: "vertical-align",
            getAttrs(t) {
              return t !== "super" ? !1 : null;
            },
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["sup", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setSuperscript:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleSuperscript:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetSuperscript:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-.": () => this.editor.commands.toggleSuperscript() };
      },
    }),
    j7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function W7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        j7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zM21.85 9h-4.88V8l.89-.82c.76-.64 1.32-1.18 1.7-1.63q.555-.66.57-1.23a.88.88 0 0 0-.27-.7c-.18-.19-.47-.28-.86-.29c-.31.01-.58.07-.84.17l-.66.39l-.45-1.17c.27-.22.59-.39.98-.53S18.85 2 19.32 2c.78 0 1.38.2 1.78.61c.4.39.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.48-.76.93-1.27 1.36l-.64.52v.02h2.58z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const aw = u.markRaw({ name: "mdi-format-superscript", render: W7 }),
    lw = U7.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 110,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("superscript"),
                icon: u.markRaw(aw),
                title: T.global.t("editor.common.superscript"),
                action: () => e.chain().focus().toggleSuperscript().run(),
              },
            };
          },
        };
      },
    });
  function h0(t, e) {
    return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
  }
  function cw(t, e, n, r, o, i) {
    var s;
    let a = 0,
      l = !0,
      c = e.firstChild;
    const d = t.firstChild;
    if (d !== null)
      for (let f = 0, p = 0; f < d.childCount; f += 1) {
        const { colspan: h, colwidth: m } = d.child(f).attrs;
        for (let g = 0; g < h; g += 1, p += 1) {
          const b = o === p ? i : m && m[g],
            y = b ? `${b}px` : "";
          if (((a += b || r), b || (l = !1), c)) {
            if (c.style.width !== y) {
              const [x, w] = h0(r, b);
              c.style.setProperty(x, w);
            }
            c = c.nextSibling;
          } else {
            const x = document.createElement("col"),
              [w, _] = h0(r, b);
            x.style.setProperty(w, _), e.appendChild(x);
          }
        }
      }
    for (; c; ) {
      const f = c.nextSibling;
      (s = c.parentNode) === null || s === void 0 || s.removeChild(c), (c = f);
    }
    l
      ? ((n.style.width = `${a}px`), (n.style.minWidth = ""))
      : ((n.style.width = ""), (n.style.minWidth = `${a}px`));
  }
  let q7 = class {
    constructor(e, n) {
      (this.node = e),
        (this.cellMinWidth = n),
        (this.dom = document.createElement("div")),
        (this.dom.className = "tableWrapper"),
        (this.table = this.dom.appendChild(document.createElement("table"))),
        (this.colgroup = this.table.appendChild(
          document.createElement("colgroup")
        )),
        cw(e, this.colgroup, this.table, n),
        (this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        ));
    }
    update(e) {
      return e.type !== this.node.type
        ? !1
        : ((this.node = e),
          cw(e, this.colgroup, this.table, this.cellMinWidth),
          !0);
    }
    ignoreMutation(e) {
      return (
        e.type === "attributes" &&
        (e.target === this.table || this.colgroup.contains(e.target))
      );
    }
  };
  function uw(t, e, n, r) {
    let o = 0,
      i = !0;
    const s = [],
      a = t.firstChild;
    if (!a) return {};
    for (let f = 0, p = 0; f < a.childCount; f += 1) {
      const { colspan: h, colwidth: m } = a.child(f).attrs;
      for (let g = 0; g < h; g += 1, p += 1) {
        const b = n === p ? r : m && m[g];
        (o += b || e), b || (i = !1);
        const [y, x] = h0(e, b);
        s.push(["col", { style: `${y}: ${x}` }]);
      }
    }
    const l = i ? `${o}px` : "",
      c = i ? "" : `${o}px`;
    return {
      colgroup: ["colgroup", {}, ...s],
      tableWidth: l,
      tableMinWidth: c,
    };
  }
  function dw(t, e) {
    return t.createAndFill();
  }
  function K7(t) {
    if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
    const e = {};
    return (
      Object.keys(t.nodes).forEach((n) => {
        const r = t.nodes[n];
        r.spec.tableRole && (e[r.spec.tableRole] = r);
      }),
      (t.cached.tableNodeTypes = e),
      e
    );
  }
  function G7(t, e, n, r, o) {
    const i = K7(t),
      s = [],
      a = [];
    for (let c = 0; c < n; c += 1) {
      const d = dw(i.cell);
      if ((d && a.push(d), r)) {
        const f = dw(i.header_cell);
        f && s.push(f);
      }
    }
    const l = [];
    for (let c = 0; c < e; c += 1)
      l.push(i.row.createChecked(null, r && c === 0 ? s : a));
    return i.table.createChecked(null, l);
  }
  function J7(t) {
    return t instanceof ke;
  }
  const Eu = ({ editor: t }) => {
      const { selection: e } = t.state;
      if (!J7(e)) return !1;
      let n = 0;
      const r = lh(e.ranges[0].$from, (i) => i.type.name === "table");
      return (
        r == null ||
          r.node.descendants((i) => {
            if (i.type.name === "table") return !1;
            ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
          }),
        n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
      );
    },
    Y7 = Pe.create({
      name: "table",
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: !1,
          handleWidth: 5,
          cellMinWidth: 25,
          View: q7,
          lastColumnResizable: !0,
          allowTableNodeSelection: !1,
        };
      },
      content: "tableRow+",
      tableRole: "table",
      isolating: !0,
      group: "block",
      parseHTML() {
        return [{ tag: "table" }];
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        const {
          colgroup: n,
          tableWidth: r,
          tableMinWidth: o,
        } = uw(t, this.options.cellMinWidth);
        return [
          "table",
          se(this.options.HTMLAttributes, e, {
            style: r ? `width: ${r}` : `min-width: ${o}`,
          }),
          n,
          ["tbody", 0],
        ];
      },
      addCommands() {
        return {
          insertTable:
            ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) =>
            ({ tr: r, dispatch: o, editor: i }) => {
              const s = G7(i.schema, t, e, n);
              if (o) {
                const a = r.selection.from + 1;
                r.replaceSelectionWith(s)
                  .scrollIntoView()
                  .setSelection(U.near(r.doc.resolve(a)));
              }
              return !0;
            },
          addColumnBefore:
            () =>
            ({ state: t, dispatch: e }) =>
              Hy(t, e),
          addColumnAfter:
            () =>
            ({ state: t, dispatch: e }) =>
              Up(t, e),
          deleteColumn:
            () =>
            ({ state: t, dispatch: e }) =>
              Vy(t, e),
          addRowBefore:
            () =>
            ({ state: t, dispatch: e }) =>
              jy(t, e),
          addRowAfter:
            () =>
            ({ state: t, dispatch: e }) =>
              Wp(t, e),
          deleteRow:
            () =>
            ({ state: t, dispatch: e }) =>
              qy(t, e),
          deleteTable:
            () =>
            ({ state: t, dispatch: e }) =>
              Zy(t, e),
          mergeCells:
            () =>
            ({ state: t, dispatch: e }) =>
              qp(t, e),
          splitCell:
            () =>
            ({ state: t, dispatch: e }) =>
              Kp(t, e),
          toggleHeaderColumn:
            () =>
            ({ state: t, dispatch: e }) =>
              Ei("column")(t, e),
          toggleHeaderRow:
            () =>
            ({ state: t, dispatch: e }) =>
              Ei("row")(t, e),
          toggleHeaderCell:
            () =>
            ({ state: t, dispatch: e }) =>
              Xy(t, e),
          mergeOrSplit:
            () =>
            ({ state: t, dispatch: e }) =>
              qp(t, e) ? !0 : Kp(t, e),
          setCellAttribute:
            (t, e) =>
            ({ state: n, dispatch: r }) =>
              Jy(t, e)(n, r),
          goToNextCell:
            () =>
            ({ state: t, dispatch: e }) =>
              Gp(1)(t, e),
          goToPreviousCell:
            () =>
            ({ state: t, dispatch: e }) =>
              Gp(-1)(t, e),
          fixTables:
            () =>
            ({ state: t, dispatch: e }) => (e && zp(t), !0),
          setCellSelection:
            (t) =>
            ({ tr: e, dispatch: n }) => {
              if (n) {
                const r = ke.create(e.doc, t.anchorCell, t.headCell);
                e.setSelection(r);
              }
              return !0;
            },
        };
      },
      addKeyboardShortcuts() {
        return {
          Tab: () =>
            this.editor.commands.goToNextCell()
              ? !0
              : this.editor.can().addRowAfter()
              ? this.editor.chain().addRowAfter().goToNextCell().run()
              : !1,
          "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
          Backspace: Eu,
          "Mod-Backspace": Eu,
          Delete: Eu,
          "Mod-Delete": Eu,
        };
      },
      addProseMirrorPlugins() {
        return [
          ...(this.options.resizable && this.editor.isEditable
            ? [
                a_({
                  handleWidth: this.options.handleWidth,
                  cellMinWidth: this.options.cellMinWidth,
                  defaultCellMinWidth: this.options.cellMinWidth,
                  View: this.options.View,
                  lastColumnResizable: this.options.lastColumnResizable,
                }),
              ]
            : []),
          p_({ allowTableNodeSelection: this.options.allowTableNodeSelection }),
        ];
      },
      extendNodeSchema(t) {
        const e = { name: t.name, options: t.options, storage: t.storage };
        return { tableRole: re(j(t, "tableRole", e)) };
      },
    }),
    X7 = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function Z7(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        X7,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 6.25A3.25 3.25 0 0 1 6.25 3h11.5A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75zM6.25 4.5A1.75 1.75 0 0 0 4.5 6.25V8.5h4v-4zM4.5 10v4h4v-4zm5.5 0v4h4v-4zm5.5 0v4h4v-4zm0 9.5h2.25a1.75 1.75 0 0 0 1.75-1.75V15.5h-4zm0-11h4V6.25a1.75 1.75 0 0 0-1.75-1.75H15.5zm-11 7v2.25c0 .966.784 1.75 1.75 1.75H8.5v-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Q7 = u.markRaw({
      name: "fluent-table-column-top-bottom-24-regular",
      render: Z7,
    }),
    eI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function tI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        eI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M5 4h14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 4v4h6V8zm8 0v4h6V8zm-8 6v4h6v-4zm8 0v4h6v-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const nI = u.markRaw({ name: "mdi-table", render: tI }),
    rI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function oI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        rI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M11 2a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H2V2zm-7 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm11 7h3V8h2v3h3v2h-3v3h-2v-3h-3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const iI = u.markRaw({ name: "mdi-table-column-plus-after", render: oI }),
    sI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function aI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        sI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9V2zm7 8v4h-7v-4zm0 6v4h-7v-4zm0-12v4h-7V4zM9 11H6V8H4v3H1v2h3v3h2v-3h3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const lI = u.markRaw({ name: "mdi-table-column-plus-before", render: aI }),
    cI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function uI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        cI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M4 2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m0 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm13.59 8L15 9.41L16.41 8L19 10.59L21.59 8L23 9.41L20.41 12L23 14.59L21.59 16L19 13.41L16.41 16L15 14.59z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const dI = u.markRaw({ name: "mdi-table-column-remove", render: uI }),
    fI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function pI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        fI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M1 6v13a2 2 0 0 0 2 2h6V11h12V6a2 2 0 0 0-2-2H3a2 2 0 0 0-2 2m2 0h4v3H3m4 10H3v-3h4m0-2H3v-3h4m2-2V6h4v3m6 0h-4V6h4m-2 10a1 1 0 1 1-1 1a1 1 0 0 1 1-1m0-3a6.45 6.45 0 0 1 6 4a6.5 6.5 0 0 1-12 0a6.45 6.45 0 0 1 6-4m0 1.5a2.5 2.5 0 1 0 2.5 2.5a2.5 2.5 0 0 0-2.5-2.5",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const fw = u.markRaw({ name: "mdi-table-headers-eye", render: pI }),
    hI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function mI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        hI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M5 10H3V4h8v2H5zm14 8h-6v2h8v-6h-2zM5 18v-4H3v6h8v-2zM21 4h-8v2h6v4h2zM8 13v2l3-3l-3-3v2H3v2zm8-2V9l-3 3l3 3v-2h5v-2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const gI = u.markRaw({ name: "mdi-table-merge-cells", render: mI }),
    bI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function yI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        bI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M18 14h2v3h3v2h-3v3h-2v-3h-3v-2h3zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const _I = u.markRaw({ name: "mdi-table-plus", render: yI }),
    kI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function wI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        kI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m15.46 15.88l1.42-1.42L19 16.59l2.12-2.13l1.42 1.42L20.41 18l2.13 2.12l-1.42 1.42L19 19.41l-2.12 2.13l-1.42-1.42L17.59 18zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const xI = u.markRaw({ name: "mdi-table-remove", render: wI }),
    CI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function vI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        CI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M22 10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V3h2v2h4V3h2v2h4V3h2v2h4V3h2zM4 10h4V7H4zm6 0h4V7h-4zm10 0V7h-4v3zm-9 4h2v3h3v2h-3v3h-2v-3H8v-2h3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const EI = u.markRaw({ name: "mdi-table-row-plus-after", render: vI }),
    AI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function SI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        AI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M22 14a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7h2v-2h4v2h2v-2h4v2h2v-2h4v2h2zM4 14h4v3H4zm6 0h4v3h-4zm10 0v3h-4v-3zm-9-4h2V7h3V5h-3V2h-2v3H8v2h3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const MI = u.markRaw({ name: "mdi-table-row-plus-before", render: SI }),
    TI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function NI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        TI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M9.41 13L12 15.59L14.59 13L16 14.41L13.41 17L16 19.59L14.59 21L12 18.41L9.41 21L8 19.59L10.59 17L8 14.41zM22 9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2zM4 9h4V6H4zm6 0h4V6h-4zm6 0h4V6h-4z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const OI = u.markRaw({ name: "mdi-table-row-remove", render: NI }),
    RI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function DI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        RI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M19 14h2v6H3v-6h2v4h14zM3 4v6h2V6h14v4h2V4zm8 7v2H8v2l-3-3l3-3v2zm5 0V9l3 3l-3 3v-2h-3v-2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const LI = u.markRaw({ name: "mdi-table-split-cell", render: DI }),
    II = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function BI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        II,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              { fill: "currentColor", d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z" },
              null,
              -1
            ),
          ])
      )
    );
  }
  const pw = u.markRaw({ name: "mdi-plus", render: BI }),
    hw = (t) => {
      const e = Au(t.selection);
      if (e) {
        const { map: n } = me.get(e.node);
        if (n && n.length) {
          const r = e.start + n[0],
            o = e.start + n[n.length - 1],
            i = t.doc.resolve(r),
            s = t.doc.resolve(o);
          return t.setSelection(new ke(s, i));
        }
      }
      return t;
    },
    mw = (t) => (e) => (n) => {
      const r = Au(n.selection),
        o = t === "row";
      if (r) {
        const i = me.get(r.node);
        if (e >= 0 && e < (o ? i.height : i.width)) {
          const s = o
              ? i.cellsInRect({ left: 0, right: 1, top: 0, bottom: i.height })
              : i.cellsInRect({ left: 0, right: i.width, top: 0, bottom: 1 }),
            a = i.findCell(s[e]),
            l = {
              left: o ? i.width - 1 : a.left,
              right: o ? i.width : a.right,
              top: o ? a.top : i.height - 1,
              bottom: o ? a.bottom : i.height,
            };
          let c = i.cellsInRect(l);
          for (; c.length === 0; )
            o ? (l.left -= 1) : (l.top -= 1), (c = i.cellsInRect(l));
          const d = r.start + s[e],
            f = r.start + c[c.length - 1],
            p = n.doc.resolve(d),
            h = n.doc.resolve(f);
          return n.setSelection(new ke(h, p));
        }
      }
      return n;
    },
    PI = mw("column"),
    $I = mw("row"),
    FI = (t) => (e) => {
      const n = Au(e);
      if (n) {
        const r = me.get(n.node);
        return (Array.isArray(t) ? t : Array.from([t])).reduce((i, s) => {
          if (s >= 0 && s <= r.width - 1) {
            const a = r.cellsInRect({
              left: s,
              right: s + 1,
              top: 0,
              bottom: r.height,
            });
            return i.concat(
              a.map((l) => {
                const c = n.node.nodeAt(l),
                  d = l + n.start;
                return { pos: d, start: d + 1, node: c };
              })
            );
          }
          return i;
        }, []);
      }
    },
    HI = (t) => (e) => {
      const n = Au(e);
      if (n) {
        const r = me.get(n.node);
        return (Array.isArray(t) ? t : Array.from([t])).reduce((i, s) => {
          if (s >= 0 && s <= r.height - 1) {
            const a = r.cellsInRect({
              left: 0,
              right: r.width,
              top: s,
              bottom: s + 1,
            });
            return i.concat(
              a.map((l) => {
                const c = n.node.nodeAt(l),
                  d = l + n.start;
                return { pos: d, start: d + 1, node: c };
              })
            );
          }
          return i;
        }, []);
      }
    },
    Au = (t) => jt((e) => e.type.spec.tableRole === "table")(t),
    m0 = (t) => (e) => {
      const n = me.get(e.$anchorCell.node(-1)),
        r = e.$anchorCell.start(-1),
        o = n.cellsInRect(t),
        i = n.cellsInRect(
          n.rectBetween(e.$anchorCell.pos - r, e.$headCell.pos - r)
        );
      for (let s = 0, a = o.length; s < a; s++)
        if (i.indexOf(o[s]) === -1) return !1;
      return !0;
    },
    Su = (t) => t instanceof ke,
    zI = (t) => (e) => {
      if (Su(e)) {
        const n = me.get(e.$anchorCell.node(-1)),
          r = n.cellsInRect({ left: 0, right: n.width, top: 0, bottom: 1 });
        if (t >= r.length) return !1;
        const o = n.findCell(r[t]);
        return m0({ left: o.left, right: o.right, top: 0, bottom: n.height })(
          e
        );
      }
      return !1;
    },
    VI = (t) => (e) => {
      if (Su(e)) {
        const n = me.get(e.$anchorCell.node(-1)),
          r = n.cellsInRect({ left: 0, right: 1, top: 0, bottom: n.height });
        if (t >= r.length) return !1;
        const o = n.findCell(r[t]);
        return m0({ left: 0, right: n.width, top: o.top, bottom: o.bottom })(e);
      }
      return !1;
    },
    g0 = (t) => {
      if (Su(t)) {
        const e = me.get(t.$anchorCell.node(-1));
        return m0({ left: 0, right: e.width, top: 0, bottom: e.height })(t);
      }
      return !1;
    },
    UI = (t) => {
      const { $anchor: e } = t.selection,
        n = Math.max(0, e.pos - 2),
        r = t.doc.resolve(n).node();
      return !(!r || r.type.name !== "table");
    },
    gw = (t) => bw(1)(t),
    jI = (t) => bw(-1)(t),
    bw = (t) => (e) => {
      const n = an(e);
      if (n.table) {
        const r = n.map,
          o = r.cellsInRect(n),
          i = WI(r)(o[o.length - 1], t);
        if (i) {
          const { top: s, left: a } = i,
            l = r.map[s * r.width + a];
          return { start: l + n.tableStart + 2, node: n.table.nodeAt(l) };
        }
        return;
      }
    },
    WI = (t) => (e, n) => {
      function r({ top: s, left: a, right: l, bottom: c }) {
        const d = { top: s, left: a, right: l, bottom: c };
        if (l + 1 > t.width) {
          if (c === t.height) return;
          d.top++, (d.left = 0), (d.right = 1), d.bottom++;
        } else d.left++, d.right++;
        const f = t.map[d.top * t.width + d.left],
          p = t.findCell(f);
        return p.top != d.top || p.left < d.left
          ? r({ ...d, right: p.right })
          : f;
      }
      function o({ top: s, left: a, right: l, bottom: c }) {
        const d = { top: s, left: a, right: l, bottom: c };
        if (a - 1 < 0) {
          if (s === 0) return;
          d.top--, (d.left = t.width - 1), (d.right = t.width), d.bottom--;
        } else d.left--, d.right--;
        const f = t.map[d.top * t.width + d.left];
        return t.findCell(f).top != d.top ? o(d) : f;
      }
      function i(s, a) {
        const { top: l, left: c, right: d, bottom: f } = t.findCell(s);
        if (a == 0) return { top: l, left: c, right: d, bottom: f };
        const p = { top: l, left: c, right: d, bottom: f };
        let h;
        if ((a > 0 ? ((h = r(p)), a--) : ((h = o(p)), a++), !!h))
          return i(h, a);
      }
      return i(e, n);
    },
    yw = Pe.create({
      name: "tableCell",
      content: "block+",
      tableRole: "cell",
      isolating: !0,
      fakeSelection: !0,
      addOptions() {
        return { HTMLAttributes: {} };
      },
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          colspan: {
            default: 1,
            parseHTML: (e) => {
              const n = e.getAttribute("colspan");
              return n ? parseInt(n, 10) : 1;
            },
          },
          rowspan: {
            default: 1,
            parseHTML: (e) => {
              const n = e.getAttribute("rowspan");
              return n ? parseInt(n, 10) : 1;
            },
          },
          colwidth: {
            default: [100],
            parseHTML: (e) => {
              const n = e.getAttribute("colwidth");
              return n ? n.split(",").map((o) => parseInt(o, 10)) : null;
            },
          },
          style: { default: null },
        };
      },
      parseHTML() {
        return [{ tag: "td" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["td", se(this.options.HTMLAttributes, t), 0];
      },
      addStorage() {
        return { gripMap: new Map() };
      },
      onDestroy() {
        this.storage.gripMap.clear();
      },
      addProseMirrorPlugins() {
        const t = this.editor,
          e = this.storage;
        return [
          new ie({
            key: new de("table-cell-control"),
            props: {
              decorations(n) {
                const { doc: r, selection: o } = n,
                  i = [],
                  s = FI(0)(o);
                return (
                  s &&
                    s.forEach(({ pos: a }, l) => {
                      l === 0 &&
                        i.push(
                          Te.widget(a + 1, () => {
                            const c = "table" + l;
                            let d = "grip-table";
                            g0(o) && (d += " selected");
                            let p = e.gripMap.get(c);
                            return (
                              p ||
                                ((p = document.createElement("a")),
                                p.addEventListener("mousedown", (h) => {
                                  h.preventDefault(),
                                    h.stopImmediatePropagation(),
                                    t.view.dispatch(hw(t.state.tr));
                                })),
                              (p.className = d),
                              e.gripMap.set(c, p),
                              p
                            );
                          })
                        ),
                        i.push(
                          Te.widget(a + 1, () => {
                            const c = "row" + l,
                              d = VI(l)(o);
                            let f = "grip-row";
                            d && (f += " selected"),
                              l === 0 && (f += " first"),
                              l === s.length - 1 && (f += " last");
                            let p = e.gripMap.get(c);
                            if (!p) {
                              p = document.createElement("a");
                              const h = u.h(
                                Rm,
                                { triggers: ["hover"] },
                                {
                                  default: () =>
                                    u.h(pw, { class: "plus-icon" }),
                                  popper: () =>
                                    T.global.t(
                                      "editor.menus.table.add_row_after"
                                    ),
                                }
                              );
                              u.render(h, p),
                                p.addEventListener(
                                  "mousedown",
                                  (m) => {
                                    m.preventDefault(),
                                      m.stopImmediatePropagation(),
                                      t.view.dispatch($I(l)(t.state.tr)),
                                      m.target !== p &&
                                        Wp(t.state, t.view.dispatch);
                                  },
                                  !0
                                );
                            }
                            return (p.className = f), e.gripMap.set(c, p), p;
                          })
                        );
                    }),
                  ue.create(r, i)
                );
              },
            },
          }),
        ];
      },
    }),
    _w = Pe.create({
      name: "tableHeader",
      content: "block+",
      tableRole: "header_cell",
      isolating: !0,
      fakeSelection: !0,
      addOptions() {
        return { HTMLAttributes: {} };
      },
      addAttributes() {
        return {
          colspan: { default: 1 },
          rowspan: { default: 1 },
          colwidth: {
            default: [100],
            parseHTML: (t) => {
              const e = t.getAttribute("colwidth");
              return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
            },
          },
          style: { default: null },
        };
      },
      parseHTML() {
        return [{ tag: "th" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["th", se(this.options.HTMLAttributes, t), 0];
      },
      addStorage() {
        return { gripMap: new Map() };
      },
      onDestroy() {
        this.storage.gripMap.clear();
      },
      addProseMirrorPlugins() {
        const t = this.editor,
          e = this.storage;
        return [
          new ie({
            key: new de("table-header-control"),
            props: {
              decorations(n) {
                const { doc: r, selection: o } = n,
                  i = [],
                  s = HI(0)(o);
                return (
                  s &&
                    s.forEach(({ pos: a }, l) => {
                      i.push(
                        Te.widget(a + 1, () => {
                          const c = "column" + l,
                            d = zI(l)(o);
                          let f = "grip-column";
                          d && (f += " selected"),
                            l === 0
                              ? (f += " first")
                              : l === s.length - 1 && (f += " last");
                          let p = e.gripMap.get(c);
                          if (!p) {
                            p = document.createElement("a");
                            const h = u.h(
                              Rm,
                              { triggers: ["hover"] },
                              {
                                default: () => u.h(pw, { class: "plus-icon" }),
                                popper: () =>
                                  T.global.t(
                                    "editor.menus.table.add_column_after"
                                  ),
                              }
                            );
                            u.render(h, p),
                              p.addEventListener("mousedown", (m) => {
                                m.preventDefault(),
                                  m.stopImmediatePropagation(),
                                  t.view.dispatch(PI(l)(t.state.tr)),
                                  m.target !== p &&
                                    Up(t.state, t.view.dispatch);
                              });
                          }
                          return (p.className = f), e.gripMap.set(c, p), p;
                        })
                      );
                    }),
                  ue.create(r, i)
                );
              },
            },
          }),
        ];
      },
    }),
    qI = Pe.create({
      name: "tableRow",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      content: "(tableCell | tableHeader)*",
      tableRole: "row",
      parseHTML() {
        return [{ tag: "tr" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["tr", se(this.options.HTMLAttributes, t), 0];
      },
    }).extend({
      allowGapCursor: !1,
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          style: {
            default: "height: 60px;",
            parseHTML: (e) => e.getAttribute("style"),
          },
        };
      },
    });
  function kw(t, e, n, r, o, i) {
    var d;
    let s = 0,
      a = !0,
      l = e.firstChild;
    const c = t.firstChild;
    if (c) {
      for (let f = 0, p = 0; f < c.childCount; f += 1) {
        const { colspan: h, colwidth: m } = c.child(f).attrs;
        for (let g = 0; g < h; g += 1, p += 1) {
          const b = o === p ? i : m && m[g],
            y = b ? `${b}px` : "";
          (s += b || r),
            b || (a = !1),
            l
              ? (l.style.width !== y && (l.style.width = y),
                (l = l.nextSibling))
              : (e.appendChild(document.createElement("col")).style.width = y);
        }
      }
      for (; l; ) {
        const f = l.nextSibling;
        (d = l.parentNode) == null || d.removeChild(l), (l = f);
      }
      a
        ? ((n.style.width = `${s}px`), (n.style.minWidth = ""))
        : ((n.style.width = ""), (n.style.minWidth = `${s}px`));
    }
  }
  let b0;
  class KI {
    constructor(e, n) {
      oe(this, "node");
      oe(this, "cellMinWidth");
      oe(this, "dom");
      oe(this, "scrollDom");
      oe(this, "table");
      oe(this, "colgroup");
      oe(this, "contentDOM");
      oe(this, "containerDOM");
      (this.node = e),
        (this.cellMinWidth = n),
        (this.dom = document.createElement("div")),
        (this.dom.className = "table-container"),
        (this.containerDOM = this.dom.appendChild(
          document.createElement("div")
        )),
        (this.containerDOM.className = "tableWrapper"),
        this.containerDOM.addEventListener("wheel", (r) =>
          this.handleHorizontalWheel(this.containerDOM, r)
        ),
        this.containerDOM.addEventListener("scroll", () => {
          if (!b0) return !1;
          const { view: r } = b0;
          r.dispatch(r.state.tr);
        }),
        (this.scrollDom = document.createElement("div")),
        (this.scrollDom.className = "scrollWrapper"),
        this.containerDOM.appendChild(this.scrollDom),
        (this.table = this.scrollDom.appendChild(
          document.createElement("table")
        )),
        (this.colgroup = this.table.appendChild(
          document.createElement("colgroup")
        )),
        kw(e, this.colgroup, this.table, n),
        (this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        )),
        setTimeout(() => {
          this.updateTableShadow();
        });
    }
    update(e) {
      return e.type !== this.node.type
        ? !1
        : ((this.node = e),
          kw(e, this.colgroup, this.table, this.cellMinWidth),
          this.updateTableShadow(),
          !0);
    }
    updateTableShadow() {
      const {
        scrollWidth: e,
        clientWidth: n,
        scrollLeft: r,
      } = this.containerDOM;
      e > n && r < e - n
        ? this.dom.classList.add("table-right-shadow")
        : this.dom.classList.remove("table-right-shadow"),
        r > 0
          ? this.dom.classList.add("table-left-shadow")
          : this.dom.classList.remove("table-left-shadow");
    }
    ignoreMutation(e) {
      return (
        e.type === "attributes" &&
        (e.target === this.table ||
          e.target === this.dom ||
          this.colgroup.contains(e.target))
      );
    }
    handleHorizontalWheel(e, n) {
      const { scrollWidth: r, clientWidth: o } = e;
      r > o &&
        (n.stopPropagation(),
        n.preventDefault(),
        e.scrollBy({ left: n.deltaY }));
    }
  }
  const fo = Y7.extend({
      allowGapCursor: !0,
      addExtensions() {
        return [yw, qI, _w];
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          HTMLAttributes: {},
          resizable: !0,
          handleWidth: 5,
          cellMinWidth: 25,
          View: KI,
          lastColumnResizable: !0,
          allowTableNodeSelection: !1,
          getToolboxItems({ editor: e }) {
            return {
              priority: 15,
              component: u.markRaw(io),
              props: {
                editor: e,
                icon: u.markRaw(_I),
                title: T.global.t("editor.menus.table.add"),
                action: () =>
                  e
                    .chain()
                    .focus()
                    .insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
                    .run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 120,
              icon: u.markRaw(nI),
              title: "editor.extensions.commands_menu.table",
              keywords: ["table", "biaoge"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
                  .run();
              },
            };
          },
          getBubbleMenu({ editor: e }) {
            return {
              pluginKey: "tableBubbleMenu",
              shouldShow: ({ state: n }) => Et(n, fo.name),
              getRenderContainer(n) {
                let r = n;
                for (
                  r.nodeName === "#text" && (r = n.parentElement);
                  r && r.classList && !r.classList.contains("tableWrapper");

                )
                  r = r.parentElement;
                return r;
              },
              tippyOptions: { offset: [26, 0] },
              items: [
                {
                  priority: 10,
                  props: {
                    icon: u.markRaw(lI),
                    title: T.global.t("editor.menus.table.add_column_before"),
                    action: () => {
                      e.chain().focus().addColumnBefore().run();
                    },
                  },
                },
                {
                  priority: 20,
                  props: {
                    icon: u.markRaw(iI),
                    title: T.global.t("editor.menus.table.add_column_after"),
                    action: () => e.chain().focus().addColumnAfter().run(),
                  },
                },
                {
                  priority: 30,
                  props: {
                    icon: u.markRaw(dI),
                    title: T.global.t("editor.menus.table.delete_column"),
                    action: () => e.chain().focus().deleteColumn().run(),
                  },
                },
                { priority: 40, component: u.markRaw(Ve) },
                {
                  priority: 50,
                  props: {
                    icon: u.markRaw(MI),
                    title: T.global.t("editor.menus.table.add_row_before"),
                    action: () => e.chain().focus().addRowBefore().run(),
                  },
                },
                {
                  priority: 60,
                  props: {
                    icon: u.markRaw(EI),
                    title: T.global.t("editor.menus.table.add_row_after"),
                    action: () => e.chain().focus().addRowAfter().run(),
                  },
                },
                {
                  priority: 70,
                  props: {
                    icon: u.markRaw(OI),
                    title: T.global.t("editor.menus.table.delete_row"),
                    action: () => e.chain().focus().deleteRow().run(),
                  },
                },
                { priority: 80, component: u.markRaw(Ve) },
                {
                  priority: 90,
                  props: {
                    icon: u.markRaw(fw),
                    title: T.global.t(
                      "editor.menus.table.toggle_header_column"
                    ),
                    action: () => e.chain().focus().toggleHeaderColumn().run(),
                  },
                },
                {
                  priority: 100,
                  props: {
                    icon: u.markRaw(fw),
                    title: T.global.t("editor.menus.table.toggle_header_row"),
                    action: () => e.chain().focus().toggleHeaderRow().run(),
                  },
                },
                {
                  priority: 101,
                  props: {
                    icon: u.markRaw(Q7),
                    title: T.global.t("editor.menus.table.toggle_header_cell"),
                    action: () => e.chain().focus().toggleHeaderCell().run(),
                  },
                },
                { priority: 110, component: u.markRaw(Ve) },
                {
                  priority: 120,
                  props: {
                    icon: u.markRaw(gI),
                    title: T.global.t("editor.menus.table.merge_cells"),
                    action: () => e.chain().focus().mergeCells().run(),
                  },
                },
                {
                  priority: 130,
                  props: {
                    icon: u.markRaw(LI),
                    title: T.global.t("editor.menus.table.split_cell"),
                    action: () => e.chain().focus().splitCell().run(),
                  },
                },
                { priority: 140, component: u.markRaw(Ve) },
                {
                  priority: 150,
                  props: {
                    icon: u.markRaw(xI),
                    title: T.global.t("editor.menus.table.delete_table"),
                    action: () => e.chain().focus().deleteTable().run(),
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && !n.classList.contains("tableWrapper"); )
                  n = n.parentElement;
                return { el: n, dragDomOffset: { x: 20, y: 20 } };
              },
              handleDrop({ view: e, event: n, slice: r, insertPos: o }) {
                const { state: i } = e,
                  s = i.selection.$anchor;
                for (let a = s.depth; a > 0; a--)
                  if (s.node(a).type.spec.tableRole == "table") {
                    if (
                      !e.posAtCoords({ left: n.clientX, top: n.clientY }) ||
                      !r
                    )
                      return;
                    let d = i.tr;
                    d = d.delete(s.before(a), s.after(a));
                    const f = d.mapping.map(o);
                    return (
                      (d = d.replaceRange(f, f, r).scrollIntoView()),
                      d ? (e.dispatch(d), n.preventDefault(), !0) : !1
                    );
                  }
              },
            };
          },
        };
      },
      addKeyboardShortcuts() {
        const t = () => {
          const { editor: e } = this;
          if (e.commands.undoInputRule()) return !0;
          const { selection: n } = e.state;
          return !Ut(e.state, fo.name) && UI(e.state) && n.empty
            ? (e.commands.selectNodeBackward(), !0)
            : Ut(e.state, fo.name) && g0(e.state.selection)
            ? (e.commands.deleteTable(), !0)
            : !1;
        };
        return {
          Backspace: () => t(),
          "Mod-Backspace": () => t(),
          "Mod-a": ({ editor: e }) => {
            if (!Ut(e.state, fo.name)) return !1;
            const { tr: n, selection: r } = e.state;
            if (g0(r)) return !0;
            if (Su(r)) return hw(n), e.view.dispatch(n), !0;
            let o = jt((i) => i.type.name === yw.name)(r);
            return (
              o || (o = jt((i) => i.type.name === _w.name)(r)),
              o ? (e.commands.setNodeSelection(o.pos), !0) : !1
            );
          },
          Tab: ({ editor: e }) => {
            var s;
            const { state: n } = e;
            if (!Et(e.state, fo.name)) return !1;
            let r = e.view,
              o = e.state.tr,
              i = gw(n);
            return (
              i ||
                e
                  .chain()
                  .addRowAfter()
                  .command(
                    ({ tr: a, view: l, state: c }) => (
                      (r = l), (o = a), (i = gw(c)), !0
                    )
                  ),
              i
                ? (o.setSelection(
                    new U(
                      o.doc.resolve(i.start),
                      o.doc.resolve(
                        i.start +
                          (((s = i.node) == null ? void 0 : s.nodeSize) || 0) -
                          4
                      )
                    )
                  ),
                  o.scrollIntoView(),
                  r.dispatch(o),
                  !0)
                : !1
            );
          },
          "Shift-Tab": ({ editor: e }) => {
            var o;
            const { tr: n } = e.state;
            if (!Et(e.state, fo.name)) return !1;
            const r = jI(e.state);
            return (
              r &&
                (n.setSelection(
                  new U(
                    n.doc.resolve(r.start),
                    n.doc.resolve(
                      r.start +
                        (((o = r.node) == null ? void 0 : o.nodeSize) || 0) -
                        4
                    )
                  )
                ),
                n.scrollIntoView(),
                e.view.dispatch(n)),
              !0
            );
          },
        };
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        const {
          colgroup: n,
          tableWidth: r,
          tableMinWidth: o,
        } = uw(t, this.options.cellMinWidth);
        return [
          "div",
          { style: "overflow-x: auto; overflow-y: hidden;" },
          [
            "table",
            se(this.options.HTMLAttributes, e, {
              style: r ? `width: ${r}` : `minWidth: ${o}`,
            }),
            n,
            ["tbody", 0],
          ],
        ];
      },
      onTransaction() {
        b0 = this.editor;
      },
    }).configure({ resizable: !0 }),
    GI = /^\s*(\[([( |x])?\])\s$/,
    JI = Pe.create({
      name: "taskItem",
      addOptions() {
        return { nested: !1, HTMLAttributes: {}, taskListTypeName: "taskList" };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: !0,
      addAttributes() {
        return {
          checked: {
            default: !1,
            keepOnSplit: !1,
            parseHTML: (t) => {
              const e = t.getAttribute("data-checked");
              return e === "" || e === "true";
            },
            renderHTML: (t) => ({ "data-checked": t.checked }),
          },
        };
      },
      parseHTML() {
        return [{ tag: `li[data-type="${this.name}"]`, priority: 51 }];
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        return [
          "li",
          se(this.options.HTMLAttributes, e, { "data-type": this.name }),
          [
            "label",
            [
              "input",
              { type: "checkbox", checked: t.attrs.checked ? "checked" : null },
            ],
            ["span"],
          ],
          ["div", 0],
        ];
      },
      addKeyboardShortcuts() {
        const t = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
        };
        return this.options.nested
          ? { ...t, Tab: () => this.editor.commands.sinkListItem(this.name) }
          : t;
      },
      addNodeView() {
        return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
          const o = document.createElement("li"),
            i = document.createElement("label"),
            s = document.createElement("span"),
            a = document.createElement("input"),
            l = document.createElement("div");
          return (
            (i.contentEditable = "false"),
            (a.type = "checkbox"),
            a.addEventListener("mousedown", (c) => c.preventDefault()),
            a.addEventListener("change", (c) => {
              if (!r.isEditable && !this.options.onReadOnlyChecked) {
                a.checked = !a.checked;
                return;
              }
              const { checked: d } = c.target;
              r.isEditable &&
                typeof n == "function" &&
                r
                  .chain()
                  .focus(void 0, { scrollIntoView: !1 })
                  .command(({ tr: f }) => {
                    const p = n();
                    if (typeof p != "number") return !1;
                    const h = f.doc.nodeAt(p);
                    return (
                      f.setNodeMarkup(p, void 0, {
                        ...(h == null ? void 0 : h.attrs),
                        checked: d,
                      }),
                      !0
                    );
                  })
                  .run(),
                !r.isEditable &&
                  this.options.onReadOnlyChecked &&
                  (this.options.onReadOnlyChecked(t, d) ||
                    (a.checked = !a.checked));
            }),
            Object.entries(this.options.HTMLAttributes).forEach(([c, d]) => {
              o.setAttribute(c, d);
            }),
            (o.dataset.checked = t.attrs.checked),
            (a.checked = t.attrs.checked),
            i.append(a, s),
            o.append(i, l),
            Object.entries(e).forEach(([c, d]) => {
              o.setAttribute(c, d);
            }),
            {
              dom: o,
              contentDOM: l,
              update: (c) =>
                c.type !== this.type
                  ? !1
                  : ((o.dataset.checked = c.attrs.checked),
                    (a.checked = c.attrs.checked),
                    !0),
            }
          );
        };
      },
      addInputRules() {
        return [
          Wo({
            find: GI,
            type: this.type,
            getAttributes: (t) => ({ checked: t[t.length - 1] === "x" }),
          }),
        ];
      },
    }),
    YI = Pe.create({
      name: "taskList",
      addOptions() {
        return { itemTypeName: "taskItem", HTMLAttributes: {} };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [{ tag: `ul[data-type="${this.name}"]`, priority: 51 }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return [
          "ul",
          se(this.options.HTMLAttributes, t, { "data-type": this.name }),
          0,
        ];
      },
      addCommands() {
        return {
          toggleTaskList:
            () =>
            ({ commands: t }) =>
              t.toggleList(this.name, this.options.itemTypeName),
        };
      },
      addKeyboardShortcuts() {
        return { "Mod-Shift-9": () => this.editor.commands.toggleTaskList() };
      },
    }),
    XI = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function ZI(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        XI,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M21 19v-2H8v2zm0-6v-2H8v2zM8 7h13V5H8zM4 5v2h2V5zM3 5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const ww = u.markRaw({ name: "mdi-format-list-checkbox", render: ZI }),
    xw = YI.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 150,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("taskList"),
                icon: u.markRaw(ww),
                title: T.global.t("editor.common.task_list"),
                action: () => e.chain().focus().toggleTaskList().run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 150,
              icon: u.markRaw(ww),
              title: "editor.common.task_list",
              keywords: ["tasklist", "renwuliebiao"],
              command: ({ editor: e, range: n }) => {
                e.chain().focus().deleteRange(n).toggleTaskList().run();
              },
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && n.tagName !== "LI"; ) n = n.parentElement;
                return { el: n, dragDomOffset: { y: -1 } };
              },
            };
          },
        };
      },
      addExtensions() {
        return [JI];
      },
    }),
    QI = we.create({
      name: "textAlign",
      addOptions() {
        return {
          types: [],
          alignments: ["left", "center", "right", "justify"],
          defaultAlignment: null,
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              textAlign: {
                default: this.options.defaultAlignment,
                parseHTML: (t) => {
                  const e = t.style.textAlign;
                  return this.options.alignments.includes(e)
                    ? e
                    : this.options.defaultAlignment;
                },
                renderHTML: (t) =>
                  t.textAlign ? { style: `text-align: ${t.textAlign}` } : {},
              },
            },
          },
        ];
      },
      addCommands() {
        return {
          setTextAlign:
            (t) =>
            ({ commands: e }) =>
              this.options.alignments.includes(t)
                ? this.options.types
                    .map((n) => e.updateAttributes(n, { textAlign: t }))
                    .every((n) => n)
                : !1,
          unsetTextAlign:
            () =>
            ({ commands: t }) =>
              this.options.types
                .map((e) => t.resetAttributes(e, "textAlign"))
                .every((e) => e),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
          "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
          "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
          "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify"),
        };
      },
    }),
    eB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function tB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        eB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 3h18v2H3zm4 4h10v2H7zm-4 4h18v2H3zm4 4h10v2H7zm-4 4h18v2H3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Ia = u.markRaw({ name: "mdi-format-align-center", render: tB }),
    nB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function rB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        nB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 3h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Ba = u.markRaw({ name: "mdi-format-align-justify", render: rB }),
    oB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function iB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        oB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 3h18v2H3zm0 4h12v2H3zm0 4h18v2H3zm0 4h12v2H3zm0 4h18v2H3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Ui = u.markRaw({ name: "mdi-format-align-left", render: iB }),
    sB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function aB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        sB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3 3h18v2H3zm6 4h12v2H9zm-6 4h18v2H3zm6 4h12v2H9zm-6 4h18v2H3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Pa = u.markRaw({ name: "mdi-format-align-right", render: aB }),
    lB = { left: Ui, center: Ia, right: Pa, justify: Ba },
    cB = (t) => {
      let e = Ui;
      return (
        Object.entries(lB).forEach(([n, r]) => {
          if (t.isActive({ textAlign: n })) {
            e = r;
            return;
          }
        }),
        e
      );
    },
    Cw = QI.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 180,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: !1,
                icon: u.markRaw(cB(e)),
                title: T.global.t("editor.common.align_method"),
              },
              children: [
                {
                  priority: 0,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive({ textAlign: "left" }),
                    icon: u.markRaw(Ui),
                    title: T.global.t("editor.common.align_left"),
                    action: () => e.chain().focus().setTextAlign("left").run(),
                  },
                },
                {
                  priority: 10,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive({ textAlign: "center" }),
                    icon: u.markRaw(Ia),
                    title: T.global.t("editor.common.align_center"),
                    action: () =>
                      e.chain().focus().setTextAlign("center").run(),
                  },
                },
                {
                  priority: 20,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive({ textAlign: "right" }),
                    icon: u.markRaw(Pa),
                    title: T.global.t("editor.common.align_right"),
                    action: () => e.chain().focus().setTextAlign("right").run(),
                  },
                },
                {
                  priority: 30,
                  component: u.markRaw(At),
                  props: {
                    editor: e,
                    isActive: e.isActive({ textAlign: "justify" }),
                    icon: u.markRaw(Ba),
                    title: T.global.t("editor.common.align_justify"),
                    action: () =>
                      e.chain().focus().setTextAlign("justify").run(),
                  },
                },
              ],
            };
          },
        };
      },
    }),
    uB = vt.create({
      name: "underline",
      addOptions() {
        return { HTMLAttributes: {} };
      },
      parseHTML() {
        return [
          { tag: "u" },
          {
            style: "text-decoration",
            consuming: !1,
            getAttrs: (t) => (t.includes("underline") ? {} : !1),
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["u", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          setUnderline:
            () =>
            ({ commands: t }) =>
              t.setMark(this.name),
          toggleUnderline:
            () =>
            ({ commands: t }) =>
              t.toggleMark(this.name),
          unsetUnderline:
            () =>
            ({ commands: t }) =>
              t.unsetMark(this.name),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline(),
        };
      },
    }),
    dB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function fB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        dB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M5 21h14v-2H5zm7-4a6 6 0 0 0 6-6V3h-2.5v8a3.5 3.5 0 0 1-3.5 3.5A3.5 3.5 0 0 1 8.5 11V3H6v8a6 6 0 0 0 6 6",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const vw = u.markRaw({ name: "mdi-format-underline", render: fB }),
    Ew = uB.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            return {
              priority: 60,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("underline"),
                icon: u.markRaw(vw),
                title: T.global.t("editor.common.underline"),
                action: () => e.chain().focus().toggleUnderline().run(),
              },
            };
          },
        };
      },
    }),
    pB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function hB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        pB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-8 5H9v2c0 1.1-.9 2-2 2c1.1 0 2 .9 2 2v2h2v2H9c-1.1 0-2-.9-2-2v-1c0-1.1-.9-2-2-2v-2c1.1 0 2-.9 2-2V8c0-1.1.9-2 2-2h2zm8 5c-1.1 0-2 .9-2 2v1c0 1.1-.9 2-2 2h-2v-2h2v-2c0-1.1.9-2 2-2c-1.1 0-2-.9-2-2V8h-2V6h2c1.1 0 2 .9 2 2v1c0 1.1.9 2 2 2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const y0 = u.markRaw({ name: "mdi-code-braces-box", render: hB });
  function mB(t) {
    return u.getCurrentScope() ? (u.onScopeDispose(t), !0) : !1;
  }
  function gB(t) {
    return typeof t == "function" ? t() : u.unref(t);
  }
  const bB = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const yB = () => {};
  function _B(t, e, n = {}) {
    const { immediate: r = !0 } = n,
      o = u.ref(!1);
    let i = null;
    function s() {
      i && (clearTimeout(i), (i = null));
    }
    function a() {
      (o.value = !1), s();
    }
    function l(...c) {
      s(),
        (o.value = !0),
        (i = setTimeout(() => {
          (o.value = !1), (i = null), t(...c);
        }, gB(e)));
    }
    return (
      r && ((o.value = !0), bB && l()),
      mB(a),
      { isPending: u.readonly(o), start: l, stop: a }
    );
  }
  function kB(t = 1e3, e = {}) {
    const { controls: n = !1, callback: r } = e,
      o = _B(r ?? yB, t, e),
      i = u.computed(() => !o.isPending.value);
    return n ? { ready: i, ...o } : i;
  }
  const wB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function xB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        wB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                d: "M14 8H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V10c0-1.103-.897-2-2-2z",
                fill: "currentColor",
              },
              null,
              -1
            ),
            u.createElementVNode(
              "path",
              {
                d: "M20 2H10a2 2 0 0 0-2 2v2h8a2 2 0 0 1 2 2v8h2a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z",
                fill: "currentColor",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const CB = u.markRaw({ name: "bx-bxs-copy", render: xB }),
    vB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function EB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        vB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              { fill: "currentColor", d: "m12 16l-6-6h12z" },
              null,
              -1
            ),
          ])
      )
    );
  }
  const AB = u.markRaw({ name: "ri-arrow-down-s-fill", render: EB }),
    SB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function MB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        SB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              { fill: "currentColor", d: "m16 12l-6 6V6z" },
              null,
              -1
            ),
          ])
      )
    );
  }
  const TB = u.markRaw({ name: "ri-arrow-right-s-fill", render: MB }),
    NB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function OB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        NB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m-.997-4L6.76 11.757l1.414-1.414l2.829 2.829l5.657-5.657l1.414 1.414z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const RB = u.markRaw({ name: "ri-checkbox-circle-line", render: OB }),
    DB = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function LB(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        DB,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m12 13.171l4.95-4.95l1.414 1.415L12 16L5.636 9.636L7.05 8.222z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const IB = u.markRaw({ name: "ri-arrow-down-s-line", render: LB }),
    BB = { class: "h-8" },
    PB = { class: "absolute top-0 bottom-0" },
    $B = ["placeholder"],
    FB = { class: "bg-white" },
    HB = { class: "select max-h-64 cursor-pointer p-1" },
    zB = ["index", "onMousedown"],
    VB = { class: "flex-1 text-ellipsis text-sm" },
    UB = {
      key: 1,
      class: "w-full h-8 flex items-center rounded-md text-base px-3 py-1",
    },
    Aw = Pd(
      u.defineComponent({
        __name: "CodeBlockSelect",
        props: u.mergeModels(
          {
            container: {},
            containerClass: {},
            options: {},
            filterSort: { type: Function },
          },
          { modelValue: { default: "" }, modelModifiers: {} }
        ),
        emits: u.mergeModels(["select"], ["update:modelValue"]),
        setup(t, { emit: e }) {
          const n = t,
            r = u.useModel(t, "modelValue"),
            o = e,
            i = u.ref(!1),
            s = u.ref(""),
            a = u.ref(null),
            l = u.ref(null),
            c = u.computed(() => (a.value ? a.value.label : r.value)),
            d = u.computed(() =>
              s.value
                ? n.options.filter((y) =>
                    y.value
                      .toLocaleLowerCase()
                      .includes(s.value.toLocaleLowerCase())
                  )
                : n.options
            ),
            f = () => {
              (i.value = !0),
                setTimeout(() => {
                  b();
                }, 50);
            },
            p = () => {
              (i.value = !1), s.value && ((r.value = s.value), (s.value = ""));
            },
            h = (y) => {
              var x;
              (a.value = y),
                (r.value = y.value),
                (s.value = ""),
                (x = l.value) == null || x.blur(),
                o("select");
            },
            m = u.ref(-1),
            g = (y) => {
              const x = y.key;
              if (x === "ArrowUp")
                return (
                  (m.value = (m.value - 1 + d.value.length) % d.value.length),
                  !0
                );
              if (x === "ArrowDown")
                return (m.value = (m.value + 1) % d.value.length), !0;
              if (x === "Enter")
                return m.value === -1 || h(d.value[m.value]), !0;
            };
          u.watch(
            r,
            (y) => {
              y &&
                ((a.value = n.options.find((x) => x.value === y) || null),
                (m.value = n.options.findIndex((x) => x.value === y)));
            },
            { immediate: !0 }
          ),
            u.watch(
              m,
              () => {
                setTimeout(() => {
                  b();
                });
              },
              { immediate: !0 }
            );
          const b = () => {
            if (m.value === -1) return;
            const y = document.querySelector(
              `.select > div:nth-child(${m.value + 1})`
            );
            y &&
              y.scrollIntoView({
                behavior: "instant",
                block: "nearest",
                inline: "nearest",
              });
          };
          return (y, x) => (
            u.openBlock(),
            u.createBlock(
              u.unref(vo),
              {
                triggers: [],
                shown: i.value,
                "auto-hide": !1,
                distance: 0,
                "auto-size": "",
                container: y.container || "body",
              },
              {
                popper: u.withCtx(() => [
                  u.createElementVNode("div", FB, [
                    u.createElementVNode("div", HB, [
                      d.value && d.value.length > 0
                        ? (u.openBlock(!0),
                          u.createElementBlock(
                            u.Fragment,
                            { key: 0 },
                            u.renderList(
                              d.value,
                              (w, _) => (
                                u.openBlock(),
                                u.createElementBlock(
                                  "div",
                                  {
                                    key: w.value,
                                    index: _,
                                    class: u.normalizeClass([
                                      "w-full h-8 flex items-center rounded-md text-base px-3 py-1 hover:bg-zinc-100",
                                      {
                                        "bg-zinc-200": w.value === r.value,
                                        "bg-zinc-100": m.value === _,
                                      },
                                    ]),
                                    onMousedown: (v) => h(w),
                                  },
                                  [
                                    u.createElementVNode(
                                      "span",
                                      VB,
                                      u.toDisplayString(w.label),
                                      1
                                    ),
                                  ],
                                  42,
                                  zB
                                )
                              )
                            ),
                            128
                          ))
                        : (u.openBlock(),
                          u.createElementBlock(
                            "div",
                            UB,
                            x[2] ||
                              (x[2] = [
                                u.createElementVNode(
                                  "span",
                                  { class: "flex-1 text-ellipsis text-sm" },
                                  "No options",
                                  -1
                                ),
                              ])
                          )),
                    ]),
                  ]),
                ]),
                default: u.withCtx(() => [
                  u.createElementVNode(
                    "div",
                    { class: "relative inline-block w-full", onKeydown: g },
                    [
                      u.createElementVNode("div", BB, [
                        u.createElementVNode(
                          "div",
                          {
                            class: u.normalizeClass([
                              "select-input w-full h-full grid items-center text-sm rounded-md px-3 cursor-pointer box-border",
                              { "bg-white": i.value, "border-[1px]": i.value },
                            ]),
                          },
                          [
                            u.createElementVNode("span", PB, [
                              u.withDirectives(
                                u.createElementVNode(
                                  "input",
                                  {
                                    ref_key: "inputRef",
                                    ref: l,
                                    "onUpdate:modelValue":
                                      x[0] || (x[0] = (w) => (s.value = w)),
                                    class:
                                      "appearance-none bg-transparent h-full ps-0 pe-0 border-none outline-none m-0 p-0 cursor-auto",
                                    placeholder: i.value ? c.value : "",
                                    onFocus: f,
                                    onBlur: p,
                                  },
                                  null,
                                  40,
                                  $B
                                ),
                                [[u.vModelText, s.value]]
                              ),
                            ]),
                            u.withDirectives(
                              u.createElementVNode(
                                "span",
                                { class: "text-ellipsis text-sm" },
                                u.toDisplayString(c.value),
                                513
                              ),
                              [[u.vShow, !i.value]]
                            ),
                            u.createElementVNode(
                              "span",
                              {
                                class: "justify-self-end",
                                onClick:
                                  x[1] ||
                                  (x[1] = (w) => {
                                    var _;
                                    return (_ = l.value) == null
                                      ? void 0
                                      : _.focus();
                                  }),
                              },
                              [u.createVNode(u.unref(IB))]
                            ),
                          ],
                          2
                        ),
                      ]),
                    ],
                    32
                  ),
                ]),
                _: 1,
              },
              8,
              ["shown", "container"]
            )
          );
        },
      }),
      [["__scopeId", "data-v-0ea43cd6"]]
    ),
    jB = {
      contenteditable: "false",
      class:
        "bg-neutral-100 border-b-[1px] border-b-gray-100 py-1 flex items-center justify-between",
    },
    WB = { class: "pr-3 flex items-center" },
    qB = { class: "pr-3 flex items-center" },
    KB = u.defineComponent({
      __name: "CodeBlockViewRenderer",
      props: {
        decorations: {},
        selected: { type: Boolean },
        updateAttributes: { type: Function },
        deleteNode: { type: Function },
        node: {},
        view: {},
        getPos: { type: Function },
        innerDecorations: {},
        editor: {},
        extension: {},
        HTMLAttributes: {},
      },
      setup(t) {
        const e = t,
          n = u.computed(() => {
            let d = [];
            const f = e.extension.options.languages;
            return (
              typeof f == "function" ? (d = f(e.editor.state)) : (d = f),
              (d = d || []),
              d.map((h) => h.value).indexOf("auto") === -1 &&
                d.unshift({ label: "Auto", value: "auto" }),
              d
            );
          }),
          r = u.computed({
            get: () => {
              var d;
              return (
                ((d = e.node) == null ? void 0 : d.attrs.language) || "auto"
              );
            },
            set: (d) => {
              e.updateAttributes({ language: d });
            },
          }),
          o = u.computed(() => {
            let d = [];
            const f = e.extension.options.themes;
            if (
              (typeof f == "function" ? (d = f(e.editor.state)) : (d = f), !!d)
            )
              return d;
          }),
          i = u.computed({
            get: () => {
              var d, f;
              return (
                ((d = e.node) == null ? void 0 : d.attrs.theme) ||
                ((f = o.value) == null ? void 0 : f[0].value)
              );
            },
            set: (d) => {
              e.updateAttributes({ theme: d });
            },
          }),
          s = u.computed({
            get: () => e.node.attrs.collapsed || !1,
            set: (d) => {
              e.updateAttributes({ collapsed: d });
            },
          }),
          { ready: a, start: l } = kB(2e3, { controls: !0, immediate: !1 }),
          c = () => {
            if (!a.value) return;
            const d = e.node.textContent;
            navigator.clipboard.writeText(d).then(() => {
              l();
            });
          };
        return (d, f) => {
          const p = u.resolveDirective("tooltip");
          return (
            u.openBlock(),
            u.createBlock(
              u.unref(Ii),
              {
                as: "div",
                class: "code-node border-[1px] rounded mt-3 overflow-hidden",
              },
              {
                default: u.withCtx(() => [
                  u.createElementVNode("div", jB, [
                    u.createElementVNode(
                      "div",
                      {
                        class: "flex-1 flex items-center pl-3",
                        onClick:
                          f[5] ||
                          (f[5] = u.withModifiers(
                            (h) => (s.value ? (s.value = !1) : null),
                            ["self"]
                          )),
                      },
                      [
                        u.createElementVNode("div", WB, [
                          u.createElementVNode(
                            "div",
                            {
                              class:
                                "w-8 h-8 cursor-pointer rounded flex items-center justify-center hover:bg-zinc-200",
                              onClick:
                                f[0] ||
                                (f[0] = u.withModifiers(
                                  (h) => (s.value = !s.value),
                                  ["stop"]
                                )),
                            },
                            [
                              s.value
                                ? (u.openBlock(),
                                  u.createBlock(u.unref(TB), { key: 0 }))
                                : (u.openBlock(),
                                  u.createBlock(u.unref(AB), { key: 1 })),
                            ]
                          ),
                        ]),
                        u.createVNode(
                          Aw,
                          {
                            modelValue: r.value,
                            "onUpdate:modelValue":
                              f[1] || (f[1] = (h) => (r.value = h)),
                            class: "w-48",
                            container: d.editor.options.element,
                            options: n.value,
                            onSelect:
                              f[2] || (f[2] = (h) => d.editor.commands.focus()),
                          },
                          null,
                          8,
                          ["modelValue", "container", "options"]
                        ),
                        o.value && o.value.length > 0
                          ? (u.openBlock(),
                            u.createBlock(
                              Aw,
                              {
                                key: 0,
                                modelValue: i.value,
                                "onUpdate:modelValue":
                                  f[3] || (f[3] = (h) => (i.value = h)),
                                container: d.editor.options.element,
                                class: "w-48",
                                options: o.value,
                                onSelect:
                                  f[4] ||
                                  (f[4] = (h) => d.editor.commands.focus()),
                              },
                              null,
                              8,
                              ["modelValue", "container", "options"]
                            ))
                          : u.createCommentVNode("", !0),
                      ]
                    ),
                    u.createElementVNode("div", qB, [
                      u.withDirectives(
                        (u.openBlock(),
                        u.createElementBlock(
                          "div",
                          {
                            class: u.normalizeClass([
                              "w-8 h-8 cursor-pointer rounded flex items-center justify-center",
                              { "hover:bg-zinc-200": u.unref(a) },
                            ]),
                            onClick: c,
                          },
                          [
                            u.unref(a)
                              ? (u.openBlock(),
                                u.createBlock(u.unref(CB), {
                                  key: 1,
                                  class: "w-4 h-4 text-gray-500",
                                }))
                              : (u.openBlock(),
                                u.createBlock(u.unref(RB), {
                                  key: 0,
                                  class: "w-4 h-4 text-green-500",
                                })),
                          ],
                          2
                        )),
                        [
                          [
                            p,
                            u.unref(a)
                              ? u
                                  .unref(T)
                                  .global.t("editor.common.codeblock.copy_code")
                              : u
                                  .unref(T)
                                  .global.t(
                                    "editor.common.codeblock.copy_code_success"
                                  ),
                          ],
                        ]
                      ),
                    ]),
                  ]),
                  u.withDirectives(
                    u.createElementVNode(
                      "pre",
                      null,
                      [
                        u.createVNode(u.unref(Fk), {
                          as: "code",
                          class: "hljs",
                        }),
                      ],
                      512
                    ),
                    [[u.vShow, !s.value]]
                  ),
                ]),
                _: 1,
              }
            )
          );
        };
      },
    }),
    GB = /^```([a-z]+)?[\s\n]$/,
    JB = /^~~~([a-z]+)?[\s\n]$/,
    Mu = Pe.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: !0,
          exitOnArrowDown: !0,
          defaultLanguage: null,
          HTMLAttributes: {},
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: !0,
      defining: !0,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (t) => {
              var e;
              const { languageClassPrefix: n } = this.options,
                i = [
                  ...(((e = t.firstElementChild) === null || e === void 0
                    ? void 0
                    : e.classList) || []),
                ]
                  .filter((s) => s.startsWith(n))
                  .map((s) => s.replace(n, ""))[0];
              return i || null;
            },
            rendered: !1,
          },
        };
      },
      parseHTML() {
        return [{ tag: "pre", preserveWhitespace: "full" }];
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        return [
          "pre",
          se(this.options.HTMLAttributes, e),
          [
            "code",
            {
              class: t.attrs.language
                ? this.options.languageClassPrefix + t.attrs.language
                : null,
            },
            0,
          ],
        ];
      },
      addCommands() {
        return {
          setCodeBlock:
            (t) =>
            ({ commands: e }) =>
              e.setNode(this.name, t),
          toggleCodeBlock:
            (t) =>
            ({ commands: e }) =>
              e.toggleNode(this.name, "paragraph", t),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          Backspace: () => {
            const { empty: t, $anchor: e } = this.editor.state.selection,
              n = e.pos === 1;
            return !t || e.parent.type.name !== this.name
              ? !1
              : n || !e.parent.textContent.length
              ? this.editor.commands.clearNodes()
              : !1;
          },
          Enter: ({ editor: t }) => {
            if (!this.options.exitOnTripleEnter) return !1;
            const { state: e } = t,
              { selection: n } = e,
              { $from: r, empty: o } = n;
            if (!o || r.parent.type !== this.type) return !1;
            const i = r.parentOffset === r.parent.nodeSize - 2,
              s = r.parent.textContent.endsWith(`

`);
            return !i || !s
              ? !1
              : t
                  .chain()
                  .command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0))
                  .exitCode()
                  .run();
          },
          ArrowDown: ({ editor: t }) => {
            if (!this.options.exitOnArrowDown) return !1;
            const { state: e } = t,
              { selection: n, doc: r } = e,
              { $from: o, empty: i } = n;
            if (
              !i ||
              o.parent.type !== this.type ||
              !(o.parentOffset === o.parent.nodeSize - 2)
            )
              return !1;
            const a = o.after();
            return a === void 0
              ? !1
              : r.nodeAt(a)
              ? t.commands.command(
                  ({ tr: c }) => (c.setSelection(J.near(r.resolve(a))), !0)
                )
              : t.commands.exitCode();
          },
        };
      },
      addInputRules() {
        return [
          Tc({
            find: GB,
            type: this.type,
            getAttributes: (t) => ({ language: t[1] }),
          }),
          Tc({
            find: JB,
            type: this.type,
            getAttributes: (t) => ({ language: t[1] }),
          }),
        ];
      },
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (t, e) => {
                if (!e.clipboardData || this.editor.isActive(this.type.name))
                  return !1;
                const n = e.clipboardData.getData("text/plain"),
                  r = e.clipboardData.getData("vscode-editor-data"),
                  o = r ? JSON.parse(r) : void 0,
                  i = o == null ? void 0 : o.mode;
                if (!n || !i) return !1;
                const { tr: s, schema: a } = t.state,
                  l = a.text(
                    n.replace(
                      /\r\n?/g,
                      `
`
                    )
                  );
                return (
                  s.replaceSelectionWith(this.type.create({ language: i }, l)),
                  s.selection.$from.parent.type !== this.type &&
                    s.setSelection(
                      U.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))
                    ),
                  s.setMeta("paste", !0),
                  t.dispatch(s),
                  !0
                );
              },
            },
          }),
        ];
      },
    }),
    Sw = (t, e) => {
      const { doc: n, selection: r } = t;
      if (!n || !r || !(r instanceof U)) return t;
      const { from: o, to: i } = r;
      return (
        n.nodesBetween(o, i, (s, a) => {
          if (o - i == 0 && e === "indent") return t.insertText("  ", o, i), !1;
          const c = n.textBetween(
              a + 1,
              o,
              `
`
            ).lastIndexOf(`
`),
            d = c === -1 ? a + 1 : a + c + 1,
            f = n.textBetween(
              d,
              i,
              `
`
            );
          if (e === "indent") {
            let p = f.replace(
              /\n/g,
              `
  `
            );
            d === a + 1 && (p = "  " + p), t.insertText(p, d, i);
          } else {
            let p = f.replace(
              /\n {2}/g,
              `
`
            );
            d === a + 1 && p.indexOf("  ") == 0 && (p = p.replace("  ", "")),
              t.insertText(p, d, i);
          }
          return !1;
        }),
        t
      );
    },
    Mw = (t) => {
      let e = t;
      for (
        e.nodeName === "#text" && (e = t.parentElement);
        e && e.classList && !e.classList.contains("code-node");

      )
        e = e.parentElement;
      return e;
    },
    Tw = Mu.extend({
      allowGapCursor: !0,
      priority: 110,
      fakeSelection: !0,
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          collapsed: {
            default: !1,
            parseHTML: (e) => !!e.getAttribute("collapsed"),
            renderHTML: (e) => (e.collapsed ? { collapsed: e.collapsed } : {}),
          },
          theme: {
            default: this.options.defaultTheme,
            parseHTML: (e) => e.getAttribute("theme") || null,
            renderHTML: (e) => (e.theme ? { theme: e.theme } : {}),
          },
        };
      },
      addCommands() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          codeIndent:
            () =>
            ({ tr: e, state: n, dispatch: r }) => {
              const { selection: o } = n;
              return (
                (e = e.setSelection(o)),
                (e = Sw(e, "indent")),
                e.docChanged && r ? (r(e), !0) : !1
              );
            },
          codeOutdent:
            () =>
            ({ tr: e, state: n, dispatch: r }) => {
              const { selection: o } = n;
              return (
                (e = e.setSelection(o)),
                (e = Sw(e, "outdent")),
                e.docChanged && r ? (r(e), !0) : !1
              );
            },
        };
      },
      addKeyboardShortcuts() {
        return {
          Backspace: ({ editor: t }) => {
            if (!Ut(t.state, this.name)) return !1;
            const { selection: e } = t.state;
            if (!e.empty)
              return (
                t
                  .chain()
                  .focus()
                  .deleteSelection()
                  .setTextSelection(e.$from.pos)
                  .run(),
                !0
              );
            const { $anchor: n } = e;
            return n.parentOffset === 0 || !n.parent.textContent.length;
          },
          Tab: () =>
            this.editor.isActive("codeBlock")
              ? this.editor.chain().focus().codeIndent().run()
              : !1,
          "Shift-Tab": () =>
            this.editor.isActive("codeBlock")
              ? this.editor.chain().focus().codeOutdent().run()
              : !1,
          "Mod-a": () => {
            if (this.editor.isActive("codeBlock")) {
              const { tr: t, selection: e } = this.editor.state,
                n = jt((a) => a.type.name === Mu.name)(e);
              if (!n) return !1;
              const r = n.start,
                o = n.start + n.node.nodeSize - 1,
                i = t.doc.resolve(r),
                s = t.doc.resolve(o);
              return this.editor.view.dispatch(t.setSelection(new U(i, s))), !0;
            }
            return !1;
          },
        };
      },
      addNodeView() {
        return Bi(KB);
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          languages: [],
          themes: [],
          defaultLanguage: null,
          defaultTheme: null,
          getToolbarItems({ editor: e }) {
            return {
              priority: 160,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: e.isActive("codeBlock"),
                icon: u.markRaw(y0),
                title: T.global.t("editor.common.codeblock.title"),
                action: () => e.chain().focus().toggleCodeBlock().run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 80,
              icon: u.markRaw(y0),
              title: "editor.common.codeblock.title",
              keywords: ["codeblock", "daimakuai"],
              command: ({ editor: e, range: n }) => {
                e.chain().focus().deleteRange(n).setCodeBlock().run();
              },
            };
          },
          getToolboxItems({ editor: e }) {
            return [
              {
                priority: 50,
                component: u.markRaw(io),
                props: {
                  editor: e,
                  icon: u.markRaw(y0),
                  title: T.global.t("editor.common.codeblock.title"),
                  action: () => {
                    e.chain().focus().setCodeBlock().run();
                  },
                },
              },
            ];
          },
          getBubbleMenu() {
            return {
              pluginKey: "codeBlockBubbleMenu",
              shouldShow: ({ state: e }) => Et(e, Mu.name),
              getRenderContainer: (e) => Mw(e),
              items: [
                {
                  priority: 10,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: e }) => Yo(Mu.name, e),
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                return { el: Mw(e) };
              },
            };
          },
        };
      },
      addProseMirrorPlugins() {
        var t;
        return [
          new ie({
            key: new de("codeBlockVSCodeHandlerFixPaste"),
            props: {
              handlePaste: (e, n) => {
                if (!n.clipboardData || this.editor.isActive(this.type.name))
                  return !1;
                const r = n.clipboardData.getData("text/plain"),
                  o = n.clipboardData.getData("vscode-editor-data"),
                  i = o ? JSON.parse(o) : void 0,
                  s = i == null ? void 0 : i.mode;
                if (!r || !s) return !1;
                const { tr: a, schema: l } = e.state,
                  c = l.text(
                    r.replace(
                      /\r\n?/g,
                      `
`
                    )
                  );
                a.replaceSelectionWith(this.type.create({ language: s }, c));
                const { selection: d } = a;
                let f = Math.max(0, d.from - 1);
                for (
                  ;
                  f > 0 && a.doc.resolve(f).parent.type.name !== this.type.name;

                )
                  f--;
                return (
                  a.setSelection(U.near(a.doc.resolve(f))),
                  a.setMeta("paste", !0),
                  e.dispatch(a),
                  !0
                );
              },
            },
          }),
          ...(((t = this.parent) == null ? void 0 : t.call(this)) || []),
        ];
      },
    });
  function YB(t) {
    var e;
    const {
        char: n,
        allowSpaces: r,
        allowToIncludeChar: o,
        allowedPrefixes: i,
        startOfLine: s,
        $position: a,
      } = t,
      l = r && !o,
      c = Y_(n),
      d = new RegExp(`\\s${c}$`),
      f = s ? "^" : "",
      p = o ? "" : c,
      h = l
        ? new RegExp(`${f}${c}.*?(?=\\s${p}|$)`, "gm")
        : new RegExp(`${f}(?:^)?${c}[^\\s${p}]*`, "gm"),
      m =
        ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) &&
        a.nodeBefore.text;
    if (!m) return null;
    const g = a.pos - m.length,
      b = Array.from(m.matchAll(h)).pop();
    if (!b || b.input === void 0 || b.index === void 0) return null;
    const y = b.input.slice(Math.max(0, b.index - 1), b.index),
      x = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(y);
    if (i !== null && !x) return null;
    const w = g + b.index;
    let _ = w + b[0].length;
    return (
      l && d.test(m.slice(_ - 1, _ + 1)) && ((b[0] += " "), (_ += 1)),
      w < a.pos && _ >= a.pos
        ? { range: { from: w, to: _ }, query: b[0].slice(n.length), text: b[0] }
        : null
    );
  }
  const XB = new de("suggestion");
  function ZB({
    pluginKey: t = XB,
    editor: e,
    char: n = "@",
    allowSpaces: r = !1,
    allowToIncludeChar: o = !1,
    allowedPrefixes: i = [" "],
    startOfLine: s = !1,
    decorationTag: a = "span",
    decorationClass: l = "suggestion",
    command: c = () => null,
    items: d = () => [],
    render: f = () => ({}),
    allow: p = () => !0,
    findSuggestionMatch: h = YB,
  }) {
    let m;
    const g = f == null ? void 0 : f(),
      b = new ie({
        key: t,
        view() {
          return {
            update: async (y, x) => {
              var w, _, v, C, S, N, M;
              const L =
                  (w = this.key) === null || w === void 0
                    ? void 0
                    : w.getState(x),
                $ =
                  (_ = this.key) === null || _ === void 0
                    ? void 0
                    : _.getState(y.state),
                B = L.active && $.active && L.range.from !== $.range.from,
                H = !L.active && $.active,
                Q = L.active && !$.active,
                X = !H && !Q && L.query !== $.query,
                Y = H || (B && X),
                Z = X || B,
                ce = Q || (B && X);
              if (!Y && !Z && !ce) return;
              const Ae = ce && !Y ? L : $,
                Ie = y.dom.querySelector(
                  `[data-decoration-id="${Ae.decorationId}"]`
                );
              (m = {
                editor: e,
                range: Ae.range,
                query: Ae.query,
                text: Ae.text,
                items: [],
                command: (xe) => c({ editor: e, range: Ae.range, props: xe }),
                decorationNode: Ie,
                clientRect: Ie
                  ? () => {
                      var xe;
                      const { decorationId: De } =
                          (xe = this.key) === null || xe === void 0
                            ? void 0
                            : xe.getState(e.state),
                        He = y.dom.querySelector(
                          `[data-decoration-id="${De}"]`
                        );
                      return (
                        (He == null ? void 0 : He.getBoundingClientRect()) ||
                        null
                      );
                    }
                  : null,
              }),
                Y &&
                  ((v = g == null ? void 0 : g.onBeforeStart) === null ||
                    v === void 0 ||
                    v.call(g, m)),
                Z &&
                  ((C = g == null ? void 0 : g.onBeforeUpdate) === null ||
                    C === void 0 ||
                    C.call(g, m)),
                (Z || Y) && (m.items = await d({ editor: e, query: Ae.query })),
                ce &&
                  ((S = g == null ? void 0 : g.onExit) === null ||
                    S === void 0 ||
                    S.call(g, m)),
                Z &&
                  ((N = g == null ? void 0 : g.onUpdate) === null ||
                    N === void 0 ||
                    N.call(g, m)),
                Y &&
                  ((M = g == null ? void 0 : g.onStart) === null ||
                    M === void 0 ||
                    M.call(g, m));
            },
            destroy: () => {
              var y;
              m &&
                ((y = g == null ? void 0 : g.onExit) === null ||
                  y === void 0 ||
                  y.call(g, m));
            },
          };
        },
        state: {
          init() {
            return {
              active: !1,
              range: { from: 0, to: 0 },
              query: null,
              text: null,
              composing: !1,
            };
          },
          apply(y, x, w, _) {
            const { isEditable: v } = e,
              { composing: C } = e.view,
              { selection: S } = y,
              { empty: N, from: M } = S,
              L = { ...x };
            if (((L.composing = C), v && (N || e.view.composing))) {
              (M < x.range.from || M > x.range.to) &&
                !C &&
                !x.composing &&
                (L.active = !1);
              const $ = h({
                  char: n,
                  allowSpaces: r,
                  allowToIncludeChar: o,
                  allowedPrefixes: i,
                  startOfLine: s,
                  $position: S.$from,
                }),
                B = `id_${Math.floor(Math.random() * 4294967295)}`;
              $ &&
              p({ editor: e, state: _, range: $.range, isActive: x.active })
                ? ((L.active = !0),
                  (L.decorationId = x.decorationId ? x.decorationId : B),
                  (L.range = $.range),
                  (L.query = $.query),
                  (L.text = $.text))
                : (L.active = !1);
            } else L.active = !1;
            return (
              L.active ||
                ((L.decorationId = null),
                (L.range = { from: 0, to: 0 }),
                (L.query = null),
                (L.text = null)),
              L
            );
          },
        },
        props: {
          handleKeyDown(y, x) {
            var w;
            const { active: _, range: v } = b.getState(y.state);
            return (
              (_ &&
                ((w = g == null ? void 0 : g.onKeyDown) === null || w === void 0
                  ? void 0
                  : w.call(g, { view: y, event: x, range: v }))) ||
              !1
            );
          },
          decorations(y) {
            const { active: x, range: w, decorationId: _ } = b.getState(y);
            return x
              ? ue.create(y.doc, [
                  Te.inline(w.from, w.to, {
                    nodeName: a,
                    class: l,
                    "data-decoration-id": _,
                  }),
                ])
              : null;
          },
        },
      });
    return b;
  }
  const Nw = (t) => typeof t == "object" && t != null && t.nodeType === 1,
    Ow = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
    _0 = (t, e) => {
      if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
        const n = getComputedStyle(t, null);
        return (
          Ow(n.overflowY, e) ||
          Ow(n.overflowX, e) ||
          ((r) => {
            const o = ((i) => {
              if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
              try {
                return i.ownerDocument.defaultView.frameElement;
              } catch {
                return null;
              }
            })(r);
            return (
              !!o &&
              (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth)
            );
          })(t)
        );
      }
      return !1;
    },
    Tu = (t, e, n, r, o, i, s, a) =>
      (i < t && s > e) || (i > t && s < e)
        ? 0
        : (i <= t && a <= n) || (s >= e && a >= n)
        ? i - t - r
        : (s > e && a < n) || (i < t && a > n)
        ? s - e + o
        : 0,
    QB = (t) => {
      const e = t.parentElement;
      return e ?? (t.getRootNode().host || null);
    },
    Rw = (t, e) => {
      var n, r, o, i;
      if (typeof document > "u") return [];
      const {
          scrollMode: s,
          block: a,
          inline: l,
          boundary: c,
          skipOverflowHiddenElements: d,
        } = e,
        f = typeof c == "function" ? c : (B) => B !== c;
      if (!Nw(t)) throw new TypeError("Invalid target");
      const p = document.scrollingElement || document.documentElement,
        h = [];
      let m = t;
      for (; Nw(m) && f(m); ) {
        if (((m = QB(m)), m === p)) {
          h.push(m);
          break;
        }
        (m != null &&
          m === document.body &&
          _0(m) &&
          !_0(document.documentElement)) ||
          (m != null && _0(m, d) && h.push(m));
      }
      const g =
          (r = (n = window.visualViewport) == null ? void 0 : n.width) != null
            ? r
            : innerWidth,
        b =
          (i = (o = window.visualViewport) == null ? void 0 : o.height) != null
            ? i
            : innerHeight,
        { scrollX: y, scrollY: x } = window,
        {
          height: w,
          width: _,
          top: v,
          right: C,
          bottom: S,
          left: N,
        } = t.getBoundingClientRect();
      let M =
          a === "start" || a === "nearest" ? v : a === "end" ? S : v + w / 2,
        L = l === "center" ? N + _ / 2 : l === "end" ? C : N;
      const $ = [];
      for (let B = 0; B < h.length; B++) {
        const H = h[B],
          {
            height: Q,
            width: X,
            top: Y,
            right: Z,
            bottom: ce,
            left: Ae,
          } = H.getBoundingClientRect();
        if (
          s === "if-needed" &&
          v >= 0 &&
          N >= 0 &&
          S <= b &&
          C <= g &&
          v >= Y &&
          S <= ce &&
          N >= Ae &&
          C <= Z
        )
          return $;
        const Ie = getComputedStyle(H),
          xe = parseInt(Ie.borderLeftWidth, 10),
          De = parseInt(Ie.borderTopWidth, 10),
          He = parseInt(Ie.borderRightWidth, 10),
          We = parseInt(Ie.borderBottomWidth, 10);
        let Oe = 0,
          Be = 0;
        const pt =
            "offsetWidth" in H ? H.offsetWidth - H.clientWidth - xe - He : 0,
          Je =
            "offsetHeight" in H ? H.offsetHeight - H.clientHeight - De - We : 0,
          yt =
            "offsetWidth" in H
              ? H.offsetWidth === 0
                ? 0
                : X / H.offsetWidth
              : 0,
          tt =
            "offsetHeight" in H
              ? H.offsetHeight === 0
                ? 0
                : Q / H.offsetHeight
              : 0;
        if (p === H)
          (Oe =
            a === "start"
              ? M
              : a === "end"
              ? M - b
              : a === "nearest"
              ? Tu(x, x + b, b, De, We, x + M, x + M + w, w)
              : M - b / 2),
            (Be =
              l === "start"
                ? L
                : l === "center"
                ? L - g / 2
                : l === "end"
                ? L - g
                : Tu(y, y + g, g, xe, He, y + L, y + L + _, _)),
            (Oe = Math.max(0, Oe + x)),
            (Be = Math.max(0, Be + y));
        else {
          (Oe =
            a === "start"
              ? M - Y - De
              : a === "end"
              ? M - ce + We + Je
              : a === "nearest"
              ? Tu(Y, ce, Q, De, We + Je, M, M + w, w)
              : M - (Y + Q / 2) + Je / 2),
            (Be =
              l === "start"
                ? L - Ae - xe
                : l === "center"
                ? L - (Ae + X / 2) + pt / 2
                : l === "end"
                ? L - Z + He + pt
                : Tu(Ae, Z, X, xe, He + pt, L, L + _, _));
          const { scrollLeft: Gt, scrollTop: Rn } = H;
          (Oe = Math.max(
            0,
            Math.min(Rn + Oe / tt, H.scrollHeight - Q / tt + Je)
          )),
            (Be = Math.max(
              0,
              Math.min(Gt + Be / yt, H.scrollWidth - X / yt + pt)
            )),
            (M += Rn - Oe),
            (L += Gt - Be);
        }
        $.push({ el: H, top: Oe, left: Be });
      }
      return $;
    },
    eP = (t) =>
      t === !1
        ? { block: "end", inline: "nearest" }
        : ((e) => e === Object(e) && Object.keys(e).length !== 0)(t)
        ? t
        : { block: "start", inline: "nearest" };
  function Dw(t, e) {
    if (
      !t.isConnected ||
      !((o) => {
        let i = o;
        for (; i && i.parentNode; ) {
          if (i.parentNode === document) return !0;
          i =
            i.parentNode instanceof ShadowRoot
              ? i.parentNode.host
              : i.parentNode;
        }
        return !1;
      })(t)
    )
      return;
    const n = ((o) => {
      const i = window.getComputedStyle(o);
      return {
        top: parseFloat(i.scrollMarginTop) || 0,
        right: parseFloat(i.scrollMarginRight) || 0,
        bottom: parseFloat(i.scrollMarginBottom) || 0,
        left: parseFloat(i.scrollMarginLeft) || 0,
      };
    })(t);
    if (((o) => typeof o == "object" && typeof o.behavior == "function")(e))
      return e.behavior(Rw(t, e));
    const r = typeof e == "boolean" || e == null ? void 0 : e.behavior;
    for (const { el: o, top: i, left: s } of Rw(t, eP(e))) {
      const a = i - n.top + n.bottom,
        l = s - n.left + n.right;
      o.scroll({ top: a, left: l, behavior: r });
    }
  }
  const tP = { class: "command-items" },
    nP = ["id", "onClick"],
    rP = {
      class: "command-title group-hover:text-gray-900 group-hover:font-medium",
    },
    oP = { key: 1, class: "command-empty" },
    iP = u.defineComponent({
      __name: "CommandsView",
      props: {
        items: { type: Array, required: !0 },
        command: { type: Function, required: !0 },
      },
      setup(t, { expose: e }) {
        const n = t,
          r = u.ref(0);
        u.watch(
          () => n.items,
          () => {
            r.value = 0;
          }
        );
        function o({ event: c }) {
          return c.key === "ArrowUp" || (c.key === "k" && c.ctrlKey)
            ? (i(), !0)
            : c.key === "ArrowDown" || (c.key === "j" && c.ctrlKey)
            ? (s(), !0)
            : c.key === "Enter"
            ? (a(), !0)
            : !1;
        }
        function i() {
          r.value = (r.value + n.items.length - 1) % n.items.length;
        }
        function s() {
          r.value = (r.value + 1) % n.items.length;
        }
        function a() {
          l(r.value);
        }
        function l(c) {
          const d = n.items[c];
          d && n.command(d);
        }
        return (
          u.watch(
            () => r.value,
            () => {
              const c = document.getElementById(`command-item-${r.value}`);
              c && Dw(c, { behavior: "smooth", scrollMode: "if-needed" });
            }
          ),
          e({ onKeyDown: o }),
          (c, d) => (
            u.openBlock(),
            u.createElementBlock("div", tP, [
              t.items.length
                ? (u.openBlock(!0),
                  u.createElementBlock(
                    u.Fragment,
                    { key: 0 },
                    u.renderList(
                      t.items,
                      (f, p) => (
                        u.openBlock(),
                        u.createElementBlock(
                          "div",
                          {
                            id: `command-item-${p}`,
                            key: p,
                            class: u.normalizeClass([
                              { "is-selected": p === r.value },
                              "command-item group hover:bg-gray-100",
                            ]),
                            onClick: (h) => l(p),
                          },
                          [
                            (u.openBlock(),
                            u.createBlock(u.resolveDynamicComponent(f.icon), {
                              class: "command-icon group-hover:!bg-white",
                            })),
                            u.createElementVNode(
                              "span",
                              rP,
                              u.toDisplayString(u.unref(T).global.t(f.title)),
                              1
                            ),
                          ],
                          10,
                          nP
                        )
                      )
                    ),
                    128
                  ))
                : (u.openBlock(),
                  u.createElementBlock("div", oP, [
                    u.createElementVNode(
                      "span",
                      null,
                      u.toDisplayString(
                        u
                          .unref(T)
                          .global.t(
                            "editor.extensions.commands_menu.no_results"
                          )
                      ),
                      1
                    ),
                  ])),
            ])
          )
        );
      },
    }),
    Lw = we.create({
      name: "commands-menu",
      addProseMirrorPlugins() {
        const t = sP(this.editor);
        return [
          ZB({
            editor: this.editor,
            char: "/",
            command: ({ editor: e, range: n, props: r }) => {
              r.command({ editor: e, range: n });
            },
            items: ({ query: e }) =>
              t.filter((n) =>
                [...n.keywords, n.title].some((r) => r.includes(e))
              ),
            render: () => {
              let e, n;
              return {
                onStart: (r) => {
                  (e = new Th(iP, { props: r, editor: r.editor })),
                    r.clientRect &&
                      (n = oo("body", {
                        getReferenceClientRect: r.clientRect,
                        appendTo: () => document.body,
                        content: e.element,
                        showOnCreate: !0,
                        interactive: !0,
                        trigger: "manual",
                        placement: "bottom-start",
                      }));
                },
                onUpdate(r) {
                  e.updateProps(r),
                    r.clientRect &&
                      n[0].setProps({ getReferenceClientRect: r.clientRect });
                },
                onKeyDown(r) {
                  var o;
                  return r.event.key === "Escape"
                    ? (n[0].hide(), !0)
                    : (o = e.ref) == null
                    ? void 0
                    : o.onKeyDown(r);
                },
                onExit() {
                  n[0].destroy(), e.destroy();
                },
              };
            },
          }),
        ];
      },
    });
  function sP(t) {
    return (t == null ? void 0 : t.extensionManager).extensions
      .reduce((n, r) => {
        const { getCommandMenuItems: o } = r.options;
        if (!o) return n;
        const i = o();
        return Array.isArray(i) ? [...n, ...i] : [...n, i];
      }, [])
      .sort((n, r) => n.priority - r.priority);
  }
  const aP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function lP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        aP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10.59 13.41c.41.39.41 1.03 0 1.42c-.39.39-1.03.39-1.42 0a5.003 5.003 0 0 1 0-7.07l3.54-3.54a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.53 3.53a2.98 2.98 0 0 0 0 4.24m2.82-4.24c.39-.39 1.03-.39 1.42 0a5.003 5.003 0 0 1 0 7.07l-3.54 3.54a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l3.53-3.53a2.98 2.98 0 0 0 0-4.24a.973.973 0 0 1 0-1.42",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const $a = u.markRaw({ name: "mdi-link-variant", render: lP }),
    cP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function uP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        cP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5M18 12c0-3.33-2.67-6-6-6s-6 2.67-6 6s2.67 6 6 6s6-2.67 6-6m-3 0l-5 3V9",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Iw = u.markRaw({ name: "mdi-motion-play", render: uP }),
    dP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function fP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        dP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m10 16.5l6-4.5l-6-4.5M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Bw = u.markRaw({ name: "mdi-motion-play-outline", render: fP }),
    pP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function hP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        pP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16 9h-3v5.5a2.5 2.5 0 0 1-2.5 2.5A2.5 2.5 0 0 1 8 14.5a2.5 2.5 0 0 1 2.5-2.5c.57 0 1.08.19 1.5.5V7h4zm-4-7a10 10 0 0 1 10 10a10 10 0 0 1-10 10A10 10 0 0 1 2 12A10 10 0 0 1 12 2m0 2a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Pw = u.markRaw({ name: "mdi-music-circle-outline", render: hP }),
    mP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function gP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        mP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10 16.5v-9l6 4.5M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const $w = u.markRaw({ name: "mdi-play-circle", render: gP }),
    bP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function yP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        bP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M12 20c-4.41 0-8-3.59-8-8s3.59-8 8-8s8 3.59 8 8s-3.59 8-8 8m0-18A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2m-2 14.5l6-4.5l-6-4.5z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Fw = u.markRaw({ name: "mdi-play-circle-outline", render: yP }),
    _P = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function kP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        _P,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m21 12l-7-7v4C7 10 4 15 3 20c2.5-3.5 6-5.1 11-5.1V19z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Fa = u.markRaw({ name: "mdi-share", render: kP }),
    wP = {
      class:
        "inline-block overflow-hidden transition-all text-center relative h-full w-full",
    },
    xP = { key: 0, class: "p-1.5" },
    CP = ["placeholder"],
    vP = ["autoplay", "loop", "src"],
    EP = u.defineComponent({
      __name: "AudioView",
      props: {
        decorations: {},
        selected: { type: Boolean },
        updateAttributes: { type: Function },
        deleteNode: { type: Function },
        node: {},
        view: {},
        getPos: { type: Function },
        innerDecorations: {},
        editor: {},
        extension: {},
        HTMLAttributes: {},
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              var a;
              return (a = e.node) == null ? void 0 : a.attrs.src;
            },
            set: (a) => {
              e.updateAttributes({ src: a });
            },
          }),
          r = u.computed(() => e.node.attrs.autoplay),
          o = u.computed(() => e.node.attrs.loop);
        function i() {
          e.editor.commands.setNodeSelection(e.getPos());
        }
        const s = u.ref();
        return (
          u.onMounted(() => {
            n.value || s.value.focus();
          }),
          (a, l) => (
            u.openBlock(),
            u.createBlock(
              u.unref(Ii),
              { as: "div", class: "inline-block w-full" },
              {
                default: u.withCtx(() => [
                  u.createElementVNode("div", wP, [
                    n.value
                      ? (u.openBlock(),
                        u.createElementBlock(
                          "audio",
                          {
                            key: 1,
                            controls: "",
                            autoplay: r.value,
                            loop: o.value,
                            src: a.node.attrs.src,
                            onMouseenter: i,
                          },
                          null,
                          40,
                          vP
                        ))
                      : (u.openBlock(),
                        u.createElementBlock("div", xP, [
                          u.withDirectives(
                            u.createElementVNode(
                              "input",
                              {
                                ref_key: "inputRef",
                                ref: s,
                                "onUpdate:modelValue":
                                  l[0] || (l[0] = (c) => (n.value = c)),
                                class:
                                  "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                                placeholder: u
                                  .unref(T)
                                  .global.t(
                                    "editor.common.placeholder.link_input"
                                  ),
                                tabindex: "-1",
                                onFocus: i,
                              },
                              null,
                              40,
                              CP
                            ),
                            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
                          ),
                        ])),
                  ]),
                ]),
                _: 1,
              }
            )
          )
        );
      },
    }),
    AP = ["placeholder"],
    SP = u.defineComponent({
      __name: "BubbleItemAudioLink",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              var r;
              return (r = e.editor.getAttributes(dt.name)) == null
                ? void 0
                : r.src;
            },
            set: (r) => {
              e.editor
                .chain()
                .updateAttributes(dt.name, { src: r })
                .setNodeSelection(e.editor.state.selection.from)
                .focus()
                .run();
            },
          });
        return (r, o) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
                placeholder: u
                  .unref(T)
                  .global.t("editor.common.placeholder.link_input"),
                class:
                  "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
              },
              null,
              8,
              AP
            )),
            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
          );
      },
    }),
    dt = Pe.create({
      name: "audio",
      fakeSelection: !0,
      inline() {
        return !0;
      },
      group() {
        return "inline";
      },
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          src: { default: null, parseHTML: (e) => e.getAttribute("src") },
          autoplay: {
            default: null,
            parseHTML: (e) => e.getAttribute("autoplay"),
            renderHTML: (e) => ({ autoplay: e.autoplay }),
          },
          controls: {
            default: !0,
            parseHTML: (e) => e.getAttribute("controls"),
            renderHTML: (e) => ({ controls: e.controls }),
          },
          loop: {
            default: null,
            parseHTML: (e) => e.getAttribute("loop"),
            renderHTML: (e) => ({ loop: e.loop }),
          },
        };
      },
      parseHTML() {
        return [{ tag: "audio" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["audio", se(t)];
      },
      addCommands() {
        return {
          setAudio:
            (t) =>
            ({ commands: e }) =>
              e.insertContent({ type: this.name, attrs: t }),
        };
      },
      addInputRules() {
        return [
          Ti({
            find: /^\$audio\$$/,
            type: this.type,
            getAttributes: () => ({ width: "100%" }),
          }),
        ];
      },
      addNodeView() {
        return Bi(EP);
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getCommandMenuItems() {
            return {
              priority: 110,
              icon: u.markRaw(Pw),
              title: "editor.extensions.commands_menu.audio",
              keywords: ["audio", "yinpin"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .insertContent([
                    { type: "audio", attrs: { src: "" } },
                    { type: "paragraph", content: "" },
                  ])
                  .run();
              },
            };
          },
          getToolboxItems({ editor: e }) {
            return {
              priority: 20,
              component: u.markRaw(io),
              props: {
                editor: e,
                icon: u.markRaw(Pw),
                title: T.global.t("editor.extensions.commands_menu.audio"),
                action: () => {
                  e.chain()
                    .focus()
                    .insertContent([{ type: "audio", attrs: { src: "" } }])
                    .run();
                },
              },
            };
          },
          getBubbleMenu({ editor: e }) {
            return {
              pluginKey: "audioBubbleMenu",
              shouldShow: ({ state: n }) => Et(n, dt.name),
              items: [
                {
                  priority: 10,
                  props: {
                    isActive: () => e.getAttributes(dt.name).autoplay,
                    icon: u.markRaw(
                      e.getAttributes(dt.name).autoplay ? $w : Fw
                    ),
                    action: () => {
                      e.chain()
                        .updateAttributes(dt.name, {
                          autoplay: e.getAttributes(dt.name).autoplay
                            ? null
                            : !0,
                        })
                        .setNodeSelection(e.state.selection.from)
                        .focus()
                        .run();
                    },
                    title: e.getAttributes(dt.name).autoplay
                      ? T.global.t("editor.extensions.audio.disable_autoplay")
                      : T.global.t("editor.extensions.audio.enable_autoplay"),
                  },
                },
                {
                  priority: 20,
                  props: {
                    isActive: () => e.getAttributes(dt.name).loop,
                    icon: u.markRaw(e.getAttributes(dt.name).loop ? Iw : Bw),
                    action: () => {
                      e.chain()
                        .updateAttributes(dt.name, {
                          loop: e.getAttributes(dt.name).loop ? null : !0,
                        })
                        .setNodeSelection(e.state.selection.from)
                        .focus()
                        .run();
                    },
                    title: e.getAttributes(dt.name).loop
                      ? T.global.t("editor.extensions.audio.disable_loop")
                      : T.global.t("editor.extensions.audio.enable_loop"),
                  },
                },
                { priority: 30, component: u.markRaw(Ve) },
                {
                  priority: 40,
                  props: {
                    icon: u.markRaw($a),
                    title: T.global.t("editor.common.button.edit_link"),
                    action: () => u.markRaw(SP),
                  },
                },
                {
                  priority: 50,
                  props: {
                    icon: u.markRaw(Fa),
                    title: T.global.t("editor.common.tooltip.open_link"),
                    action: () => {
                      window.open(e.getAttributes(dt.name).src, "_blank");
                    },
                  },
                },
                { priority: 60, component: u.markRaw(Ve) },
                {
                  priority: 70,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: n }) => {
                      Yo(dt.name, n);
                    },
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && !n.hasAttribute("data-node-view-wrapper"); )
                  n = n.parentElement;
                return { el: n };
              },
            };
          },
        };
      },
    }),
    MP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function TP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        MP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "m16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.01 4.01 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53l-4.95-4.95z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const NP = u.markRaw({ name: "mdi-eraser", render: TP }),
    Hw = we.create({
      name: "clearFormat",
      addOptions() {
        return {
          getToolbarItems({ editor: t }) {
            return {
              priority: 23,
              component: u.markRaw($e),
              props: {
                editor: t,
                isActive: !1,
                icon: u.markRaw(NP),
                title: T.global.t("editor.common.clear_format"),
                action: () => t.chain().focus().unsetAllMarks().run(),
              },
            };
          },
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-\\": () => this.editor.chain().focus().unsetAllMarks().run(),
        };
      },
    }),
    Nu = Pe.create({
      name: "column",
      content: "block+",
      isolating: !0,
      fakeSelection: !0,
      addOptions() {
        return { HTMLAttributes: { class: "column" } };
      },
      addAttributes() {
        return {
          index: { default: 0, parseHTML: (t) => t.getAttribute("index") },
          style: {
            default: "min-width: 0;flex: 1 1;box-sizing: border-box;",
            parseHTML: (t) => t.getAttribute("style"),
          },
        };
      },
      parseHTML() {
        return [{ tag: "div[class=column]" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["div", se(this.options.HTMLAttributes, t), 0];
      },
    }),
    OP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function RP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        OP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M5 3c-1.11 0-2 .89-2 2v14c0 1.11.89 2 2 2h6V3m2 0v8h8V5c0-1.11-.89-2-2-2m-6 10v8h6c1.11 0 2-.89 2-2v-6",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const zw = u.markRaw({ name: "mdi-collage", render: RP }),
    DP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function LP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        DP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M12 3a1 1 0 0 1 1 1v8a5 5 0 1 1 .213 8.152L13 20a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2H7v14h4zm8 10h-6v2h6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const IP = u.markRaw({ name: "ri-delete-column", render: LP }),
    BP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function PP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        BP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M20 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2h-4v14h4zM6 7a5 5 0 1 1 0 10A5 5 0 0 1 6 7m1 2H5v1.999L3 11v2l2-.001V15h2v-2.001L9 13v-2l-2-.001z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const $P = u.markRaw({ name: "ri-insert-column-left", render: PP }),
    FP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function HP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        FP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM9 5H5v14h4zm9 2a5 5 0 1 1 0 10a5 5 0 0 1 0-10m1 2h-2v1.999L15 11v2l2-.001V15h2v-2.001L21 13v-2l-2-.001z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const zP = u.markRaw({ name: "ri-insert-column-right", render: HP }),
    VP = (t, e) => {
      const n = UP(t),
        r = [];
      for (let o = 0; o < e; o += 1) {
        const i = n.column.createAndFill({ index: o });
        i && r.push(i);
      }
      return n.columns.createChecked({ cols: e }, r);
    },
    UP = (t) => {
      if (t.cached.columnsNodeTypes) return t.cached.columnsNodeTypes;
      const e = { columns: t.nodes.columns, column: t.nodes.column };
      return (t.cached.columnsNodeTypes = e), e;
    },
    k0 = (t, e, n) => {
      const r = jt((i) => i.type.name === ji.name)(e.selection),
        o = jt((i) => i.type.name === Nu.name)(e.selection);
      if (t && r && o) {
        const i = r.node,
          s = o.node.attrs.index,
          a = i.toJSON();
        let l = s;
        n === "delete"
          ? ((l = s - 1), a.content.splice(s, 1))
          : ((l = n === "addBefore" ? s : s + 1),
            a.content.splice(l, 0, {
              type: "column",
              attrs: { index: s },
              content: [{ type: "paragraph" }],
            })),
          (a.attrs.cols = a.content.length),
          a.content.forEach((p, h) => {
            p.attrs.index = h;
          });
        const c = Qt.fromJSON(e.schema, a);
        let d = r.pos;
        c.content.forEach((p, h, m) => {
          m < l && (d += p.nodeSize);
        });
        const f = e.tr.setTime(Date.now());
        f
          .replaceWith(r.pos, r.pos + r.node.nodeSize, c)
          .setSelection(U.near(f.doc.resolve(d))),
          t(f);
      }
      return !0;
    },
    Vw = (t, e, n) => {
      const r = jt((i) => i.type.name === ji.name)(t.selection),
        o = jt((i) => i.type.name === Nu.name)(t.selection);
      if (e && r && o) {
        const i = r.node,
          s = o.node.attrs.index;
        let a = 0;
        n === "before"
          ? (a = (s - 1 + i.attrs.cols) % i.attrs.cols)
          : (a = (s + 1) % i.attrs.cols);
        let l = r.pos;
        i.content.forEach((d, f, p) => {
          p < a && (l += d.nodeSize);
        });
        const c = t.tr.setTime(Date.now());
        return c.setSelection(U.near(c.doc.resolve(l))), e(c), !0;
      }
      return !1;
    },
    ji = Pe.create({
      name: "columns",
      group: "block",
      priority: 10,
      defining: !0,
      isolating: !0,
      allowGapCursor: !0,
      content: "column{1,}",
      fakeSelection: !1,
      addOptions() {
        return {
          HTMLAttributes: { class: "columns" },
          getToolboxItems({ editor: t }) {
            return [
              {
                priority: 50,
                component: u.markRaw(io),
                props: {
                  editor: t,
                  icon: u.markRaw(zw),
                  title: T.global.t("editor.extensions.commands_menu.columns"),
                  action: () => {
                    t.chain().focus().insertColumns({ cols: 2 }).run();
                  },
                },
              },
            ];
          },
          getCommandMenuItems() {
            return {
              priority: 70,
              icon: u.markRaw(zw),
              title: "editor.extensions.commands_menu.columns",
              keywords: ["fenlan", "columns"],
              command: ({ editor: t, range: e }) => {
                t.chain()
                  .focus()
                  .deleteRange(e)
                  .insertColumns({ cols: 2 })
                  .run();
              },
            };
          },
          getBubbleMenu() {
            return {
              pluginKey: "columnsBubbleMenu",
              shouldShow: ({ state: t }) => Et(t, ji.name),
              getRenderContainer: (t) => {
                let e = t;
                for (
                  e.nodeName === "#text" && (e = t.parentElement);
                  e && e.classList && !e.classList.contains("column");

                )
                  e = e.parentElement;
                return e;
              },
              items: [
                {
                  priority: 10,
                  props: {
                    icon: u.markRaw($P),
                    title: T.global.t(
                      "editor.extensions.columns.add_column_before"
                    ),
                    action: ({ editor: t }) => {
                      t.chain().focus().addColBefore().run();
                    },
                  },
                },
                {
                  priority: 20,
                  props: {
                    icon: u.markRaw(zP),
                    title: T.global.t(
                      "editor.extensions.columns.add_column_after"
                    ),
                    action: ({ editor: t }) => {
                      t.chain().focus().addColAfter().run();
                    },
                  },
                },
                {
                  priority: 30,
                  props: {
                    icon: u.markRaw(IP),
                    title: T.global.t(
                      "editor.extensions.columns.delete_column"
                    ),
                    action: ({ editor: t }) => {
                      t.chain().focus().deleteCol().run();
                    },
                  },
                },
                { priority: 40, component: u.markRaw(Ve) },
                {
                  priority: 50,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: t }) => {
                      Yo(ji.name, t);
                    },
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: t }) {
                let e = t;
                for (; e && !e.classList.contains("columns"); )
                  e = e.parentElement;
                return { el: e, dragDomOffset: { y: -5 } };
              },
              allowPropagationDownward: !0,
            };
          },
        };
      },
      addAttributes() {
        return {
          cols: { default: 2, parseHTML: (t) => t.getAttribute("cols") },
          style: {
            default: "display: flex;width: 100%;gap: 1em;",
            parseHTML: (t) => t.getAttribute("style"),
          },
        };
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["div", se(this.options.HTMLAttributes, t), 0];
      },
      addCommands() {
        return {
          insertColumns:
            (t) =>
            ({ tr: e, dispatch: n, editor: r }) => {
              const o = VP(r.schema, (t && t.cols) || 3);
              if (n) {
                const i = e.selection.anchor + 1;
                e.replaceSelectionWith(o)
                  .scrollIntoView()
                  .setSelection(U.near(e.doc.resolve(i)));
              }
              return !0;
            },
          addColBefore:
            () =>
            ({ dispatch: t, state: e }) =>
              k0(t, e, "addBefore"),
          addColAfter:
            () =>
            ({ dispatch: t, state: e }) =>
              k0(t, e, "addAfter"),
          deleteCol:
            () =>
            ({ dispatch: t, state: e }) =>
              k0(t, e, "delete"),
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-G": () => this.editor.commands.insertColumns(),
          Tab: () => Vw(this.editor.state, this.editor.view.dispatch, "after"),
          "Shift-Tab": () =>
            Vw(this.editor.state, this.editor.view.dispatch, "before"),
        };
      },
    });
  let hn,
    fe = null,
    qt,
    Ge = null,
    ei = null,
    Ou,
    Ha = !1,
    za = !1;
  const jP = () => {
      const t = document.createElement("div");
      return (
        t.classList.add("draggable"),
        (t.draggable = !0),
        t.setAttribute("data-drag-handle", "true"),
        t
      );
    },
    Uw = () => {
      var t, e;
      (t = fe == null ? void 0 : fe.classList) == null || t.add("show"),
        (e = fe == null ? void 0 : fe.classList) == null || e.remove("hide");
    },
    Va = () => {
      var t, e, n;
      (t = fe == null ? void 0 : fe.classList) == null || t.remove("show"),
        (e = fe == null ? void 0 : fe.classList) == null || e.remove("active"),
        (n = fe == null ? void 0 : fe.classList) == null || n.add("hide");
    },
    WP = (t, e) => {
      const n = t.dom.parentElement;
      if (!n || !fe) return;
      const r = e == null ? void 0 : e.el;
      if (!r) return;
      const o = r.getBoundingClientRect(),
        i = n.getBoundingClientRect(),
        s = fe.getBoundingClientRect(),
        a = o.left - i.left - s.width - 5 + e.domOffsetLeft,
        l = o.top - i.top + s.height / 2 + n.scrollTop + e.domOffsetTop;
      (fe.style.left = `${a}px`), (fe.style.top = `${l - 2}px`), Uw();
    },
    jw = () => {
      Ge && ((za = !0), qt.dispatch(qt.state.tr), clearTimeout(Ou), Uw());
    },
    Ww = () => {
      Ge && ((za = !1), qt.dispatch(qt.state.tr), Va());
    },
    qw = () => {
      if (!Ge) return null;
      if (((za = !1), qt.dispatch(qt.state.tr), K.isSelectable(Ge.node))) {
        const t = K.create(qt.state.doc, Ge.$pos.pos - Ge.offset);
        return (
          qt.dispatch(qt.state.tr.setSelection(t)), qt.focus(), (ei = t), t
        );
      }
      return null;
    },
    Kw = () => {
      Ha && ((Ha = !1), (ei = null), (Ge = null));
    },
    Gw = (t) => {
      if (((Ha = !0), (za = !1), t.dataTransfer && Ge && ei)) {
        const e = ei.content();
        t.dataTransfer.effectAllowed = "move";
        const { dom: n, text: r } = ob(qt, e);
        t.dataTransfer.clearData(),
          t.dataTransfer.setData("text/html", n.innerHTML),
          t.dataTransfer.setData("text/plain", r),
          t.dataTransfer.setDragImage(Ge == null ? void 0 : Ge.el, 0, 0),
          (qt.dragging = { slice: e, move: !0 });
      }
    },
    qP = (t, e, n) => {
      const { node: r } = t.domAtPos(n.pos);
      let o = r,
        i = o.parentElement;
      for (; i && i !== e && n.pos === t.posAtDOM(i, 0); )
        (o = i), (i = i.parentElement);
      return o;
    },
    Jw = (t, e) => {
      const n = t.posAtDOM(e, 0);
      return n < 0 ? null : t.state.doc.resolve(n);
    },
    Yw = (t, e) => {
      const n = e.dom.parentElement;
      if (!n) return null;
      const r = Jw(e, t);
      if (!r) return null;
      const o = r.node(),
        i = qP(e, n, r);
      return {
        node: o,
        $pos: r,
        el: i,
        offset: 1,
        domOffsetLeft: 0,
        domOffsetTop: 0,
      };
    },
    KP = (t, e) => {
      var o, i;
      const n = t.extensionManager.extensions.find(
        (s) => s.name === e.type.name
      );
      return n
        ? (i = (o = n.options).getDraggable) == null
          ? void 0
          : i.call(o, { editor: t })
        : void 0;
    },
    Xw = (t, e, n) => {
      var i, s, a;
      const r =
          (i = e == null ? void 0 : e.getRenderContainer) == null
            ? void 0
            : i.call(e, { dom: n, view: t }),
        o = Yw((r == null ? void 0 : r.el) || n, t);
      return {
        el: (r == null ? void 0 : r.el) || n,
        node: (r == null ? void 0 : r.node) || (o == null ? void 0 : o.node),
        $pos: (r == null ? void 0 : r.$pos) || (o == null ? void 0 : o.$pos),
        offset:
          (r == null ? void 0 : r.nodeOffset) ||
          (o == null ? void 0 : o.offset),
        domOffsetLeft:
          ((s = r == null ? void 0 : r.dragDomOffset) == null ? void 0 : s.x) ||
          0,
        domOffsetTop:
          ((a = r == null ? void 0 : r.dragDomOffset) == null ? void 0 : a.y) ||
          0,
      };
    },
    GP = (t, e, n = 1) => {
      const r = Jw(t, e);
      if (!r) return;
      if (n > r.depth) {
        if (n - r.depth == 1) {
          const i = r.node();
          if (i.firstChild && !i.firstChild.type.isBlock) return i.firstChild;
        }
        return;
      }
      const o = r.node(n);
      if (o) return o;
    },
    w0 = ({ editor: t, view: e, dom: n, event: r, depth: o = 1 }) => {
      const i = GP(e, n, o);
      if (!i) return;
      const s = KP(t, i);
      if (s) {
        if (typeof s == "boolean") return s;
        const a = Xw(e, s, n),
          l = { left: r.clientX, top: r.clientY },
          c = e.posAtCoords(l);
        if (
          c &&
          (c.inside == -1 ||
            !(c.inside >= a.$pos.start() && c.inside <= a.$pos.end()))
        )
          return s;
        if (s.allowPropagationDownward) {
          const d = w0({ editor: t, view: e, dom: n, event: r, depth: ++o });
          if (d) return d;
        }
        return s;
      }
      return w0({ editor: t, view: e, dom: n, event: r, depth: ++o });
    },
    JP = (t, e, n) => {
      var i, s;
      const r = t.resolve(e);
      if (!n.content.size) return e;
      let o = n.content;
      for (let a = 0; a < n.openStart; a++)
        o =
          (i = o == null ? void 0 : o.firstChild) == null ? void 0 : i.content;
      for (let a = 1; a <= (n.openStart == 0 && n.size ? 2 : 1); a++)
        for (let l = r.depth; l >= 0; l--) {
          const c =
              l == r.depth
                ? 0
                : r.pos <= (r.start(l + 1) + r.end(l + 1)) / 2
                ? -1
                : 1,
            d = r.index(l) + (c > 0 ? 1 : 0),
            f = r.node(l);
          let p = !1;
          if (a == 1) p = f.canReplace(d, d, o);
          else {
            const h = f
              .contentMatchAt(d)
              .findWrapping(
                (s = o == null ? void 0 : o.firstChild) == null
                  ? void 0
                  : s.type
              );
            p = (h && f.canReplaceWith(d, d, h[0])) || !1;
          }
          if (p)
            return c == 0 ? r.pos : c < 0 ? r.before(l + 1) : r.after(l + 1);
        }
      return null;
    },
    YP = we.create({
      name: "draggable",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("node-draggable"),
            view: (t) => {
              (fe = jP()),
                fe.addEventListener("mouseenter", jw),
                fe.addEventListener("mouseleave", Ww),
                fe.addEventListener("mousedown", qw),
                fe.addEventListener("mouseup", Kw),
                fe.addEventListener("dragstart", Gw);
              const e = t.dom.parentNode;
              return (
                e.appendChild(fe),
                (e.style.position = "relative"),
                {
                  update: (n) => {
                    qt = n;
                  },
                  destroy: () => {
                    fe &&
                      (clearTimeout(Ou),
                      fe.removeEventListener("mouseenter", jw),
                      fe.removeEventListener("mouseleave", Ww),
                      fe.removeEventListener("mousedown", qw),
                      fe.removeEventListener("mouseup", Kw),
                      fe.removeEventListener("dragstart", Gw),
                      fe.remove());
                  },
                }
              );
            },
            props: {
              handleDOMEvents: {
                mousemove: (t, e) => {
                  var l;
                  const n = { left: e.clientX, top: e.clientY },
                    r = t.posAtCoords(n);
                  if (!r || !r.pos) return !1;
                  const o = r.inside > -1 ? r.inside : r.pos,
                    i =
                      t.nodeDOM(o) ||
                      ((l = t.domAtPos(o)) == null ? void 0 : l.node) ||
                      e.target;
                  if (!i) return Va(), !1;
                  let s = i;
                  for (; s && s.nodeType === 3; ) s = s.parentElement;
                  if (!(s instanceof HTMLElement)) return Va(), !1;
                  const a = this.editor;
                  if (
                    ((hn = w0({ editor: a, view: t, dom: s, event: e })), !hn)
                  )
                    return !1;
                  if (
                    (typeof hn == "boolean"
                      ? (Ge = Yw(s, t))
                      : (Ge = Xw(t, hn, s)),
                    !!Ge)
                  )
                    return WP(t, Ge), !1;
                },
                mouseleave: () => (
                  clearTimeout(Ou),
                  (Ou = setTimeout(() => {
                    Va();
                  }, 400)),
                  !1
                ),
              },
              handleKeyDown() {
                return fe && ((hn = void 0), Va()), !1;
              },
              handleDrop: (t, e, n) => {
                var a;
                if (!fe || !ei) return !1;
                const r = t.posAtCoords({ left: e.clientX, top: e.clientY });
                if (!r) return !0;
                const o = t.state.doc.resolve(r.pos),
                  i = JP(t.state.doc, o.pos, n);
                if (!i) return !1;
                let s = !1;
                if (Ha && typeof hn != "boolean") {
                  const l =
                    (a = hn == null ? void 0 : hn.handleDrop) == null
                      ? void 0
                      : a.call(hn, {
                          view: t,
                          event: e,
                          slice: n,
                          insertPos: i,
                          node: Ge == null ? void 0 : Ge.node,
                          selection: ei,
                        });
                  typeof l == "boolean" && (s = l);
                }
                return (Ha = !1), (hn = void 0), (ei = null), (Ge = null), s;
              },
              decorations: (t) => {
                if (!za || !Ge) return ue.empty;
                const { $pos: e } = Ge;
                return ue.create(t.doc, [
                  Te.node(e.before(), e.after(), {
                    class: "has-draggable-handle",
                  }),
                ]);
              },
            },
          }),
        ];
      },
    }),
    XP = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function ZP(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        XP,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M8 3C5.79 3 4 4.79 4 7v7c0 1.1.9 2 2 2h3v4c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2v-4h3c1.1 0 2-.9 2-2V3zm0 2h4v2h2V5h1v4h2V5h1v5H6V7c0-1.1.9-2 2-2m-2 9v-2h12v2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const QP = u.markRaw({ name: "mdi-brush-variant", render: ZP }),
    e$ = (t) => {
      const e = [],
        { doc: n, selection: r } = t,
        { from: o, to: i, empty: s } = r;
      if (s) return e;
      let a = !1;
      return (
        n.nodesBetween(o, i, (l, c) => {
          if (
            !(!l || (l == null ? void 0 : l.nodeSize) === void 0) &&
            l.isText &&
            !a
          )
            return (
              (a = !0),
              e.push(
                ...l.marks.map((d) => ({
                  from: c,
                  to: c + l.nodeSize,
                  mark: d,
                }))
              ),
              !1
            );
        }),
        e
      );
    },
    t$ = (t, e, n) => {
      const { selection: r } = t,
        o = n || t.tr,
        { from: i, to: s } = r;
      return (
        r instanceof ke
          ? r.ranges.forEach((a) => {
              const l = { from: a.$from.pos, to: a.$to.pos };
              Zw(o, t, l, e);
            })
          : Zw(o, t, { from: i, to: s }, e),
        o
      );
    },
    Zw = (t, e, n, r) => {
      const { from: o, to: i } = n;
      e.doc.nodesBetween(o, i, (s, a) => {
        if (!(!s || (s == null ? void 0 : s.nodeSize) === void 0)) {
          if (s.isText) {
            const l = { from: Math.max(a, o), to: Math.min(a + s.nodeSize, i) };
            s.marks.forEach((c) => {
              t.step(new en(l.from, l.to, c));
            }),
              r.forEach((c) => {
                t.step(new $n(l.from, l.to, c.mark));
              });
          }
          return !0;
        }
      });
    },
    Qw = we.create({
      name: "formatBrush",
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolbarItems({ editor: e }) {
            const n = e.view.dom.classList.contains("format-brush-mode");
            return {
              priority: 25,
              component: u.markRaw($e),
              props: {
                editor: e,
                isActive: n,
                icon: u.markRaw(QP),
                title: n
                  ? T.global.t(
                      "editor.extensions.format_brush.toolbar_item.cancel"
                    )
                  : T.global.t(
                      "editor.extensions.format_brush.toolbar_item.title"
                    ),
                action: () => {
                  n
                    ? e.commands.pasteFormatBrush()
                    : e.commands.copyFormatBrush();
                },
              },
            };
          },
        };
      },
      addCommands() {
        return {
          copyFormatBrush:
            () =>
            ({ state: t }) => {
              const e = e$(t);
              return (
                (this.storage.formatBrushMarks = e),
                (this.storage.formatBrush = !0),
                this.editor.view.dom.classList.add("format-brush-mode"),
                !0
              );
            },
          pasteFormatBrush: () => () => (
            (this.storage.formatBrushMarks = []),
            (this.storage.formatBrush = !1),
            this.editor.view.dom.classList.remove("format-brush-mode"),
            !0
          ),
        };
      },
      addStorage() {
        return { formatBrush: !1, formatBrushMarks: [] };
      },
      addProseMirrorPlugins() {
        const t = this.storage,
          e = this.editor;
        return [
          new ie({
            key: new de("formatBrushPlugin"),
            props: {
              handleDOMEvents: {
                mouseup(n) {
                  t.formatBrush &&
                    e
                      .chain()
                      .command(
                        ({ tr: r }) => (t$(n.state, t.formatBrushMarks, r), !0)
                      )
                      .pasteFormatBrush()
                      .run();
                },
              },
            },
          }),
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Shift-Mod-c": () => (this.editor.commands.copyFormatBrush(), !0),
        };
      },
    });
  class Ne extends J {
    constructor(n) {
      super(n, n);
      oe(this, "start", !1);
      this.start = o$(n);
    }
    map(n, r) {
      const o = n.resolve(r.map(this.head));
      return Ne.valid(o) ? new Ne(o) : J.near(o);
    }
    content() {
      return z.empty;
    }
    eq(n) {
      return n instanceof Ne && n.head == this.head;
    }
    toJSON() {
      return { type: "node-gap-cursor", pos: this.head };
    }
    get isStart() {
      return this.start;
    }
    static fromJSON(n, r) {
      if (typeof r.pos != "number")
        throw new RangeError("Invalid input for GapCursorSelection.fromJSON");
      return new Ne(n.resolve(r.pos));
    }
    getBookmark() {
      return new x0(this.anchor);
    }
    static valid(n) {
      if (n.depth < 1) return !1;
      const o = n.doc.childBefore(n.pos).node;
      return !o ||
        n.parent.isTextblock ||
        (!n$(n) && !r$(n)) ||
        !o.type.spec.allowGapCursor
        ? !1
        : !o.type.inlineContent;
    }
    static findGapCursorFrom(n, r, o = !1) {
      let i = !0;
      for (; i; ) {
        if (!o && Ne.valid(n)) return n;
        let s = n.pos,
          a = null;
        for (let l = n.depth; l >= 0; l--) {
          const c = n.node(l),
            d = r > 0 ? n.indexAfter(l) : n.index(l) - 1;
          if (r > 0 ? d < c.childCount : d >= 0) {
            a = c.child(d);
            break;
          }
          if (l == 0) return null;
          s += r;
          const f = n.doc.resolve(s);
          if (Ne.valid(f)) return f;
        }
        for (; a; ) {
          const l = r > 0 ? a.firstChild : a.lastChild;
          if (!l) {
            if (a.isAtom && !a.isText && !K.isSelectable(a)) {
              (n = n.doc.resolve(s + a.nodeSize * r)), (o = !1);
              break;
            }
            i = !1;
            break;
          }
          (a = l), (s += r);
          const c = n.doc.resolve(s);
          if (Ne.valid(c)) return c;
        }
        a || (i = !1);
      }
      return null;
    }
  }
  (Ne.prototype.visible = !1),
    (Ne.findFrom = Ne.findGapCursorFrom),
    J.jsonID("node-gap-cursor", Ne);
  class x0 {
    constructor(e) {
      this.pos = e;
    }
    map(e) {
      return new x0(e.map(this.pos));
    }
    resolve(e) {
      const n = e.resolve(this.pos);
      return Ne.valid(n) ? new Ne(n) : J.near(n);
    }
  }
  function n$(t) {
    for (let e = t.depth; e >= 0; e--) {
      const n = t.index(e),
        r = t.node(e);
      if (n === 0) {
        if (r.type.spec.isolating) return !0;
        continue;
      }
      if (ex(r.child(n - 1), !1)) return !0;
    }
    return !0;
  }
  function r$(t) {
    for (let e = t.depth; e >= 0; e--) {
      const n = t.indexAfter(e),
        r = t.node(e);
      if (n === r.childCount) {
        if (r.type.spec.isolating) return !0;
        continue;
      }
      if (ex(r.child(n), !0)) return !0;
    }
    return !0;
  }
  function ex(t, e) {
    for (; t; ) {
      if (
        (t.childCount === 0 && !t.inlineContent) ||
        t.isAtom ||
        t.type.spec.isolating
      )
        return !0;
      if (t.inlineContent) return !1;
      t = e ? t.firstChild : t.lastChild;
    }
    return !1;
  }
  function o$(t) {
    if (t.depth < 1) return null;
    const e = t.start(1),
      n = t.end(1);
    return t.pos < e + (n - e) / 2;
  }
  const tx = we.create({
    priority: 9999,
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        new ie({
          key: new de("custom-gap-cursor"),
          props: {
            decorations: a$,
            createSelectionBetween(t, e, n) {
              return e.pos == n.pos && Ne.valid(n) ? new Ne(n) : null;
            },
            handleClick(t, e, n) {
              if (!t || !t.editable) return !1;
              const r = t.posAtCoords({ left: n.clientX, top: n.clientY });
              if (r && r.inside > -1) return !1;
              const o = t.state.doc.resolve(e);
              return Ne.valid(o)
                ? (t.dispatch(t.state.tr.setSelection(new Ne(o))), !0)
                : !1;
            },
            handleKeyDown: Ms({
              ArrowLeft: Ru("horiz", -1),
              ArrowRight: Ru("horiz", 1),
              ArrowUp: Ru("vert", -1),
              ArrowDown: Ru("vert", 1),
              Enter: (t, e) => {
                const n = Du(t, !1);
                return n && e ? (e(n), !0) : !1;
              },
              Backspace: (t, e) => {
                const { selection: n, tr: r } = t;
                if (
                  Et(t, "paragraph") &&
                  y3(t.selection.$from.parent) &&
                  n instanceof U &&
                  n.empty
                ) {
                  const { $from: c } = n;
                  return Hi(c)(r), e && nx(-1, "left", t)(r) ? (e(r), !0) : !1;
                }
                if (!(n instanceof Ne) || !e) return !1;
                const { isStart: o, $from: i } = n,
                  s = t.doc.childBefore(i.pos),
                  a = s.index,
                  l = t.doc.resolve(0).posAtIndex(a);
                return o
                  ? i$(l, t, e)
                  : s.node && Hi(t.doc.resolve(l))(r)
                  ? (e(r), !0)
                  : !1;
              },
              Tab: (t, e) => {
                const n = Du(t);
                return n && e ? (e(n), !0) : !1;
              },
            }),
            handleTextInput(t) {
              const { state: e, dispatch: n } = t,
                r = Du(e);
              return r && n && n(r), !1;
            },
            handleDOMEvents: {
              beforeinput: (t, e) => {
                const { state: n, dispatch: r } = t;
                if (
                  e.inputType != "insertCompositionText" ||
                  !(n.selection instanceof Ne)
                )
                  return !1;
                const o = Du(n);
                return o && r && r(o), !1;
              },
            },
          },
        }),
      ];
    },
    extendNodeSchema(t) {
      const e = { name: t.name, options: t.options, storage: t.storage };
      return { allowGapCursor: re(j(t, "allowGapCursor", e)) ?? null };
    },
  });
  function i$(t, e, n) {
    const { tr: r } = e;
    if (t == 0) return !1;
    const o = e.doc.resolve(t - 1),
      i = o.parent;
    return i.inlineContent || i.isTextblock
      ? s$(o, e, n)
      : Ne.valid(o) && n
      ? (n(r.setSelection(new Ne(o))), !0)
      : Hi(o)(r) && n
      ? (n(r), !0)
      : !1;
  }
  function s$(t, e, n) {
    return t.parentOffset == 0 && t.pos > 1 && n
      ? (n(e.tr.delete(t.pos - 1, t.pos)), !0)
      : (n && n(e.tr.setSelection(U.create(e.doc, t.pos))), !0);
  }
  function Ru(t, e) {
    const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
    return (r, o, i) => {
      const { tr: s } = r;
      return nx(e, n, r, i)(s) && o ? (o(s), !0) : !1;
    };
  }
  const nx = (t, e, n, r) => (o) => {
    const i = n.selection;
    let s = t > 0 ? i.$to : i.$from,
      a = i.empty;
    if (i instanceof U) {
      if (s.depth == 0 || (r && !r.endOfTextblock(e))) return;
      if (
        ((a = !1),
        (s = n.doc.resolve(t > 0 ? s.after() : s.before())),
        s.depth > 0)
      ) {
        const c = s.pos,
          d = s.start(1) + 1,
          f = s.end(1) - 1;
        if (c != d && c != f) return;
      }
    }
    if (i instanceof Ne) return;
    const l = Ne.findGapCursorFrom(s, t, a);
    if (l) return o.setSelection(new Ne(l)), l;
  };
  function Du(t, e = !0) {
    const { tr: n } = t;
    if (!(t.selection instanceof Ne)) return;
    const { isStart: r, $from: o } = t.selection;
    if (t.selection instanceof mt || o.parent.inlineContent) return;
    const i = t.doc.resolve(0),
      s = t.doc.childBefore(o.pos),
      a = r ? s.index : s.index + 1,
      l = i.posAtIndex(a);
    return (
      n.insert(l, t.schema.nodes.paragraph.create()),
      (e || !r) && (n.setSelection(U.create(n.doc, l + 1)), n.scrollIntoView()),
      n
    );
  }
  function a$(t) {
    if (!(t.selection instanceof Ne)) return null;
    const e = t.selection.$head;
    if (e.depth < 1) return null;
    const n = e.node(1),
      r = e.start(1) - 1,
      o = t.selection.isStart;
    return ue.create(t.doc, [
      Te.node(r, r + n.nodeSize, {
        key: "node-gap-cursor",
        class: `card-gap-cursor ${o ? "start" : "end"}-card-gap-cursor`,
      }),
    ]);
  }
  const l$ = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g,
    c$ =
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
  function Lu(t) {
    return !t || t.replace(l$, "").match(c$);
  }
  const u$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function d$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        u$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              { fill: "currentColor", d: "M3 21V3h18v18zM5 5v14h14V5z" },
              null,
              -1
            ),
          ])
      )
    );
  }
  const f$ = u.markRaw({ name: "mdi-border-all-variant", render: d$ }),
    p$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function h$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        p$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M15 5h2V3h-2m0 18h2v-2h-2M11 5h2V3h-2m8 2h2V3h-2m0 6h2V7h-2m0 14h2v-2h-2m0-6h2v-2h-2m0 6h2v-2h-2M3 5h2V3H3m0 6h2V7H3m0 6h2v-2H3m0 6h2v-2H3m0 6h2v-2H3m8 2h2v-2h-2m-4 2h2v-2H7M7 5h2V3H7z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const m$ = u.markRaw({ name: "mdi-border-none-variant", render: h$ }),
    g$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function b$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        g$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                d: "M16 18H7V4h9m-4.5 18a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m4-21h-8A2.5 2.5 0 0 0 5 3.5v17A2.5 2.5 0 0 0 7.5 23h8a2.5 2.5 0 0 0 2.5-2.5v-17A2.5 2.5 0 0 0 15.5 1z",
                fill: "currentColor",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const y$ = u.markRaw({ name: "mdi-cellphone-iphone", render: b$ }),
    _$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function k$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        _$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M21 14H3V4h18m0-2H3c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h7l-2 3v1h8v-1l-2-3h7a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2Z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const w$ = u.markRaw({ name: "mdi-desktop-mac", render: k$ }),
    x$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function C$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        x$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                d: "M19 19H4V3h15m-7.5 20a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m7-23h-14A2.5 2.5 0 0 0 2 2.5v19A2.5 2.5 0 0 0 4.5 24h14a2.5 2.5 0 0 0 2.5-2.5v-19A2.5 2.5 0 0 0 18.5 0z",
                fill: "currentColor",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const rx = u.markRaw({ name: "mdi-tablet-ipad", render: C$ }),
    v$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function E$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        v$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2m-5.15 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 0 1-4.33 3.56M14.34 14H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2M12 19.96c-.83-1.2-1.5-2.53-1.91-3.96h3.82c-.41 1.43-1.08 2.76-1.91 3.96M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m-2.92 8H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16m-.82-2C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2M12 4.03c.83 1.2 1.5 2.54 1.91 3.97h-3.82c.41-1.43 1.08-2.77 1.91-3.97M18.92 8h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M12 2C6.47 2 2 6.5 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const ox = u.markRaw({ name: "mdi-web", render: E$ }),
    A$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function S$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        A$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16.5 11.74c0-.59-.07-1.16-.14-1.74h3.38c.08.33.15.67.19 1c.72.07 1.41.23 2.07.5C21.71 6.21 17.35 2 12 2C6.47 2 2 6.5 2 12s4.5 10 10 10c.87 0 1.71-.12 2.5-.33a6.6 6.6 0 0 1-1.46-3.47c-.31.61-.65 1.2-1.04 1.76c-.83-1.2-1.5-2.53-1.91-3.96h3.09c.17-.72.46-1.39.85-2H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2c0 .5-.04 1-.1 1.5a6.4 6.4 0 0 1 2.1-1.76M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2zm.82 2H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m2.09 0c.41-1.43 1.08-2.77 1.91-3.97c.83 1.2 1.5 2.54 1.91 3.97zm8.83 0h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M23 17.5c0 .82-.25 1.58-.67 2.21l-1.09-1.09c.17-.34.26-.72.26-1.12A2.5 2.5 0 0 0 19 15v1.5l-2.25-2.25L19 12v1.5c2.21 0 4 1.79 4 4m-4 1l2.25 2.25L19 23v-1.5c-2.21 0-4-1.79-4-4c0-.82.25-1.58.67-2.21l1.09 1.09c-.17.34-.26.72-.26 1.12A2.5 2.5 0 0 0 19 20z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const M$ = u.markRaw({ name: "mdi-web-sync", render: S$ }),
    T$ = ["placeholder"],
    N$ = u.defineComponent({
      __name: "BubbleItemIframeLink",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(et.name).src,
            set: (r) => {
              !r ||
                !Lu(r) ||
                e.editor.chain().updateAttributes(et.name, { src: r }).run();
            },
          });
        return (r, o) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
                placeholder: u
                  .unref(T)
                  .global.t("editor.common.placeholder.link_input"),
                class:
                  "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
              },
              null,
              8,
              T$
            )),
            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
          );
      },
    }),
    O$ = u.defineComponent({
      __name: "BubbleItemIframeSize",
      props: { editor: {} },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(et.name).width,
            set: (i) => {
              o(i, r.value);
            },
          }),
          r = u.computed({
            get: () => e.editor.getAttributes(et.name).height,
            set: (i) => {
              o(n.value, i);
            },
          }),
          o = (i, s) => {
            e.editor
              .chain()
              .updateAttributes(et.name, { width: i, height: s })
              .focus()
              .setNodeSelection(e.editor.state.selection.from)
              .run();
          };
        return (i, s) => (
          u.openBlock(),
          u.createElementBlock(
            u.Fragment,
            null,
            [
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: n.value,
                  "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_width_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: r.value,
                  "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_height_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
              u.createVNode(u.unref(Ve)),
            ],
            64
          )
        );
      },
    }),
    R$ = { key: 0, class: "p-1.5" },
    D$ = ["placeholder"],
    L$ = ["src", "width", "height", "frameborder"],
    I$ = u.defineComponent({
      __name: "IframeView",
      props: {
        decorations: {},
        selected: { type: Boolean },
        updateAttributes: { type: Function },
        deleteNode: { type: Function },
        node: {},
        view: {},
        getPos: { type: Function },
        innerDecorations: {},
        editor: {},
        extension: {},
        HTMLAttributes: {},
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              var s;
              return (s = e.node) == null ? void 0 : s.attrs.src;
            },
            set: (s) => {
              !s || !Lu(s) || e.updateAttributes({ src: s });
            },
          }),
          r = u.computed(() => e.node.attrs.frameborder);
        function o() {
          e.editor.commands.setNodeSelection(e.getPos());
        }
        const i = u.ref();
        return (
          u.onMounted(() => {
            n.value || i.value.focus();
          }),
          (s, a) => (
            u.openBlock(),
            u.createBlock(
              u.unref(Ii),
              { as: "div", class: "inline-block w-full" },
              {
                default: u.withCtx(() => [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
                      style: u.normalizeStyle({ width: s.node.attrs.width }),
                    },
                    [
                      n.value
                        ? (u.openBlock(),
                          u.createElementBlock(
                            "iframe",
                            {
                              key: 1,
                              class: u.normalizeClass([
                                "rounded-md",
                                { "border-2": r.value === "1" },
                              ]),
                              src: s.node.attrs.src,
                              width: s.node.attrs.width,
                              height: s.node.attrs.height,
                              scrolling: "yes",
                              frameborder: r.value,
                              framespacing: "0",
                              allowfullscreen: "true",
                              onMouseenter: o,
                            },
                            null,
                            42,
                            L$
                          ))
                        : (u.openBlock(),
                          u.createElementBlock("div", R$, [
                            u.withDirectives(
                              u.createElementVNode(
                                "input",
                                {
                                  ref_key: "inputRef",
                                  ref: i,
                                  "onUpdate:modelValue":
                                    a[0] || (a[0] = (l) => (n.value = l)),
                                  class:
                                    "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                                  placeholder: u
                                    .unref(T)
                                    .global.t(
                                      "editor.common.placeholder.link_input"
                                    ),
                                  tabindex: "-1",
                                  onFocus: o,
                                },
                                null,
                                40,
                                D$
                              ),
                              [[u.vModelText, n.value, void 0, { lazy: !0 }]]
                            ),
                          ])),
                    ],
                    4
                  ),
                ]),
                _: 1,
              }
            )
          )
        );
      },
    }),
    et = Pe.create({
      name: "iframe",
      fakeSelection: !0,
      inline() {
        return !0;
      },
      group() {
        return "inline";
      },
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          src: { default: null, parseHTML: (e) => e.getAttribute("src") },
          width: {
            default: "100%",
            parseHTML: (e) => e.getAttribute("width"),
            renderHTML(e) {
              return { width: e.width };
            },
          },
          height: {
            default: "300px",
            parseHTML: (e) => e.getAttribute("height"),
            renderHTML: (e) => ({ height: e.height }),
          },
          scrolling: {
            default: null,
            parseHTML: (e) => e.getAttribute("scrolling"),
            renderHTML: (e) => ({ scrolling: e.scrolling }),
          },
          frameborder: {
            default: "0",
            parseHTML: (e) => e.getAttribute("frameborder"),
            renderHTML: (e) => ({ frameborder: e.frameborder }),
          },
          allowfullscreen: {
            default: !0,
            parseHTML: (e) => e.getAttribute("allowfullscreen"),
            renderHTML: (e) => ({ allowfullscreen: e.allowfullscreen }),
          },
          framespacing: {
            default: 0,
            parseHTML: (e) => {
              const n = e.getAttribute("framespacing");
              return n ? parseInt(n, 10) : null;
            },
            renderHTML: (e) => ({ framespacing: e.framespacing }),
          },
          style: {
            renderHTML() {
              return { style: "display: inline-block" };
            },
          },
        };
      },
      parseHTML() {
        return [
          {
            tag: "iframe",
            getAttrs: (t) => {
              const e = t.getAttribute("src");
              return !e || !Lu(e) ? !1 : { src: e };
            },
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return Lu(t.src)
          ? ["iframe", se(t)]
          : ["iframe", se({ ...t, src: "" })];
      },
      addCommands() {
        return {
          setIframe:
            (t) =>
            ({ commands: e }) =>
              e.insertContent({ type: this.name, attrs: t }),
        };
      },
      addInputRules() {
        return [
          Ti({
            find: /^\$iframe\$$/,
            type: this.type,
            getAttributes: () => ({ width: "100%" }),
          }),
        ];
      },
      addPasteRules() {
        return [
          X_({
            find: /<iframe.*?src="(.*?)".*?<\/iframe>/g,
            type: this.type,
            getAttributes: (t) => {
              const n = document
                .createRange()
                .createContextualFragment(t[0])
                .querySelector("iframe");
              if (n)
                return {
                  src: n.src,
                  width: n.width || "100%",
                  height: n.height || "300px",
                };
            },
          }),
        ];
      },
      addNodeView() {
        return Bi(I$);
      },
      addOptions() {
        return {
          getCommandMenuItems() {
            return {
              priority: 90,
              icon: u.markRaw(ox),
              title: "editor.extensions.commands_menu.iframe",
              keywords: ["iframe", "qianruwangye"],
              command: ({ editor: t, range: e }) => {
                t.chain()
                  .focus()
                  .deleteRange(e)
                  .insertContent([{ type: "iframe", attrs: { src: "" } }])
                  .run();
              },
            };
          },
          getToolboxItems({ editor: t }) {
            return [
              {
                priority: 40,
                component: u.markRaw(io),
                props: {
                  editor: t,
                  icon: u.markRaw(ox),
                  title: T.global.t("editor.extensions.commands_menu.iframe"),
                  action: () => {
                    t.chain()
                      .focus()
                      .insertContent([{ type: "iframe", attrs: { src: "" } }])
                      .run();
                  },
                },
              },
            ];
          },
          getBubbleMenu({ editor: t }) {
            return {
              pluginKey: "iframeBubbleMenu",
              shouldShow: ({ state: e }) => Et(e, et.name),
              items: [
                {
                  priority: 10,
                  props: {
                    isActive: () =>
                      t.getAttributes(et.name).frameborder === "1",
                    icon: u.markRaw(
                      t.getAttributes(et.name).frameborder === "1" ? f$ : m$
                    ),
                    action: () => {
                      t.chain()
                        .updateAttributes(et.name, {
                          frameborder:
                            t.getAttributes(et.name).frameborder === "1"
                              ? "0"
                              : "1",
                        })
                        .focus()
                        .setNodeSelection(t.state.selection.from)
                        .run();
                    },
                    title:
                      t.getAttributes(et.name).frameborder === "1"
                        ? T.global.t(
                            "editor.extensions.iframe.disable_frameborder"
                          )
                        : T.global.t(
                            "editor.extensions.iframe.enable_frameborder"
                          ),
                  },
                },
                { priority: 20, component: u.markRaw(Ve) },
                { priority: 30, component: u.markRaw(O$) },
                {
                  priority: 40,
                  props: {
                    isActive: () => Iu(t, "390px", "844px"),
                    icon: u.markRaw(y$),
                    action: () => {
                      Bu(t, "390px", "844px");
                    },
                    title: T.global.t("editor.extensions.iframe.phone_size"),
                  },
                },
                {
                  priority: 50,
                  props: {
                    isActive: () => Iu(t, "834px", "1194px"),
                    icon: u.markRaw(rx),
                    action: () => {
                      Bu(t, "834px", "1194px");
                    },
                    title: T.global.t(
                      "editor.extensions.iframe.tablet_vertical_size"
                    ),
                  },
                },
                {
                  priority: 60,
                  props: {
                    isActive: () => Iu(t, "1194px", "834px"),
                    icon: u.markRaw(rx),
                    iconStyle: "transform: rotate(90deg)",
                    action: () => {
                      Bu(t, "1194px", "834px");
                    },
                    title: T.global.t(
                      "editor.extensions.iframe.tablet_horizontal_size"
                    ),
                  },
                },
                {
                  priority: 70,
                  props: {
                    isActive: () => Iu(t, "100%", "834px"),
                    icon: u.markRaw(w$),
                    action: () => {
                      Bu(t, "100%", "834px");
                    },
                    title: T.global.t("editor.extensions.iframe.desktop_size"),
                  },
                },
                { priority: 80, component: u.markRaw(Ve) },
                {
                  priority: 90,
                  props: {
                    isActive: () => t.isActive({ textAlign: "left" }),
                    icon: u.markRaw(Ui),
                    action: () => Pu(t, "left"),
                  },
                },
                {
                  priority: 100,
                  props: {
                    isActive: () => t.isActive({ textAlign: "center" }),
                    icon: u.markRaw(Ia),
                    action: () => Pu(t, "center"),
                  },
                },
                {
                  priority: 110,
                  props: {
                    isActive: () => t.isActive({ textAlign: "right" }),
                    icon: u.markRaw(Pa),
                    action: () => Pu(t, "right"),
                  },
                },
                {
                  priority: 120,
                  props: {
                    isActive: () => t.isActive({ textAlign: "justify" }),
                    icon: u.markRaw(Ba),
                    action: () => Pu(t, "justify"),
                  },
                },
                { priority: 130, component: u.markRaw(Ve) },
                {
                  priority: 140,
                  props: {
                    icon: u.markRaw(M$),
                    action: () => {
                      t.chain()
                        .updateAttributes(et.name, {
                          src: t.getAttributes(et.name).src,
                        })
                        .run();
                    },
                  },
                },
                {
                  priority: 150,
                  props: {
                    icon: u.markRaw($a),
                    title: T.global.t("editor.common.button.edit_link"),
                    action: () => u.markRaw(N$),
                  },
                },
                {
                  priority: 160,
                  props: {
                    icon: u.markRaw(Fa),
                    title: T.global.t("editor.common.tooltip.open_link"),
                    action: () => {
                      window.open(t.getAttributes(et.name).src, "_blank");
                    },
                  },
                },
                {
                  priority: 190,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: e }) => {
                      Yo(et.name, e);
                    },
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: t, view: e }) {
                var o;
                let n = t;
                for (; n && n.tagName !== "P"; ) n = n.parentElement;
                n &&
                  (n =
                    (o = n.firstElementChild) == null
                      ? void 0
                      : o.firstElementChild);
                let r;
                if (n.firstElementChild) {
                  const i = e.posAtDOM(n.firstElementChild, 0);
                  r = e.state.doc.resolve(i).node();
                }
                return { node: r, el: n };
              },
            };
          },
        };
      },
    }),
    Iu = (t, e, n) => {
      const r = t.getAttributes(et.name);
      return e === r.width && n === r.height;
    },
    Bu = (t, e, n) => {
      t.chain()
        .updateAttributes(et.name, { width: e, height: n })
        .focus()
        .setNodeSelection(t.state.selection.from)
        .run();
    },
    Pu = (t, e) => {
      t.chain().focus().setTextAlign(e).run();
    },
    B$ = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
    P$ = Pe.create({
      name: "image",
      addOptions() {
        return { inline: !1, allowBase64: !1, HTMLAttributes: {} };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: !0,
      addAttributes() {
        return {
          src: { default: null },
          alt: { default: null },
          title: { default: null },
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64
              ? "img[src]"
              : 'img[src]:not([src^="data:"])',
          },
        ];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["img", se(this.options.HTMLAttributes, t)];
      },
      addCommands() {
        return {
          setImage:
            (t) =>
            ({ commands: e }) =>
              e.insertContent({ type: this.name, attrs: t }),
        };
      },
      addInputRules() {
        return [
          Ti({
            find: B$,
            type: this.type,
            getAttributes: (t) => {
              const [, , e, n, r] = t;
              return { src: n, alt: e, title: r };
            },
          }),
        ];
      },
    }),
    $$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function F$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        $$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                d: "M8.5 13.498l2.5 3.006l3.5-4.506l4.5 6H5m16 1v-14a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z",
                fill: "currentColor",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const H$ = u.markRaw({ name: "mdi-file-image-box", render: F$ }),
    z$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function V$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        z$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7a5 5 0 0 0-5 5a5 5 0 0 0 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4a5 5 0 0 0 5-5a5 5 0 0 0-5-5",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const U$ = u.markRaw({ name: "mdi-link", render: V$ }),
    j$ = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function W$(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        j$,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M10 21H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2h14c1.11 0 2 .89 2 2v5.33c-.3-.12-.63-.19-.96-.19c-.37 0-.72.08-1.04.23V5H5v14h5.11l-.11.11zM7 9h10V7H7zm0 8h5.11L14 15.12V15H7zm0-4h9.12l.88-.88V11H7zm14.7.58l-1.28-1.28a.55.55 0 0 0-.77 0l-1 1l2.05 2.05l1-1a.55.55 0 0 0 0-.77M12 22h2.06l6.05-6.07l-2.05-2.05L12 19.94z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const q$ = u.markRaw({ name: "mdi-text-box-edit-outline", render: W$ }),
    K$ = ["placeholder"],
    G$ = u.defineComponent({
      __name: "BubbleItemImageAlt",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(ft.name).alt,
            set: (r) => {
              e.editor
                .chain()
                .updateAttributes(ft.name, { alt: r })
                .setNodeSelection(e.editor.state.selection.from)
                .focus()
                .run();
            },
          });
        return (r, o) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
                placeholder: u
                  .unref(T)
                  .global.t("editor.common.placeholder.alt_input"),
                class:
                  "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
              },
              null,
              8,
              K$
            )),
            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
          );
      },
    }),
    J$ = ["placeholder"],
    Y$ = { class: "inline-flex items-center mt-2" },
    X$ = { class: "ml-2 text-sm text-gray-500" },
    Z$ = u.defineComponent({
      __name: "BubbleItemImageHref",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              const o = e.editor.getAttributes(vu.name);
              return (
                (o == null ? void 0 : o.href) ||
                e.editor.getAttributes(ft.name).href
              );
            },
            set: (o) => {
              e.editor.commands.setLink({ href: o, target: "_blank" });
            },
          }),
          r = u.computed({
            get() {
              const o = e.editor.getAttributes(vu.name);
              return (o == null ? void 0 : o.target) === "_blank";
            },
            set(o) {
              e.editor.commands.setLink({
                href: n.value,
                target: o ? "_blank" : "_self",
              });
            },
          });
        return (o, i) => (
          u.openBlock(),
          u.createElementBlock(
            u.Fragment,
            null,
            [
              u.withDirectives(
                u.createElementVNode(
                  "input",
                  {
                    "onUpdate:modelValue":
                      i[0] || (i[0] = (s) => (n.value = s)),
                    placeholder: u
                      .unref(T)
                      .global.t("editor.common.placeholder.alt_href"),
                    class:
                      "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
                  },
                  null,
                  8,
                  J$
                ),
                [[u.vModelText, n.value, void 0, { lazy: !0 }]]
              ),
              u.createElementVNode("label", Y$, [
                u.withDirectives(
                  u.createElementVNode(
                    "input",
                    {
                      "onUpdate:modelValue":
                        i[1] || (i[1] = (s) => (r.value = s)),
                      type: "checkbox",
                      class:
                        "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded",
                    },
                    null,
                    512
                  ),
                  [[u.vModelCheckbox, r.value]]
                ),
                u.createElementVNode(
                  "span",
                  X$,
                  u.toDisplayString(
                    u
                      .unref(T)
                      .global.t("editor.extensions.link.open_in_new_window")
                  ),
                  1
                ),
              ]),
            ],
            64
          )
        );
      },
    }),
    Q$ = ["placeholder"],
    eF = u.defineComponent({
      __name: "BubbleItemImageLink",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(ft.name).src,
            set: (r) => {
              e.editor
                .chain()
                .updateAttributes(ft.name, { src: r })
                .setNodeSelection(e.editor.state.selection.from)
                .focus()
                .run();
            },
          });
        return (r, o) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
                placeholder: u
                  .unref(T)
                  .global.t("editor.common.placeholder.link_input"),
                class:
                  "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
              },
              null,
              8,
              Q$
            )),
            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
          );
      },
    }),
    tF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function nF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        tF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M12 3a9 9 0 0 0-9 9H0l4 4l4-4H5a7 7 0 0 1 7-7a7 7 0 0 1 7 7a7 7 0 0 1-7 7c-1.5 0-2.91-.5-4.06-1.3L6.5 19.14A9.1 9.1 0 0 0 12 21a9 9 0 0 0 9-9a9 9 0 0 0-9-9m2 9a2 2 0 0 0-2-2a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const rF = u.markRaw({ name: "mdi-backup-restore", render: nF }),
    oF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function iF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        oF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M21 3H3C2 3 1 4 1 5v14a2 2 0 0 0 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2M5 17l3.5-4.5l2.5 3l3.5-4.5l4.5 6z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const ix = u.markRaw({ name: "mdi-image-size-select-actual", render: iF }),
    sF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function aF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        sF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M21 15h2v2h-2zm0-4h2v2h-2zm2 8h-2v2c1 0 2-1 2-2M13 3h2v2h-2zm8 4h2v2h-2zm0-4v2h2c0-1-1-2-2-2M1 7h2v2H1zm16-4h2v2h-2zm0 16h2v2h-2zM3 3C2 3 1 4 1 5h2zm6 0h2v2H9zM5 3h2v2H5zm-4 8v8a2 2 0 0 0 2 2h12V11zm2 8l2.5-3.21l1.79 2.15l2.5-3.22L13 19z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const sx = u.markRaw({ name: "mdi-image-size-select-large", render: aF }),
    lF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function cF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        lF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M23 15h-2v2h2zm0-4h-2v2h2zm0 8h-2v2c1 0 2-1 2-2M15 3h-2v2h2zm8 4h-2v2h2zm-2-4v2h2c0-1-1-2-2-2M3 21h8v-6H1v4a2 2 0 0 0 2 2M3 7H1v2h2zm12 12h-2v2h2zm4-16h-2v2h2zm0 16h-2v2h2zM3 3C2 3 1 4 1 5h2zm0 8H1v2h2zm8-8H9v2h2zM7 3H5v2h2z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const ax = u.markRaw({ name: "mdi-image-size-select-small", render: cF }),
    uF = u.defineComponent({
      __name: "BubbleItemImageSize",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(ft.name).width,
            set: (i) => {
              o(i, r.value);
            },
          }),
          r = u.computed({
            get: () => e.editor.getAttributes(ft.name).height,
            set: (i) => {
              o(n.value, i);
            },
          });
        function o(i, s) {
          e.editor
            .chain()
            .updateAttributes(ft.name, { width: i, height: s })
            .setNodeSelection(e.editor.state.selection.from)
            .focus()
            .run();
        }
        return (i, s) => (
          u.openBlock(),
          u.createElementBlock(
            u.Fragment,
            null,
            [
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: n.value,
                  "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_width_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: r.value,
                  "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_height_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
              u.createVNode(u.unref(Ve)),
              u.createVNode(
                u.unref(Eo),
                {
                  tooltip: u
                    .unref(T)
                    .global.t("editor.extensions.image.small_size"),
                  selected:
                    i.editor.getAttributes(u.unref(ft).name).width === "25%",
                  onClick: s[2] || (s[2] = (a) => o("25%", "auto")),
                },
                { icon: u.withCtx(() => [u.createVNode(u.unref(ax))]), _: 1 },
                8,
                ["tooltip", "selected"]
              ),
              u.createVNode(
                u.unref(Eo),
                {
                  tooltip: u
                    .unref(T)
                    .global.t("editor.extensions.image.medium_size"),
                  selected:
                    i.editor.getAttributes(u.unref(ft).name).width === "50%",
                  onClick: s[3] || (s[3] = (a) => o("50%", "auto")),
                },
                { icon: u.withCtx(() => [u.createVNode(u.unref(sx))]), _: 1 },
                8,
                ["tooltip", "selected"]
              ),
              u.createVNode(
                u.unref(Eo),
                {
                  tooltip: u
                    .unref(T)
                    .global.t("editor.extensions.image.large_size"),
                  selected:
                    i.editor.getAttributes(u.unref(ft).name).width === "100%",
                  onClick: s[4] || (s[4] = (a) => o("100%", "100%")),
                },
                { icon: u.withCtx(() => [u.createVNode(u.unref(ix))]), _: 1 },
                8,
                ["tooltip", "selected"]
              ),
              u.createVNode(
                u.unref(Eo),
                {
                  tooltip: u
                    .unref(T)
                    .global.t("editor.extensions.image.restore_size"),
                  onClick: s[5] || (s[5] = (a) => o(void 0, void 0)),
                },
                { icon: u.withCtx(() => [u.createVNode(u.unref(rF))]), _: 1 },
                8,
                ["tooltip"]
              ),
              u.createVNode(u.unref(Ve)),
            ],
            64
          )
        );
      },
    }),
    dF = { key: 0, class: "p-1.5 w-full" },
    fF = ["placeholder"],
    pF = ["src", "title", "alt", "href"],
    hF = u.defineComponent({
      __name: "ImageView",
      props: {
        decorations: {},
        selected: { type: Boolean },
        updateAttributes: { type: Function },
        deleteNode: { type: Function },
        node: {},
        view: {},
        getPos: { type: Function },
        innerDecorations: {},
        editor: {},
        extension: {},
        HTMLAttributes: {},
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              var d;
              return (d = e.node) == null ? void 0 : d.attrs.src;
            },
            set: (d) => {
              e.updateAttributes({ src: d });
            },
          }),
          r = u.computed({
            get: () => {
              var d;
              return (d = e.node) == null ? void 0 : d.attrs.alt;
            },
            set: (d) => {
              e.updateAttributes({ alt: d });
            },
          }),
          o = u.computed({
            get: () => {
              var d;
              return (d = e.node) == null ? void 0 : d.attrs.href;
            },
            set: (d) => {
              e.updateAttributes({ href: d });
            },
          });
        function i() {
          e.editor.commands.setNodeSelection(e.getPos());
        }
        const s = u.ref(0),
          a = u.ref(),
          l = u.ref();
        function c() {
          l.value && (s.value = l.value.clientWidth / l.value.clientHeight);
        }
        return (
          u.onMounted(() => {
            if (!n.value) {
              a.value.focus();
              return;
            }
            if (!l.value) return;
            let d, f;
            l.value.addEventListener("mousedown", function (m) {
              var g;
              (d = m.clientX),
                (f = ((g = l.value) == null ? void 0 : g.clientWidth) || 1),
                document.documentElement.addEventListener("mousemove", p, !1),
                document.documentElement.addEventListener("mouseup", h, !1);
            });
            function p(m) {
              var x;
              if (!l.value) return;
              const g = Math.min(
                  f + m.clientX - d,
                  ((x = l.value.parentElement) == null
                    ? void 0
                    : x.clientWidth) || 0
                ),
                b = g.toFixed(0) + "px",
                y = (g / s.value).toFixed(0) + "px";
              e.editor
                .chain()
                .updateAttributes(ft.name, { width: b, height: y })
                .setNodeSelection(e.getPos())
                .focus()
                .run();
            }
            function h() {
              document.documentElement.removeEventListener("mousemove", p, !1),
                document.documentElement.removeEventListener("mouseup", h, !1);
            }
          }),
          (d, f) => (
            u.openBlock(),
            u.createBlock(
              u.unref(Ii),
              { as: "div", class: "inline-block w-full" },
              {
                default: u.withCtx(() => [
                  n.value
                    ? (u.openBlock(),
                      u.createElementBlock(
                        "div",
                        {
                          key: 1,
                          ref_key: "resizeRef",
                          ref: l,
                          class: u.normalizeClass([
                            "resize-x inline-block overflow-hidden text-center relative rounded-md max-w-full",
                            { "ring-2 rounded": d.selected },
                          ]),
                          style: u.normalizeStyle({
                            width: d.node.attrs.width,
                            height: d.node.attrs.height,
                          }),
                        },
                        [
                          u.createElementVNode(
                            "img",
                            {
                              src: n.value,
                              title: d.node.attrs.title,
                              alt: r.value,
                              href: o.value,
                              class: "w-full h-full",
                              onLoad: c,
                            },
                            null,
                            40,
                            pF
                          ),
                        ],
                        6
                      ))
                    : (u.openBlock(),
                      u.createElementBlock("div", dF, [
                        u.withDirectives(
                          u.createElementVNode(
                            "input",
                            {
                              ref_key: "inputRef",
                              ref: a,
                              "onUpdate:modelValue":
                                f[0] || (f[0] = (p) => (n.value = p)),
                              class:
                                "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                              placeholder: u
                                .unref(T)
                                .global.t(
                                  "editor.common.placeholder.link_input"
                                ),
                              tabindex: "-1",
                              onFocus: i,
                            },
                            null,
                            40,
                            fF
                          ),
                          [[u.vModelText, n.value, void 0, { lazy: !0 }]]
                        ),
                      ])),
                ]),
                _: 1,
              }
            )
          )
        );
      },
    }),
    ft = P$.extend({
      fakeSelection: !0,
      inline() {
        return !0;
      },
      group() {
        return "inline";
      },
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          width: {
            default: void 0,
            parseHTML: (e) => e.getAttribute("width") || e.style.width || null,
            renderHTML: (e) => ({ width: e.width }),
          },
          height: {
            default: void 0,
            parseHTML: (e) =>
              e.getAttribute("height") || e.style.height || null,
            renderHTML: (e) => ({ height: e.height }),
          },
          href: {
            default: null,
            parseHTML: (e) => e.getAttribute("href") || null,
            renderHTML: (e) => ({ href: e.href }),
          },
          style: {
            renderHTML() {
              return { style: "display: inline-block" };
            },
          },
        };
      },
      addNodeView() {
        return Bi(hF);
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64
              ? "img[src]"
              : 'img[src]:not([src^="data:"])',
          },
        ];
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getToolboxItems({ editor: e }) {
            return [
              {
                priority: 10,
                component: u.markRaw(io),
                props: {
                  editor: e,
                  icon: u.markRaw(H$),
                  title: T.global.t("editor.common.image"),
                  action: () => {
                    e.chain()
                      .focus()
                      .insertContent([{ type: "image", attrs: { src: "" } }])
                      .run();
                  },
                },
              },
            ];
          },
          getBubbleMenu({ editor: e }) {
            return {
              pluginKey: "imageBubbleMenu",
              shouldShow: ({ state: n }) => Et(n, ft.name),
              defaultAnimation: !1,
              items: [
                { priority: 10, component: u.markRaw(uF) },
                {
                  priority: 20,
                  props: {
                    isActive: () => e.isActive({ textAlign: "left" }),
                    icon: u.markRaw(Ui),
                    action: () => $u(e, "left"),
                  },
                },
                {
                  priority: 30,
                  props: {
                    isActive: () => e.isActive({ textAlign: "center" }),
                    icon: u.markRaw(Ia),
                    action: () => $u(e, "center"),
                  },
                },
                {
                  priority: 40,
                  props: {
                    isActive: () => e.isActive({ textAlign: "right" }),
                    icon: u.markRaw(Pa),
                    action: () => $u(e, "right"),
                  },
                },
                {
                  priority: 50,
                  props: {
                    isActive: () => e.isActive({ textAlign: "justify" }),
                    icon: u.markRaw(Ba),
                    action: () => $u(e, "justify"),
                  },
                },
                { priority: 60, component: u.markRaw(Ve) },
                {
                  priority: 70,
                  props: {
                    icon: u.markRaw($a),
                    title: T.global.t("editor.common.button.edit_link"),
                    action: () => u.markRaw(eF),
                  },
                },
                {
                  priority: 80,
                  props: {
                    icon: u.markRaw(Fa),
                    title: T.global.t("editor.common.tooltip.open_link"),
                    action: () => {
                      window.open(e.getAttributes(ft.name).src, "_blank");
                    },
                  },
                },
                {
                  priority: 90,
                  props: {
                    icon: u.markRaw(q$),
                    title: T.global.t("editor.extensions.image.edit_alt"),
                    action: () => u.markRaw(G$),
                  },
                },
                {
                  priority: 100,
                  props: {
                    icon: u.markRaw(U$),
                    title: T.global.t("editor.extensions.image.edit_href"),
                    action: () => u.markRaw(Z$),
                  },
                },
                { priority: 110, component: u.markRaw(Ve) },
                {
                  priority: 120,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: n }) => {
                      Yo(ft.name, n);
                    },
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e, view: n }) {
                var i;
                let r = e;
                for (; r && r.tagName !== "P"; ) r = r.parentElement;
                r &&
                  (r =
                    (i = r.firstElementChild) == null
                      ? void 0
                      : i.firstElementChild);
                let o;
                if (r.firstElementChild) {
                  const s = n.posAtDOM(r.firstElementChild, 0);
                  o = n.state.doc.resolve(s).node();
                }
                return { node: o, el: r, dragDomOffset: { y: -5 } };
              },
            };
          },
        };
      },
      renderHTML({ HTMLAttributes: t }) {
        return t.href
          ? ["a", { href: t.href }, ["img", se(t)]]
          : ["img", se(t)];
      },
    }),
    $u = (t, e) => {
      t.chain().focus().setTextAlign(e).run();
    },
    lx = we.create({
      name: "indent",
      addOptions() {
        return {
          names: ["heading", "paragraph"],
          indentRange: 24,
          minIndentLevel: 0,
          maxIndentLevel: 24 * 10,
          defaultIndentLevel: 0,
          HTMLAttributes: {},
          firstLineIndent: !0,
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.names,
            attributes: {
              indent: {
                default: this.options.defaultIndentLevel,
                renderHTML: (t) => ({
                  style:
                    t.indent != 0
                      ? `margin-left: ${t.indent}px!important;`
                      : "",
                }),
                parseHTML: (t) =>
                  parseInt(t.style.marginLeft, 10) ||
                  this.options.defaultIndentLevel,
              },
              lineIndent: {
                default: !1,
                renderHTML: (t) => ({
                  style: t.lineIndent ? "text-indent: 2em" : "",
                }),
                parseHTML: (t) => t.style.textIndent === "2em",
              },
            },
          },
        ];
      },
      addCommands() {
        return {
          indent:
            () =>
            ({ tr: t, state: e, dispatch: n, editor: r }) => {
              const { selection: o } = e;
              return (
                (t = t.setSelection(o)),
                (t = cx(
                  t,
                  this.options,
                  r.extensionManager.extensions,
                  "indent"
                )),
                t.docChanged && n && n(t),
                !0
              );
            },
          outdent:
            () =>
            ({ tr: t, state: e, dispatch: n, editor: r }) => {
              const { selection: o } = e;
              return (
                (t = t.setSelection(o)),
                (t = cx(
                  t,
                  this.options,
                  r.extensionManager.extensions,
                  "outdent"
                )),
                t.docChanged && n && n(t),
                !0
              );
            },
        };
      },
      addKeyboardShortcuts() {
        return { Tab: dx(), "Shift-Tab": fx(), "Mod-]": dx(), "Mod-[": fx() };
      },
      onUpdate() {
        const { editor: t } = this;
        if (t.isActive("listItem")) {
          const e = t.state.selection.$head.node();
          e.attrs.indent &&
            t.commands.updateAttributes(e.type.name, { indent: 0 });
        }
      },
    }),
    mF = (t, e, n) => (t < e ? e : t > n ? n : t);
  function gF(t, e, n, r) {
    if (!t.doc) return t;
    const o = t.doc.nodeAt(e);
    if (!o) return t;
    if (r.firstLineIndent && bF(t) && o.attrs.lineIndent !== n > 0) {
      const d = { ...o.attrs, lineIndent: n > 0 };
      return t.setNodeMarkup(e, o.type, d, o.marks);
    }
    const i = r.indentRange * n,
      s = r.minIndentLevel,
      a = r.maxIndentLevel,
      l = mF((o.attrs.indent || 0) + i, s, a);
    if (l === o.attrs.indent) return t;
    const c = { ...o.attrs, indent: l };
    return t.setNodeMarkup(e, o.type, c, o.marks);
  }
  const bF = (t) => {
      const { selection: e } = t,
        { $from: n, from: r, to: o } = e;
      return r == 0 ? !0 : r != o ? !1 : n.textOffset == 0;
    },
    cx = (t, e, n, r) => {
      const { doc: o, selection: i } = t;
      if (!o || !i || !(i instanceof U)) return t;
      const { from: s, to: a } = i;
      return (
        o.nodesBetween(s, a, (l, c) =>
          e.names.includes(l.type.name)
            ? (yF(t, c) && r === "indent"
                ? t.insertText("	", s, a)
                : (t = gF(t, c, r === "indent" ? 1 : -1, e)),
              !1)
            : !Sc(l.type.name, n)
        ),
        t
      );
    },
    yF = (t, e) => {
      const { selection: n } = t,
        { from: r, to: o } = n;
      return r == 0 ? !1 : r - o == 0 && e != r - 1;
    },
    ux = (t) => t.isActive("table") || t.isActive("columns"),
    dx =
      () =>
      ({ editor: t }) => {
        if (ux(t)) return !1;
        if (zh(t)) {
          const e = t.can().sinkListItem("listItem") ? "listItem" : "taskItem";
          return t.chain().focus().sinkListItem(e).run();
        }
        return t.chain().focus().indent().run();
      },
    fx =
      (t) =>
      ({ editor: e }) => {
        if (ux(e)) return !1;
        if (zh(e)) {
          const n = e.can().liftListItem("listItem") ? "listItem" : "taskItem";
          return e.chain().focus().liftListItem(n).run();
        }
        return e.chain().focus().outdent().run();
      },
    px = we.create({
      name: "nodeSelected",
      addOptions() {
        return { className: "has-node-selected" };
      },
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("nodeSelected"),
            props: {
              decorations: ({ doc: t, selection: e }) => {
                const { isEditable: n, isFocused: r } = this.editor,
                  { anchor: o } = e,
                  i = [];
                return !n || !r
                  ? ue.create(t, [])
                  : (t.descendants((s, a) => {
                      if (s.isText || !(o >= a && o <= a + s.nodeSize - 1))
                        return !1;
                      i.push(
                        Te.node(a, a + s.nodeSize, {
                          class: this.options.className,
                        })
                      );
                    }),
                    ue.create(t, i));
              },
            },
          }),
        ];
      },
    });
  class St extends J {
    constructor(e, n) {
      hx(e, n), super(e, n);
    }
    map(e, n) {
      const r = e.resolve(n.map(this.head)),
        o = e.resolve(n.map(this.anchor));
      return new St(o, r);
    }
    eq(e) {
      return e instanceof St && e.anchor == this.anchor && e.head == this.head;
    }
    getBookmark() {
      return new C0(this.anchor, this.head);
    }
    toJSON() {
      return { type: "range", anchor: this.anchor, head: this.head };
    }
    static valid(e, n, r) {
      const o = mx(e.doc.resolve(n), e.doc.resolve(r));
      return !(o.length === 0 || o.reverse()[0].pos < 0);
    }
    static between(e, n) {
      hx(e, n);
      const r = e.doc,
        o = e.pos < n.pos ? 1 : -1,
        i = o > 0 ? e.pos : n.pos,
        s = o > 0 ? n.pos : e.pos,
        a = mx(e, n);
      if (a.length === 0) return null;
      const l = a[a.length - 1];
      if (l.pos < 0) return null;
      let c = 0;
      a.forEach(({ pos: h }) => {
        h < 0 && (c = h);
      });
      const d = s - i - l.pos - l.node.nodeSize,
        f = o > 0 ? i + c : s - (d > 0 ? 0 : d),
        p = o > 0 ? s - (d > 0 ? 0 : d) : i + c;
      return new St(r.resolve(f), r.resolve(p));
    }
    static fromJSON(e, n) {
      if (typeof n.anchor != "number" || typeof n.head != "number")
        throw new RangeError("Invalid input for RangeSelection.fromJSON");
      return new St(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r) {
      return new this(e.resolve(n), e.resolve(r));
    }
    static allRange(e) {
      return new St(e.resolve(0), e.resolve(e.content.size));
    }
  }
  J.jsonID("range", St);
  class C0 {
    constructor(e, n) {
      (this.anchor = e), (this.head = n);
    }
    map(e) {
      return new C0(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      return new St(e.resolve(this.anchor), e.resolve(this.head));
    }
  }
  function hx(t, e) {
    t.pos === e.pos && console.warn("The RangeSelection cannot be empty.");
  }
  function mx(t, e) {
    const n = t.doc,
      r = t.pos < e.pos ? 1 : -1,
      o = r > 0 ? t.pos : e.pos,
      i = r > 0 ? e.pos : t.pos,
      s = [];
    return (
      n.nodesBetween(
        o,
        i,
        (a, l, c, d) => {
          if (a.isText || a.type.name === "paragraph") return !0;
          s.push({ node: a, pos: l, parent: c, index: d });
        },
        -o
      ),
      s
    );
  }
  const Ht = { anchor: 0, head: 0, enable: !1 },
    gx = we.create({
      priority: 100,
      name: "rangeSelectionExtension",
      addProseMirrorPlugins() {
        return [
          new ie({
            key: new de("rangeSelectionPlugin"),
            props: {
              decorations: ({ doc: t, selection: e }) => {
                const { isEditable: n, isFocused: r } = this.editor;
                if (!n || !r || !(e instanceof St)) return null;
                const { $from: o, $to: i } = e,
                  s = [];
                return (
                  t.nodesBetween(o.pos, i.pos, (a, l) => {
                    a.isText ||
                      a.type.name === "paragraph" ||
                      (a.type.spec.fakeSelection &&
                        s.push(
                          Te.node(l, l + a.nodeSize, {
                            class: "no-selection range-fake-selection",
                          })
                        ));
                  }),
                  ue.create(t, s)
                );
              },
              createSelectionBetween: (t, e, n) =>
                e.pos === n.pos
                  ? null
                  : St.valid(t.state, e.pos, n.pos)
                  ? new St(e, n)
                  : null,
              handleDOMEvents: {
                mousedown: (t, e) => {
                  const n = { left: e.clientX, top: e.clientY },
                    r = t.posAtCoords(n);
                  !r || !r.pos || ((Ht.enable = !0), (Ht.anchor = r.pos));
                },
                mousemove: (t, e) => {
                  if (!Ht.enable) return;
                  const n = { left: e.clientX, top: e.clientY },
                    r = t.posAtCoords(n);
                  if (!r || !r.pos || r.pos === Ht.anchor || r.pos === Ht.head)
                    return;
                  Ht.head = r.pos;
                  const o = St.between(
                    t.state.doc.resolve(Ht.anchor),
                    t.state.doc.resolve(Ht.head)
                  );
                  o && t.dispatch(t.state.tr.setSelection(o));
                },
                mouseup: () => {
                  (Ht.enable = !1), (Ht.anchor = 0), (Ht.head = 0);
                },
                mouseleave: () => {
                  (Ht.enable = !1), (Ht.anchor = 0), (Ht.head = 0);
                },
              },
            },
          }),
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-a": ({ editor: t }) => (
            t.view.dispatch(
              t.view.state.tr.setSelection(St.allRange(t.view.state.doc))
            ),
            !0
          ),
        };
      },
      extendNodeSchema(t) {
        const e = { name: t.name, options: t.options, storage: t.storage };
        return { fakeSelection: re(j(t, "fakeSelection", e)) ?? !1 };
      },
    }),
    _F = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function kF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        _F,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M15.5 12c2.5 0 4.5 2 4.5 4.5c0 .88-.25 1.71-.69 2.4l3.08 3.1L21 23.39l-3.12-3.07c-.69.43-1.51.68-2.38.68c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5m0 2a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5M5 3h14c1.11 0 2 .89 2 2v8.03c-.5-.8-1.19-1.49-2-2.03V5H5v14h4.5c.31.75.76 1.42 1.31 2H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2m2 4h10v2H7zm0 4h5.03c-.8.5-1.49 1.19-2.03 2H7zm0 4h2.17c-.11.5-.17 1-.17 1.5v.5H7z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const wF = u.markRaw({ name: "mdi-text-box-search-outline", render: kF }),
    xF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function CF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        xF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "g",
              {
                fill: "none",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
              },
              [
                u.createElementVNode("path", {
                  d: "M14 4a2 2 0 0 1 2-2m0 8a2 2 0 0 1-2-2m6-6a2 2 0 0 1 2 2m0 4a2 2 0 0 1-2 2M3 7l3 3l3-3",
                }),
                u.createElementVNode("path", { d: "M6 10V5a3 3 0 0 1 3-3h1" }),
                u.createElementVNode("rect", {
                  width: "8",
                  height: "8",
                  x: "2",
                  y: "14",
                  rx: "2",
                }),
              ],
              -1
            ),
          ])
      )
    );
  }
  const vF = u.markRaw({ name: "lucide-replace", render: CF }),
    EF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function AF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        EF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "g",
              {
                fill: "none",
                stroke: "currentColor",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
              },
              [
                u.createElementVNode("path", {
                  d: "M14 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2m0-18a2 2 0 0 1 2-2m0 8a2 2 0 0 1-2-2m6 6a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2m0-20a2 2 0 0 1 2 2m0 4a2 2 0 0 1-2 2M3 7l3 3l3-3",
                }),
                u.createElementVNode("path", { d: "M6 10V5a3 3 0 0 1 3-3h1" }),
                u.createElementVNode("rect", {
                  width: "8",
                  height: "8",
                  x: "2",
                  y: "14",
                  rx: "2",
                }),
              ],
              -1
            ),
          ])
      )
    );
  }
  const SF = u.markRaw({ name: "lucide-replace-all", render: AF }),
    MF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function TF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        MF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M11 4h2v12l5.5-5.5l1.42 1.42L12 19.84l-7.92-7.92L5.5 10.5L11 16z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const NF = u.markRaw({ name: "mdi-arrow-down", render: TF }),
    OF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function RF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        OF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13 20h-2V8l-5.5 5.5l-1.42-1.42L12 4.16l7.92 7.92l-1.42 1.42L13 8z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const DF = u.markRaw({ name: "mdi-arrow-up", render: RF }),
    LF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function IF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        LF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const BF = u.markRaw({ name: "mdi-close", render: IF }),
    PF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function $F(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        PF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M20.06 18a4 4 0 0 1-.2-.89c-.67.7-1.48 1.05-2.41 1.05c-.83 0-1.52-.24-2.05-.71c-.53-.45-.8-1.06-.8-1.79c0-.88.33-1.56 1-2.05s1.61-.73 2.83-.73h1.4v-.64q0-.735-.45-1.17c-.3-.29-.75-.43-1.33-.43c-.52 0-.95.12-1.3.36c-.35.25-.52.54-.52.89h-1.46c0-.43.15-.84.45-1.24c.28-.4.71-.71 1.22-.94c.51-.21 1.06-.35 1.69-.35c.98 0 1.74.24 2.29.73s.84 1.16.86 2.02V16c0 .8.1 1.42.3 1.88V18zm-2.4-1.12c.45 0 .88-.11 1.29-.32c.4-.21.7-.49.88-.83v-1.57H18.7c-1.77 0-2.66.47-2.66 1.41c0 .43.15.73.46.96c.3.23.68.35 1.16.35m-12.2-3.17h4.07L7.5 8.29zM6.64 6h1.72l4.71 12h-1.93l-.97-2.57H4.82L3.86 18H1.93z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const FF = u.markRaw({ name: "mdi-format-letter-case", render: $F }),
    HF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function zF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        HF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M11.14 4L6.43 16h1.93l.96-2.57h5.35l.97 2.57h1.93L12.86 4M12 6.29l2.03 5.42H9.96M20 14v4H4v-3H2v5h20v-6Z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const VF = u.markRaw({ name: "mdi-format-letter-matches", render: zF }),
    UF = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function jF(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        UF,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M16 16.92c-.33.05-.66.08-1 .08s-.67-.03-1-.08v-3.51l-2.5 2.48c-.5-.39-1-.89-1.39-1.39l2.48-2.5H9.08c-.05-.33-.08-.66-.08-1s.03-.67.08-1h3.51l-2.48-2.5c.19-.25.39-.5.65-.74c.24-.26.49-.46.74-.65L14 8.59V5.08c.33-.05.66-.08 1-.08s.67.03 1 .08v3.51l2.5-2.48c.5.39 1 .89 1.39 1.39L17.41 10h3.51c.05.33.08.66.08 1s-.03.67-.08 1h-3.51l2.48 2.5c-.19.25-.39.5-.65.74c-.24.26-.49.46-.74.65L16 13.41zM5 19a2 2 0 0 1 2-2a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const WF = u.markRaw({ name: "mdi-regex", render: jF }),
    qF = ["onKeydown"],
    KF = { class: "w-full flex flex-col gap-1" },
    GF = { class: "flex items-center relative" },
    JF = { class: "relative w-full max-w-[55%]" },
    YF = ["placeholder", "onKeydown"],
    XF = { class: "absolute inset-y-0 end-0 flex items-center pr-1 gap-1" },
    ZF = ["title"],
    QF = ["title"],
    eH = ["title"],
    tH = { class: "min-w-[130px] text-sm mx-2" },
    nH = { key: 0 },
    rH = { key: 1 },
    oH = { class: "h-full flex items-center absolute right-0" },
    iH = ["title", "disabled"],
    sH = ["title", "disabled"],
    aH = ["title"],
    lH = { class: "flex items-center" },
    cH = { class: "relative w-full max-w-[55%]" },
    uH = ["placeholder", "onKeydown"],
    dH = { class: "flex items-center gap-2 mx-2" },
    fH = ["title", "disabled"],
    pH = ["title", "disabled"],
    hH = u.defineComponent({
      __name: "SearchAndReplace",
      props: {
        editor: { type: Object, required: !0 },
        pluginKey: { type: Object, required: !0 },
        visible: { type: Boolean, default: !1 },
      },
      setup(t) {
        const e = t,
          n = u.ref(""),
          r = u.ref(""),
          o = u.ref(!1),
          i = u.ref(!1),
          s = u.ref(!1),
          a = u.ref(!1),
          l = u.computed(() => {
            a.value;
            const { editor: b, pluginKey: y } = e;
            if (!b || !y) return { findIndex: 0, findCount: 0 };
            const x = y.getState(b.state);
            return {
              findIndex: (x == null ? void 0 : x.findIndex) || 0,
              findCount: (x == null ? void 0 : x.findCount) || 0,
            };
          }),
          c = () => {
            e.editor.commands.findNext();
          },
          d = () => {
            e.editor.commands.findPrevious();
          },
          f = (b) => {
            const { editor: y, pluginKey: x } = e;
            if (!y || !x) return;
            const w = y.state.tr;
            w.setMeta(x, b), y.view.dispatch(w), (a.value = !a.value);
          },
          p = () => {
            e.editor.commands.replace(), (a.value = !a.value);
          },
          h = () => {
            e.editor.commands.replaceAll(), (a.value = !a.value);
          },
          m = () => {
            e.editor.commands.closeSearch();
          };
        u.watch(
          () => n.value.trim(),
          (b, y) => {
            b !== y && f({ setSearchTerm: b });
          }
        ),
          u.watch(
            () => r.value.trim(),
            (b, y) => {
              b !== y && f({ setReplaceTerm: b });
            }
          ),
          u.watch(
            () => o.value,
            (b, y) => {
              b !== y && f({ setRegex: b });
            }
          ),
          u.watch(
            () => i.value,
            (b, y) => {
              b !== y && f({ setCaseSensitive: b });
            }
          ),
          u.watch(
            () => s.value,
            (b, y) => {
              b !== y && f({ setMatchWord: b });
            }
          );
        const g = u.ref(null);
        return (
          u.watch(
            () => e.visible,
            (b) => {
              b &&
                u.nextTick(() => {
                  var y;
                  (y = g.value) == null || y.focus();
                });
            }
          ),
          (b, y) =>
            u.withDirectives(
              (u.openBlock(),
              u.createBlock(
                u.Transition,
                { appear: "", name: "slide" },
                {
                  default: u.withCtx(() => [
                    u.createElementVNode(
                      "div",
                      {
                        class:
                          "absolute float-right top-0 right-5 z-50 flex justify-end bg-white shadow p-1 !pt-2 rounded min-w-[500px]",
                        onKeydown: u.withKeys(u.withModifiers(m, ["prevent"]), [
                          "escape",
                        ]),
                      },
                      [
                        u.createElementVNode("section", KF, [
                          u.createElementVNode("div", GF, [
                            u.createElementVNode("div", JF, [
                              u.withDirectives(
                                u.createElementVNode(
                                  "input",
                                  {
                                    ref_key: "searchInput",
                                    ref: g,
                                    "onUpdate:modelValue":
                                      y[0] || (y[0] = (x) => (n.value = x)),
                                    type: "text",
                                    class:
                                      "block w-full p-1 ps-2 !pr-[5.5rem] bg-gray-50 rounded border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                                    placeholder: u
                                      .unref(T)
                                      .global.t(
                                        "editor.extensions.search_and_replace.search_placeholder"
                                      ),
                                    tabindex: "2",
                                    onKeydown: u.withKeys(
                                      u.withModifiers(c, ["prevent"]),
                                      ["enter"]
                                    ),
                                  },
                                  null,
                                  40,
                                  YF
                                ),
                                [[u.vModelText, n.value]]
                              ),
                              u.createElementVNode("div", XF, [
                                u.createElementVNode(
                                  "button",
                                  {
                                    title: u
                                      .unref(T)
                                      .global.t(
                                        "editor.extensions.search_and_replace.case_sensitive"
                                      ),
                                    type: "button",
                                    class: u.normalizeClass([
                                      "p-0.5 rounded-sm hover:bg-gray-200",
                                      {
                                        "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                          i.value,
                                      },
                                    ]),
                                    onClick:
                                      y[1] ||
                                      (y[1] = (x) => (i.value = !i.value)),
                                  },
                                  [u.createVNode(u.unref(FF))],
                                  10,
                                  ZF
                                ),
                                u.createElementVNode(
                                  "button",
                                  {
                                    title: u
                                      .unref(T)
                                      .global.t(
                                        "editor.extensions.search_and_replace.match_word"
                                      ),
                                    type: "button",
                                    class: u.normalizeClass([
                                      "p-0.5 rounded-sm hover:bg-gray-200",
                                      {
                                        "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                          s.value,
                                      },
                                    ]),
                                    onClick:
                                      y[2] ||
                                      (y[2] = (x) => (s.value = !s.value)),
                                  },
                                  [u.createVNode(u.unref(VF))],
                                  10,
                                  QF
                                ),
                                u.createElementVNode(
                                  "button",
                                  {
                                    title: u
                                      .unref(T)
                                      .global.t(
                                        "editor.extensions.search_and_replace.use_regex"
                                      ),
                                    type: "button",
                                    class: u.normalizeClass([
                                      "p-0.5 rounded-sm hover:bg-gray-200",
                                      {
                                        "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                          o.value,
                                      },
                                    ]),
                                    onClick:
                                      y[3] ||
                                      (y[3] = (x) => (o.value = !o.value)),
                                  },
                                  [u.createVNode(u.unref(WF))],
                                  10,
                                  eH
                                ),
                              ]),
                            ]),
                            u.createElementVNode("div", tH, [
                              l.value.findCount === 0
                                ? (u.openBlock(),
                                  u.createElementBlock("div", nH, [
                                    u.createElementVNode(
                                      "span",
                                      {
                                        class: u.normalizeClass({
                                          "text-red-600": n.value.length > 0,
                                        }),
                                      },
                                      u.toDisplayString(
                                        u
                                          .unref(T)
                                          .global.t(
                                            "editor.extensions.search_and_replace.not_found"
                                          )
                                      ),
                                      3
                                    ),
                                  ]))
                                : (u.openBlock(),
                                  u.createElementBlock("div", rH, [
                                    u.createElementVNode(
                                      "span",
                                      null,
                                      u.toDisplayString(
                                        u
                                          .unref(T)
                                          .global.t(
                                            "editor.extensions.search_and_replace.occurrence_found",
                                            {
                                              index: l.value.findIndex + 1,
                                              total: l.value.findCount,
                                            }
                                          )
                                      ),
                                      1
                                    ),
                                  ])),
                            ]),
                            u.createElementVNode("div", oH, [
                              u.createElementVNode(
                                "button",
                                {
                                  title: u
                                    .unref(T)
                                    .global.t(
                                      "editor.extensions.search_and_replace.find_previous"
                                    ),
                                  type: "button",
                                  class: u.normalizeClass([
                                    "p-0.5 rounded-sm opacity-50",
                                    {
                                      "hover:!bg-gray-200 !opacity-100":
                                        l.value.findCount > 0,
                                    },
                                  ]),
                                  disabled: l.value.findCount === 0,
                                  onClick: d,
                                },
                                [u.createVNode(u.unref(DF))],
                                10,
                                iH
                              ),
                              u.createElementVNode(
                                "button",
                                {
                                  title: u
                                    .unref(T)
                                    .global.t(
                                      "editor.extensions.search_and_replace.find_next"
                                    ),
                                  type: "button",
                                  class: u.normalizeClass([
                                    "p-0.5 rounded-sm opacity-50",
                                    {
                                      "hover:!bg-gray-200 !opacity-100":
                                        l.value.findCount > 0,
                                    },
                                  ]),
                                  disabled: l.value.findCount === 0,
                                  onClick: c,
                                },
                                [u.createVNode(u.unref(NF))],
                                10,
                                sH
                              ),
                              u.createElementVNode(
                                "button",
                                {
                                  title: u
                                    .unref(T)
                                    .global.t(
                                      "editor.extensions.search_and_replace.close"
                                    ),
                                  type: "button",
                                  class: "p-0.5 rounded-sm hover:bg-gray-200",
                                  onClick: m,
                                },
                                [u.createVNode(u.unref(BF))],
                                8,
                                aH
                              ),
                            ]),
                          ]),
                          u.createElementVNode("div", lH, [
                            u.createElementVNode("div", cH, [
                              u.withDirectives(
                                u.createElementVNode(
                                  "input",
                                  {
                                    "onUpdate:modelValue":
                                      y[4] || (y[4] = (x) => (r.value = x)),
                                    type: "text",
                                    class:
                                      "block w-full p-1 ps-2 rounded bg-gray-50 border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                                    placeholder: u
                                      .unref(T)
                                      .global.t(
                                        "editor.extensions.search_and_replace.replace_placeholder"
                                      ),
                                    tabindex: "2",
                                    onKeydown: u.withKeys(
                                      u.withModifiers(p, ["prevent"]),
                                      ["enter"]
                                    ),
                                  },
                                  null,
                                  40,
                                  uH
                                ),
                                [[u.vModelText, r.value]]
                              ),
                            ]),
                            u.createElementVNode("div", dH, [
                              u.createElementVNode(
                                "button",
                                {
                                  title: u
                                    .unref(T)
                                    .global.t(
                                      "editor.extensions.search_and_replace.replace"
                                    ),
                                  type: "button",
                                  class: u.normalizeClass([
                                    "p-0.5 rounded-sm opacity-50",
                                    {
                                      "hover:!bg-gray-200 !opacity-100":
                                        l.value.findCount > 0,
                                    },
                                  ]),
                                  disabled: l.value.findCount === 0,
                                  onClick: p,
                                },
                                [u.createVNode(u.unref(vF))],
                                10,
                                fH
                              ),
                              u.createElementVNode(
                                "button",
                                {
                                  title: u
                                    .unref(T)
                                    .global.t(
                                      "editor.extensions.search_and_replace.replace_all"
                                    ),
                                  type: "button",
                                  class: u.normalizeClass([
                                    "p-0.5 rounded-sm opacity-50",
                                    {
                                      "hover:!bg-gray-200 !opacity-100":
                                        l.value.findCount > 0,
                                    },
                                  ]),
                                  disabled: l.value.findCount === 0,
                                  onClick: h,
                                },
                                [u.createVNode(u.unref(SF))],
                                10,
                                pH
                              ),
                            ]),
                          ]),
                        ]),
                      ],
                      40,
                      qF
                    ),
                  ]),
                  _: 1,
                },
                512
              )),
              [[u.vShow, t.visible]]
            )
        );
      },
    }),
    Mt = new de("searchAndReplace");
  class mH {
    constructor({ view: e, editor: n, element: r }) {
      oe(this, "editor");
      oe(this, "view");
      oe(this, "containerElement");
      oe(this, "init");
      (this.editor = n),
        (this.view = e),
        (this.containerElement = r),
        (this.init = !1);
    }
    update() {
      const { parentElement: e } = this.editor.options.element;
      return (
        !this.init &&
          e &&
          (e.insertAdjacentElement("afterbegin", this.containerElement),
          (this.init = !0)),
        !1
      );
    }
    destroy() {
      return !1;
    }
  }
  class gH {
    constructor({
      editor: e,
      enable: n,
      regex: r,
      caseSensitive: o,
      wholeWord: i,
    }) {
      oe(this, "_findIndex");
      oe(this, "editor");
      oe(this, "enable");
      oe(this, "findIndexFlag");
      oe(this, "findCount");
      oe(this, "searchTerm");
      oe(this, "replaceTerm");
      oe(this, "regex");
      oe(this, "caseSensitive");
      oe(this, "wholeWord");
      oe(this, "results", []);
      oe(this, "searchResultDecorations", []);
      oe(this, "findIndexDecoration");
      oe(this, "getRegex", () => {
        const {
          searchTerm: e,
          regex: n,
          caseSensitive: r,
          wholeWord: o,
        } = this;
        let i = n ? e : e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return o && (i = `\\b${i}\\b`), new RegExp(i, r ? "gu" : "gui");
      });
      (this.editor = e),
        (this.enable = n || !1),
        (this.searchTerm = ""),
        (this.replaceTerm = ""),
        (this.regex = r || !1),
        (this.caseSensitive = o || !1),
        (this.wholeWord = i || !1),
        (this._findIndex = 0),
        (this.findCount = 0),
        (this.searchResultDecorations = []),
        (this.findIndexDecoration = void 0),
        (this.results = []),
        (this.findIndexFlag = !0);
    }
    get findIndex() {
      return this._findIndex;
    }
    set findIndex(e) {
      this._findIndex = this.verifySetIndex(e);
    }
    apply(e) {
      const n = e.getMeta(Mt);
      if (
        (n &&
          "setEnable" in n &&
          (n.setEnable && !this.enable && (n.setSearchTerm = this.searchTerm),
          (this.enable = n.setEnable)),
        !this.enable)
      )
        return this;
      if (
        (n && n.refresh && this.processSearches(e),
        n && "setReplaceTerm" in n && (this.replaceTerm = n.setReplaceTerm),
        n && "setFindIndex" in n)
      ) {
        const { setFindIndex: r } = n;
        (this.findIndex = r), this.processFindIndexDecoration();
      }
      return (
        n && this.scrollIntoFindIndexView(),
        n &&
          "setRegex" in n &&
          this.regex !== n.setRegex &&
          ((this.regex = n.setRegex), (n.setSearchTerm = this.searchTerm)),
        n &&
          "setWholeWord" in n &&
          this.wholeWord !== n.setWholeWord &&
          ((this.wholeWord = n.setWholeWord),
          (n.setSearchTerm = this.searchTerm)),
        n &&
          "setCaseSensitive" in n &&
          this.caseSensitive !== n.setCaseSensitive &&
          ((this.caseSensitive = n.setCaseSensitive),
          (n.setSearchTerm = this.searchTerm)),
        n && "setSearchTerm" in n
          ? ((this.searchTerm = n.setSearchTerm),
            (this.findIndexFlag = !0),
            this.processSearches(e),
            this.scrollIntoFindIndexView(),
            this)
          : e.docChanged
          ? this.processSearches(e)
          : (e.getMeta("pointer") &&
              (this.getNearestResultBySelection(e.selection),
              this.processFindIndexDecoration()),
            this)
      );
    }
    scrollIntoFindIndexView() {
      const { results: e, editor: n, _findIndex: r } = this;
      if (e.length > r && r >= 0) {
        const o = e[r];
        if (o) {
          const { pos: i } = o,
            { view: s } = n;
          let a = s.nodeDOM(i - 1);
          a instanceof HTMLElement || (a = s.domAtPos(i, 0).node),
            a instanceof HTMLElement &&
              Dw(a, { behavior: "smooth", scrollMode: "if-needed" });
        }
      }
    }
    verifySetIndex(e) {
      const { results: n } = this;
      return n.length === 0
        ? 0
        : e <= -1
        ? n.length - 1
        : e > n.length - 1
        ? 0
        : e;
    }
    processSearches({ doc: e, selection: n }) {
      const r = this.getFullText(e),
        o = this.getRegex();
      this.results.length = 0;
      for (let i = 0; i < r.length; i += 1) {
        const { text: s, pos: a, index: l } = r[i],
          c = Array.from(s.matchAll(o)).filter(([d]) => d.trim());
        for (let d = 0; d < c.length; d += 1) {
          const f = c[d];
          if (f[0] === "") break;
          f.index !== void 0 &&
            this.results.push({
              pos: a,
              index: l,
              from: a + f.index,
              to: a + f.index + f[0].length,
            });
        }
      }
      return (
        this.processResultDecorations(),
        this.findIndexFlag &&
          (this.getNearestResultBySelection(n), (this.findIndexFlag = !1)),
        this.processFindIndexDecoration(),
        this
      );
    }
    processFindIndexDecoration() {
      const { results: e, findIndex: n } = this,
        r = e[n];
      r &&
        (this.findIndexDecoration = Te.inline(r.from, r.to, {
          class: "search-result-current",
        }));
    }
    processResultDecorations() {
      const { results: e } = this;
      (this.findCount = e.length), (this.searchResultDecorations.length = 0);
      for (let n = 0; n < e.length; n += 1) {
        const r = e[n];
        this.searchResultDecorations.push(
          Te.inline(r.from, r.to, { class: "search-result" })
        );
      }
    }
    getNearestResultBySelection(e) {
      const { results: n } = this;
      for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        if (e && e.to <= o.from) {
          this.findIndex = r;
          break;
        }
      }
    }
    getFullText(e) {
      const n = [];
      return (
        e.descendants((r, o, i, s) => {
          r.isText && n.push({ text: `${r.text}`, pos: o, index: s });
        }),
        n
      );
    }
  }
  const bH = (t) =>
      new ie({
        key: Mt,
        view: (e) => new mH({ view: e, ...t }),
        state: { init: () => new gH({ ...t }), apply: (e, n) => n.apply(e) },
        props: {
          decorations: (e) => {
            const n = Mt.getState(e);
            if (n) {
              const {
                searchResultDecorations: r,
                findIndexDecoration: o,
                enable: i,
              } = n;
              if (!i) return ue.empty;
              const s = [...r];
              if ((o && s.push(o), s.length > 0)) return ue.create(e.doc, s);
            }
            return ue.empty;
          },
        },
      }),
    Wi = u.h(hH);
  function yH() {
    const t = Wi.component;
    return t ? t.props.visible : !1;
  }
  const bx = we.create({
      name: "searchAndReplace",
      addOptions() {
        return {
          getToolbarItems({ editor: t }) {
            return [
              {
                priority: 230,
                component: u.markRaw($e),
                props: {
                  editor: t,
                  isActive: yH(),
                  icon: u.markRaw(wF),
                  title: T.global.t(
                    "editor.extensions.search_and_replace.title"
                  ),
                  action: () => {
                    const e = Wi.component;
                    e &&
                      (e.props.visible
                        ? t.commands.closeSearch()
                        : t.commands.openSearch());
                  },
                },
              },
            ];
          },
        };
      },
      addCommands() {
        return {
          replace:
            () =>
            ({ state: t, dispatch: e }) => {
              const n = Mt.getState(t);
              if (!n) return !1;
              const { replaceTerm: r, results: o, findIndex: i } = n,
                s = o[i];
              if (!s) return !1;
              const { from: a, to: l } = s;
              if (e) {
                const c = t.tr;
                c.insertText(r, a, l),
                  c.setMeta(Mt, { setFindIndex: i, refresh: !0 }),
                  e(c);
              }
              return !1;
            },
          replaceAll:
            () =>
            ({ state: t, dispatch: e }) => {
              const n = Mt.getState(t);
              if (!n) return !1;
              const { replaceTerm: r, results: o } = n,
                i = t.tr;
              let s = 0;
              return (
                o.forEach((a) => {
                  const { from: l, to: c } = a;
                  i.insertText(r, s + l, s + c), (s = s + r.length - (c - l));
                }),
                e && e(i),
                !1
              );
            },
          findNext:
            () =>
            ({ state: t, dispatch: e }) => {
              if (e) {
                const n = t.tr,
                  r = Mt.getState(t);
                if (!r) return !1;
                const { findIndex: o } = r;
                n.setMeta(Mt, { setFindIndex: o + 1 }), e(n);
              }
              return !1;
            },
          findPrevious:
            () =>
            ({ state: t, dispatch: e }) => {
              if (e) {
                const n = Mt.getState(t);
                if (!n) return !1;
                const { findIndex: r } = n,
                  o = t.tr;
                o.setMeta(Mt, { setFindIndex: r - 1 }), e(o);
              }
              return !1;
            },
          openSearch:
            () =>
            ({ state: t, dispatch: e }) => {
              if (!Mt.getState(t)) return !1;
              const r = Wi.component;
              if (r) {
                r.props.visible = !0;
                const o = t.tr;
                o.setMeta(Mt, { setEnable: !0 }), e && e(o);
              }
              return !1;
            },
          closeSearch:
            () =>
            ({ state: t, dispatch: e }) => {
              if (!Mt.getState(t)) return !1;
              const r = Wi.component;
              if (r) {
                r.props.visible = !1;
                const o = t.tr;
                o.setMeta(Mt, { setEnable: !1 }), e && e(o);
              }
              return !1;
            },
        };
      },
      addProseMirrorPlugins() {
        const t = document.createElement("div");
        return (
          (t.style.position = "sticky"),
          (t.style.top = "0"),
          (t.style.zIndex = "50"),
          (Wi.props = { editor: this.editor, pluginKey: Mt, visible: !1 }),
          u.render(Wi, t),
          [bH({ editor: this.editor, element: t })]
        );
      },
      addKeyboardShortcuts() {
        return { "Mod-f": () => (this.editor.commands.openSearch(), !0) };
      },
    }),
    _H = { class: "p-1" },
    kH = { class: "text-xs text-gray-600" },
    wH = u.defineComponent({
      __name: "ColorBubbleItem",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t;
        function n(o) {
          var i;
          o && ((i = e.editor) == null || i.chain().focus().setColor(o).run());
        }
        function r() {
          var o;
          (o = e.editor) == null || o.chain().focus().unsetColor().run();
        }
        return (o, i) => (
          u.openBlock(),
          u.createBlock(
            Wc,
            { "onUpdate:modelValue": n },
            {
              prefix: u.withCtx(() => [
                u.createElementVNode("div", _H, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: r,
                    },
                    [
                      i[0] ||
                        (i[0] = u.createElementVNode(
                          "div",
                          {
                            class:
                              "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black",
                          },
                          null,
                          -1
                        )),
                      u.createElementVNode(
                        "span",
                        kH,
                        u.toDisplayString(
                          u
                            .unref(T)
                            .global.t("editor.common.button.restore_default")
                        ),
                        1
                      ),
                    ]
                  ),
                ]),
              ]),
              default: u.withCtx(() => [
                u.createVNode(
                  u.unref(bl),
                  u.mergeProps(e, { editor: o.editor }),
                  null,
                  16,
                  ["editor"]
                ),
              ]),
              _: 1,
            }
          )
        );
      },
    }),
    xH = { class: "p-1" },
    CH = { class: "inline-flex items-center gap-2" },
    vH = { class: "text-xs text-gray-600" },
    EH = { class: "p-1" },
    AH = { class: "text-xs text-gray-600" },
    SH = u.defineComponent({
      __name: "HighlightBubbleItem",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t;
        function n(o) {
          var i;
          o &&
            ((i = e.editor) == null ||
              i.chain().focus().toggleHighlight({ color: o }).run());
        }
        function r() {
          var o;
          (o = e.editor) == null || o.chain().focus().unsetHighlight().run();
        }
        return (o, i) => (
          u.openBlock(),
          u.createBlock(
            Wc,
            { "onUpdate:modelValue": n },
            {
              prefix: u.withCtx(() => [
                u.createElementVNode("div", xH, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: r,
                    },
                    [
                      u.createElementVNode("div", CH, [
                        u.createVNode(u.unref(S3)),
                        u.createElementVNode(
                          "span",
                          vH,
                          u.toDisplayString(
                            u
                              .unref(T)
                              .global.t("editor.extensions.highlight.unset")
                          ),
                          1
                        ),
                      ]),
                    ]
                  ),
                ]),
                u.createElementVNode("div", EH, [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                      onClick: i[1] || (i[1] = (s) => n()),
                    },
                    [
                      i[2] ||
                        (i[2] = u.createElementVNode(
                          "div",
                          {
                            class:
                              "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                            style: { "background-color": "#fff8c5" },
                          },
                          null,
                          -1
                        )),
                      u.createElementVNode(
                        "span",
                        AH,
                        u.toDisplayString(
                          u
                            .unref(T)
                            .global.t("editor.common.button.restore_default")
                        ),
                        1
                      ),
                    ]
                  ),
                ]),
              ]),
              default: u.withCtx(() => [
                u.createVNode(
                  u.unref(bl),
                  u.mergeProps(e, { onClick: i[0] || (i[0] = (s) => n()) }),
                  null,
                  16
                ),
              ]),
              _: 1,
            }
          )
        );
      },
    }),
    MH =
      "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
    TH =
      "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2",
    qi = (t, e) => {
      for (const n in e) t[n] = e[n];
      return t;
    },
    v0 = "numeric",
    E0 = "ascii",
    A0 = "alpha",
    Fu = "asciinumeric",
    Hu = "alphanumeric",
    S0 = "domain",
    yx = "emoji",
    NH = "scheme",
    OH = "slashscheme",
    _x = "whitespace";
  function RH(t, e) {
    return t in e || (e[t] = []), e[t];
  }
  function ti(t, e, n) {
    e[v0] && ((e[Fu] = !0), (e[Hu] = !0)),
      e[E0] && ((e[Fu] = !0), (e[A0] = !0)),
      e[Fu] && (e[Hu] = !0),
      e[A0] && (e[Hu] = !0),
      e[Hu] && (e[S0] = !0),
      e[yx] && (e[S0] = !0);
    for (const r in e) {
      const o = RH(r, n);
      o.indexOf(t) < 0 && o.push(t);
    }
  }
  function DH(t, e) {
    const n = {};
    for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
    return n;
  }
  function Kt(t) {
    t === void 0 && (t = null),
      (this.j = {}),
      (this.jr = []),
      (this.jd = null),
      (this.t = t);
  }
  (Kt.groups = {}),
    (Kt.prototype = {
      accepts() {
        return !!this.t;
      },
      go(t) {
        const e = this,
          n = e.j[t];
        if (n) return n;
        for (let r = 0; r < e.jr.length; r++) {
          const o = e.jr[r][0],
            i = e.jr[r][1];
          if (i && o.test(t)) return i;
        }
        return e.jd;
      },
      has(t, e) {
        return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
      },
      ta(t, e, n, r) {
        for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
      },
      tr(t, e, n, r) {
        r = r || Kt.groups;
        let o;
        return (
          e && e.j ? (o = e) : ((o = new Kt(e)), n && r && ti(e, n, r)),
          this.jr.push([t, o]),
          o
        );
      },
      ts(t, e, n, r) {
        let o = this;
        const i = t.length;
        if (!i) return o;
        for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
        return o.tt(t[i - 1], e, n, r);
      },
      tt(t, e, n, r) {
        r = r || Kt.groups;
        const o = this;
        if (e && e.j) return (o.j[t] = e), e;
        const i = e;
        let s,
          a = o.go(t);
        if (
          (a
            ? ((s = new Kt()),
              qi(s.j, a.j),
              s.jr.push.apply(s.jr, a.jr),
              (s.jd = a.jd),
              (s.t = a.t))
            : (s = new Kt()),
          i)
        ) {
          if (r)
            if (s.t && typeof s.t == "string") {
              const l = qi(DH(s.t, r), n);
              ti(i, l, r);
            } else n && ti(i, n, r);
          s.t = i;
        }
        return (o.j[t] = s), s;
      },
    });
  const le = (t, e, n, r, o) => t.ta(e, n, r, o),
    mn = (t, e, n, r, o) => t.tr(e, n, r, o),
    kx = (t, e, n, r, o) => t.ts(e, n, r, o),
    V = (t, e, n, r, o) => t.tt(e, n, r, o),
    vr = "WORD",
    M0 = "UWORD",
    Ua = "LOCALHOST",
    T0 = "TLD",
    N0 = "UTLD",
    zu = "SCHEME",
    Ki = "SLASH_SCHEME",
    O0 = "NUM",
    wx = "WS",
    R0 = "NL",
    ja = "OPENBRACE",
    Wa = "CLOSEBRACE",
    Vu = "OPENBRACKET",
    Uu = "CLOSEBRACKET",
    ju = "OPENPAREN",
    Wu = "CLOSEPAREN",
    qu = "OPENANGLEBRACKET",
    Ku = "CLOSEANGLEBRACKET",
    Gu = "FULLWIDTHLEFTPAREN",
    Ju = "FULLWIDTHRIGHTPAREN",
    Yu = "LEFTCORNERBRACKET",
    Xu = "RIGHTCORNERBRACKET",
    Zu = "LEFTWHITECORNERBRACKET",
    Qu = "RIGHTWHITECORNERBRACKET",
    ed = "FULLWIDTHLESSTHAN",
    td = "FULLWIDTHGREATERTHAN",
    nd = "AMPERSAND",
    rd = "APOSTROPHE",
    od = "ASTERISK",
    po = "AT",
    id = "BACKSLASH",
    sd = "BACKTICK",
    ad = "CARET",
    ho = "COLON",
    D0 = "COMMA",
    ld = "DOLLAR",
    Qn = "DOT",
    cd = "EQUALS",
    L0 = "EXCLAMATION",
    er = "HYPHEN",
    ud = "PERCENT",
    dd = "PIPE",
    fd = "PLUS",
    pd = "POUND",
    hd = "QUERY",
    I0 = "QUOTE",
    B0 = "SEMI",
    tr = "SLASH",
    qa = "TILDE",
    md = "UNDERSCORE",
    xx = "EMOJI",
    gd = "SYM";
  var Cx = Object.freeze({
    __proto__: null,
    WORD: vr,
    UWORD: M0,
    LOCALHOST: Ua,
    TLD: T0,
    UTLD: N0,
    SCHEME: zu,
    SLASH_SCHEME: Ki,
    NUM: O0,
    WS: wx,
    NL: R0,
    OPENBRACE: ja,
    CLOSEBRACE: Wa,
    OPENBRACKET: Vu,
    CLOSEBRACKET: Uu,
    OPENPAREN: ju,
    CLOSEPAREN: Wu,
    OPENANGLEBRACKET: qu,
    CLOSEANGLEBRACKET: Ku,
    FULLWIDTHLEFTPAREN: Gu,
    FULLWIDTHRIGHTPAREN: Ju,
    LEFTCORNERBRACKET: Yu,
    RIGHTCORNERBRACKET: Xu,
    LEFTWHITECORNERBRACKET: Zu,
    RIGHTWHITECORNERBRACKET: Qu,
    FULLWIDTHLESSTHAN: ed,
    FULLWIDTHGREATERTHAN: td,
    AMPERSAND: nd,
    APOSTROPHE: rd,
    ASTERISK: od,
    AT: po,
    BACKSLASH: id,
    BACKTICK: sd,
    CARET: ad,
    COLON: ho,
    COMMA: D0,
    DOLLAR: ld,
    DOT: Qn,
    EQUALS: cd,
    EXCLAMATION: L0,
    HYPHEN: er,
    PERCENT: ud,
    PIPE: dd,
    PLUS: fd,
    POUND: pd,
    QUERY: hd,
    QUOTE: I0,
    SEMI: B0,
    SLASH: tr,
    TILDE: qa,
    UNDERSCORE: md,
    EMOJI: xx,
    SYM: gd,
  });
  const Gi = /[a-z]/,
    P0 = new RegExp("\\p{L}", "u"),
    $0 = new RegExp("\\p{Emoji}", "u"),
    F0 = /\d/,
    vx = /\s/,
    Ex = `
`,
    LH = "️",
    IH = "‍";
  let bd = null,
    yd = null;
  function BH(t) {
    t === void 0 && (t = []);
    const e = {};
    Kt.groups = e;
    const n = new Kt();
    bd == null && (bd = Ax(MH)),
      yd == null && (yd = Ax(TH)),
      V(n, "'", rd),
      V(n, "{", ja),
      V(n, "}", Wa),
      V(n, "[", Vu),
      V(n, "]", Uu),
      V(n, "(", ju),
      V(n, ")", Wu),
      V(n, "<", qu),
      V(n, ">", Ku),
      V(n, "（", Gu),
      V(n, "）", Ju),
      V(n, "「", Yu),
      V(n, "」", Xu),
      V(n, "『", Zu),
      V(n, "』", Qu),
      V(n, "＜", ed),
      V(n, "＞", td),
      V(n, "&", nd),
      V(n, "*", od),
      V(n, "@", po),
      V(n, "`", sd),
      V(n, "^", ad),
      V(n, ":", ho),
      V(n, ",", D0),
      V(n, "$", ld),
      V(n, ".", Qn),
      V(n, "=", cd),
      V(n, "!", L0),
      V(n, "-", er),
      V(n, "%", ud),
      V(n, "|", dd),
      V(n, "+", fd),
      V(n, "#", pd),
      V(n, "?", hd),
      V(n, '"', I0),
      V(n, "/", tr),
      V(n, ";", B0),
      V(n, "~", qa),
      V(n, "_", md),
      V(n, "\\", id);
    const r = mn(n, F0, O0, { [v0]: !0 });
    mn(r, F0, r);
    const o = mn(n, Gi, vr, { [E0]: !0 });
    mn(o, Gi, o);
    const i = mn(n, P0, M0, { [A0]: !0 });
    mn(i, Gi), mn(i, P0, i);
    const s = mn(n, vx, wx, { [_x]: !0 });
    V(n, Ex, R0, { [_x]: !0 }), V(s, Ex), mn(s, vx, s);
    const a = mn(n, $0, xx, { [yx]: !0 });
    mn(a, $0, a), V(a, LH, a);
    const l = V(a, IH);
    mn(l, $0, a);
    const c = [[Gi, o]],
      d = [
        [Gi, null],
        [P0, i],
      ];
    for (let f = 0; f < bd.length; f++) mo(n, bd[f], T0, vr, c);
    for (let f = 0; f < yd.length; f++) mo(n, yd[f], N0, M0, d);
    ti(T0, { tld: !0, ascii: !0 }, e),
      ti(N0, { utld: !0, alpha: !0 }, e),
      mo(n, "file", zu, vr, c),
      mo(n, "mailto", zu, vr, c),
      mo(n, "http", Ki, vr, c),
      mo(n, "https", Ki, vr, c),
      mo(n, "ftp", Ki, vr, c),
      mo(n, "ftps", Ki, vr, c),
      ti(zu, { scheme: !0, ascii: !0 }, e),
      ti(Ki, { slashscheme: !0, ascii: !0 }, e),
      (t = t.sort((f, p) => (f[0] > p[0] ? 1 : -1)));
    for (let f = 0; f < t.length; f++) {
      const p = t[f][0],
        m = t[f][1] ? { [NH]: !0 } : { [OH]: !0 };
      p.indexOf("-") >= 0
        ? (m[S0] = !0)
        : Gi.test(p)
        ? F0.test(p)
          ? (m[Fu] = !0)
          : (m[E0] = !0)
        : (m[v0] = !0),
        kx(n, p, p, m);
    }
    return (
      kx(n, "localhost", Ua, { ascii: !0 }),
      (n.jd = new Kt(gd)),
      { start: n, tokens: qi({ groups: e }, Cx) }
    );
  }
  function PH(t, e) {
    const n = $H(e.replace(/[A-Z]/g, (a) => a.toLowerCase())),
      r = n.length,
      o = [];
    let i = 0,
      s = 0;
    for (; s < r; ) {
      let a = t,
        l = null,
        c = 0,
        d = null,
        f = -1,
        p = -1;
      for (; s < r && (l = a.go(n[s])); )
        (a = l),
          a.accepts()
            ? ((f = 0), (p = 0), (d = a))
            : f >= 0 && ((f += n[s].length), p++),
          (c += n[s].length),
          (i += n[s].length),
          s++;
      (i -= f),
        (s -= p),
        (c -= f),
        o.push({ t: d.t, v: e.slice(i - c, i), s: i - c, e: i });
    }
    return o;
  }
  function $H(t) {
    const e = [],
      n = t.length;
    let r = 0;
    for (; r < n; ) {
      let o = t.charCodeAt(r),
        i,
        s =
          o < 55296 ||
          o > 56319 ||
          r + 1 === n ||
          (i = t.charCodeAt(r + 1)) < 56320 ||
          i > 57343
            ? t[r]
            : t.slice(r, r + 2);
      e.push(s), (r += s.length);
    }
    return e;
  }
  function mo(t, e, n, r, o) {
    let i;
    const s = e.length;
    for (let a = 0; a < s - 1; a++) {
      const l = e[a];
      t.j[l]
        ? (i = t.j[l])
        : ((i = new Kt(r)), (i.jr = o.slice()), (t.j[l] = i)),
        (t = i);
    }
    return (i = new Kt(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
  }
  function Ax(t) {
    const e = [],
      n = [];
    let r = 0,
      o = "0123456789";
    for (; r < t.length; ) {
      let i = 0;
      for (; o.indexOf(t[r + i]) >= 0; ) i++;
      if (i > 0) {
        e.push(n.join(""));
        for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--) n.pop();
        r += i;
      } else n.push(t[r]), r++;
    }
    return e;
  }
  const Ka = {
    defaultProtocol: "http",
    events: null,
    format: Mx,
    formatHref: Mx,
    nl2br: !1,
    tagName: "a",
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null,
  };
  function Sx(t, e) {
    e === void 0 && (e = null);
    let n = qi({}, Ka);
    t && (n = qi(n, t instanceof Sx ? t.o : t));
    const r = n.ignoreTags,
      o = [];
    for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
    (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
  }
  Sx.prototype = {
    o: Ka,
    ignoreTags: [],
    defaultRender(t) {
      return t;
    },
    check(t) {
      return this.get("validate", t.toString(), t);
    },
    get(t, e, n) {
      const r = e != null;
      let o = this.o[t];
      return (
        o &&
        (typeof o == "object"
          ? ((o = n.t in o ? o[n.t] : Ka[t]),
            typeof o == "function" && r && (o = o(e, n)))
          : typeof o == "function" && r && (o = o(e, n.t, n)),
        o)
      );
    },
    getObj(t, e, n) {
      let r = this.o[t];
      return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
    },
    render(t) {
      const e = t.render(this);
      return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
    },
  };
  function Mx(t) {
    return t;
  }
  function Tx(t, e) {
    (this.t = "token"), (this.v = t), (this.tk = e);
  }
  Tx.prototype = {
    isLink: !1,
    toString() {
      return this.v;
    },
    toHref(t) {
      return this.toString();
    },
    toFormattedString(t) {
      const e = this.toString(),
        n = t.get("truncate", e, this),
        r = t.get("format", e, this);
      return n && r.length > n ? r.substring(0, n) + "…" : r;
    },
    toFormattedHref(t) {
      return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
    },
    startIndex() {
      return this.tk[0].s;
    },
    endIndex() {
      return this.tk[this.tk.length - 1].e;
    },
    toObject(t) {
      return (
        t === void 0 && (t = Ka.defaultProtocol),
        {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(t),
          start: this.startIndex(),
          end: this.endIndex(),
        }
      );
    },
    toFormattedObject(t) {
      return {
        type: this.t,
        value: this.toFormattedString(t),
        isLink: this.isLink,
        href: this.toFormattedHref(t),
        start: this.startIndex(),
        end: this.endIndex(),
      };
    },
    validate(t) {
      return t.get("validate", this.toString(), this);
    },
    render(t) {
      const e = this,
        n = this.toHref(t.get("defaultProtocol")),
        r = t.get("formatHref", n, this),
        o = t.get("tagName", n, e),
        i = this.toFormattedString(t),
        s = {},
        a = t.get("className", n, e),
        l = t.get("target", n, e),
        c = t.get("rel", n, e),
        d = t.getObj("attributes", n, e),
        f = t.getObj("events", n, e);
      return (
        (s.href = r),
        a && (s.class = a),
        l && (s.target = l),
        c && (s.rel = c),
        d && qi(s, d),
        { tagName: o, attributes: s, content: i, eventListeners: f }
      );
    },
  };
  function _d(t, e) {
    class n extends Tx {
      constructor(o, i) {
        super(o, i), (this.t = t);
      }
    }
    for (const r in e) n.prototype[r] = e[r];
    return (n.t = t), n;
  }
  const Nx = _d("email", {
      isLink: !0,
      toHref() {
        return "mailto:" + this.toString();
      },
    }),
    Ox = _d("text"),
    FH = _d("nl"),
    kd = _d("url", {
      isLink: !0,
      toHref(t) {
        return (
          t === void 0 && (t = Ka.defaultProtocol),
          this.hasProtocol() ? this.v : `${t}://${this.v}`
        );
      },
      hasProtocol() {
        const t = this.tk;
        return t.length >= 2 && t[0].t !== Ua && t[1].t === ho;
      },
    }),
    gn = (t) => new Kt(t);
  function HH(t) {
    let { groups: e } = t;
    const n = e.domain.concat([
        nd,
        od,
        po,
        id,
        sd,
        ad,
        ld,
        cd,
        er,
        O0,
        ud,
        dd,
        fd,
        pd,
        tr,
        gd,
        qa,
        md,
      ]),
      r = [
        rd,
        ho,
        D0,
        Qn,
        L0,
        hd,
        I0,
        B0,
        qu,
        Ku,
        ja,
        Wa,
        Uu,
        Vu,
        ju,
        Wu,
        Gu,
        Ju,
        Yu,
        Xu,
        Zu,
        Qu,
        ed,
        td,
      ],
      o = [
        nd,
        rd,
        od,
        id,
        sd,
        ad,
        ld,
        cd,
        er,
        ja,
        Wa,
        ud,
        dd,
        fd,
        pd,
        hd,
        tr,
        gd,
        qa,
        md,
      ],
      i = gn(),
      s = V(i, qa);
    le(s, o, s), le(s, e.domain, s);
    const a = gn(),
      l = gn(),
      c = gn();
    le(i, e.domain, a),
      le(i, e.scheme, l),
      le(i, e.slashscheme, c),
      le(a, o, s),
      le(a, e.domain, a);
    const d = V(a, po);
    V(s, po, d), V(l, po, d), V(c, po, d);
    const f = V(s, Qn);
    le(f, o, s), le(f, e.domain, s);
    const p = gn();
    le(d, e.domain, p), le(p, e.domain, p);
    const h = V(p, Qn);
    le(h, e.domain, p);
    const m = gn(Nx);
    le(h, e.tld, m), le(h, e.utld, m), V(d, Ua, m);
    const g = V(p, er);
    le(g, e.domain, p), le(m, e.domain, p), V(m, Qn, h), V(m, er, g);
    const b = V(m, ho);
    le(b, e.numeric, Nx);
    const y = V(a, er),
      x = V(a, Qn);
    le(y, e.domain, a), le(x, o, s), le(x, e.domain, a);
    const w = gn(kd);
    le(x, e.tld, w),
      le(x, e.utld, w),
      le(w, e.domain, a),
      le(w, o, s),
      V(w, Qn, x),
      V(w, er, y),
      V(w, po, d);
    const _ = V(w, ho),
      v = gn(kd);
    le(_, e.numeric, v);
    const C = gn(kd),
      S = gn();
    le(C, n, C),
      le(C, r, S),
      le(S, n, C),
      le(S, r, S),
      V(w, tr, C),
      V(v, tr, C);
    const N = V(l, ho),
      M = V(c, ho),
      L = V(M, tr),
      $ = V(L, tr);
    le(l, e.domain, a),
      V(l, Qn, x),
      V(l, er, y),
      le(c, e.domain, a),
      V(c, Qn, x),
      V(c, er, y),
      le(N, e.domain, C),
      V(N, tr, C),
      le($, e.domain, C),
      le($, n, C),
      V($, tr, C);
    const B = [
      [ja, Wa],
      [Vu, Uu],
      [ju, Wu],
      [qu, Ku],
      [Gu, Ju],
      [Yu, Xu],
      [Zu, Qu],
      [ed, td],
    ];
    for (let H = 0; H < B.length; H++) {
      const [Q, X] = B[H],
        Y = V(C, Q);
      V(S, Q, Y), V(Y, X, C);
      const Z = gn(kd);
      le(Y, n, Z);
      const ce = gn();
      le(Y, r),
        le(Z, n, Z),
        le(Z, r, ce),
        le(ce, n, Z),
        le(ce, r, ce),
        V(Z, X, C),
        V(ce, X, C);
    }
    return V(i, Ua, w), V(i, R0, FH), { start: i, tokens: Cx };
  }
  function zH(t, e, n) {
    let r = n.length,
      o = 0,
      i = [],
      s = [];
    for (; o < r; ) {
      let a = t,
        l = null,
        c = null,
        d = 0,
        f = null,
        p = -1;
      for (; o < r && !(l = a.go(n[o].t)); ) s.push(n[o++]);
      for (; o < r && (c = l || a.go(n[o].t)); )
        (l = null),
          (a = c),
          a.accepts() ? ((p = 0), (f = a)) : p >= 0 && p++,
          o++,
          d++;
      if (p < 0) (o -= d), o < r && (s.push(n[o]), o++);
      else {
        s.length > 0 && (i.push(H0(Ox, e, s)), (s = [])), (o -= p), (d -= p);
        const h = f.t,
          m = n.slice(o - d, o);
        i.push(H0(h, e, m));
      }
    }
    return s.length > 0 && i.push(H0(Ox, e, s)), i;
  }
  function H0(t, e, n) {
    const r = n[0].s,
      o = n[n.length - 1].e,
      i = e.slice(r, o);
    return new t(i, n);
  }
  const Tt = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1,
  };
  function VH() {
    Tt.scanner = BH(Tt.customSchemes);
    for (let t = 0; t < Tt.tokenQueue.length; t++)
      Tt.tokenQueue[t][1]({ scanner: Tt.scanner });
    Tt.parser = HH(Tt.scanner.tokens);
    for (let t = 0; t < Tt.pluginQueue.length; t++)
      Tt.pluginQueue[t][1]({ scanner: Tt.scanner, parser: Tt.parser });
    Tt.initialized = !0;
  }
  function UH(t) {
    return (
      Tt.initialized || VH(), zH(Tt.parser.start, t, PH(Tt.scanner.start, t))
    );
  }
  function jH(t, e) {
    const n = UH(t);
    return n.length === 1 && n[0].isLink && n[0].t === e;
  }
  const WH = {
      class:
        "relative rounded-md bg-white overflow-hidden shadow w-96 p-1 max-h-72 overflow-y-auto",
    },
    qH = ["placeholder"],
    KH = { class: "inline-flex items-center mt-2" },
    GH = { class: "ml-2 text-sm text-gray-500" },
    JH = u.defineComponent({
      __name: "LinkBubbleButton",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get() {
              const i = e.editor.getAttributes("link");
              return i == null ? void 0 : i.href;
            },
            set(i) {
              e.editor.commands.setLink({
                href: i,
                target: r.value ? "_blank" : "_self",
              });
            },
          }),
          r = u.computed({
            get() {
              const i = e.editor.getAttributes("link");
              return (i == null ? void 0 : i.target) === "_blank";
            },
            set(i) {
              e.editor.commands.setLink({
                href: n.value,
                target: i ? "_blank" : "_self",
              });
            },
          }),
          o = () => {
            var l;
            if (e.isActive({ editor: e.editor })) return;
            const { state: i } = e.editor,
              { selection: s } = i,
              { empty: a } = s;
            if (s instanceof U) {
              if (a) return !1;
              const { content: c } = s.content();
              if (!c || c.childCount !== 1) return !1;
              const d = (l = c.firstChild) == null ? void 0 : l.textContent;
              d &&
                jH(d, "url") &&
                e.editor.commands.setLink({ href: d, target: "_self" });
            }
          };
        return (i, s) => (
          u.openBlock(),
          u.createBlock(
            u.unref(vo),
            {
              class: "inline-flex",
              triggers: ["click"],
              distance: 10,
              onClick: o,
            },
            {
              popper: u.withCtx(() => [
                u.createElementVNode("div", WH, [
                  u.withDirectives(
                    u.createElementVNode(
                      "input",
                      {
                        "onUpdate:modelValue":
                          s[0] || (s[0] = (a) => (n.value = a)),
                        placeholder: u
                          .unref(T)
                          .global.t("editor.extensions.link.placeholder"),
                        class:
                          "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
                      },
                      null,
                      8,
                      qH
                    ),
                    [[u.vModelText, n.value, void 0, { lazy: !0 }]]
                  ),
                  u.createElementVNode("label", KH, [
                    u.withDirectives(
                      u.createElementVNode(
                        "input",
                        {
                          "onUpdate:modelValue":
                            s[1] || (s[1] = (a) => (r.value = a)),
                          type: "checkbox",
                          class:
                            "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded",
                        },
                        null,
                        512
                      ),
                      [[u.vModelCheckbox, r.value]]
                    ),
                    u.createElementVNode(
                      "span",
                      GH,
                      u.toDisplayString(
                        u
                          .unref(T)
                          .global.t("editor.extensions.link.open_in_new_window")
                      ),
                      1
                    ),
                  ]),
                ]),
              ]),
              default: u.withCtx(() => [
                u.withDirectives(
                  (u.openBlock(),
                  u.createElementBlock(
                    "button",
                    {
                      class: u.normalizeClass([
                        "text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md",
                        {
                          "bg-gray-200 !text-black": i.isActive({
                            editor: i.editor,
                          }),
                        },
                      ]),
                    },
                    [u.createVNode(u.unref($a))],
                    2
                  )),
                  [
                    [
                      u.unref(us),
                      i.isActive({ editor: i.editor })
                        ? u
                            .unref(T)
                            .global.t("editor.extensions.link.edit_link")
                        : u
                            .unref(T)
                            .global.t("editor.extensions.link.add_link"),
                    ],
                  ]
                ),
              ]),
              _: 1,
            }
          )
        );
      },
    }),
    YH = Pe.create({ name: "text", group: "inline" }),
    XH = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function ZH(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        XH,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M2 5.27L3.28 4L20 20.72L18.73 22l-4.83-4.83l-2.61 2.61a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l2.62-2.6l-1.62-1.61c-.01.24-.11.49-.29.68c-.39.39-1.03.39-1.42 0A4.97 4.97 0 0 1 7.72 11zm10.71-1.05a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.33 3.33l-1.41-1.42zm.7 4.95c.39-.39 1.03-.39 1.42 0a5 5 0 0 1 1.23 5.06l-1.78-1.77c-.05-.68-.34-1.35-.87-1.87a.973.973 0 0 1 0-1.42",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const QH = u.markRaw({ name: "mdi-link-variant-off", render: ZH }),
    ez = ["audio", "video", "image", "iframe", "codeBlock"],
    Rx = YH.extend({
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getBubbleMenu() {
            return {
              pluginKey: "textBubbleMenu",
              shouldShow: ({ state: e, from: n, to: r }) => {
                const { doc: o, selection: i } = e,
                  { empty: s } = i;
                return !(
                  s ||
                  ez.some((l) => Et(e, l)) ||
                  o.textBetween(n || 0, r || 0).length === 0 ||
                  (!Si(i) && !(i instanceof St))
                );
              },
              tippyOptions: { fixed: !1 },
              defaultAnimation: !1,
              items: [
                {
                  priority: 10,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("bold"),
                    icon: u.markRaw(Gk),
                    title: T.global.t("editor.common.bold"),
                    action: ({ editor: e }) => {
                      e.chain().focus().toggleBold().run();
                    },
                  },
                },
                {
                  priority: 20,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("italic"),
                    icon: u.markRaw(N3),
                    title: T.global.t("editor.common.italic"),
                    action: ({ editor: e }) => {
                      e.chain().focus().toggleItalic().run();
                    },
                  },
                },
                {
                  priority: 30,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("underline"),
                    icon: u.markRaw(vw),
                    title: T.global.t("editor.common.underline"),
                    action: ({ editor: e }) =>
                      e.chain().focus().toggleUnderline().run(),
                  },
                },
                {
                  priority: 40,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("strike"),
                    icon: u.markRaw(rw),
                    title: T.global.t("editor.common.strike"),
                    action: ({ editor: e }) =>
                      e.chain().focus().toggleStrike().run(),
                  },
                },
                {
                  priority: 50,
                  component: u.markRaw(SH),
                  props: {
                    isActive: ({ editor: e }) => e.isActive("highlight"),
                    icon: u.markRaw(A3),
                    title: T.global.t("editor.common.highlight"),
                  },
                },
                {
                  priority: 60,
                  component: u.markRaw(wH),
                  props: {
                    isActive: ({ editor: e }) => e.isActive("color"),
                    icon: u.markRaw(r3),
                    title: T.global.t("editor.common.color"),
                  },
                },
                {
                  priority: 70,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("code"),
                    icon: u.markRaw(t3),
                    title: T.global.t("editor.common.code"),
                    action: ({ editor: e }) =>
                      e.chain().focus().toggleCode().run(),
                  },
                },
                {
                  priority: 80,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("superscript"),
                    icon: u.markRaw(aw),
                    title: T.global.t("editor.common.superscript"),
                    action: ({ editor: e }) =>
                      e.chain().focus().toggleSuperscript().run(),
                  },
                },
                {
                  priority: 90,
                  props: {
                    isActive: ({ editor: e }) => e.isActive("subscript"),
                    icon: u.markRaw(iw),
                    title: T.global.t("editor.common.subscript"),
                    action: ({ editor: e }) =>
                      e.chain().focus().toggleSubscript().run(),
                  },
                },
                {
                  priority: 100,
                  component: u.markRaw(JH),
                  props: { isActive: ({ editor: e }) => e.isActive("link") },
                },
                {
                  priority: 110,
                  props: {
                    isActive: () => !1,
                    visible: ({ editor: e }) => e.isActive("link"),
                    icon: u.markRaw(QH),
                    title: T.global.t("editor.extensions.link.cancel_link"),
                    action: ({ editor: e }) => e.commands.unsetLink(),
                  },
                },
                {
                  priority: 120,
                  props: {
                    isActive: () => !1,
                    visible: ({ editor: e }) => e.isActive("link"),
                    icon: u.markRaw(Fa),
                    title: T.global.t("editor.common.tooltip.open_link"),
                    action: ({ editor: e }) => {
                      const n = e.getAttributes("link");
                      n != null && n.href && window.open(n.href, "_blank");
                    },
                  },
                },
              ],
            };
          },
        };
      },
    });
  function Dx({ types: t, node: e }) {
    return (Array.isArray(t) && t.includes(e.type)) || e.type === t;
  }
  const Lx = we.create({
      name: "trailingNode",
      addOptions() {
        return { node: "paragraph", notAfter: ["paragraph"] };
      },
      addProseMirrorPlugins() {
        const t = new de(this.name),
          e = Object.entries(this.editor.schema.nodes)
            .map(([, r]) => r)
            .filter((r) => this.options.notAfter.includes(r.name)),
          n = this.editor.isEditable;
        return [
          new ie({
            key: t,
            appendTransaction: (r, o, i) => {
              if (!n) return;
              const { doc: s, tr: a, schema: l } = i,
                c = t.getState(i),
                d = s.content.size,
                f = l.nodes[this.options.node];
              if (c) return a.insert(d, f.create());
            },
            state: {
              init: (r, o) => {
                if (!n) return !1;
                const i = o.tr.doc.lastChild;
                return !Dx({ node: i, types: e });
              },
              apply: (r, o) => {
                if (!n || !r.docChanged) return o;
                const i = r.doc.lastChild;
                return !Dx({ node: i, types: e });
              },
            },
          }),
        ];
      },
    }),
    tz = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function nz(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        tz,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13.53 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66c-.04-.32-.07-.64-.07-.97s.03-.66.07-1L2.46 9.37a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.12.22.07.49-.12.64L19.43 11c.04.34.07.67.07 1v.19c-.5-.12-1-.19-1.5-.19c-.92 0-1.78.21-2.56.58c.03-.19.06-.38.06-.58c0-1.93-1.57-3.5-3.5-3.5S8.5 10.07 8.5 12s1.57 3.5 3.5 3.5c.2 0 .39-.03.58-.06a5.97 5.97 0 0 0 .95 6.56M16 15v6l5-3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const rz = u.markRaw({ name: "mdi-cog-play", render: nz }),
    oz = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function iz(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        oz,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M13.54 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66L4.5 12l.07-1l-2.11-1.63a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.13.22.07.49-.12.64L19.43 11l.07 1v.19c-.5-.12-1-.19-1.5-.19c-.17 0-.34 0-.5.03c0-.62-.1-1.24-.3-1.83l2.11-1.55l-.75-1.3l-2.41 1.04a5.42 5.42 0 0 0-3.03-1.77L12.75 4h-1.5l-.37 2.61c-1.2.25-2.26.89-3.03 1.78L5.44 7.35l-.75 1.3L6.8 10.2a5.55 5.55 0 0 0 0 3.6l-2.12 1.56l.75 1.3l2.43-1.04c.77.88 1.82 1.52 3.01 1.76l.37 2.62h1.11c.26.75.65 1.42 1.19 2m2.42-9.64c.04-.12.04-.24.04-.36c0-2.21-1.79-4-4-4s-4 1.79-4 4s1.79 4 4 4c.12 0 .24 0 .36-.04a6.05 6.05 0 0 1 3.6-3.6M12 14c-1.1 0-2-.89-2-2s.9-2 2-2s2 .9 2 2s-.89 2-2 2m4 1v6l5-3z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const sz = u.markRaw({ name: "mdi-cog-play-outline", render: iz }),
    az = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" };
  function lz(t, e) {
    return (
      u.openBlock(),
      u.createElementBlock(
        "svg",
        az,
        e[0] ||
          (e[0] = [
            u.createElementVNode(
              "path",
              {
                fill: "currentColor",
                d: "M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4v-11z",
              },
              null,
              -1
            ),
          ])
      )
    );
  }
  const Ix = u.markRaw({ name: "mdi-video", render: lz }),
    cz = ["placeholder"],
    uz = u.defineComponent({
      __name: "BubbleItemVideoLink",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(Ee.name).src,
            set: (r) => {
              e.editor.chain().updateAttributes(Ee.name, { src: r }).run();
            },
          });
        return (r, o) =>
          u.withDirectives(
            (u.openBlock(),
            u.createElementBlock(
              "input",
              {
                "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
                placeholder: u
                  .unref(T)
                  .global.t("editor.common.placeholder.link_input"),
                class:
                  "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
              },
              null,
              8,
              cz
            )),
            [[u.vModelText, n.value, void 0, { lazy: !0 }]]
          );
      },
    }),
    dz = u.defineComponent({
      __name: "BubbleItemVideoSize",
      props: {
        editor: {},
        isActive: { type: Function },
        visible: { type: Function },
        icon: {},
        title: {},
        action: { type: Function },
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => e.editor.getAttributes(Ee.name).width,
            set: (i) => {
              o(i, r.value);
            },
          }),
          r = u.computed({
            get: () => e.editor.getAttributes(Ee.name).height,
            set: (i) => {
              o(n.value, i);
            },
          });
        function o(i, s) {
          e.editor
            .chain()
            .updateAttributes(Ee.name, { width: i, height: s })
            .setNodeSelection(e.editor.state.selection.from)
            .focus()
            .run();
        }
        return (i, s) => (
          u.openBlock(),
          u.createElementBlock(
            u.Fragment,
            null,
            [
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: n.value,
                  "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_width_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
              u.createVNode(
                u.unref(Ao),
                {
                  modelValue: r.value,
                  "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                  modelModifiers: { lazy: !0, trim: !0 },
                  tooltip: u
                    .unref(T)
                    .global.t("editor.common.tooltip.custom_height_input"),
                },
                null,
                8,
                ["modelValue", "tooltip"]
              ),
            ],
            64
          )
        );
      },
    }),
    fz = { key: 0, class: "p-1.5" },
    pz = ["placeholder"],
    hz = ["controls", "autoplay", "loop", "src"],
    mz = u.defineComponent({
      __name: "VideoView",
      props: {
        decorations: {},
        selected: { type: Boolean },
        updateAttributes: { type: Function },
        deleteNode: { type: Function },
        node: {},
        view: {},
        getPos: { type: Function },
        innerDecorations: {},
        editor: {},
        extension: {},
        HTMLAttributes: {},
      },
      setup(t) {
        const e = t,
          n = u.computed({
            get: () => {
              var l;
              return (l = e.node) == null ? void 0 : l.attrs.src;
            },
            set: (l) => {
              e.updateAttributes({ src: l });
            },
          }),
          r = u.computed(() => e.node.attrs.controls),
          o = u.computed(() => e.node.attrs.autoplay),
          i = u.computed(() => e.node.attrs.loop);
        function s() {
          e.editor.commands.setNodeSelection(e.getPos());
        }
        const a = u.ref();
        return (
          u.onMounted(() => {
            n.value || a.value.focus();
          }),
          (l, c) => (
            u.openBlock(),
            u.createBlock(
              u.unref(Ii),
              { as: "div", class: "inline-block w-full" },
              {
                default: u.withCtx(() => [
                  u.createElementVNode(
                    "div",
                    {
                      class:
                        "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
                      style: u.normalizeStyle({ width: l.node.attrs.width }),
                    },
                    [
                      n.value
                        ? (u.openBlock(),
                          u.createElementBlock(
                            "video",
                            {
                              key: 1,
                              controls: r.value,
                              autoplay: o.value,
                              loop: i.value,
                              class: "rounded-md m-0",
                              src: l.node.attrs.src,
                              style: u.normalizeStyle({
                                width: l.node.attrs.width,
                                height: l.node.attrs.height,
                              }),
                              onMouseenter: s,
                            },
                            null,
                            44,
                            hz
                          ))
                        : (u.openBlock(),
                          u.createElementBlock("div", fz, [
                            u.withDirectives(
                              u.createElementVNode(
                                "input",
                                {
                                  ref_key: "inputRef",
                                  ref: a,
                                  "onUpdate:modelValue":
                                    c[0] || (c[0] = (d) => (n.value = d)),
                                  class:
                                    "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                                  placeholder: u
                                    .unref(T)
                                    .global.t(
                                      "editor.common.placeholder.link_input"
                                    ),
                                  tabindex: "-1",
                                  onFocus: s,
                                },
                                null,
                                40,
                                pz
                              ),
                              [[u.vModelText, n.value, void 0, { lazy: !0 }]]
                            ),
                          ])),
                    ],
                    4
                  ),
                ]),
                _: 1,
              }
            )
          )
        );
      },
    }),
    Ee = Pe.create({
      name: "video",
      fakeSelection: !0,
      inline() {
        return !0;
      },
      group() {
        return "inline";
      },
      addAttributes() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          src: { default: null, parseHTML: (e) => e.getAttribute("src") },
          width: {
            default: "100%",
            parseHTML: (e) => e.getAttribute("width"),
            renderHTML(e) {
              return { width: e.width };
            },
          },
          height: {
            default: "auto",
            parseHTML: (e) => e.getAttribute("height"),
            renderHTML: (e) => ({ height: e.height }),
          },
          autoplay: {
            default: null,
            parseHTML: (e) => e.getAttribute("autoplay"),
            renderHTML: (e) => ({ autoplay: e.autoplay }),
          },
          controls: {
            default: !0,
            parseHTML: (e) => e.getAttribute("controls"),
            renderHTML: (e) => ({ controls: e.controls }),
          },
          loop: {
            default: null,
            parseHTML: (e) => e.getAttribute("loop"),
            renderHTML: (e) => ({ loop: e.loop }),
          },
          textAlign: {
            default: null,
            parseHTML: (e) => e.getAttribute("text-align"),
            renderHTML: (e) => ({ "text-align": e.textAlign }),
          },
        };
      },
      parseHTML() {
        return [{ tag: "video" }];
      },
      renderHTML({ HTMLAttributes: t }) {
        return ["video", se(t)];
      },
      addCommands() {
        return {
          setVideo:
            (t) =>
            ({ commands: e }) =>
              e.insertContent({ type: this.name, attrs: t }),
        };
      },
      addInputRules() {
        return [
          Ti({
            find: /^\$video\$$/,
            type: this.type,
            getAttributes: () => ({ width: "100%" }),
          }),
        ];
      },
      addNodeView() {
        return Bi(mz);
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          getCommandMenuItems() {
            return {
              priority: 100,
              icon: u.markRaw(Ix),
              title: "editor.extensions.commands_menu.video",
              keywords: ["video", "shipin"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .insertContent([
                    { type: "video", attrs: { src: "" } },
                    { type: "paragraph", content: "" },
                  ])
                  .run();
              },
            };
          },
          getToolboxItems({ editor: e }) {
            return [
              {
                priority: 20,
                component: u.markRaw(io),
                props: {
                  editor: e,
                  icon: u.markRaw(Ix),
                  title: T.global.t("editor.extensions.commands_menu.video"),
                  action: () => {
                    e.chain()
                      .focus()
                      .insertContent([{ type: "video", attrs: { src: "" } }])
                      .run();
                  },
                },
              },
            ];
          },
          getBubbleMenu({ editor: e }) {
            return {
              pluginKey: "videoBubbleMenu",
              shouldShow: ({ state: n }) => Et(n, Ee.name),
              items: [
                {
                  priority: 10,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).controls,
                    icon: u.markRaw(
                      e.getAttributes(Ee.name).controls ? rz : sz
                    ),
                    action: () =>
                      e
                        .chain()
                        .updateAttributes(Ee.name, {
                          controls: e.getAttributes(Ee.name).controls
                            ? null
                            : !0,
                        })
                        .setNodeSelection(e.state.selection.from)
                        .focus()
                        .run(),
                    title: e.getAttributes(Ee.name).controls
                      ? T.global.t("editor.extensions.video.disable_controls")
                      : T.global.t("editor.extensions.video.enable_controls"),
                  },
                },
                {
                  priority: 20,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).autoplay,
                    icon: u.markRaw(
                      e.getAttributes(Ee.name).autoplay ? $w : Fw
                    ),
                    action: () =>
                      e
                        .chain()
                        .updateAttributes(Ee.name, {
                          autoplay: e.getAttributes(Ee.name).autoplay
                            ? null
                            : !0,
                        })
                        .setNodeSelection(e.state.selection.from)
                        .focus()
                        .run(),
                    title: e.getAttributes(Ee.name).autoplay
                      ? T.global.t("editor.extensions.video.disable_autoplay")
                      : T.global.t("editor.extensions.video.enable_autoplay"),
                  },
                },
                {
                  priority: 30,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).loop,
                    icon: u.markRaw(e.getAttributes(Ee.name).loop ? Iw : Bw),
                    action: () => {
                      e.chain()
                        .updateAttributes(Ee.name, {
                          loop: e.getAttributes(Ee.name).loop ? null : !0,
                        })
                        .setNodeSelection(e.state.selection.from)
                        .focus()
                        .run();
                    },
                    title: e.getAttributes(Ee.name).loop
                      ? T.global.t("editor.extensions.video.disable_loop")
                      : T.global.t("editor.extensions.video.enable_loop"),
                  },
                },
                { priority: 40, component: u.markRaw(Ve) },
                { priority: 50, component: u.markRaw(dz) },
                { priority: 60, component: u.markRaw(Ve) },
                {
                  priority: 70,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).width === "25%",
                    icon: u.markRaw(ax),
                    action: () => z0(e, "25%", "auto"),
                    title: T.global.t("editor.extensions.video.small_size"),
                  },
                },
                {
                  priority: 80,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).width === "50%",
                    icon: u.markRaw(sx),
                    action: () => z0(e, "50%", "auto"),
                    title: T.global.t("editor.extensions.video.medium_size"),
                  },
                },
                {
                  priority: 90,
                  props: {
                    isActive: () => e.getAttributes(Ee.name).width === "100%",
                    icon: u.markRaw(ix),
                    action: () => z0(e, "100%", "auto"),
                    title: T.global.t("editor.extensions.video.large_size"),
                  },
                },
                { priority: 100, component: u.markRaw(Ve) },
                {
                  priority: 110,
                  props: {
                    isActive: () => e.isActive({ textAlign: "left" }),
                    icon: u.markRaw(Ui),
                    action: () => wd(e, "left"),
                  },
                },
                {
                  priority: 120,
                  props: {
                    isActive: () => e.isActive({ textAlign: "center" }),
                    icon: u.markRaw(Ia),
                    action: () => wd(e, "center"),
                  },
                },
                {
                  priority: 130,
                  props: {
                    isActive: () => e.isActive({ textAlign: "right" }),
                    icon: u.markRaw(Pa),
                    action: () => wd(e, "right"),
                  },
                },
                {
                  priority: 140,
                  props: {
                    isActive: () => e.isActive({ textAlign: "justify" }),
                    icon: u.markRaw(Ba),
                    action: () => wd(e, "justify"),
                  },
                },
                { priority: 150, component: u.markRaw(Ve) },
                {
                  priority: 160,
                  props: {
                    icon: u.markRaw($a),
                    title: T.global.t("editor.common.button.edit_link"),
                    action: () => u.markRaw(uz),
                  },
                },
                {
                  priority: 170,
                  props: {
                    icon: u.markRaw(Fa),
                    title: T.global.t("editor.common.tooltip.open_link"),
                    action: () => {
                      window.open(e.getAttributes(Ee.name).src, "_blank");
                    },
                  },
                },
                { priority: 180, component: u.markRaw(Ve) },
                {
                  priority: 190,
                  props: {
                    icon: u.markRaw(So),
                    title: T.global.t("editor.common.button.delete"),
                    action: ({ editor: n }) => {
                      Yo(Ee.name, n);
                    },
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e, view: n }) {
                var i;
                let r = e;
                for (; r && r.tagName !== "P"; ) r = r.parentElement;
                r &&
                  (r =
                    (i = r.firstElementChild) == null
                      ? void 0
                      : i.firstElementChild);
                let o;
                if (r.firstElementChild) {
                  const s = n.posAtDOM(r.firstElementChild, 0);
                  o = n.state.doc.resolve(s).node();
                }
                return { node: o, el: r };
              },
            };
          },
        };
      },
    }),
    z0 = (t, e, n) => {
      t.chain()
        .updateAttributes(Ee.name, { width: e, height: n })
        .setNodeSelection(t.state.selection.from)
        .focus()
        .run();
    },
    wd = (t, e) => {
      t.chain().focus().setTextAlign(e).run();
    },
    gz = [
      Kk,
      Jk,
      e3,
      n3,
      Vk,
      Uk.configure({ width: 2, class: "dropcursor", color: "skyblue" }),
      tx,
      jk,
      qc,
      T3,
      Wk,
      O3,
      nw,
      ow,
      Rx,
      ft,
      xw,
      M3,
      h3,
      m3,
      vu.configure({ autolink: !0, openOnClick: !1 }),
      Cw.configure({ types: ["heading", "paragraph"] }),
      Ew,
      fo.configure({ resizable: !0 }),
      sw,
      lw,
      qk.configure({
        placeholder: T.global.t("editor.extensions.commands_menu.placeholder"),
      }),
      Lw.configure({ suggestion: {} }),
      Tw,
      et,
      Ee,
      dt,
      lx,
      ji,
      Nu,
      px,
      Lx,
      bx,
      Hw,
      Qw,
      gx,
    ],
    bz = {
      install(t) {
        t.component("RichTextEditor", zk);
      },
    };
  return (
    (k.AddMarkStep = $n),
    (k.AddNodeMarkStep = lr),
    (k.AllSelection = mt),
    (k.AttrStep = $r),
    (k.BlockActionButton = Eo),
    (k.BlockActionInput = Ao),
    (k.BlockActionSeparator = Ve),
    (k.BlockCard = av),
    (k.BubbleItem = bl),
    (k.BubbleMenu = DR),
    (k.CellBookmark = Py),
    (k.CellSelection = ke),
    (k.Change = Zt),
    (k.ChangeSet = ui),
    (k.CommandManager = ra),
    (k.ContentMatch = Br),
    (k.CoreEditor = G_),
    (k.DOMParser = Pn),
    (k.DOMSerializer = Pr),
    (k.Decoration = Te),
    (k.DecorationSet = ue),
    (k.DocAttrStep = fi),
    (k.Dropdown = S8),
    (k.DropdownSubmenu = M8),
    (k.Editor = Mh),
    (k.EditorContent = $k),
    (k.EditorState = Io),
    (k.EditorView = ib),
    (k.Extension = we),
    (k.ExtensionAudio = dt),
    (k.ExtensionBlockquote = Kk),
    (k.ExtensionBold = Jk),
    (k.ExtensionBulletList = e3),
    (k.ExtensionClearFormat = Hw),
    (k.ExtensionCode = n3),
    (k.ExtensionCodeBlock = Tw),
    (k.ExtensionColor = h3),
    (k.ExtensionColumn = Nu),
    (k.ExtensionColumns = ji),
    (k.ExtensionCommands = Lw),
    (k.ExtensionDocument = Vk),
    (k.ExtensionDraggable = YP),
    (k.ExtensionDropcursor = Uk),
    (k.ExtensionFontSize = m3),
    (k.ExtensionFormatBrush = Qw),
    (k.ExtensionGapcursor = tx),
    (k.ExtensionHardBreak = jk),
    (k.ExtensionHeading = qc),
    (k.ExtensionHighlight = M3),
    (k.ExtensionHistory = T3),
    (k.ExtensionHorizontalRule = Wk),
    (k.ExtensionIframe = et),
    (k.ExtensionImage = ft),
    (k.ExtensionIndent = lx),
    (k.ExtensionItalic = O3),
    (k.ExtensionLink = vu),
    (k.ExtensionListKeymap = N7),
    (k.ExtensionNodeSelected = px),
    (k.ExtensionOrderedList = nw),
    (k.ExtensionParagraph = Xo),
    (k.ExtensionPlaceholder = qk),
    (k.ExtensionRangeSelection = gx),
    (k.ExtensionSearchAndReplace = bx),
    (k.ExtensionStrike = ow),
    (k.ExtensionSubscript = sw),
    (k.ExtensionSuperscript = lw),
    (k.ExtensionTable = fo),
    (k.ExtensionTaskList = xw),
    (k.ExtensionText = Rx),
    (k.ExtensionTextAlign = Cw),
    (k.ExtensionTextStyle = Nh),
    (k.ExtensionTrailingNode = Lx),
    (k.ExtensionUnderline = Ew),
    (k.ExtensionVideo = Ee),
    (k.FloatingMenu = LR),
    (k.Fragment = D),
    (k.GapCursor = Ct),
    (k.InputRule = Ai),
    (k.MapResult = Ml),
    (k.Mapping = Ro),
    (k.Mark = vt),
    (k.MarkType = ys),
    (k.MarkdownParser = fy),
    (k.MarkdownSerializer = hy),
    (k.MarkdownSerializerState = gy),
    (k.MenuItem = Qr),
    (k.Node = Pe),
    (k.NodeBubbleMenu = Hk),
    (k.NodePos = to),
    (k.NodeRange = bs),
    (k.NodeSelection = K),
    (k.NodeType = uf),
    (k.NodeView = J_),
    (k.NodeViewContent = Fk),
    (k.NodeViewWrapper = Ii),
    (k.PMInputRule = mr),
    (k.PMMark = _e),
    (k.PMNode = Qt),
    (k.PasteRule = yc),
    (k.Plugin = ie),
    (k.PluginKey = de),
    (k.RangeSelection = St),
    (k.RemoveMarkStep = en),
    (k.RemoveNodeMarkStep = Do),
    (k.ReplaceAroundStep = Qe),
    (k.ReplaceError = ms),
    (k.ReplaceStep = Ze),
    (k.ResizeState = l_),
    (k.ResolvedPos = di),
    (k.RichTextEditor = zk),
    (k.Schema = _s),
    (k.Selection = J),
    (k.SelectionRange = As),
    (k.Slice = z),
    (k.Span = Ce),
    (k.Step = it),
    (k.StepMap = Rt),
    (k.StepResult = qe),
    (k.TableMap = me),
    (k.TableView = s_),
    (k.TextSelection = U),
    (k.ToolbarItem = $e),
    (k.ToolbarSubItem = At),
    (k.ToolboxItem = io),
    (k.Tracker = eO),
    (k.Transaction = Rg),
    (k.Transform = Tl),
    (k.VueNodeViewRenderer = Bi),
    (k.VueRenderer = Th),
    (k.__clipCells = e_),
    (k.__endComposition = uA),
    (k.__insertCells = Yp),
    (k.__parseFromClipboard = cA),
    (k.__pastedCells = Qy),
    (k.__serializeForClipboard = ob),
    (k.addColSpan = Hp),
    (k.addColumn = Vp),
    (k.addColumnAfter = Up),
    (k.addColumnBefore = Hy),
    (k.addListNodes = tT),
    (k.addRow = jp),
    (k.addRowAfter = Wp),
    (k.addRowBefore = jy),
    (k.allExtensions = gz),
    (k.autoJoin = xE),
    (k.baseKeymap = CE),
    (k.blockTypeItem = B8),
    (k.bulletList = Ay),
    (k.callOrReturn = re),
    (k.canJoin = An),
    (k.canSplit = En),
    (k.cellAround = Uo),
    (k.cellNear = Ly),
    (k.chainCommands = Fl),
    (k.closeDoubleQuote = _b),
    (k.closeHistory = MA),
    (k.closeSingleQuote = wb),
    (k.colCount = pT),
    (k.collab = fE),
    (k.columnIsHeader = By),
    (k.columnResizing = a_),
    (k.columnResizingPluginKey = Bt),
    (k.combineTransactionSteps = M_),
    (k.createChainableState = na),
    (k.createDocument = xc),
    (k.createNodeFromContent = ua),
    (k.createParagraphNear = Rf),
    (k.createStyleTag = K_),
    (k.default = bz),
    (k.defaultBlockAt = T_),
    (k.defaultMarkdownParser = _8),
    (k.defaultMarkdownSerializer = w8),
    (k.deleteCellSelection = ta),
    (k.deleteColumn = Vy),
    (k.deleteNode = Yo),
    (k.deleteNodeByPos = Hi),
    (k.deleteProps = sh),
    (k.deleteRow = qy),
    (k.deleteSelection = Dl),
    (k.deleteTable = Zy),
    (k.dropCursor = Jg),
    (k.dropPoint = gf),
    (k.elementFromString = Mi),
    (k.ellipsis = $A),
    (k.emDash = PA),
    (k.escapeForRegEx = Y_),
    (k.exitCode = Of),
    (k.extensions = GN),
    (k.findCell = fT),
    (k.findChildren = RN),
    (k.findChildrenInRange = N_),
    (k.findDuplicates = x_),
    (k.findParentNode = jt),
    (k.findParentNodeClosestToPos = lh),
    (k.findWrapping = ws),
    (k.fixTables = zp),
    (k.fixTablesKey = $y),
    (k.fromString = g_),
    (k.gapCursor = gA),
    (k.generateAnchor = g3),
    (k.generateAnchorId = b3),
    (k.generateHTML = DN),
    (k.generateJSON = LN),
    (k.generateText = IN),
    (k.getAttributes = ch),
    (k.getAttributesFromExtensions = Zp),
    (k.getChangedRanges = D_),
    (k.getDebugJSON = L_),
    (k.getExtensionField = j),
    (k.getHTMLFromFragment = ia),
    (k.getMarkAttributes = ah),
    (k.getMarkRange = kc),
    (k.getMarkType = br),
    (k.getMarksBetween = Ec),
    (k.getNodeAtPosition = I_),
    (k.getNodeAttributes = O_),
    (k.getNodeType = Ke),
    (k.getRenderedAttributes = hc),
    (k.getSchema = Cc),
    (k.getSchemaByResolvedExtensions = th),
    (k.getSchemaTypeByName = mc),
    (k.getSchemaTypeNameByName = da),
    (k.getSplittedAttributes = fa),
    (k.getText = vc),
    (k.getTextBetween = rh),
    (k.getTextContentFromNodes = y_),
    (k.getTextSerializersFromSchema = la),
    (k.getVersion = mE),
    (k.goToNextCell = Gp),
    (k.handlePaste = r_),
    (k.history = gb),
    (k.icons = vi),
    (k.inSameTable = cc),
    (k.injectExtensionAttributesToParseRule = eh),
    (k.inputRules = IA),
    (k.inputRulesPlugin = __),
    (k.insertPoint = xg),
    (k.isActive = Et),
    (k.isAtEndOfNode = B_),
    (k.isAtStartOfNode = P_),
    (k.isEmptyObject = m_),
    (k.isExtensionRulesEnabled = nh),
    (k.isFunction = Qp),
    (k.isInTable = sn),
    (k.isList = Sc),
    (k.isMacOS = ih),
    (k.isMarkActive = Ac),
    (k.isNodeActive = Ut),
    (k.isNodeEmpty = pa),
    (k.isNodeSelection = ha),
    (k.isNumber = k_),
    (k.isPlainObject = sa),
    (k.isRegExp = gc),
    (k.isString = ZN),
    (k.isTextSelection = Si),
    (k.isiOS = wc),
    (k.joinBackward = Cf),
    (k.joinDown = Ug),
    (k.joinForward = Af),
    (k.joinPoint = xs),
    (k.joinTextblockBackward = Fg),
    (k.joinTextblockForward = Hg),
    (k.joinUp = Ll),
    (k.joinUpItem = N8),
    (k.keydownHandler = Ms),
    (k.keymap = Xg),
    (k.lift = Il),
    (k.liftEmptyBlock = Df),
    (k.liftItem = O8),
    (k.liftListItem = Ny),
    (k.liftTarget = Lo),
    (k.listItem = Sy),
    (k.macBaseKeymap = $f),
    (k.markDownSchema = uy),
    (k.markInputRule = no),
    (k.markPasteRule = yr),
    (k.marks = vy),
    (k.menuBar = $8),
    (k.mergeAttributes = se),
    (k.mergeCells = qp),
    (k.mergeDeep = aa),
    (k.minMax = Kn),
    (k.moveCellForward = Iy),
    (k.newlineInCode = Tf),
    (k.nextCell = Fp),
    (k.nodeInputRule = Ti),
    (k.nodePasteRule = X_),
    (k.nodeViewProps = BR),
    (k.nodes = Cy),
    (k.objectIncludes = ca),
    (k.openDoubleQuote = yb),
    (k.openSingleQuote = kb),
    (k.orderedList = Ey),
    (k.pasteRulesPlugin = w_),
    (k.pcBaseKeymap = Fn),
    (k.pmTextblockTypeInputRule = zA),
    (k.pmWrappingInputRule = HA),
    (k.pointsAtCell = lc),
    (k.posToDOMRect = Mc),
    (k.rebaseSteps = Pg),
    (k.receiveTransaction = pE),
    (k.redo = zs),
    (k.redoDepth = RA),
    (k.redoItem = L8),
    (k.redoNoScroll = NA),
    (k.removeColSpan = eo),
    (k.removeColumn = zy),
    (k.removeDuplicates = R_),
    (k.removeRow = Wy),
    (k.renderGrouped = xy),
    (k.replaceStep = Cs),
    (k.resolveFocusPosition = oh),
    (k.rewriteUnknownContent = PN),
    (k.rowIsHeader = Uy),
    (k.schema = X8),
    (k.selectAll = Wg),
    (k.selectNodeBackward = vf),
    (k.selectNodeForward = Sf),
    (k.selectParentNode = Bl),
    (k.selectParentNodeItem = R8),
    (k.selectTextblockEnd = Bf),
    (k.selectTextblockStart = If),
    (k.selectedRect = an),
    (k.selectionCell = ea),
    (k.selectionToInsertionEnd = S_),
    (k.sendableSteps = hE),
    (k.setBlockType = $l),
    (k.setCellAttr = Jy),
    (k.simplifyChanges = hv),
    (k.sinkListItem = Oy),
    (k.smartQuotes = FA),
    (k.splitBlock = Lf),
    (k.splitBlockAs = jg),
    (k.splitBlockKeepMarks = gE),
    (k.splitCell = Kp),
    (k.splitCellWithType = Gy),
    (k.splitExtensions = oa),
    (k.splitListItem = Ty),
    (k.splitListItemKeepMarks = rT),
    (k.tableEditing = p_),
    (k.tableEditingKey = gr),
    (k.tableNodeTypes = ct),
    (k.tableNodes = uT),
    (k.textInputRule = YN),
    (k.textPasteRule = QN),
    (k.textblockTypeInputRule = Tc),
    (k.toggleHeader = Ei),
    (k.toggleHeaderCell = Xy),
    (k.toggleHeaderColumn = xT),
    (k.toggleHeaderRow = wT),
    (k.toggleMark = kE),
    (k.trailingNode = PT),
    (k.undo = Hs),
    (k.undoDepth = OA),
    (k.undoInputRule = BA),
    (k.undoItem = D8),
    (k.undoNoScroll = TA),
    (k.updateColumnsOnResize = pc),
    (k.useEditor = IR),
    (k.wrapIn = Pl),
    (k.wrapInList = My),
    (k.wrapItem = I8),
    (k.wrappingInputRule = Wo),
    Object.defineProperties(k, {
      __esModule: { value: !0 },
      [Symbol.toStringTag]: { value: "Module" },
    }),
    k
  );
})({}, Vue);
