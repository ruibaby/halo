var bx = Object.defineProperty;
var yx = (t, e, n) =>
  e in t
    ? bx(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (t[e] = n);
var ue = (t, e, n) => yx(t, typeof e != "symbol" ? e + "" : e, n);
import {
  pushScopeId as vx,
  popScopeId as _x,
  defineComponent as se,
  nextTick as fh,
  openBlock as S,
  createBlock as de,
  createElementBlock as O,
  normalizeClass as $e,
  renderSlot as Kn,
  normalizeProps as ph,
  guardReactiveProps as hh,
  withScopeId as xx,
  resolveComponent as $n,
  normalizeStyle as mt,
  withKeys as Bl,
  createElementVNode as C,
  Fragment as gt,
  createCommentVNode as un,
  mergeProps as Fn,
  withCtx as me,
  createVNode as J,
  ref as Te,
  createApp as kx,
  h as Zt,
  toDisplayString as it,
  withDirectives as je,
  unref as I,
  computed as ce,
  vModelText as Ot,
  markRaw as k,
  getCurrentInstance as Lc,
  effectScope as wx,
  inject as Cx,
  onMounted as Wr,
  onUnmounted as Ax,
  watch as jt,
  isRef as Sx,
  shallowRef as gb,
  Text as Ex,
  KeepAlive as Mx,
  resolveDynamicComponent as wn,
  onBeforeUnmount as Ca,
  watchEffect as Tx,
  reactive as Ox,
  render as Ws,
  customRef as Dx,
  provide as V0,
  renderList as Fr,
  readonly as Nx,
  getCurrentScope as Lx,
  onScopeDispose as Rx,
  mergeModels as U0,
  useModel as Ix,
  vShow as mh,
  resolveDirective as Px,
  withModifiers as xs,
  vModelCheckbox as bb,
  Transition as $x,
} from "vue";
const Bx = ["top", "right", "bottom", "left"],
  j0 = ["start", "end"],
  W0 = /* @__PURE__ */ Bx.reduce(
    (t, e) => t.concat(e, e + "-" + j0[0], e + "-" + j0[1]),
    []
  ),
  qs = Math.min,
  Fo = Math.max,
  Hx = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom",
  },
  Fx = {
    start: "end",
    end: "start",
  };
function Hf(t, e, n) {
  return Fo(t, qs(e, n));
}
function fi(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function gr(t) {
  return t.split("-")[0];
}
function Wn(t) {
  return t.split("-")[1];
}
function yb(t) {
  return t === "x" ? "y" : "x";
}
function gh(t) {
  return t === "y" ? "height" : "width";
}
function Aa(t) {
  return ["top", "bottom"].includes(gr(t)) ? "y" : "x";
}
function bh(t) {
  return yb(Aa(t));
}
function vb(t, e, n) {
  n === void 0 && (n = !1);
  const r = Wn(t),
    o = bh(t),
    i = gh(o);
  let s =
    o === "x"
      ? r === (n ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
      ? "bottom"
      : "top";
  return e.reference[i] > e.floating[i] && (s = Ql(s)), [s, Ql(s)];
}
function zx(t) {
  const e = Ql(t);
  return [Zl(t), e, Zl(e)];
}
function Zl(t) {
  return t.replace(/start|end/g, (e) => Fx[e]);
}
function Vx(t, e, n) {
  const r = ["left", "right"],
    o = ["right", "left"],
    i = ["top", "bottom"],
    s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? (e ? o : r) : e ? r : o;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function Ux(t, e, n, r) {
  const o = Wn(t);
  let i = Vx(gr(t), n === "start", r);
  return (
    o && ((i = i.map((s) => s + "-" + o)), e && (i = i.concat(i.map(Zl)))), i
  );
}
function Ql(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Hx[e]);
}
function jx(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t,
  };
}
function _b(t) {
  return typeof t != "number"
    ? jx(t)
    : {
        top: t,
        right: t,
        bottom: t,
        left: t,
      };
}
function ks(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height,
  };
}
function q0(t, e, n) {
  let { reference: r, floating: o } = t;
  const i = Aa(e),
    s = bh(e),
    a = gh(s),
    l = gr(e),
    u = i === "y",
    c = r.x + r.width / 2 - o.width / 2,
    d = r.y + r.height / 2 - o.height / 2,
    f = r[a] / 2 - o[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: c,
        y: r.y - o.height,
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: r.y + r.height,
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: d,
      };
      break;
    case "left":
      p = {
        x: r.x - o.width,
        y: d,
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y,
      };
  }
  switch (Wn(e)) {
    case "start":
      p[s] -= f * (n && u ? -1 : 1);
      break;
    case "end":
      p[s] += f * (n && u ? -1 : 1);
      break;
  }
  return p;
}
const Wx = async (t, e, n) => {
  const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: i = [],
      platform: s,
    } = n,
    a = i.filter(Boolean),
    l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let u = await s.getElementRects({
      reference: t,
      floating: e,
      strategy: o,
    }),
    { x: c, y: d } = q0(u, r, l),
    f = r,
    p = {},
    h = 0;
  for (let m = 0; m < a.length; m++) {
    const { name: g, fn: b } = a[m],
      {
        x: _,
        y: v,
        data: y,
        reset: w,
      } = await b({
        x: c,
        y: d,
        initialPlacement: r,
        placement: f,
        strategy: o,
        middlewareData: p,
        rects: u,
        platform: s,
        elements: {
          reference: t,
          floating: e,
        },
      });
    if (
      ((c = _ ?? c),
      (d = v ?? d),
      (p = {
        ...p,
        [g]: {
          ...p[g],
          ...y,
        },
      }),
      w && h <= 50)
    ) {
      h++,
        typeof w == "object" &&
          (w.placement && (f = w.placement),
          w.rects &&
            (u =
              w.rects === !0
                ? await s.getElementRects({
                    reference: t,
                    floating: e,
                    strategy: o,
                  })
                : w.rects),
          ({ x: c, y: d } = q0(u, f, l))),
        (m = -1);
      continue;
    }
  }
  return {
    x: c,
    y: d,
    placement: f,
    strategy: o,
    middlewareData: p,
  };
};
async function Rc(t, e) {
  var n;
  e === void 0 && (e = {});
  const { x: r, y: o, platform: i, rects: s, elements: a, strategy: l } = t,
    {
      boundary: u = "clippingAncestors",
      rootBoundary: c = "viewport",
      elementContext: d = "floating",
      altBoundary: f = !1,
      padding: p = 0,
    } = fi(e, t),
    h = _b(p),
    g = a[f ? (d === "floating" ? "reference" : "floating") : d],
    b = ks(
      await i.getClippingRect({
        element:
          (n = await (i.isElement == null ? void 0 : i.isElement(g))) == null ||
          n
            ? g
            : g.contextElement ||
              (await (i.getDocumentElement == null
                ? void 0
                : i.getDocumentElement(a.floating))),
        boundary: u,
        rootBoundary: c,
        strategy: l,
      })
    ),
    _ =
      d === "floating"
        ? {
            ...s.floating,
            x: r,
            y: o,
          }
        : s.reference,
    v = await (i.getOffsetParent == null
      ? void 0
      : i.getOffsetParent(a.floating)),
    y = (await (i.isElement == null ? void 0 : i.isElement(v)))
      ? (await (i.getScale == null ? void 0 : i.getScale(v))) || {
          x: 1,
          y: 1,
        }
      : {
          x: 1,
          y: 1,
        },
    w = ks(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            rect: _,
            offsetParent: v,
            strategy: l,
          })
        : _
    );
  return {
    top: (b.top - w.top + h.top) / y.y,
    bottom: (w.bottom - b.bottom + h.bottom) / y.y,
    left: (b.left - w.left + h.left) / y.x,
    right: (w.right - b.right + h.right) / y.x,
  };
}
const qx = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        platform: s,
        elements: a,
        middlewareData: l,
      } = e,
      { element: u, padding: c = 0 } = fi(t, e) || {};
    if (u == null) return {};
    const d = _b(c),
      f = {
        x: n,
        y: r,
      },
      p = bh(o),
      h = gh(p),
      m = await s.getDimensions(u),
      g = p === "y",
      b = g ? "top" : "left",
      _ = g ? "bottom" : "right",
      v = g ? "clientHeight" : "clientWidth",
      y = i.reference[h] + i.reference[p] - f[p] - i.floating[h],
      w = f[p] - i.reference[p],
      x = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let M = x ? x[v] : 0;
    (!M || !(await (s.isElement == null ? void 0 : s.isElement(x)))) &&
      (M = a.floating[v] || i.floating[h]);
    const N = y / 2 - w / 2,
      T = M / 2 - m[h] / 2 - 1,
      P = qs(d[b], T),
      z = qs(d[_], T),
      H = P,
      U = M - m[h] - z,
      re = M / 2 - m[h] / 2 + N,
      te = Hf(H, re, U),
      Q =
        !l.arrow &&
        Wn(o) != null &&
        re != te &&
        i.reference[h] / 2 - (re < H ? P : z) - m[h] / 2 < 0,
      ne = Q ? (re < H ? re - H : re - U) : 0;
    return {
      [p]: f[p] + ne,
      data: {
        [p]: te,
        centerOffset: re - te - ne,
        ...(Q && {
          alignmentOffset: ne,
        }),
      },
      reset: Q,
    };
  },
});
function Kx(t, e, n) {
  return (
    t
      ? [...n.filter((o) => Wn(o) === t), ...n.filter((o) => Wn(o) !== t)]
      : n.filter((o) => gr(o) === o)
  ).filter((o) => (t ? Wn(o) === t || (e ? Zl(o) !== o : !1) : !0));
}
const Gx = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "autoPlacement",
        options: t,
        async fn(e) {
          var n, r, o;
          const {
              rects: i,
              middlewareData: s,
              placement: a,
              platform: l,
              elements: u,
            } = e,
            {
              crossAxis: c = !1,
              alignment: d,
              allowedPlacements: f = W0,
              autoAlignment: p = !0,
              ...h
            } = fi(t, e),
            m = d !== void 0 || f === W0 ? Kx(d || null, p, f) : f,
            g = await Rc(e, h),
            b = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0,
            _ = m[b];
          if (_ == null) return {};
          const v = vb(
            _,
            i,
            await (l.isRTL == null ? void 0 : l.isRTL(u.floating))
          );
          if (a !== _)
            return {
              reset: {
                placement: m[0],
              },
            };
          const y = [g[gr(_)], g[v[0]], g[v[1]]],
            w = [
              ...(((r = s.autoPlacement) == null ? void 0 : r.overflows) || []),
              {
                placement: _,
                overflows: y,
              },
            ],
            x = m[b + 1];
          if (x)
            return {
              data: {
                index: b + 1,
                overflows: w,
              },
              reset: {
                placement: x,
              },
            };
          const M = w
              .map((P) => {
                const z = Wn(P.placement);
                return [
                  P.placement,
                  z && c
                    ? // Check along the mainAxis and main crossAxis side.
                      P.overflows.slice(0, 2).reduce((H, U) => H + U, 0)
                    : // Check only the mainAxis.
                      P.overflows[0],
                  P.overflows,
                ];
              })
              .sort((P, z) => P[1] - z[1]),
            T =
              ((o = M.filter((P) =>
                P[2]
                  .slice(
                    0,
                    // Aligned placements should not check their opposite crossAxis
                    // side.
                    Wn(P[0]) ? 2 : 3
                  )
                  .every((z) => z <= 0)
              )[0]) == null
                ? void 0
                : o[0]) || M[0][0];
          return T !== a
            ? {
                data: {
                  index: b + 1,
                  overflows: w,
                },
                reset: {
                  placement: T,
                },
              }
            : {};
        },
      }
    );
  },
  Jx = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "flip",
        options: t,
        async fn(e) {
          var n, r;
          const {
              placement: o,
              middlewareData: i,
              rects: s,
              initialPlacement: a,
              platform: l,
              elements: u,
            } = e,
            {
              mainAxis: c = !0,
              crossAxis: d = !0,
              fallbackPlacements: f,
              fallbackStrategy: p = "bestFit",
              fallbackAxisSideDirection: h = "none",
              flipAlignment: m = !0,
              ...g
            } = fi(t, e);
          if ((n = i.arrow) != null && n.alignmentOffset) return {};
          const b = gr(o),
            _ = gr(a) === a,
            v = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)),
            y = f || (_ || !m ? [Ql(a)] : zx(a));
          !f && h !== "none" && y.push(...Ux(a, m, h, v));
          const w = [a, ...y],
            x = await Rc(e, g),
            M = [];
          let N = ((r = i.flip) == null ? void 0 : r.overflows) || [];
          if ((c && M.push(x[b]), d)) {
            const H = vb(o, s, v);
            M.push(x[H[0]], x[H[1]]);
          }
          if (
            ((N = [
              ...N,
              {
                placement: o,
                overflows: M,
              },
            ]),
            !M.every((H) => H <= 0))
          ) {
            var T, P;
            const H = (((T = i.flip) == null ? void 0 : T.index) || 0) + 1,
              U = w[H];
            if (U)
              return {
                data: {
                  index: H,
                  overflows: N,
                },
                reset: {
                  placement: U,
                },
              };
            let re =
              (P = N.filter((te) => te.overflows[0] <= 0).sort(
                (te, Q) => te.overflows[1] - Q.overflows[1]
              )[0]) == null
                ? void 0
                : P.placement;
            if (!re)
              switch (p) {
                case "bestFit": {
                  var z;
                  const te =
                    (z = N.map((Q) => [
                      Q.placement,
                      Q.overflows
                        .filter((ne) => ne > 0)
                        .reduce((ne, fe) => ne + fe, 0),
                    ]).sort((Q, ne) => Q[1] - ne[1])[0]) == null
                      ? void 0
                      : z[0];
                  te && (re = te);
                  break;
                }
                case "initialPlacement":
                  re = a;
                  break;
              }
            if (o !== re)
              return {
                reset: {
                  placement: re,
                },
              };
          }
          return {};
        },
      }
    );
  };
async function Yx(t, e) {
  const { placement: n, platform: r, elements: o } = t,
    i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
    s = gr(n),
    a = Wn(n),
    l = Aa(n) === "y",
    u = ["left", "top"].includes(s) ? -1 : 1,
    c = i && l ? -1 : 1,
    d = fi(e, t);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: h,
  } = typeof d == "number"
    ? {
        mainAxis: d,
        crossAxis: 0,
        alignmentAxis: null,
      }
    : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...d,
      };
  return (
    a && typeof h == "number" && (p = a === "end" ? h * -1 : h),
    l
      ? {
          x: p * c,
          y: f * u,
        }
      : {
          x: f * u,
          y: p * c,
        }
  );
}
const Xx = function (t) {
    return (
      t === void 0 && (t = 0),
      {
        name: "offset",
        options: t,
        async fn(e) {
          var n, r;
          const { x: o, y: i, placement: s, middlewareData: a } = e,
            l = await Yx(e, t);
          return s === ((n = a.offset) == null ? void 0 : n.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : {
                x: o + l.x,
                y: i + l.y,
                data: {
                  ...l,
                  placement: s,
                },
              };
        },
      }
    );
  },
  Zx = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "shift",
        options: t,
        async fn(e) {
          const { x: n, y: r, placement: o } = e,
            {
              mainAxis: i = !0,
              crossAxis: s = !1,
              limiter: a = {
                fn: (g) => {
                  let { x: b, y: _ } = g;
                  return {
                    x: b,
                    y: _,
                  };
                },
              },
              ...l
            } = fi(t, e),
            u = {
              x: n,
              y: r,
            },
            c = await Rc(e, l),
            d = Aa(gr(o)),
            f = yb(d);
          let p = u[f],
            h = u[d];
          if (i) {
            const g = f === "y" ? "top" : "left",
              b = f === "y" ? "bottom" : "right",
              _ = p + c[g],
              v = p - c[b];
            p = Hf(_, p, v);
          }
          if (s) {
            const g = d === "y" ? "top" : "left",
              b = d === "y" ? "bottom" : "right",
              _ = h + c[g],
              v = h - c[b];
            h = Hf(_, h, v);
          }
          const m = a.fn({
            ...e,
            [f]: p,
            [d]: h,
          });
          return {
            ...m,
            data: {
              x: m.x - n,
              y: m.y - r,
            },
          };
        },
      }
    );
  },
  Qx = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "size",
        options: t,
        async fn(e) {
          const { placement: n, rects: r, platform: o, elements: i } = e,
            { apply: s = () => {}, ...a } = fi(t, e),
            l = await Rc(e, a),
            u = gr(n),
            c = Wn(n),
            d = Aa(n) === "y",
            { width: f, height: p } = r.floating;
          let h, m;
          u === "top" || u === "bottom"
            ? ((h = u),
              (m =
                c ===
                ((await (o.isRTL == null ? void 0 : o.isRTL(i.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((m = u), (h = c === "end" ? "top" : "bottom"));
          const g = p - l[h],
            b = f - l[m],
            _ = !e.middlewareData.shift;
          let v = g,
            y = b;
          if (d) {
            const x = f - l.left - l.right;
            y = c || _ ? qs(b, x) : x;
          } else {
            const x = p - l.top - l.bottom;
            v = c || _ ? qs(g, x) : x;
          }
          if (_ && !c) {
            const x = Fo(l.left, 0),
              M = Fo(l.right, 0),
              N = Fo(l.top, 0),
              T = Fo(l.bottom, 0);
            d
              ? (y = f - 2 * (x !== 0 || M !== 0 ? x + M : Fo(l.left, l.right)))
              : (v =
                  p - 2 * (N !== 0 || T !== 0 ? N + T : Fo(l.top, l.bottom)));
          }
          await s({
            ...e,
            availableWidth: y,
            availableHeight: v,
          });
          const w = await o.getDimensions(i.floating);
          return f !== w.width || p !== w.height
            ? {
                reset: {
                  rects: !0,
                },
              }
            : {};
        },
      }
    );
  };
function Cn(t) {
  var e;
  return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function fr(t) {
  return Cn(t).getComputedStyle(t);
}
const K0 = Math.min,
  ws = Math.max,
  eu = Math.round;
function xb(t) {
  const e = fr(t);
  let n = parseFloat(e.width),
    r = parseFloat(e.height);
  const o = t.offsetWidth,
    i = t.offsetHeight,
    s = eu(n) !== o || eu(r) !== i;
  return s && ((n = o), (r = i)), { width: n, height: r, fallback: s };
}
function wo(t) {
  return wb(t) ? (t.nodeName || "").toLowerCase() : "";
}
let Xa;
function kb() {
  if (Xa) return Xa;
  const t = navigator.userAgentData;
  return t && Array.isArray(t.brands)
    ? ((Xa = t.brands.map((e) => e.brand + "/" + e.version).join(" ")), Xa)
    : navigator.userAgent;
}
function pr(t) {
  return t instanceof Cn(t).HTMLElement;
}
function yo(t) {
  return t instanceof Cn(t).Element;
}
function wb(t) {
  return t instanceof Cn(t).Node;
}
function G0(t) {
  return typeof ShadowRoot > "u"
    ? !1
    : t instanceof Cn(t).ShadowRoot || t instanceof ShadowRoot;
}
function Ic(t) {
  const { overflow: e, overflowX: n, overflowY: r, display: o } = fr(t);
  return (
    /auto|scroll|overlay|hidden|clip/.test(e + r + n) &&
    !["inline", "contents"].includes(o)
  );
}
function ek(t) {
  return ["table", "td", "th"].includes(wo(t));
}
function Ff(t) {
  const e = /firefox/i.test(kb()),
    n = fr(t),
    r = n.backdropFilter || n.WebkitBackdropFilter;
  return (
    n.transform !== "none" ||
    n.perspective !== "none" ||
    (!!r && r !== "none") ||
    (e && n.willChange === "filter") ||
    (e && !!n.filter && n.filter !== "none") ||
    ["transform", "perspective"].some((o) => n.willChange.includes(o)) ||
    ["paint", "layout", "strict", "content"].some((o) => {
      const i = n.contain;
      return i != null && i.includes(o);
    })
  );
}
function Cb() {
  return !/^((?!chrome|android).)*safari/i.test(kb());
}
function yh(t) {
  return ["html", "body", "#document"].includes(wo(t));
}
function Ab(t) {
  return yo(t) ? t : t.contextElement;
}
const Sb = { x: 1, y: 1 };
function Pi(t) {
  const e = Ab(t);
  if (!pr(e)) return Sb;
  const n = e.getBoundingClientRect(),
    { width: r, height: o, fallback: i } = xb(e);
  let s = (i ? eu(n.width) : n.width) / r,
    a = (i ? eu(n.height) : n.height) / o;
  return (
    (s && Number.isFinite(s)) || (s = 1),
    (a && Number.isFinite(a)) || (a = 1),
    { x: s, y: a }
  );
}
function Ks(t, e, n, r) {
  var o, i;
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const s = t.getBoundingClientRect(),
    a = Ab(t);
  let l = Sb;
  e && (r ? yo(r) && (l = Pi(r)) : (l = Pi(t)));
  const u = a ? Cn(a) : window,
    c = !Cb() && n;
  let d =
      (s.left +
        ((c && ((o = u.visualViewport) == null ? void 0 : o.offsetLeft)) ||
          0)) /
      l.x,
    f =
      (s.top +
        ((c && ((i = u.visualViewport) == null ? void 0 : i.offsetTop)) || 0)) /
      l.y,
    p = s.width / l.x,
    h = s.height / l.y;
  if (a) {
    const m = Cn(a),
      g = r && yo(r) ? Cn(r) : r;
    let b = m.frameElement;
    for (; b && r && g !== m; ) {
      const _ = Pi(b),
        v = b.getBoundingClientRect(),
        y = getComputedStyle(b);
      (v.x += (b.clientLeft + parseFloat(y.paddingLeft)) * _.x),
        (v.y += (b.clientTop + parseFloat(y.paddingTop)) * _.y),
        (d *= _.x),
        (f *= _.y),
        (p *= _.x),
        (h *= _.y),
        (d += v.x),
        (f += v.y),
        (b = Cn(b).frameElement);
    }
  }
  return {
    width: p,
    height: h,
    top: f,
    right: d + p,
    bottom: f + h,
    left: d,
    x: d,
    y: f,
  };
}
function vo(t) {
  return ((wb(t) ? t.ownerDocument : t.document) || window.document)
    .documentElement;
}
function Pc(t) {
  return yo(t)
    ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
    : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function Eb(t) {
  return Ks(vo(t)).left + Pc(t).scrollLeft;
}
function Gs(t) {
  if (wo(t) === "html") return t;
  const e = t.assignedSlot || t.parentNode || (G0(t) && t.host) || vo(t);
  return G0(e) ? e.host : e;
}
function Mb(t) {
  const e = Gs(t);
  return yh(e) ? e.ownerDocument.body : pr(e) && Ic(e) ? e : Mb(e);
}
function tu(t, e) {
  var n;
  e === void 0 && (e = []);
  const r = Mb(t),
    o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
    i = Cn(r);
  return o
    ? e.concat(i, i.visualViewport || [], Ic(r) ? r : [])
    : e.concat(r, tu(r));
}
function J0(t, e, n) {
  return e === "viewport"
    ? ks(
        (function (r, o) {
          const i = Cn(r),
            s = vo(r),
            a = i.visualViewport;
          let l = s.clientWidth,
            u = s.clientHeight,
            c = 0,
            d = 0;
          if (a) {
            (l = a.width), (u = a.height);
            const f = Cb();
            (f || (!f && o === "fixed")) &&
              ((c = a.offsetLeft), (d = a.offsetTop));
          }
          return { width: l, height: u, x: c, y: d };
        })(t, n)
      )
    : yo(e)
    ? ks(
        (function (r, o) {
          const i = Ks(r, !0, o === "fixed"),
            s = i.top + r.clientTop,
            a = i.left + r.clientLeft,
            l = pr(r) ? Pi(r) : { x: 1, y: 1 };
          return {
            width: r.clientWidth * l.x,
            height: r.clientHeight * l.y,
            x: a * l.x,
            y: s * l.y,
          };
        })(e, n)
      )
    : ks(
        (function (r) {
          const o = vo(r),
            i = Pc(r),
            s = r.ownerDocument.body,
            a = ws(o.scrollWidth, o.clientWidth, s.scrollWidth, s.clientWidth),
            l = ws(
              o.scrollHeight,
              o.clientHeight,
              s.scrollHeight,
              s.clientHeight
            );
          let u = -i.scrollLeft + Eb(r);
          const c = -i.scrollTop;
          return (
            fr(s).direction === "rtl" &&
              (u += ws(o.clientWidth, s.clientWidth) - a),
            { width: a, height: l, x: u, y: c }
          );
        })(vo(t))
      );
}
function Y0(t) {
  return pr(t) && fr(t).position !== "fixed" ? t.offsetParent : null;
}
function X0(t) {
  const e = Cn(t);
  let n = Y0(t);
  for (; n && ek(n) && fr(n).position === "static"; ) n = Y0(n);
  return n &&
    (wo(n) === "html" ||
      (wo(n) === "body" && fr(n).position === "static" && !Ff(n)))
    ? e
    : n ||
        (function (r) {
          let o = Gs(r);
          for (; pr(o) && !yh(o); ) {
            if (Ff(o)) return o;
            o = Gs(o);
          }
          return null;
        })(t) ||
        e;
}
function tk(t, e, n) {
  const r = pr(e),
    o = vo(e),
    i = Ks(t, !0, n === "fixed", e);
  let s = { scrollLeft: 0, scrollTop: 0 };
  const a = { x: 0, y: 0 };
  if (r || (!r && n !== "fixed"))
    if (((wo(e) !== "body" || Ic(o)) && (s = Pc(e)), pr(e))) {
      const l = Ks(e, !0);
      (a.x = l.x + e.clientLeft), (a.y = l.y + e.clientTop);
    } else o && (a.x = Eb(o));
  return {
    x: i.left + s.scrollLeft - a.x,
    y: i.top + s.scrollTop - a.y,
    width: i.width,
    height: i.height,
  };
}
const nk = {
    getClippingRect: function (t) {
      let { element: e, boundary: n, rootBoundary: r, strategy: o } = t;
      const i =
          n === "clippingAncestors"
            ? (function (u, c) {
                const d = c.get(u);
                if (d) return d;
                let f = tu(u).filter((g) => yo(g) && wo(g) !== "body"),
                  p = null;
                const h = fr(u).position === "fixed";
                let m = h ? Gs(u) : u;
                for (; yo(m) && !yh(m); ) {
                  const g = fr(m),
                    b = Ff(m);
                  (
                    h
                      ? b || p
                      : b ||
                        g.position !== "static" ||
                        !p ||
                        !["absolute", "fixed"].includes(p.position)
                  )
                    ? (p = g)
                    : (f = f.filter((_) => _ !== m)),
                    (m = Gs(m));
                }
                return c.set(u, f), f;
              })(e, this._c)
            : [].concat(n),
        s = [...i, r],
        a = s[0],
        l = s.reduce((u, c) => {
          const d = J0(e, c, o);
          return (
            (u.top = ws(d.top, u.top)),
            (u.right = K0(d.right, u.right)),
            (u.bottom = K0(d.bottom, u.bottom)),
            (u.left = ws(d.left, u.left)),
            u
          );
        }, J0(e, a, o));
      return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top,
      };
    },
    convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {
      let { rect: e, offsetParent: n, strategy: r } = t;
      const o = pr(n),
        i = vo(n);
      if (n === i) return e;
      let s = { scrollLeft: 0, scrollTop: 0 },
        a = { x: 1, y: 1 };
      const l = { x: 0, y: 0 };
      if (
        (o || (!o && r !== "fixed")) &&
        ((wo(n) !== "body" || Ic(i)) && (s = Pc(n)), pr(n))
      ) {
        const u = Ks(n);
        (a = Pi(n)), (l.x = u.x + n.clientLeft), (l.y = u.y + n.clientTop);
      }
      return {
        width: e.width * a.x,
        height: e.height * a.y,
        x: e.x * a.x - s.scrollLeft * a.x + l.x,
        y: e.y * a.y - s.scrollTop * a.y + l.y,
      };
    },
    isElement: yo,
    getDimensions: function (t) {
      return pr(t) ? xb(t) : t.getBoundingClientRect();
    },
    getOffsetParent: X0,
    getDocumentElement: vo,
    getScale: Pi,
    async getElementRects(t) {
      let { reference: e, floating: n, strategy: r } = t;
      const o = this.getOffsetParent || X0,
        i = this.getDimensions;
      return {
        reference: tk(e, await o(n), r),
        floating: { x: 0, y: 0, ...(await i(n)) },
      };
    },
    getClientRects: (t) => Array.from(t.getClientRects()),
    isRTL: (t) => fr(t).direction === "rtl",
  },
  rk = (t, e, n) => {
    const r = /* @__PURE__ */ new Map(),
      o = { platform: nk, ...n },
      i = { ...o.platform, _c: r };
    return Wx(t, e, { ...o, platform: i });
  },
  Xo = {
    // Disable popper components
    disabled: !1,
    // Default position offset along main axis (px)
    distance: 5,
    // Default position offset along cross axis (px)
    skidding: 0,
    // Default container where the tooltip will be appended
    container: "body",
    // Element used to compute position and size boundaries
    boundary: void 0,
    // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
    instantMove: !1,
    // Auto destroy tooltip DOM nodes (ms)
    disposeTimeout: 150,
    // Triggers on the popper itself
    popperTriggers: [],
    // Positioning strategy
    strategy: "absolute",
    // Prevent overflow
    preventOverflow: !0,
    // Flip to the opposite placement if needed
    flip: !0,
    // Shift on the cross axis to prevent the popper from overflowing
    shift: !0,
    // Overflow padding (px)
    overflowPadding: 0,
    // Arrow padding (px)
    arrowPadding: 0,
    // Compute arrow overflow (useful to hide it)
    arrowOverflow: !0,
    /**
     * By default, compute autohide on 'click'.
     */
    autoHideOnMousedown: !1,
    // Themes
    themes: {
      tooltip: {
        // Default tooltip placement relative to target element
        placement: "top",
        // Default events that trigger the tooltip
        triggers: ["hover", "focus", "touch"],
        // Close tooltip on click on tooltip target
        hideTriggers: (t) => [...t, "click"],
        // Delay (ms)
        delay: {
          show: 200,
          hide: 0,
        },
        // Update popper on content resize
        handleResize: !1,
        // Enable HTML content in directive
        html: !1,
        // Displayed when tooltip content is loading
        loadingContent: "...",
      },
      dropdown: {
        // Default dropdown placement relative to target element
        placement: "bottom",
        // Default events that trigger the dropdown
        triggers: ["click"],
        // Delay (ms)
        delay: 0,
        // Update popper on content resize
        handleResize: !0,
        // Hide on clock outside
        autoHide: !0,
      },
      menu: {
        $extend: "dropdown",
        triggers: ["hover", "focus"],
        popperTriggers: ["hover"],
        delay: {
          show: 0,
          hide: 400,
        },
      },
    },
  };
function Js(t, e) {
  let n = Xo.themes[t] || {},
    r;
  do
    (r = n[e]),
      typeof r > "u"
        ? n.$extend
          ? (n = Xo.themes[n.$extend] || {})
          : ((n = null), (r = Xo[e]))
        : (n = null);
  while (n);
  return r;
}
function ok(t) {
  const e = [t];
  let n = Xo.themes[t] || {};
  do
    n.$extend && !n.$resetCss
      ? (e.push(n.$extend), (n = Xo.themes[n.$extend] || {}))
      : (n = null);
  while (n);
  return e.map((r) => `v-popper--theme-${r}`);
}
function Z0(t) {
  const e = [t];
  let n = Xo.themes[t] || {};
  do
    n.$extend
      ? (e.push(n.$extend), (n = Xo.themes[n.$extend] || {}))
      : (n = null);
  while (n);
  return e;
}
let Ys = !1;
if (typeof window < "u") {
  Ys = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get() {
        Ys = !0;
      },
    });
    window.addEventListener("test", null, t);
  } catch {}
}
let Tb = !1;
typeof window < "u" &&
  typeof navigator < "u" &&
  (Tb = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const Ob = ["auto", "top", "bottom", "left", "right"].reduce(
    (t, e) => t.concat([e, `${e}-start`, `${e}-end`]),
    []
  ),
  Q0 = {
    hover: "mouseenter",
    focus: "focus",
    click: "click",
    touch: "touchstart",
    pointer: "pointerdown",
  },
  em = {
    hover: "mouseleave",
    focus: "blur",
    click: "click",
    touch: "touchend",
    pointer: "pointerup",
  };
function tm(t, e) {
  const n = t.indexOf(e);
  n !== -1 && t.splice(n, 1);
}
function Ed() {
  return new Promise((t) =>
    requestAnimationFrame(() => {
      requestAnimationFrame(t);
    })
  );
}
const Bn = [];
let Po = null;
const nm = {};
function rm(t) {
  let e = nm[t];
  return e || (e = nm[t] = []), e;
}
let zf = function () {};
typeof window < "u" && (zf = window.Element);
function _e(t) {
  return function (e) {
    return Js(e.theme, t);
  };
}
const Md = "__floating-vue__popper",
  Db = () =>
    se({
      name: "VPopper",
      provide() {
        return {
          [Md]: {
            parentPopper: this,
          },
        };
      },
      inject: {
        [Md]: { default: null },
      },
      props: {
        theme: {
          type: String,
          required: !0,
        },
        targetNodes: {
          type: Function,
          required: !0,
        },
        referenceNode: {
          type: Function,
          default: null,
        },
        popperNode: {
          type: Function,
          required: !0,
        },
        shown: {
          type: Boolean,
          default: !1,
        },
        showGroup: {
          type: String,
          default: null,
        },
        // eslint-disable-next-line vue/require-prop-types
        ariaId: {
          default: null,
        },
        disabled: {
          type: Boolean,
          default: _e("disabled"),
        },
        positioningDisabled: {
          type: Boolean,
          default: _e("positioningDisabled"),
        },
        placement: {
          type: String,
          default: _e("placement"),
          validator: (t) => Ob.includes(t),
        },
        delay: {
          type: [String, Number, Object],
          default: _e("delay"),
        },
        distance: {
          type: [Number, String],
          default: _e("distance"),
        },
        skidding: {
          type: [Number, String],
          default: _e("skidding"),
        },
        triggers: {
          type: Array,
          default: _e("triggers"),
        },
        showTriggers: {
          type: [Array, Function],
          default: _e("showTriggers"),
        },
        hideTriggers: {
          type: [Array, Function],
          default: _e("hideTriggers"),
        },
        popperTriggers: {
          type: Array,
          default: _e("popperTriggers"),
        },
        popperShowTriggers: {
          type: [Array, Function],
          default: _e("popperShowTriggers"),
        },
        popperHideTriggers: {
          type: [Array, Function],
          default: _e("popperHideTriggers"),
        },
        container: {
          type: [String, Object, zf, Boolean],
          default: _e("container"),
        },
        boundary: {
          type: [String, zf],
          default: _e("boundary"),
        },
        strategy: {
          type: String,
          validator: (t) => ["absolute", "fixed"].includes(t),
          default: _e("strategy"),
        },
        autoHide: {
          type: [Boolean, Function],
          default: _e("autoHide"),
        },
        handleResize: {
          type: Boolean,
          default: _e("handleResize"),
        },
        instantMove: {
          type: Boolean,
          default: _e("instantMove"),
        },
        eagerMount: {
          type: Boolean,
          default: _e("eagerMount"),
        },
        popperClass: {
          type: [String, Array, Object],
          default: _e("popperClass"),
        },
        computeTransformOrigin: {
          type: Boolean,
          default: _e("computeTransformOrigin"),
        },
        /**
         * @deprecated
         */
        autoMinSize: {
          type: Boolean,
          default: _e("autoMinSize"),
        },
        autoSize: {
          type: [Boolean, String],
          default: _e("autoSize"),
        },
        /**
         * @deprecated
         */
        autoMaxSize: {
          type: Boolean,
          default: _e("autoMaxSize"),
        },
        autoBoundaryMaxSize: {
          type: Boolean,
          default: _e("autoBoundaryMaxSize"),
        },
        preventOverflow: {
          type: Boolean,
          default: _e("preventOverflow"),
        },
        overflowPadding: {
          type: [Number, String],
          default: _e("overflowPadding"),
        },
        arrowPadding: {
          type: [Number, String],
          default: _e("arrowPadding"),
        },
        arrowOverflow: {
          type: Boolean,
          default: _e("arrowOverflow"),
        },
        flip: {
          type: Boolean,
          default: _e("flip"),
        },
        shift: {
          type: Boolean,
          default: _e("shift"),
        },
        shiftCrossAxis: {
          type: Boolean,
          default: _e("shiftCrossAxis"),
        },
        noAutoFocus: {
          type: Boolean,
          default: _e("noAutoFocus"),
        },
        disposeTimeout: {
          type: Number,
          default: _e("disposeTimeout"),
        },
      },
      emits: {
        show: () => !0,
        hide: () => !0,
        "update:shown": (t) => !0,
        "apply-show": () => !0,
        "apply-hide": () => !0,
        "close-group": () => !0,
        "close-directive": () => !0,
        "auto-hide": () => !0,
        resize: () => !0,
      },
      data() {
        return {
          isShown: !1,
          isMounted: !1,
          skipTransition: !1,
          classes: {
            showFrom: !1,
            showTo: !1,
            hideFrom: !1,
            hideTo: !0,
          },
          result: {
            x: 0,
            y: 0,
            placement: "",
            strategy: this.strategy,
            arrow: {
              x: 0,
              y: 0,
              centerOffset: 0,
            },
            transformOrigin: null,
          },
          randomId: `popper_${[Math.random(), Date.now()]
            .map((t) => t.toString(36).substring(2, 10))
            .join("_")}`,
          shownChildren: /* @__PURE__ */ new Set(),
          lastAutoHide: !0,
          pendingHide: !1,
          containsGlobalTarget: !1,
          isDisposed: !0,
          mouseDownContains: !1,
        };
      },
      computed: {
        popperId() {
          return this.ariaId != null ? this.ariaId : this.randomId;
        },
        shouldMountContent() {
          return this.eagerMount || this.isMounted;
        },
        slotData() {
          return {
            popperId: this.popperId,
            isShown: this.isShown,
            shouldMountContent: this.shouldMountContent,
            skipTransition: this.skipTransition,
            autoHide:
              typeof this.autoHide == "function"
                ? this.lastAutoHide
                : this.autoHide,
            show: this.show,
            hide: this.hide,
            handleResize: this.handleResize,
            onResize: this.onResize,
            classes: {
              ...this.classes,
              popperClass: this.popperClass,
            },
            result: this.positioningDisabled ? null : this.result,
            attrs: this.$attrs,
          };
        },
        parentPopper() {
          var t;
          return (t = this[Md]) == null ? void 0 : t.parentPopper;
        },
        hasPopperShowTriggerHover() {
          var t, e;
          return (
            ((t = this.popperTriggers) == null
              ? void 0
              : t.includes("hover")) ||
            ((e = this.popperShowTriggers) == null
              ? void 0
              : e.includes("hover"))
          );
        },
      },
      watch: {
        shown: "$_autoShowHide",
        disabled(t) {
          t ? this.dispose() : this.init();
        },
        async container() {
          this.isShown &&
            (this.$_ensureTeleport(), await this.$_computePosition());
        },
        triggers: {
          handler: "$_refreshListeners",
          deep: !0,
        },
        positioningDisabled: "$_refreshListeners",
        ...[
          "placement",
          "distance",
          "skidding",
          "boundary",
          "strategy",
          "overflowPadding",
          "arrowPadding",
          "preventOverflow",
          "shift",
          "shiftCrossAxis",
          "flip",
        ].reduce((t, e) => ((t[e] = "$_computePosition"), t), {}),
      },
      created() {
        this.autoMinSize &&
          console.warn(
            '[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'
          ),
          this.autoMaxSize &&
            console.warn(
              "[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead."
            );
      },
      mounted() {
        this.init(), this.$_detachPopperNode();
      },
      activated() {
        this.$_autoShowHide();
      },
      deactivated() {
        this.hide();
      },
      beforeUnmount() {
        this.dispose();
      },
      methods: {
        show({ event: t = null, skipDelay: e = !1, force: n = !1 } = {}) {
          var r, o;
          ((r = this.parentPopper) != null &&
            r.lockedChild &&
            this.parentPopper.lockedChild !== this) ||
            ((this.pendingHide = !1),
            (n || !this.disabled) &&
              (((o = this.parentPopper) == null ? void 0 : o.lockedChild) ===
                this && (this.parentPopper.lockedChild = null),
              this.$_scheduleShow(t, e),
              this.$emit("show"),
              (this.$_showFrameLocked = !0),
              requestAnimationFrame(() => {
                this.$_showFrameLocked = !1;
              })),
            this.$emit("update:shown", !0));
        },
        hide({ event: t = null, skipDelay: e = !1 } = {}) {
          var n;
          if (!this.$_hideInProgress) {
            if (this.shownChildren.size > 0) {
              this.pendingHide = !0;
              return;
            }
            if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
              this.parentPopper &&
                ((this.parentPopper.lockedChild = this),
                clearTimeout(this.parentPopper.lockedChildTimer),
                (this.parentPopper.lockedChildTimer = setTimeout(() => {
                  this.parentPopper.lockedChild === this &&
                    (this.parentPopper.lockedChild.hide({ skipDelay: e }),
                    (this.parentPopper.lockedChild = null));
                }, 1e3)));
              return;
            }
            ((n = this.parentPopper) == null ? void 0 : n.lockedChild) ===
              this && (this.parentPopper.lockedChild = null),
              (this.pendingHide = !1),
              this.$_scheduleHide(t, e),
              this.$emit("hide"),
              this.$emit("update:shown", !1);
          }
        },
        init() {
          var t;
          this.isDisposed &&
            ((this.isDisposed = !1),
            (this.isMounted = !1),
            (this.$_events = []),
            (this.$_preventShow = !1),
            (this.$_referenceNode =
              ((t = this.referenceNode) == null ? void 0 : t.call(this)) ??
              this.$el),
            (this.$_targetNodes = this.targetNodes().filter(
              (e) => e.nodeType === e.ELEMENT_NODE
            )),
            (this.$_popperNode = this.popperNode()),
            (this.$_innerNode =
              this.$_popperNode.querySelector(".v-popper__inner")),
            (this.$_arrowNode = this.$_popperNode.querySelector(
              ".v-popper__arrow-container"
            )),
            this.$_swapTargetAttrs("title", "data-original-title"),
            this.$_detachPopperNode(),
            this.triggers.length && this.$_addEventListeners(),
            this.shown && this.show());
        },
        dispose() {
          this.isDisposed ||
            ((this.isDisposed = !0),
            this.$_removeEventListeners(),
            this.hide({ skipDelay: !0 }),
            this.$_detachPopperNode(),
            (this.isMounted = !1),
            (this.isShown = !1),
            this.$_updateParentShownChildren(!1),
            this.$_swapTargetAttrs("data-original-title", "title"));
        },
        async onResize() {
          this.isShown &&
            (await this.$_computePosition(), this.$emit("resize"));
        },
        async $_computePosition() {
          if (this.isDisposed || this.positioningDisabled) return;
          const t = {
            strategy: this.strategy,
            middleware: [],
          };
          (this.distance || this.skidding) &&
            t.middleware.push(
              Xx({
                mainAxis: this.distance,
                crossAxis: this.skidding,
              })
            );
          const e = this.placement.startsWith("auto");
          if (
            (e
              ? t.middleware.push(
                  Gx({
                    alignment: this.placement.split("-")[1] ?? "",
                  })
                )
              : (t.placement = this.placement),
            this.preventOverflow &&
              (this.shift &&
                t.middleware.push(
                  Zx({
                    padding: this.overflowPadding,
                    boundary: this.boundary,
                    crossAxis: this.shiftCrossAxis,
                  })
                ),
              !e &&
                this.flip &&
                t.middleware.push(
                  Jx({
                    padding: this.overflowPadding,
                    boundary: this.boundary,
                  })
                )),
            t.middleware.push(
              qx({
                element: this.$_arrowNode,
                padding: this.arrowPadding,
              })
            ),
            this.arrowOverflow &&
              t.middleware.push({
                name: "arrowOverflow",
                fn: ({ placement: r, rects: o, middlewareData: i }) => {
                  let s;
                  const { centerOffset: a } = i.arrow;
                  return (
                    r.startsWith("top") || r.startsWith("bottom")
                      ? (s = Math.abs(a) > o.reference.width / 2)
                      : (s = Math.abs(a) > o.reference.height / 2),
                    {
                      data: {
                        overflow: s,
                      },
                    }
                  );
                },
              }),
            this.autoMinSize || this.autoSize)
          ) {
            const r = this.autoSize
              ? this.autoSize
              : this.autoMinSize
              ? "min"
              : null;
            t.middleware.push({
              name: "autoSize",
              fn: ({ rects: o, placement: i, middlewareData: s }) => {
                var a;
                if ((a = s.autoSize) != null && a.skip) return {};
                let l, u;
                return (
                  i.startsWith("top") || i.startsWith("bottom")
                    ? (l = o.reference.width)
                    : (u = o.reference.height),
                  (this.$_innerNode.style[
                    r === "min"
                      ? "minWidth"
                      : r === "max"
                      ? "maxWidth"
                      : "width"
                  ] = l != null ? `${l}px` : null),
                  (this.$_innerNode.style[
                    r === "min"
                      ? "minHeight"
                      : r === "max"
                      ? "maxHeight"
                      : "height"
                  ] = u != null ? `${u}px` : null),
                  {
                    data: {
                      skip: !0,
                    },
                    reset: {
                      rects: !0,
                    },
                  }
                );
              },
            });
          }
          (this.autoMaxSize || this.autoBoundaryMaxSize) &&
            ((this.$_innerNode.style.maxWidth = null),
            (this.$_innerNode.style.maxHeight = null),
            t.middleware.push(
              Qx({
                boundary: this.boundary,
                padding: this.overflowPadding,
                apply: ({ availableWidth: r, availableHeight: o }) => {
                  (this.$_innerNode.style.maxWidth =
                    r != null ? `${r}px` : null),
                    (this.$_innerNode.style.maxHeight =
                      o != null ? `${o}px` : null);
                },
              })
            ));
          const n = await rk(this.$_referenceNode, this.$_popperNode, t);
          Object.assign(this.result, {
            x: n.x,
            y: n.y,
            placement: n.placement,
            strategy: n.strategy,
            arrow: {
              ...n.middlewareData.arrow,
              ...n.middlewareData.arrowOverflow,
            },
          });
        },
        $_scheduleShow(t, e = !1) {
          if (
            (this.$_updateParentShownChildren(!0),
            (this.$_hideInProgress = !1),
            clearTimeout(this.$_scheduleTimer),
            Po &&
              this.instantMove &&
              Po.instantMove &&
              Po !== this.parentPopper)
          ) {
            Po.$_applyHide(!0), this.$_applyShow(!0);
            return;
          }
          e
            ? this.$_applyShow()
            : (this.$_scheduleTimer = setTimeout(
                this.$_applyShow.bind(this),
                this.$_computeDelay("show")
              ));
        },
        $_scheduleHide(t, e = !1) {
          if (this.shownChildren.size > 0) {
            this.pendingHide = !0;
            return;
          }
          this.$_updateParentShownChildren(!1),
            (this.$_hideInProgress = !0),
            clearTimeout(this.$_scheduleTimer),
            this.isShown && (Po = this),
            e
              ? this.$_applyHide()
              : (this.$_scheduleTimer = setTimeout(
                  this.$_applyHide.bind(this),
                  this.$_computeDelay("hide")
                ));
        },
        $_computeDelay(t) {
          const e = this.delay;
          return parseInt((e && e[t]) || e || 0);
        },
        async $_applyShow(t = !1) {
          clearTimeout(this.$_disposeTimer),
            clearTimeout(this.$_scheduleTimer),
            (this.skipTransition = t),
            !this.isShown &&
              (this.$_ensureTeleport(),
              await Ed(),
              await this.$_computePosition(),
              await this.$_applyShowEffect(),
              this.positioningDisabled ||
                this.$_registerEventListeners(
                  [...tu(this.$_referenceNode), ...tu(this.$_popperNode)],
                  "scroll",
                  () => {
                    this.$_computePosition();
                  }
                ));
        },
        async $_applyShowEffect() {
          if (this.$_hideInProgress) return;
          if (this.computeTransformOrigin) {
            const e = this.$_referenceNode.getBoundingClientRect(),
              n = this.$_popperNode.querySelector(".v-popper__wrapper"),
              r = n.parentNode.getBoundingClientRect(),
              o = e.x + e.width / 2 - (r.left + n.offsetLeft),
              i = e.y + e.height / 2 - (r.top + n.offsetTop);
            this.result.transformOrigin = `${o}px ${i}px`;
          }
          (this.isShown = !0),
            this.$_applyAttrsToTarget({
              "aria-describedby": this.popperId,
              "data-popper-shown": "",
            });
          const t = this.showGroup;
          if (t) {
            let e;
            for (let n = 0; n < Bn.length; n++)
              (e = Bn[n]),
                e.showGroup !== t && (e.hide(), e.$emit("close-group"));
          }
          Bn.push(this), document.body.classList.add("v-popper--some-open");
          for (const e of Z0(this.theme))
            rm(e).push(this),
              document.body.classList.add(`v-popper--some-open--${e}`);
          this.$emit("apply-show"),
            (this.classes.showFrom = !0),
            (this.classes.showTo = !1),
            (this.classes.hideFrom = !1),
            (this.classes.hideTo = !1),
            await Ed(),
            (this.classes.showFrom = !1),
            (this.classes.showTo = !0),
            this.noAutoFocus || this.$_popperNode.focus();
        },
        async $_applyHide(t = !1) {
          if (this.shownChildren.size > 0) {
            (this.pendingHide = !0), (this.$_hideInProgress = !1);
            return;
          }
          if ((clearTimeout(this.$_scheduleTimer), !this.isShown)) return;
          (this.skipTransition = t),
            tm(Bn, this),
            Bn.length === 0 &&
              document.body.classList.remove("v-popper--some-open");
          for (const n of Z0(this.theme)) {
            const r = rm(n);
            tm(r, this),
              r.length === 0 &&
                document.body.classList.remove(`v-popper--some-open--${n}`);
          }
          Po === this && (Po = null),
            (this.isShown = !1),
            this.$_applyAttrsToTarget({
              "aria-describedby": void 0,
              "data-popper-shown": void 0,
            }),
            clearTimeout(this.$_disposeTimer);
          const e = this.disposeTimeout;
          e !== null &&
            (this.$_disposeTimer = setTimeout(() => {
              this.$_popperNode &&
                (this.$_detachPopperNode(), (this.isMounted = !1));
            }, e)),
            this.$_removeEventListeners("scroll"),
            this.$emit("apply-hide"),
            (this.classes.showFrom = !1),
            (this.classes.showTo = !1),
            (this.classes.hideFrom = !0),
            (this.classes.hideTo = !1),
            await Ed(),
            (this.classes.hideFrom = !1),
            (this.classes.hideTo = !0);
        },
        $_autoShowHide() {
          this.shown ? this.show() : this.hide();
        },
        $_ensureTeleport() {
          if (this.isDisposed) return;
          let t = this.container;
          if (
            (typeof t == "string"
              ? (t = window.document.querySelector(t))
              : t === !1 && (t = this.$_targetNodes[0].parentNode),
            !t)
          )
            throw new Error("No container for popover: " + this.container);
          t.appendChild(this.$_popperNode), (this.isMounted = !0);
        },
        $_addEventListeners() {
          const t = (n) => {
            (this.isShown && !this.$_hideInProgress) ||
              ((n.usedByTooltip = !0),
              !this.$_preventShow && this.show({ event: n }));
          };
          this.$_registerTriggerListeners(
            this.$_targetNodes,
            Q0,
            this.triggers,
            this.showTriggers,
            t
          ),
            this.$_registerTriggerListeners(
              [this.$_popperNode],
              Q0,
              this.popperTriggers,
              this.popperShowTriggers,
              t
            );
          const e = (n) => {
            n.usedByTooltip || this.hide({ event: n });
          };
          this.$_registerTriggerListeners(
            this.$_targetNodes,
            em,
            this.triggers,
            this.hideTriggers,
            e
          ),
            this.$_registerTriggerListeners(
              [this.$_popperNode],
              em,
              this.popperTriggers,
              this.popperHideTriggers,
              e
            );
        },
        $_registerEventListeners(t, e, n) {
          this.$_events.push({ targetNodes: t, eventType: e, handler: n }),
            t.forEach((r) =>
              r.addEventListener(
                e,
                n,
                Ys
                  ? {
                      passive: !0,
                    }
                  : void 0
              )
            );
        },
        $_registerTriggerListeners(t, e, n, r, o) {
          let i = n;
          r != null && (i = typeof r == "function" ? r(i) : r),
            i.forEach((s) => {
              const a = e[s];
              a && this.$_registerEventListeners(t, a, o);
            });
        },
        $_removeEventListeners(t) {
          const e = [];
          this.$_events.forEach((n) => {
            const { targetNodes: r, eventType: o, handler: i } = n;
            !t || t === o
              ? r.forEach((s) => s.removeEventListener(o, i))
              : e.push(n);
          }),
            (this.$_events = e);
        },
        $_refreshListeners() {
          this.isDisposed ||
            (this.$_removeEventListeners(), this.$_addEventListeners());
        },
        $_handleGlobalClose(t, e = !1) {
          this.$_showFrameLocked ||
            (this.hide({ event: t }),
            t.closePopover
              ? this.$emit("close-directive")
              : this.$emit("auto-hide"),
            e &&
              ((this.$_preventShow = !0),
              setTimeout(() => {
                this.$_preventShow = !1;
              }, 300)));
        },
        $_detachPopperNode() {
          this.$_popperNode.parentNode &&
            this.$_popperNode.parentNode.removeChild(this.$_popperNode);
        },
        $_swapTargetAttrs(t, e) {
          for (const n of this.$_targetNodes) {
            const r = n.getAttribute(t);
            r && (n.removeAttribute(t), n.setAttribute(e, r));
          }
        },
        $_applyAttrsToTarget(t) {
          for (const e of this.$_targetNodes)
            for (const n in t) {
              const r = t[n];
              r == null ? e.removeAttribute(n) : e.setAttribute(n, r);
            }
        },
        $_updateParentShownChildren(t) {
          let e = this.parentPopper;
          for (; e; )
            t
              ? e.shownChildren.add(this.randomId)
              : (e.shownChildren.delete(this.randomId),
                e.pendingHide && e.hide()),
              (e = e.parentPopper);
        },
        $_isAimingPopper() {
          const t = this.$_referenceNode.getBoundingClientRect();
          if (Cs >= t.left && Cs <= t.right && As >= t.top && As <= t.bottom) {
            const e = this.$_popperNode.getBoundingClientRect(),
              n = Cs - Zr,
              r = As - Qr,
              o =
                e.left +
                e.width / 2 -
                Zr +
                (e.top + e.height / 2) -
                Qr +
                e.width +
                e.height,
              i = Zr + n * o,
              s = Qr + r * o;
            return (
              Za(Zr, Qr, i, s, e.left, e.top, e.left, e.bottom) || // Left edge
              Za(Zr, Qr, i, s, e.left, e.top, e.right, e.top) || // Top edge
              Za(Zr, Qr, i, s, e.right, e.top, e.right, e.bottom) || // Right edge
              Za(Zr, Qr, i, s, e.left, e.bottom, e.right, e.bottom)
            );
          }
          return !1;
        },
      },
      render() {
        return this.$slots.default(this.slotData);
      },
    });
if (typeof document < "u" && typeof window < "u") {
  if (Tb) {
    const t = Ys
      ? {
          passive: !0,
          capture: !0,
        }
      : !0;
    document.addEventListener("touchstart", (e) => om(e), t),
      document.addEventListener("touchend", (e) => im(e, !0), t);
  } else
    window.addEventListener("mousedown", (t) => om(t), !0),
      window.addEventListener("click", (t) => im(t, !1), !0);
  window.addEventListener("resize", ak);
}
function om(t, e) {
  for (let n = 0; n < Bn.length; n++) {
    const r = Bn[n];
    try {
      r.mouseDownContains = r.popperNode().contains(t.target);
    } catch {}
  }
}
function im(t, e) {
  ik(t, e);
}
function ik(t, e) {
  const n = {};
  for (let r = Bn.length - 1; r >= 0; r--) {
    const o = Bn[r];
    try {
      const i = (o.containsGlobalTarget =
        o.mouseDownContains || o.popperNode().contains(t.target));
      (o.pendingHide = !1),
        requestAnimationFrame(() => {
          if (((o.pendingHide = !1), !n[o.randomId] && sm(o, i, t))) {
            if (
              (o.$_handleGlobalClose(t, e),
              !t.closeAllPopover && t.closePopover && i)
            ) {
              let a = o.parentPopper;
              for (; a; ) (n[a.randomId] = !0), (a = a.parentPopper);
              return;
            }
            let s = o.parentPopper;
            for (; s && sm(s, s.containsGlobalTarget, t); )
              s.$_handleGlobalClose(t, e), (s = s.parentPopper);
          }
        });
    } catch {}
  }
}
function sm(t, e, n) {
  return n.closeAllPopover || (n.closePopover && e) || (sk(t, n) && !e);
}
function sk(t, e) {
  if (typeof t.autoHide == "function") {
    const n = t.autoHide(e);
    return (t.lastAutoHide = n), n;
  }
  return t.autoHide;
}
function ak() {
  for (let t = 0; t < Bn.length; t++) Bn[t].$_computePosition();
}
let Zr = 0,
  Qr = 0,
  Cs = 0,
  As = 0;
typeof window < "u" &&
  window.addEventListener(
    "mousemove",
    (t) => {
      (Zr = Cs), (Qr = As), (Cs = t.clientX), (As = t.clientY);
    },
    Ys
      ? {
          passive: !0,
        }
      : void 0
  );
function Za(t, e, n, r, o, i, s, a) {
  const l =
      ((s - o) * (e - i) - (a - i) * (t - o)) /
      ((a - i) * (n - t) - (s - o) * (r - e)),
    u =
      ((n - t) * (e - i) - (r - e) * (t - o)) /
      ((a - i) * (n - t) - (s - o) * (r - e));
  return l >= 0 && l <= 1 && u >= 0 && u <= 1;
}
const lk = {
    extends: Db(),
  },
  $c = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, o] of e) n[r] = o;
    return n;
  };
function uk(t, e, n, r, o, i) {
  return (
    S(),
    O(
      "div",
      {
        ref: "reference",
        class: $e([
          "v-popper",
          {
            "v-popper--shown": t.slotData.isShown,
          },
        ]),
      },
      [Kn(t.$slots, "default", ph(hh(t.slotData)))],
      2
    )
  );
}
const ck = /* @__PURE__ */ $c(lk, [["render", uk]]);
function dk() {
  var t = window.navigator.userAgent,
    e = t.indexOf("MSIE ");
  if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
  var n = t.indexOf("Trident/");
  if (n > 0) {
    var r = t.indexOf("rv:");
    return parseInt(t.substring(r + 3, t.indexOf(".", r)), 10);
  }
  var o = t.indexOf("Edge/");
  return o > 0 ? parseInt(t.substring(o + 5, t.indexOf(".", o)), 10) : -1;
}
let Hl;
function Vf() {
  Vf.init || ((Vf.init = !0), (Hl = dk() !== -1));
}
var Bc = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: !1,
    },
    ignoreWidth: {
      type: Boolean,
      default: !1,
    },
    ignoreHeight: {
      type: Boolean,
      default: !1,
    },
  },
  emits: ["notify"],
  mounted() {
    Vf(),
      fh(() => {
        (this._w = this.$el.offsetWidth),
          (this._h = this.$el.offsetHeight),
          this.emitOnMount && this.emitSize();
      });
    const t = document.createElement("object");
    (this._resizeObject = t),
      t.setAttribute("aria-hidden", "true"),
      t.setAttribute("tabindex", -1),
      (t.onload = this.addResizeHandlers),
      (t.type = "text/html"),
      Hl && this.$el.appendChild(t),
      (t.data = "about:blank"),
      Hl || this.$el.appendChild(t);
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) ||
        (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) &&
        ((this._w = this.$el.offsetWidth),
        (this._h = this.$el.offsetHeight),
        this.emitSize());
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h,
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener(
        "resize",
        this.compareAndNotify
      ),
        this.compareAndNotify();
    },
    removeResizeHandlers() {
      this._resizeObject &&
        this._resizeObject.onload &&
        (!Hl &&
          this._resizeObject.contentDocument &&
          this._resizeObject.contentDocument.defaultView.removeEventListener(
            "resize",
            this.compareAndNotify
          ),
        this.$el.removeChild(this._resizeObject),
        (this._resizeObject.onload = null),
        (this._resizeObject = null));
    },
  },
};
const fk = /* @__PURE__ */ xx("data-v-b329ee4c");
vx("data-v-b329ee4c");
const pk = {
  class: "resize-observer",
  tabindex: "-1",
};
_x();
const hk = /* @__PURE__ */ fk((t, e, n, r, o, i) => (S(), de("div", pk)));
Bc.render = hk;
Bc.__scopeId = "data-v-b329ee4c";
Bc.__file = "src/components/ResizeObserver.vue";
const Nb = (t = "theme") => ({
    computed: {
      themeClass() {
        return ok(this[t]);
      },
    },
  }),
  mk = se({
    name: "VPopperContent",
    components: {
      ResizeObserver: Bc,
    },
    mixins: [Nb()],
    props: {
      popperId: String,
      theme: String,
      shown: Boolean,
      mounted: Boolean,
      skipTransition: Boolean,
      autoHide: Boolean,
      handleResize: Boolean,
      classes: Object,
      result: Object,
    },
    emits: ["hide", "resize"],
    methods: {
      toPx(t) {
        return t != null && !isNaN(t) ? `${t}px` : null;
      },
    },
  }),
  gk = ["id", "aria-hidden", "tabindex", "data-popper-placement"],
  bk = {
    ref: "inner",
    class: "v-popper__inner",
  },
  yk = /* @__PURE__ */ C("div", { class: "v-popper__arrow-outer" }, null, -1),
  vk = /* @__PURE__ */ C("div", { class: "v-popper__arrow-inner" }, null, -1),
  _k = [yk, vk];
function xk(t, e, n, r, o, i) {
  const s = $n("ResizeObserver");
  return (
    S(),
    O(
      "div",
      {
        id: t.popperId,
        ref: "popover",
        class: $e([
          "v-popper__popper",
          [
            t.themeClass,
            t.classes.popperClass,
            {
              "v-popper__popper--shown": t.shown,
              "v-popper__popper--hidden": !t.shown,
              "v-popper__popper--show-from": t.classes.showFrom,
              "v-popper__popper--show-to": t.classes.showTo,
              "v-popper__popper--hide-from": t.classes.hideFrom,
              "v-popper__popper--hide-to": t.classes.hideTo,
              "v-popper__popper--skip-transition": t.skipTransition,
              "v-popper__popper--arrow-overflow":
                t.result && t.result.arrow.overflow,
              "v-popper__popper--no-positioning": !t.result,
            },
          ],
        ]),
        style: mt(
          t.result
            ? {
                position: t.result.strategy,
                transform: `translate3d(${Math.round(
                  t.result.x
                )}px,${Math.round(t.result.y)}px,0)`,
              }
            : void 0
        ),
        "aria-hidden": t.shown ? "false" : "true",
        tabindex: t.autoHide ? 0 : void 0,
        "data-popper-placement": t.result ? t.result.placement : void 0,
        onKeyup:
          e[2] || (e[2] = Bl((a) => t.autoHide && t.$emit("hide"), ["esc"])),
      },
      [
        C("div", {
          class: "v-popper__backdrop",
          onClick: e[0] || (e[0] = (a) => t.autoHide && t.$emit("hide")),
        }),
        C(
          "div",
          {
            class: "v-popper__wrapper",
            style: mt(
              t.result
                ? {
                    transformOrigin: t.result.transformOrigin,
                  }
                : void 0
            ),
          },
          [
            C(
              "div",
              bk,
              [
                t.mounted
                  ? (S(),
                    O(
                      gt,
                      { key: 0 },
                      [
                        C("div", null, [Kn(t.$slots, "default")]),
                        t.handleResize
                          ? (S(),
                            de(s, {
                              key: 0,
                              onNotify:
                                e[1] || (e[1] = (a) => t.$emit("resize", a)),
                            }))
                          : un("", !0),
                      ],
                      64
                    ))
                  : un("", !0),
              ],
              512
            ),
            C(
              "div",
              {
                ref: "arrow",
                class: "v-popper__arrow-container",
                style: mt(
                  t.result
                    ? {
                        left: t.toPx(t.result.arrow.x),
                        top: t.toPx(t.result.arrow.y),
                      }
                    : void 0
                ),
              },
              _k,
              4
            ),
          ],
          4
        ),
      ],
      46,
      gk
    )
  );
}
const Lb = /* @__PURE__ */ $c(mk, [["render", xk]]),
  Rb = {
    methods: {
      show(...t) {
        return this.$refs.popper.show(...t);
      },
      hide(...t) {
        return this.$refs.popper.hide(...t);
      },
      dispose(...t) {
        return this.$refs.popper.dispose(...t);
      },
      onResize(...t) {
        return this.$refs.popper.onResize(...t);
      },
    },
  };
let Uf = function () {};
typeof window < "u" && (Uf = window.Element);
const kk = se({
  name: "VPopperWrapper",
  components: {
    Popper: ck,
    PopperContent: Lb,
  },
  mixins: [Rb, Nb("finalTheme")],
  props: {
    theme: {
      type: String,
      default: null,
    },
    referenceNode: {
      type: Function,
      default: null,
    },
    shown: {
      type: Boolean,
      default: !1,
    },
    showGroup: {
      type: String,
      default: null,
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null,
    },
    disabled: {
      type: Boolean,
      default: void 0,
    },
    positioningDisabled: {
      type: Boolean,
      default: void 0,
    },
    placement: {
      type: String,
      default: void 0,
    },
    delay: {
      type: [String, Number, Object],
      default: void 0,
    },
    distance: {
      type: [Number, String],
      default: void 0,
    },
    skidding: {
      type: [Number, String],
      default: void 0,
    },
    triggers: {
      type: Array,
      default: void 0,
    },
    showTriggers: {
      type: [Array, Function],
      default: void 0,
    },
    hideTriggers: {
      type: [Array, Function],
      default: void 0,
    },
    popperTriggers: {
      type: Array,
      default: void 0,
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: void 0,
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: void 0,
    },
    container: {
      type: [String, Object, Uf, Boolean],
      default: void 0,
    },
    boundary: {
      type: [String, Uf],
      default: void 0,
    },
    strategy: {
      type: String,
      default: void 0,
    },
    autoHide: {
      type: [Boolean, Function],
      default: void 0,
    },
    handleResize: {
      type: Boolean,
      default: void 0,
    },
    instantMove: {
      type: Boolean,
      default: void 0,
    },
    eagerMount: {
      type: Boolean,
      default: void 0,
    },
    popperClass: {
      type: [String, Array, Object],
      default: void 0,
    },
    computeTransformOrigin: {
      type: Boolean,
      default: void 0,
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: void 0,
    },
    autoSize: {
      type: [Boolean, String],
      default: void 0,
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: void 0,
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: void 0,
    },
    preventOverflow: {
      type: Boolean,
      default: void 0,
    },
    overflowPadding: {
      type: [Number, String],
      default: void 0,
    },
    arrowPadding: {
      type: [Number, String],
      default: void 0,
    },
    arrowOverflow: {
      type: Boolean,
      default: void 0,
    },
    flip: {
      type: Boolean,
      default: void 0,
    },
    shift: {
      type: Boolean,
      default: void 0,
    },
    shiftCrossAxis: {
      type: Boolean,
      default: void 0,
    },
    noAutoFocus: {
      type: Boolean,
      default: void 0,
    },
    disposeTimeout: {
      type: Number,
      default: void 0,
    },
  },
  emits: {
    show: () => !0,
    hide: () => !0,
    "update:shown": (t) => !0,
    "apply-show": () => !0,
    "apply-hide": () => !0,
    "close-group": () => !0,
    "close-directive": () => !0,
    "auto-hide": () => !0,
    resize: () => !0,
  },
  computed: {
    finalTheme() {
      return this.theme ?? this.$options.vPopperTheme;
    },
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$el.children).filter(
        (t) => t !== this.$refs.popperContent.$el
      );
    },
  },
});
function wk(t, e, n, r, o, i) {
  const s = $n("PopperContent"),
    a = $n("Popper");
  return (
    S(),
    de(
      a,
      Fn({ ref: "popper" }, t.$props, {
        theme: t.finalTheme,
        "target-nodes": t.getTargetNodes,
        "popper-node": () => t.$refs.popperContent.$el,
        class: [t.themeClass],
        onShow: e[0] || (e[0] = () => t.$emit("show")),
        onHide: e[1] || (e[1] = () => t.$emit("hide")),
        "onUpdate:shown": e[2] || (e[2] = (l) => t.$emit("update:shown", l)),
        onApplyShow: e[3] || (e[3] = () => t.$emit("apply-show")),
        onApplyHide: e[4] || (e[4] = () => t.$emit("apply-hide")),
        onCloseGroup: e[5] || (e[5] = () => t.$emit("close-group")),
        onCloseDirective: e[6] || (e[6] = () => t.$emit("close-directive")),
        onAutoHide: e[7] || (e[7] = () => t.$emit("auto-hide")),
        onResize: e[8] || (e[8] = () => t.$emit("resize")),
      }),
      {
        default: me(
          ({
            popperId: l,
            isShown: u,
            shouldMountContent: c,
            skipTransition: d,
            autoHide: f,
            show: p,
            hide: h,
            handleResize: m,
            onResize: g,
            classes: b,
            result: _,
          }) => [
            Kn(t.$slots, "default", {
              shown: u,
              show: p,
              hide: h,
            }),
            J(
              s,
              {
                ref: "popperContent",
                "popper-id": l,
                theme: t.finalTheme,
                shown: u,
                mounted: c,
                "skip-transition": d,
                "auto-hide": f,
                "handle-resize": m,
                classes: b,
                result: _,
                onHide: h,
                onResize: g,
              },
              {
                default: me(() => [
                  Kn(t.$slots, "popper", {
                    shown: u,
                    hide: h,
                  }),
                ]),
                _: 2,
              },
              1032,
              [
                "popper-id",
                "theme",
                "shown",
                "mounted",
                "skip-transition",
                "auto-hide",
                "handle-resize",
                "classes",
                "result",
                "onHide",
                "onResize",
              ]
            ),
          ]
        ),
        _: 3,
      },
      16,
      ["theme", "target-nodes", "popper-node", "class"]
    )
  );
}
const vh = /* @__PURE__ */ $c(kk, [["render", wk]]),
  Ck = {
    ...vh,
    name: "VDropdown",
    vPopperTheme: "dropdown",
  };
({
  ...vh,
});
const Ak = {
    ...vh,
    name: "VTooltip",
    vPopperTheme: "tooltip",
  },
  Sk = se({
    name: "VTooltipDirective",
    components: {
      Popper: Db(),
      PopperContent: Lb,
    },
    mixins: [Rb],
    inheritAttrs: !1,
    props: {
      theme: {
        type: String,
        default: "tooltip",
      },
      html: {
        type: Boolean,
        default: (t) => Js(t.theme, "html"),
      },
      content: {
        type: [String, Number, Function],
        default: null,
      },
      loadingContent: {
        type: String,
        default: (t) => Js(t.theme, "loadingContent"),
      },
      targetNodes: {
        type: Function,
        required: !0,
      },
    },
    data() {
      return {
        asyncContent: null,
      };
    },
    computed: {
      isContentAsync() {
        return typeof this.content == "function";
      },
      loading() {
        return this.isContentAsync && this.asyncContent == null;
      },
      finalContent() {
        return this.isContentAsync
          ? this.loading
            ? this.loadingContent
            : this.asyncContent
          : this.content;
      },
    },
    watch: {
      content: {
        handler() {
          this.fetchContent(!0);
        },
        immediate: !0,
      },
      async finalContent() {
        await this.$nextTick(), this.$refs.popper.onResize();
      },
    },
    created() {
      this.$_fetchId = 0;
    },
    methods: {
      fetchContent(t) {
        if (
          typeof this.content == "function" &&
          this.$_isShown &&
          (t || (!this.$_loading && this.asyncContent == null))
        ) {
          (this.asyncContent = null), (this.$_loading = !0);
          const e = ++this.$_fetchId,
            n = this.content(this);
          n.then ? n.then((r) => this.onResult(e, r)) : this.onResult(e, n);
        }
      },
      onResult(t, e) {
        t === this.$_fetchId &&
          ((this.$_loading = !1), (this.asyncContent = e));
      },
      onShow() {
        (this.$_isShown = !0), this.fetchContent();
      },
      onHide() {
        this.$_isShown = !1;
      },
    },
  }),
  Ek = ["innerHTML"],
  Mk = ["textContent"];
function Tk(t, e, n, r, o, i) {
  const s = $n("PopperContent"),
    a = $n("Popper");
  return (
    S(),
    de(
      a,
      Fn({ ref: "popper" }, t.$attrs, {
        theme: t.theme,
        "target-nodes": t.targetNodes,
        "popper-node": () => t.$refs.popperContent.$el,
        onApplyShow: t.onShow,
        onApplyHide: t.onHide,
      }),
      {
        default: me(
          ({
            popperId: l,
            isShown: u,
            shouldMountContent: c,
            skipTransition: d,
            autoHide: f,
            hide: p,
            handleResize: h,
            onResize: m,
            classes: g,
            result: b,
          }) => [
            J(
              s,
              {
                ref: "popperContent",
                class: $e({
                  "v-popper--tooltip-loading": t.loading,
                }),
                "popper-id": l,
                theme: t.theme,
                shown: u,
                mounted: c,
                "skip-transition": d,
                "auto-hide": f,
                "handle-resize": h,
                classes: g,
                result: b,
                onHide: p,
                onResize: m,
              },
              {
                default: me(() => [
                  t.html
                    ? (S(),
                      O(
                        "div",
                        {
                          key: 0,
                          innerHTML: t.finalContent,
                        },
                        null,
                        8,
                        Ek
                      ))
                    : (S(),
                      O(
                        "div",
                        {
                          key: 1,
                          textContent: it(t.finalContent),
                        },
                        null,
                        8,
                        Mk
                      )),
                ]),
                _: 2,
              },
              1032,
              [
                "class",
                "popper-id",
                "theme",
                "shown",
                "mounted",
                "skip-transition",
                "auto-hide",
                "handle-resize",
                "classes",
                "result",
                "onHide",
                "onResize",
              ]
            ),
          ]
        ),
        _: 1,
      },
      16,
      ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]
    )
  );
}
const Ok = /* @__PURE__ */ $c(Sk, [["render", Tk]]),
  Ib = "v-popper--has-tooltip";
function Dk(t, e) {
  let n = t.placement;
  if (!n && e) for (const r of Ob) e[r] && (n = r);
  return n || (n = Js(t.theme || "tooltip", "placement")), n;
}
function Pb(t, e, n) {
  let r;
  const o = typeof e;
  return (
    o === "string"
      ? (r = { content: e })
      : e && o === "object"
      ? (r = e)
      : (r = { content: !1 }),
    (r.placement = Dk(r, n)),
    (r.targetNodes = () => [t]),
    (r.referenceNode = () => t),
    r
  );
}
let Td,
  Xs,
  Nk = 0;
function Lk() {
  if (Td) return;
  (Xs = Te([])),
    (Td = kx({
      name: "VTooltipDirectiveApp",
      setup() {
        return {
          directives: Xs,
        };
      },
      render() {
        return this.directives.map((e) =>
          Zt(Ok, {
            ...e.options,
            shown: e.shown || e.options.shown,
            key: e.id,
          })
        );
      },
      devtools: {
        hide: !0,
      },
    }));
  const t = document.createElement("div");
  document.body.appendChild(t), Td.mount(t);
}
function Rk(t, e, n) {
  Lk();
  const r = Te(Pb(t, e, n)),
    o = Te(!1),
    i = {
      id: Nk++,
      options: r,
      shown: o,
    };
  return (
    Xs.value.push(i),
    t.classList && t.classList.add(Ib),
    (t.$_popper = {
      options: r,
      item: i,
      show() {
        o.value = !0;
      },
      hide() {
        o.value = !1;
      },
    })
  );
}
function $b(t) {
  if (t.$_popper) {
    const e = Xs.value.indexOf(t.$_popper.item);
    e !== -1 && Xs.value.splice(e, 1),
      delete t.$_popper,
      delete t.$_popperOldShown,
      delete t.$_popperMountTarget;
  }
  t.classList && t.classList.remove(Ib);
}
function am(t, { value: e, modifiers: n }) {
  const r = Pb(t, e, n);
  if (!r.content || Js(r.theme || "tooltip", "disabled")) $b(t);
  else {
    let o;
    t.$_popper ? ((o = t.$_popper), (o.options.value = r)) : (o = Rk(t, e, n)),
      typeof e.shown < "u" &&
        e.shown !== t.$_popperOldShown &&
        ((t.$_popperOldShown = e.shown), e.shown ? o.show() : o.hide());
  }
}
const Ik = {
    beforeMount: am,
    updated: am,
    beforeUnmount(t) {
      $b(t);
    },
  },
  Sa = Ik,
  ii = Ck,
  Bb = Ak,
  Li = /* @__PURE__ */ se({
    __name: "BlockActionButton",
    props: {
      tooltip: { default: void 0 },
      selected: { type: Boolean, default: !1 },
    },
    setup(t) {
      return (e, n) =>
        je(
          (S(),
          O(
            "div",
            {
              class: $e([
                "editor-block__actions-button",
                {
                  "editor-block__actions-button--selected": e.selected,
                },
              ]),
            },
            [Kn(e.$slots, "icon")],
            2
          )),
          [[I(Sa), e.tooltip]]
        );
    },
  }),
  Fi = /* @__PURE__ */ se({
    __name: "BlockActionInput",
    props: {
      tooltip: { default: void 0 },
      modelValue: { default: "" },
    },
    emits: ["update:modelValue"],
    setup(t, { emit: e }) {
      const n = t,
        r = e,
        o = ce({
          get: () => n.modelValue || "",
          set: (i) => r("update:modelValue", i),
        });
      return (i, s) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": s[0] || (s[0] = (a) => (o.value = a)),
              class: "editor-block__actions-input",
            },
            null,
            512
          )),
          [
            [
              Ot,
              o.value,
              void 0,
              {
                lazy: !0,
                trim: !0,
              },
            ],
            [I(Sa), i.tooltip],
          ]
        );
    },
  }),
  _h = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, o] of e) n[r] = o;
    return n;
  },
  Pk = {},
  $k = { class: "editor-block__actions-separator" };
function Bk(t, e) {
  return S(), O("div", $k);
}
const ot = /* @__PURE__ */ _h(Pk, [["render", Bk]]),
  Hk = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function Fk(t, e) {
  return (
    S(),
    O(
      "svg",
      Hk,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M14.12 10.47L12 12.59l-2.13-2.12l-1.41 1.41L10.59 14l-2.12 2.12l1.41 1.41L12 15.41l2.12 2.12l1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6zM8 9h8v10H8z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const zk = k({ name: "mdi-delete-forever-outline", render: Fk }),
  pi = /* @__PURE__ */ se({
    __name: "MdiDeleteForeverOutline",
    setup(t) {
      return (e, n) => (S(), de(I(zk), { class: "text-red-600" }));
    },
  });
/*!
 * shared v9.14.2
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const nu = typeof window < "u",
  Eo = (t, e = !1) => (e ? Symbol.for(t) : Symbol(t)),
  Vk = (t, e, n) => Uk({ l: t, k: e, s: n }),
  Uk = (t) =>
    JSON.stringify(t)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029")
      .replace(/\u0027/g, "\\u0027"),
  st = (t) => typeof t == "number" && isFinite(t),
  jk = (t) => Fb(t) === "[object Date]",
  ru = (t) => Fb(t) === "[object RegExp]",
  Hc = (t) => xe(t) && Object.keys(t).length === 0,
  Tt = Object.assign,
  Wk = Object.create,
  Be = (t = null) => Wk(t);
let lm;
const xh = () =>
  lm ||
  (lm =
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : Be());
function um(t) {
  return t
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}
const qk = Object.prototype.hasOwnProperty;
function zn(t, e) {
  return qk.call(t, e);
}
const ct = Array.isArray,
  tt = (t) => typeof t == "function",
  Y = (t) => typeof t == "string",
  Ye = (t) => typeof t == "boolean",
  Se = (t) => t !== null && typeof t == "object",
  Kk = (t) => Se(t) && tt(t.then) && tt(t.catch),
  Hb = Object.prototype.toString,
  Fb = (t) => Hb.call(t),
  xe = (t) => {
    if (!Se(t)) return !1;
    const e = Object.getPrototypeOf(t);
    return e === null || e.constructor === Object;
  },
  Gk = (t) =>
    t == null
      ? ""
      : ct(t) || (xe(t) && t.toString === Hb)
      ? JSON.stringify(t, null, 2)
      : String(t);
function Jk(t, e = "") {
  return t.reduce((n, r, o) => (o === 0 ? n + r : n + e + r), "");
}
function Fc(t) {
  let e = t;
  return () => ++e;
}
function Yk(t, e) {
  typeof console < "u" &&
    (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
const Qa = (t) => !Se(t) || ct(t);
function Fl(t, e) {
  if (Qa(t) || Qa(e)) throw new Error("Invalid value");
  const n = [{ src: t, des: e }];
  for (; n.length; ) {
    const { src: r, des: o } = n.pop();
    Object.keys(r).forEach((i) => {
      i !== "__proto__" &&
        (Se(r[i]) && !Se(o[i]) && (o[i] = Array.isArray(r[i]) ? [] : Be()),
        Qa(o[i]) || Qa(r[i])
          ? (o[i] = r[i])
          : n.push({ src: r[i], des: o[i] }));
    });
  }
}
/*!
 * message-compiler v9.14.2
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function Xk(t, e, n) {
  return { line: t, column: e, offset: n };
}
function ou(t, e, n) {
  return { start: t, end: e };
}
const Zk = /\{([0-9a-zA-Z]+)\}/g;
function zb(t, ...e) {
  return (
    e.length === 1 && Qk(e[0]) && (e = e[0]),
    (!e || !e.hasOwnProperty) && (e = {}),
    t.replace(Zk, (n, r) => (e.hasOwnProperty(r) ? e[r] : ""))
  );
}
const Vb = Object.assign,
  cm = (t) => typeof t == "string",
  Qk = (t) => t !== null && typeof t == "object";
function Ub(t, e = "") {
  return t.reduce((n, r, o) => (o === 0 ? n + r : n + e + r), "");
}
const kh = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2,
  },
  ew = {
    [kh.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'.",
  };
function tw(t, e, ...n) {
  const r = zb(ew[t], ...(n || [])),
    o = { message: String(r), code: t };
  return e && (o.location = e), o;
}
const ie = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 17,
  },
  nw = {
    // tokenizer error messages
    [ie.EXPECTED_TOKEN]: "Expected token: '{0}'",
    [ie.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
    [ie.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]:
      "Unterminated single quote in placeholder",
    [ie.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
    [ie.INVALID_UNICODE_ESCAPE_SEQUENCE]:
      "Invalid unicode escape sequence: {0}",
    [ie.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
    [ie.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
    [ie.EMPTY_PLACEHOLDER]: "Empty placeholder",
    [ie.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
    [ie.INVALID_LINKED_FORMAT]: "Invalid linked format",
    // parser error messages
    [ie.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
    [ie.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
    [ie.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
    [ie.UNEXPECTED_LEXICAL_ANALYSIS]:
      "Unexpected lexical analysis in token: '{0}'",
    // generator error messages
    [ie.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
    // minimizer error messages
    [ie.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'",
  };
function ts(t, e, n = {}) {
  const { domain: r, messages: o, args: i } = n,
    s = zb((o || nw)[t] || "", ...(i || [])),
    a = new SyntaxError(String(s));
  return (a.code = t), e && (a.location = e), (a.domain = r), a;
}
function rw(t) {
  throw t;
}
const Cr = " ",
  ow = "\r",
  Rt = `
`,
  iw = "\u2028",
  sw = "\u2029";
function aw(t) {
  const e = t;
  let n = 0,
    r = 1,
    o = 1,
    i = 0;
  const s = (M) => e[M] === ow && e[M + 1] === Rt,
    a = (M) => e[M] === Rt,
    l = (M) => e[M] === sw,
    u = (M) => e[M] === iw,
    c = (M) => s(M) || a(M) || l(M) || u(M),
    d = () => n,
    f = () => r,
    p = () => o,
    h = () => i,
    m = (M) => (s(M) || l(M) || u(M) ? Rt : e[M]),
    g = () => m(n),
    b = () => m(n + i);
  function _() {
    return (i = 0), c(n) && (r++, (o = 0)), s(n) && n++, n++, o++, e[n];
  }
  function v() {
    return s(n + i) && i++, i++, e[n + i];
  }
  function y() {
    (n = 0), (r = 1), (o = 1), (i = 0);
  }
  function w(M = 0) {
    i = M;
  }
  function x() {
    const M = n + i;
    for (; M !== n; ) _();
    i = 0;
  }
  return {
    index: d,
    line: f,
    column: p,
    peekOffset: h,
    charAt: m,
    currentChar: g,
    currentPeek: b,
    next: _,
    peek: v,
    reset: y,
    resetPeek: w,
    skipToPeek: x,
  };
}
const Jr = void 0,
  lw = ".",
  dm = "'",
  uw = "tokenizer";
function cw(t, e = {}) {
  const n = e.location !== !1,
    r = aw(t),
    o = () => r.index(),
    i = () => Xk(r.line(), r.column(), r.index()),
    s = i(),
    a = o(),
    l = {
      currentType: 14,
      offset: a,
      startLoc: s,
      endLoc: s,
      lastType: 14,
      lastOffset: a,
      lastStartLoc: s,
      lastEndLoc: s,
      braceNest: 0,
      inLinked: !1,
      text: "",
    },
    u = () => l,
    { onError: c } = e;
  function d(A, E, B, ...G) {
    const Me = u();
    if (((E.column += B), (E.offset += B), c)) {
      const oe = n ? ou(Me.startLoc, E) : null,
        L = ts(A, oe, {
          domain: uw,
          args: G,
        });
      c(L);
    }
  }
  function f(A, E, B) {
    (A.endLoc = i()), (A.currentType = E);
    const G = { type: E };
    return (
      n && (G.loc = ou(A.startLoc, A.endLoc)), B != null && (G.value = B), G
    );
  }
  const p = (A) =>
    f(
      A,
      14
      /* TokenTypes.EOF */
    );
  function h(A, E) {
    return A.currentChar() === E
      ? (A.next(), E)
      : (d(ie.EXPECTED_TOKEN, i(), 0, E), "");
  }
  function m(A) {
    let E = "";
    for (; A.currentPeek() === Cr || A.currentPeek() === Rt; )
      (E += A.currentPeek()), A.peek();
    return E;
  }
  function g(A) {
    const E = m(A);
    return A.skipToPeek(), E;
  }
  function b(A) {
    if (A === Jr) return !1;
    const E = A.charCodeAt(0);
    return (
      (E >= 97 && E <= 122) || // a-z
      (E >= 65 && E <= 90) || // A-Z
      E === 95
    );
  }
  function _(A) {
    if (A === Jr) return !1;
    const E = A.charCodeAt(0);
    return E >= 48 && E <= 57;
  }
  function v(A, E) {
    const { currentType: B } = E;
    if (B !== 2) return !1;
    m(A);
    const G = b(A.currentPeek());
    return A.resetPeek(), G;
  }
  function y(A, E) {
    const { currentType: B } = E;
    if (B !== 2) return !1;
    m(A);
    const G = A.currentPeek() === "-" ? A.peek() : A.currentPeek(),
      Me = _(G);
    return A.resetPeek(), Me;
  }
  function w(A, E) {
    const { currentType: B } = E;
    if (B !== 2) return !1;
    m(A);
    const G = A.currentPeek() === dm;
    return A.resetPeek(), G;
  }
  function x(A, E) {
    const { currentType: B } = E;
    if (B !== 8) return !1;
    m(A);
    const G = A.currentPeek() === ".";
    return A.resetPeek(), G;
  }
  function M(A, E) {
    const { currentType: B } = E;
    if (B !== 9) return !1;
    m(A);
    const G = b(A.currentPeek());
    return A.resetPeek(), G;
  }
  function N(A, E) {
    const { currentType: B } = E;
    if (!(B === 8 || B === 12)) return !1;
    m(A);
    const G = A.currentPeek() === ":";
    return A.resetPeek(), G;
  }
  function T(A, E) {
    const { currentType: B } = E;
    if (B !== 10) return !1;
    const G = () => {
        const oe = A.currentPeek();
        return oe === "{"
          ? b(A.peek())
          : oe === "@" ||
            oe === "%" ||
            oe === "|" ||
            oe === ":" ||
            oe === "." ||
            oe === Cr ||
            !oe
          ? !1
          : oe === Rt
          ? (A.peek(), G())
          : H(A, !1);
      },
      Me = G();
    return A.resetPeek(), Me;
  }
  function P(A) {
    m(A);
    const E = A.currentPeek() === "|";
    return A.resetPeek(), E;
  }
  function z(A) {
    const E = m(A),
      B = A.currentPeek() === "%" && A.peek() === "{";
    return (
      A.resetPeek(),
      {
        isModulo: B,
        hasSpace: E.length > 0,
      }
    );
  }
  function H(A, E = !0) {
    const B = (Me = !1, oe = "", L = !1) => {
        const F = A.currentPeek();
        return F === "{"
          ? oe === "%"
            ? !1
            : Me
          : F === "@" || !F
          ? oe === "%"
            ? !0
            : Me
          : F === "%"
          ? (A.peek(), B(Me, "%", !0))
          : F === "|"
          ? oe === "%" || L
            ? !0
            : !(oe === Cr || oe === Rt)
          : F === Cr
          ? (A.peek(), B(!0, Cr, L))
          : F === Rt
          ? (A.peek(), B(!0, Rt, L))
          : !0;
      },
      G = B();
    return E && A.resetPeek(), G;
  }
  function U(A, E) {
    const B = A.currentChar();
    return B === Jr ? Jr : E(B) ? (A.next(), B) : null;
  }
  function re(A) {
    const E = A.charCodeAt(0);
    return (
      (E >= 97 && E <= 122) || // a-z
      (E >= 65 && E <= 90) || // A-Z
      (E >= 48 && E <= 57) || // 0-9
      E === 95 || // _
      E === 36
    );
  }
  function te(A) {
    return U(A, re);
  }
  function Q(A) {
    const E = A.charCodeAt(0);
    return (
      (E >= 97 && E <= 122) || // a-z
      (E >= 65 && E <= 90) || // A-Z
      (E >= 48 && E <= 57) || // 0-9
      E === 95 || // _
      E === 36 || // $
      E === 45
    );
  }
  function ne(A) {
    return U(A, Q);
  }
  function fe(A) {
    const E = A.charCodeAt(0);
    return E >= 48 && E <= 57;
  }
  function Le(A) {
    return U(A, fe);
  }
  function We(A) {
    const E = A.charCodeAt(0);
    return (
      (E >= 48 && E <= 57) || // 0-9
      (E >= 65 && E <= 70) || // A-F
      (E >= 97 && E <= 102)
    );
  }
  function Ee(A) {
    return U(A, We);
  }
  function ze(A) {
    let E = "",
      B = "";
    for (; (E = Le(A)); ) B += E;
    return B;
  }
  function Ge(A) {
    g(A);
    const E = A.currentChar();
    return E !== "%" && d(ie.EXPECTED_TOKEN, i(), 0, E), A.next(), "%";
  }
  function Qe(A) {
    let E = "";
    for (;;) {
      const B = A.currentChar();
      if (B === "{" || B === "}" || B === "@" || B === "|" || !B) break;
      if (B === "%")
        if (H(A)) (E += B), A.next();
        else break;
      else if (B === Cr || B === Rt)
        if (H(A)) (E += B), A.next();
        else {
          if (P(A)) break;
          (E += B), A.next();
        }
      else (E += B), A.next();
    }
    return E;
  }
  function He(A) {
    g(A);
    let E = "",
      B = "";
    for (; (E = ne(A)); ) B += E;
    return (
      A.currentChar() === Jr && d(ie.UNTERMINATED_CLOSING_BRACE, i(), 0), B
    );
  }
  function qe(A) {
    g(A);
    let E = "";
    return (
      A.currentChar() === "-" ? (A.next(), (E += `-${ze(A)}`)) : (E += ze(A)),
      A.currentChar() === Jr && d(ie.UNTERMINATED_CLOSING_BRACE, i(), 0),
      E
    );
  }
  function yt(A) {
    return A !== dm && A !== Rt;
  }
  function nt(A) {
    g(A), h(A, "'");
    let E = "",
      B = "";
    for (; (E = U(A, yt)); ) E === "\\" ? (B += Ct(A)) : (B += E);
    const G = A.currentChar();
    return G === Rt || G === Jr
      ? (d(ie.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0),
        G === Rt && (A.next(), h(A, "'")),
        B)
      : (h(A, "'"), B);
  }
  function Ct(A) {
    const E = A.currentChar();
    switch (E) {
      case "\\":
      case "'":
        return A.next(), `\\${E}`;
      case "u":
        return ut(A, E, 4);
      case "U":
        return ut(A, E, 6);
      default:
        return d(ie.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, E), "";
    }
  }
  function ut(A, E, B) {
    h(A, E);
    let G = "";
    for (let Me = 0; Me < B; Me++) {
      const oe = Ee(A);
      if (!oe) {
        d(
          ie.INVALID_UNICODE_ESCAPE_SEQUENCE,
          i(),
          0,
          `\\${E}${G}${A.currentChar()}`
        );
        break;
      }
      G += oe;
    }
    return `\\${E}${G}`;
  }
  function nn(A) {
    return A !== "{" && A !== "}" && A !== Cr && A !== Rt;
  }
  function Rn(A) {
    g(A);
    let E = "",
      B = "";
    for (; (E = U(A, nn)); ) B += E;
    return B;
  }
  function wr(A) {
    let E = "",
      B = "";
    for (; (E = te(A)); ) B += E;
    return B;
  }
  function qr(A) {
    const E = (B) => {
      const G = A.currentChar();
      return G === "{" ||
        G === "%" ||
        G === "@" ||
        G === "|" ||
        G === "(" ||
        G === ")" ||
        !G ||
        G === Cr
        ? B
        : ((B += G), A.next(), E(B));
    };
    return E("");
  }
  function Qn(A) {
    g(A);
    const E = h(
      A,
      "|"
      /* TokenChars.Pipe */
    );
    return g(A), E;
  }
  function fn(A, E) {
    let B = null;
    switch (A.currentChar()) {
      case "{":
        return (
          E.braceNest >= 1 && d(ie.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0),
          A.next(),
          (B = f(
            E,
            2,
            "{"
            /* TokenChars.BraceLeft */
          )),
          g(A),
          E.braceNest++,
          B
        );
      case "}":
        return (
          E.braceNest > 0 &&
            E.currentType === 2 &&
            d(ie.EMPTY_PLACEHOLDER, i(), 0),
          A.next(),
          (B = f(
            E,
            3,
            "}"
            /* TokenChars.BraceRight */
          )),
          E.braceNest--,
          E.braceNest > 0 && g(A),
          E.inLinked && E.braceNest === 0 && (E.inLinked = !1),
          B
        );
      case "@":
        return (
          E.braceNest > 0 && d(ie.UNTERMINATED_CLOSING_BRACE, i(), 0),
          (B = pn(A, E) || p(E)),
          (E.braceNest = 0),
          B
        );
      default: {
        let Me = !0,
          oe = !0,
          L = !0;
        if (P(A))
          return (
            E.braceNest > 0 && d(ie.UNTERMINATED_CLOSING_BRACE, i(), 0),
            (B = f(E, 1, Qn(A))),
            (E.braceNest = 0),
            (E.inLinked = !1),
            B
          );
        if (
          E.braceNest > 0 &&
          (E.currentType === 5 || E.currentType === 6 || E.currentType === 7)
        )
          return (
            d(ie.UNTERMINATED_CLOSING_BRACE, i(), 0),
            (E.braceNest = 0),
            er(A, E)
          );
        if ((Me = v(A, E))) return (B = f(E, 5, He(A))), g(A), B;
        if ((oe = y(A, E))) return (B = f(E, 6, qe(A))), g(A), B;
        if ((L = w(A, E))) return (B = f(E, 7, nt(A))), g(A), B;
        if (!Me && !oe && !L)
          return (
            (B = f(E, 13, Rn(A))),
            d(ie.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, B.value),
            g(A),
            B
          );
        break;
      }
    }
    return B;
  }
  function pn(A, E) {
    const { currentType: B } = E;
    let G = null;
    const Me = A.currentChar();
    switch (
      ((B === 8 || B === 9 || B === 12 || B === 10) &&
        (Me === Rt || Me === Cr) &&
        d(ie.INVALID_LINKED_FORMAT, i(), 0),
      Me)
    ) {
      case "@":
        return (
          A.next(),
          (G = f(
            E,
            8,
            "@"
            /* TokenChars.LinkedAlias */
          )),
          (E.inLinked = !0),
          G
        );
      case ".":
        return (
          g(A),
          A.next(),
          f(
            E,
            9,
            "."
            /* TokenChars.LinkedDot */
          )
        );
      case ":":
        return (
          g(A),
          A.next(),
          f(
            E,
            10,
            ":"
            /* TokenChars.LinkedDelimiter */
          )
        );
      default:
        return P(A)
          ? ((G = f(E, 1, Qn(A))), (E.braceNest = 0), (E.inLinked = !1), G)
          : x(A, E) || N(A, E)
          ? (g(A), pn(A, E))
          : M(A, E)
          ? (g(A), f(E, 12, wr(A)))
          : T(A, E)
          ? (g(A), Me === "{" ? fn(A, E) || G : f(E, 11, qr(A)))
          : (B === 8 && d(ie.INVALID_LINKED_FORMAT, i(), 0),
            (E.braceNest = 0),
            (E.inLinked = !1),
            er(A, E));
    }
  }
  function er(A, E) {
    let B = {
      type: 14,
      /* TokenTypes.EOF */
    };
    if (E.braceNest > 0) return fn(A, E) || p(E);
    if (E.inLinked) return pn(A, E) || p(E);
    switch (A.currentChar()) {
      case "{":
        return fn(A, E) || p(E);
      case "}":
        return (
          d(ie.UNBALANCED_CLOSING_BRACE, i(), 0),
          A.next(),
          f(
            E,
            3,
            "}"
            /* TokenChars.BraceRight */
          )
        );
      case "@":
        return pn(A, E) || p(E);
      default: {
        if (P(A))
          return (B = f(E, 1, Qn(A))), (E.braceNest = 0), (E.inLinked = !1), B;
        const { isModulo: Me, hasSpace: oe } = z(A);
        if (Me) return oe ? f(E, 0, Qe(A)) : f(E, 4, Ge(A));
        if (H(A)) return f(E, 0, Qe(A));
        break;
      }
    }
    return B;
  }
  function Kr() {
    const { currentType: A, offset: E, startLoc: B, endLoc: G } = l;
    return (
      (l.lastType = A),
      (l.lastOffset = E),
      (l.lastStartLoc = B),
      (l.lastEndLoc = G),
      (l.offset = o()),
      (l.startLoc = i()),
      r.currentChar() === Jr
        ? f(
            l,
            14
            /* TokenTypes.EOF */
          )
        : er(r, l)
    );
  }
  return {
    nextToken: Kr,
    currentOffset: o,
    currentPosition: i,
    context: u,
  };
}
const dw = "parser",
  fw = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function pw(t, e, n) {
  switch (t) {
    case "\\\\":
      return "\\";
    // eslint-disable-next-line no-useless-escape
    case "\\'":
      return "'";
    default: {
      const r = parseInt(e || n, 16);
      return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "";
    }
  }
}
function hw(t = {}) {
  const e = t.location !== !1,
    { onError: n, onWarn: r } = t;
  function o(v, y, w, x, ...M) {
    const N = v.currentPosition();
    if (((N.offset += x), (N.column += x), n)) {
      const T = e ? ou(w, N) : null,
        P = ts(y, T, {
          domain: dw,
          args: M,
        });
      n(P);
    }
  }
  function i(v, y, w, x, ...M) {
    const N = v.currentPosition();
    if (((N.offset += x), (N.column += x), r)) {
      const T = e ? ou(w, N) : null;
      r(tw(y, T, M));
    }
  }
  function s(v, y, w) {
    const x = { type: v };
    return e && ((x.start = y), (x.end = y), (x.loc = { start: w, end: w })), x;
  }
  function a(v, y, w, x) {
    e && ((v.end = y), v.loc && (v.loc.end = w));
  }
  function l(v, y) {
    const w = v.context(),
      x = s(3, w.offset, w.startLoc);
    return (x.value = y), a(x, v.currentOffset(), v.currentPosition()), x;
  }
  function u(v, y) {
    const w = v.context(),
      { lastOffset: x, lastStartLoc: M } = w,
      N = s(5, x, M);
    return (
      (N.index = parseInt(y, 10)),
      v.nextToken(),
      a(N, v.currentOffset(), v.currentPosition()),
      N
    );
  }
  function c(v, y, w) {
    const x = v.context(),
      { lastOffset: M, lastStartLoc: N } = x,
      T = s(4, M, N);
    return (
      (T.key = y),
      w === !0 && (T.modulo = !0),
      v.nextToken(),
      a(T, v.currentOffset(), v.currentPosition()),
      T
    );
  }
  function d(v, y) {
    const w = v.context(),
      { lastOffset: x, lastStartLoc: M } = w,
      N = s(9, x, M);
    return (
      (N.value = y.replace(fw, pw)),
      v.nextToken(),
      a(N, v.currentOffset(), v.currentPosition()),
      N
    );
  }
  function f(v) {
    const y = v.nextToken(),
      w = v.context(),
      { lastOffset: x, lastStartLoc: M } = w,
      N = s(8, x, M);
    return y.type !== 12
      ? (o(v, ie.UNEXPECTED_EMPTY_LINKED_MODIFIER, w.lastStartLoc, 0),
        (N.value = ""),
        a(N, x, M),
        {
          nextConsumeToken: y,
          node: N,
        })
      : (y.value == null &&
          o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, In(y)),
        (N.value = y.value || ""),
        a(N, v.currentOffset(), v.currentPosition()),
        {
          node: N,
        });
  }
  function p(v, y) {
    const w = v.context(),
      x = s(7, w.offset, w.startLoc);
    return (x.value = y), a(x, v.currentOffset(), v.currentPosition()), x;
  }
  function h(v) {
    const y = v.context(),
      w = s(6, y.offset, y.startLoc);
    let x = v.nextToken();
    if (x.type === 9) {
      const M = f(v);
      (w.modifier = M.node), (x = M.nextConsumeToken || v.nextToken());
    }
    switch (
      (x.type !== 10 &&
        o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(x)),
      (x = v.nextToken()),
      x.type === 2 && (x = v.nextToken()),
      x.type)
    ) {
      case 11:
        x.value == null &&
          o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(x)),
          (w.key = p(v, x.value || ""));
        break;
      case 5:
        x.value == null &&
          o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(x)),
          (w.key = c(v, x.value || ""));
        break;
      case 6:
        x.value == null &&
          o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(x)),
          (w.key = u(v, x.value || ""));
        break;
      case 7:
        x.value == null &&
          o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(x)),
          (w.key = d(v, x.value || ""));
        break;
      default: {
        o(v, ie.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
        const M = v.context(),
          N = s(7, M.offset, M.startLoc);
        return (
          (N.value = ""),
          a(N, M.offset, M.startLoc),
          (w.key = N),
          a(w, M.offset, M.startLoc),
          {
            nextConsumeToken: x,
            node: w,
          }
        );
      }
    }
    return (
      a(w, v.currentOffset(), v.currentPosition()),
      {
        node: w,
      }
    );
  }
  function m(v) {
    const y = v.context(),
      w = y.currentType === 1 ? v.currentOffset() : y.offset,
      x = y.currentType === 1 ? y.endLoc : y.startLoc,
      M = s(2, w, x);
    M.items = [];
    let N = null,
      T = null;
    do {
      const H = N || v.nextToken();
      switch (((N = null), H.type)) {
        case 0:
          H.value == null &&
            o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(H)),
            M.items.push(l(v, H.value || ""));
          break;
        case 6:
          H.value == null &&
            o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(H)),
            M.items.push(u(v, H.value || ""));
          break;
        case 4:
          T = !0;
          break;
        case 5:
          H.value == null &&
            o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(H)),
            M.items.push(c(v, H.value || "", !!T)),
            T &&
              (i(v, kh.USE_MODULO_SYNTAX, y.lastStartLoc, 0, In(H)),
              (T = null));
          break;
        case 7:
          H.value == null &&
            o(v, ie.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, In(H)),
            M.items.push(d(v, H.value || ""));
          break;
        case 8: {
          const U = h(v);
          M.items.push(U.node), (N = U.nextConsumeToken || null);
          break;
        }
      }
    } while (y.currentType !== 14 && y.currentType !== 1);
    const P = y.currentType === 1 ? y.lastOffset : v.currentOffset(),
      z = y.currentType === 1 ? y.lastEndLoc : v.currentPosition();
    return a(M, P, z), M;
  }
  function g(v, y, w, x) {
    const M = v.context();
    let N = x.items.length === 0;
    const T = s(1, y, w);
    (T.cases = []), T.cases.push(x);
    do {
      const P = m(v);
      N || (N = P.items.length === 0), T.cases.push(P);
    } while (M.currentType !== 14);
    return (
      N && o(v, ie.MUST_HAVE_MESSAGES_IN_PLURAL, w, 0),
      a(T, v.currentOffset(), v.currentPosition()),
      T
    );
  }
  function b(v) {
    const y = v.context(),
      { offset: w, startLoc: x } = y,
      M = m(v);
    return y.currentType === 14 ? M : g(v, w, x, M);
  }
  function _(v) {
    const y = cw(v, Vb({}, t)),
      w = y.context(),
      x = s(0, w.offset, w.startLoc);
    return (
      e && x.loc && (x.loc.source = v),
      (x.body = b(y)),
      t.onCacheKey && (x.cacheKey = t.onCacheKey(v)),
      w.currentType !== 14 &&
        o(
          y,
          ie.UNEXPECTED_LEXICAL_ANALYSIS,
          w.lastStartLoc,
          0,
          v[w.offset] || ""
        ),
      a(x, y.currentOffset(), y.currentPosition()),
      x
    );
  }
  return { parse: _ };
}
function In(t) {
  if (t.type === 14) return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "" : e;
}
function mw(t, e = {}) {
  const n = {
    ast: t,
    helpers: /* @__PURE__ */ new Set(),
  };
  return { context: () => n, helper: (i) => (n.helpers.add(i), i) };
}
function fm(t, e) {
  for (let n = 0; n < t.length; n++) wh(t[n], e);
}
function wh(t, e) {
  switch (t.type) {
    case 1:
      fm(t.cases, e),
        e.helper(
          "plural"
          /* HelperNameMap.PLURAL */
        );
      break;
    case 2:
      fm(t.items, e);
      break;
    case 6: {
      wh(t.key, e),
        e.helper(
          "linked"
          /* HelperNameMap.LINKED */
        ),
        e.helper(
          "type"
          /* HelperNameMap.TYPE */
        );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ),
        e.helper(
          "list"
          /* HelperNameMap.LIST */
        );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ),
        e.helper(
          "named"
          /* HelperNameMap.NAMED */
        );
      break;
  }
}
function gw(t, e = {}) {
  const n = mw(t);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ),
    t.body && wh(t.body, n);
  const r = n.context();
  t.helpers = Array.from(r.helpers);
}
function bw(t) {
  const e = t.body;
  return e.type === 2 ? pm(e) : e.cases.forEach((n) => pm(n)), t;
}
function pm(t) {
  if (t.items.length === 1) {
    const e = t.items[0];
    (e.type === 3 || e.type === 9) && ((t.static = e.value), delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t.items.length; n++) {
      const r = t.items[n];
      if (!(r.type === 3 || r.type === 9) || r.value == null) break;
      e.push(r.value);
    }
    if (e.length === t.items.length) {
      t.static = Ub(e);
      for (let n = 0; n < t.items.length; n++) {
        const r = t.items[n];
        (r.type === 3 || r.type === 9) && delete r.value;
      }
    }
  }
}
const yw = "minifier";
function Si(t) {
  switch (((t.t = t.type), t.type)) {
    case 0: {
      const e = t;
      Si(e.body), (e.b = e.body), delete e.body;
      break;
    }
    case 1: {
      const e = t,
        n = e.cases;
      for (let r = 0; r < n.length; r++) Si(n[r]);
      (e.c = n), delete e.cases;
      break;
    }
    case 2: {
      const e = t,
        n = e.items;
      for (let r = 0; r < n.length; r++) Si(n[r]);
      (e.i = n),
        delete e.items,
        e.static && ((e.s = e.static), delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t;
      e.value && ((e.v = e.value), delete e.value);
      break;
    }
    case 6: {
      const e = t;
      Si(e.key),
        (e.k = e.key),
        delete e.key,
        e.modifier && (Si(e.modifier), (e.m = e.modifier), delete e.modifier);
      break;
    }
    case 5: {
      const e = t;
      (e.i = e.index), delete e.index;
      break;
    }
    case 4: {
      const e = t;
      (e.k = e.key), delete e.key;
      break;
    }
    default:
      throw ts(ie.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: yw,
        args: [t.type],
      });
  }
  delete t.type;
}
const vw = "parser";
function _w(t, e) {
  const { sourceMap: n, filename: r, breakLineCode: o, needIndent: i } = e,
    s = e.location !== !1,
    a = {
      filename: r,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: o,
      needIndent: i,
      indentLevel: 0,
    };
  s && t.loc && (a.source = t.loc.source);
  const l = () => a;
  function u(g, b) {
    a.code += g;
  }
  function c(g, b = !0) {
    const _ = b ? o : "";
    u(i ? _ + "  ".repeat(g) : _);
  }
  function d(g = !0) {
    const b = ++a.indentLevel;
    g && c(b);
  }
  function f(g = !0) {
    const b = --a.indentLevel;
    g && c(b);
  }
  function p() {
    c(a.indentLevel);
  }
  return {
    context: l,
    push: u,
    indent: d,
    deindent: f,
    newline: p,
    helper: (g) => `_${g}`,
    needIndent: () => a.needIndent,
  };
}
function xw(t, e) {
  const { helper: n } = t;
  t.push(
    `${n(
      "linked"
      /* HelperNameMap.LINKED */
    )}(`
  ),
    zi(t, e.key),
    e.modifier
      ? (t.push(", "), zi(t, e.modifier), t.push(", _type"))
      : t.push(", undefined, _type"),
    t.push(")");
}
function kw(t, e) {
  const { helper: n, needIndent: r } = t;
  t.push(
    `${n(
      "normalize"
      /* HelperNameMap.NORMALIZE */
    )}([`
  ),
    t.indent(r());
  const o = e.items.length;
  for (let i = 0; i < o && (zi(t, e.items[i]), i !== o - 1); i++) t.push(", ");
  t.deindent(r()), t.push("])");
}
function ww(t, e) {
  const { helper: n, needIndent: r } = t;
  if (e.cases.length > 1) {
    t.push(
      `${n(
        "plural"
        /* HelperNameMap.PLURAL */
      )}([`
    ),
      t.indent(r());
    const o = e.cases.length;
    for (let i = 0; i < o && (zi(t, e.cases[i]), i !== o - 1); i++)
      t.push(", ");
    t.deindent(r()), t.push("])");
  }
}
function Cw(t, e) {
  e.body ? zi(t, e.body) : t.push("null");
}
function zi(t, e) {
  const { helper: n } = t;
  switch (e.type) {
    case 0:
      Cw(t, e);
      break;
    case 1:
      ww(t, e);
      break;
    case 2:
      kw(t, e);
      break;
    case 6:
      xw(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(
        `${n(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${n(
          "list"
          /* HelperNameMap.LIST */
        )}(${e.index}))`,
        e
      );
      break;
    case 4:
      t.push(
        `${n(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${n(
          "named"
          /* HelperNameMap.NAMED */
        )}(${JSON.stringify(e.key)}))`,
        e
      );
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      throw ts(ie.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: vw,
        args: [e.type],
      });
  }
}
const Aw = (t, e = {}) => {
  const n = cm(e.mode) ? e.mode : "normal",
    r = cm(e.filename) ? e.filename : "message.intl",
    o = !!e.sourceMap,
    i =
      e.breakLineCode != null
        ? e.breakLineCode
        : n === "arrow"
        ? ";"
        : `
`,
    s = e.needIndent ? e.needIndent : n !== "arrow",
    a = t.helpers || [],
    l = _w(t, {
      mode: n,
      filename: r,
      sourceMap: o,
      breakLineCode: i,
      needIndent: s,
    });
  l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"),
    l.indent(s),
    a.length > 0 &&
      (l.push(
        `const { ${Ub(
          a.map((d) => `${d}: _${d}`),
          ", "
        )} } = ctx`
      ),
      l.newline()),
    l.push("return "),
    zi(l, t),
    l.deindent(s),
    l.push("}"),
    delete t.helpers;
  const { code: u, map: c } = l.context();
  return {
    ast: t,
    code: u,
    map: c ? c.toJSON() : void 0,
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function Sw(t, e = {}) {
  const n = Vb({}, e),
    r = !!n.jit,
    o = !!n.minify,
    i = n.optimize == null ? !0 : n.optimize,
    a = hw(n).parse(t);
  return r
    ? (i && bw(a), o && Si(a), { ast: a, code: "" })
    : (gw(a, n), Aw(a, n));
}
var Ew = {
  LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
  COREPACK_ROOT:
    "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
  WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
  npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
  TERM_PROGRAM: "vscode",
  npm_package_scripts_prettier:
    "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
  npm_package_dependencies__tiptap_extension_link: "^2.11.2",
  npm_package_scripts_test_unit_coverage:
    "vitest run --environment jsdom --coverage",
  NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
  ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
  WASMER_DIR: "/Users/ryanwang/.wasmer",
  _P9K_TTY: "/dev/ttys005",
  npm_package_homepage:
    "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
  npm_package_dependencies__tiptap_vue_3: "^2.11.2",
  INIT_CWD:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  SHELL: "/bin/zsh",
  TERM: "xterm-256color",
  npm_package_unpkg: "./dist/rich-text-editor.iife.js",
  npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
  npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
  TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
  CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
  npm_package_dependencies_linkifyjs: "^4.1.3",
  npm_package_scripts_lint:
    "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
  npm_package_scripts_release: "release-it",
  TERM_PROGRAM_VERSION: "0.48.7",
  npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
  npm_package_dependencies_floating_vue: "^5.2.2",
  npm_package_scripts_dev: "vite",
  MallocNanoZone: "0",
  ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
  CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
  ZDOTDIR: "/Users/ryanwang",
  npm_package_dependencies__tiptap_extension_document: "^2.11.2",
  npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
  SDKMAN_PLATFORM: "darwinarm64",
  npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
  npm_config_registry: "https://registry.npmjs.org/",
  ZSH: "/Users/ryanwang/.oh-my-zsh",
  PNPM_HOME: "/Users/ryanwang/Library/pnpm",
  npm_package_repository_url: "https://github.com/halo-dev/halo.git",
  npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
  npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
  npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
  npm_package_scripts_test_unit_ui: "vitest --environment jsdom --watch --ui",
  npm_package_dependencies__tiptap_pm: "^2.11.2",
  USER: "ryanwang",
  DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
  npm_package_description: "Default editor for Halo",
  LS_COLORS:
    "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
  npm_package_license: "GPL-3.0",
  COMMAND_MODE: "unix2003",
  npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
  SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
  npm_package_exports___import: "./dist/rich-text-editor.es.js",
  PNPM_SCRIPT_SRC_DIR:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  npm_package_repository_directory: "ui/packages/editor",
  npm_package_dependencies__tiptap_extension_history: "^2.11.2",
  npm_config_strict_peer_dependencies: "",
  SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
  __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
  npm_execpath:
    "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
  PAGER: "less",
  npm_package_module: "./dist/rich-text-editor.es.js",
  npm_package_dependencies__tiptap_extension_text: "^2.11.2",
  LSCOLORS: "Gxfxcxdxbxegedabagacad",
  npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
  npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
  npm_config_frozen_lockfile: "",
  npm_package_dependencies__tiptap_extension_horizontal_rule: "^2.11.2",
  npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
  npm_package_devDependencies__types_linkifyjs: "^2.1.7",
  PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
  MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
  npm_package_devDependencies_release_it: "^16.1.5",
  npm_package_scripts_typecheck:
    "vue-tsc --noEmit -p tsconfig.app.json --composite false",
  npm_package_peerDependencies_vue: "^3.5.13",
  __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
  USER_ZDOTDIR: "/Users/ryanwang",
  COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
  npm_package_author: "@halo-dev",
  npm_package_dependencies__ckpack_vue_color: "^1.5.0",
  npm_config_auto_install_peers: "true",
  PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  npm_command: "run-script",
  JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
  VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
  npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
  npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
  EDITOR: "nvim",
  P9K_SSH: "0",
  npm_lifecycle_event: "build",
  LANG: "en_US.UTF-8",
  P9K_TTY: "old",
  npm_package_name: "@halo-dev/richtext-editor",
  npm_package_repository_type: "git",
  npm_package_types: "./dist/index.d.ts",
  npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
  npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
  npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
  npm_package_dependencies__tiptap_suggestion: "^2.11.2",
  NODE_PATH:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
  npm_package_exports___types: "./dist/index.d.ts",
  npm_package_scripts_build: "vite build --config ./vite.lib.config.ts",
  XPC_FLAGS: "0x0",
  VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
  npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
  npm_package_dependencies_tippy_js: "^6.3.7",
  npm_package_main: "./dist/rich-text-editor.iife.js",
  npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
  npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
  npm_config_node_gyp:
    "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
  XPC_SERVICE_NAME: "0",
  npm_package_version: "2.20.0",
  npm_package_devDependencies__iconify_json: "^2.2.117",
  VSCODE_INJECTION: "1",
  npm_package_dependencies__tiptap_core: "^2.11.2",
  npm_package_dependencies__tiptap_extension_code: "^2.11.2",
  HOME: "/Users/ryanwang",
  SHLVL: "2",
  npm_package_exports___dist_style_css: "./dist/style.css",
  VSCODE_GIT_ASKPASS_MAIN:
    "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
  npm_package_dependencies__tiptap_extension_image: "^2.11.2",
  npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
  npm_package_dependencies_github_markdown_css: "^5.2.0",
  npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
  npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
  LOGNAME: "ryanwang",
  LESS: "-R",
  SDKMAN_DIR: "/Users/ryanwang/.sdkman",
  npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
  VSCODE_GIT_IPC_HANDLE:
    "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
  npm_package_dependencies__tiptap_extension_table: "^2.11.2",
  npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
  BUN_INSTALL: "/Users/ryanwang/.bun",
  npm_package_scripts_test_unit_watch: "vitest --environment jsdom --watch",
  npm_package_dependencies__tiptap_extension_color: "^2.11.2",
  npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
  npm_config_user_agent: "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
  SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
  GIT_ASKPASS:
    "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
  VSCODE_GIT_ASKPASS_NODE:
    "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
  _P9K_SSH_TTY: "/dev/ttys005",
  npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
  npm_package_files_0: "dist",
  npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
  OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
  COLORTERM: "truecolor",
  npm_node_execpath: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
  NODE_ENV: "production",
};
function Mw() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" &&
    (xh().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const Mo = [];
Mo[0] =
/* States.BEFORE_PATH */
  {
    w: [
      0,
      /* States.BEFORE_PATH */
    ],
    i: [
      3, 0,
      /* Actions.APPEND */
    ],
    "[": [
      4,
      /* States.IN_SUB_PATH */
    ],
    o: [
      7,
      /* States.AFTER_PATH */
    ],
  };
Mo[1] =
/* States.IN_PATH */
  {
    w: [
      1,
      /* States.IN_PATH */
    ],
    ".": [
      2,
      /* States.BEFORE_IDENT */
    ],
    "[": [
      4,
      /* States.IN_SUB_PATH */
    ],
    o: [
      7,
      /* States.AFTER_PATH */
    ],
  };
Mo[2] =
/* States.BEFORE_IDENT */
  {
    w: [
      2,
      /* States.BEFORE_IDENT */
    ],
    i: [
      3, 0,
      /* Actions.APPEND */
    ],
    0: [
      3, 0,
      /* Actions.APPEND */
    ],
  };
Mo[3] =
/* States.IN_IDENT */
  {
    i: [
      3, 0,
      /* Actions.APPEND */
    ],
    0: [
      3, 0,
      /* Actions.APPEND */
    ],
    w: [
      1, 1,
      /* Actions.PUSH */
    ],
    ".": [
      2, 1,
      /* Actions.PUSH */
    ],
    "[": [
      4, 1,
      /* Actions.PUSH */
    ],
    o: [
      7, 1,
      /* Actions.PUSH */
    ],
  };
Mo[4] =
/* States.IN_SUB_PATH */
  {
    "'": [
      5, 0,
      /* Actions.APPEND */
    ],
    '"': [
      6, 0,
      /* Actions.APPEND */
    ],
    "[": [
      4, 2,
      /* Actions.INC_SUB_PATH_DEPTH */
    ],
    "]": [
      1, 3,
      /* Actions.PUSH_SUB_PATH */
    ],
    o: 8,
    l: [
      4, 0,
      /* Actions.APPEND */
    ],
  };
Mo[5] =
/* States.IN_SINGLE_QUOTE */
  {
    "'": [
      4, 0,
      /* Actions.APPEND */
    ],
    o: 8,
    l: [
      5, 0,
      /* Actions.APPEND */
    ],
  };
Mo[6] =
/* States.IN_DOUBLE_QUOTE */
  {
    '"': [
      4, 0,
      /* Actions.APPEND */
    ],
    o: 8,
    l: [
      6, 0,
      /* Actions.APPEND */
    ],
  };
const Tw = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function Ow(t) {
  return Tw.test(t);
}
function Dw(t) {
  const e = t.charCodeAt(0),
    n = t.charCodeAt(t.length - 1);
  return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function Nw(t) {
  if (t == null) return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return t;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function Lw(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t))
    ? !1
    : Ow(e)
    ? Dw(e)
    : "*" + e;
}
function Rw(t) {
  const e = [];
  let n = -1,
    r = 0,
    o = 0,
    i,
    s,
    a,
    l,
    u,
    c,
    d;
  const f = [];
  (f[0] =
  /* Actions.APPEND */
    () => {
      s === void 0 ? (s = a) : (s += a);
    }),
    (f[1] =
    /* Actions.PUSH */
      () => {
        s !== void 0 && (e.push(s), (s = void 0));
      }),
    (f[2] =
    /* Actions.INC_SUB_PATH_DEPTH */
      () => {
        f[0](),
        /* Actions.APPEND */
          o++;
      }),
    (f[3] =
    /* Actions.PUSH_SUB_PATH */
      () => {
        if (o > 0)
          o--,
            (r = 4),
            f[0]();
            /* Actions.APPEND */
        else {
          if (((o = 0), s === void 0 || ((s = Lw(s)), s === !1))) return !1;
          f[1]();
          /* Actions.PUSH */
        }
      });
  function p() {
    const h = t[n + 1];
    if ((r === 5 && h === "'") || (r === 6 && h === '"'))
      return (
        n++,
        (a = "\\" + h),
        f[0](),
        /* Actions.APPEND */
        !0
      );
  }
  for (; r !== null; )
    if ((n++, (i = t[n]), !(i === "\\" && p()))) {
      if (
        ((l = Nw(i)),
        (d = Mo[r]),
        (u = d[l] || d.l || 8),
        u === 8 ||
          ((r = u[0]),
          u[1] !== void 0 && ((c = f[u[1]]), c && ((a = i), c() === !1))))
      )
        return;
      if (r === 7) return e;
    }
}
const hm = /* @__PURE__ */ new Map();
function Iw(t, e) {
  return Se(t) ? t[e] : null;
}
function Pw(t, e) {
  if (!Se(t)) return null;
  let n = hm.get(e);
  if ((n || ((n = Rw(e)), n && hm.set(e, n)), !n)) return null;
  const r = n.length;
  let o = t,
    i = 0;
  for (; i < r; ) {
    const s = o[n[i]];
    if (s === void 0 || tt(o)) return null;
    (o = s), i++;
  }
  return o;
}
const $w = (t) => t,
  Bw = (t) => "",
  Hw = "text",
  Fw = (t) => (t.length === 0 ? "" : Jk(t)),
  zw = Gk;
function mm(t, e) {
  return (
    (t = Math.abs(t)),
    e === 2 ? (t ? (t > 1 ? 1 : 0) : 1) : t ? Math.min(t, 2) : 0
  );
}
function Vw(t) {
  const e = st(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (st(t.named.count) || st(t.named.n))
    ? st(t.named.count)
      ? t.named.count
      : st(t.named.n)
      ? t.named.n
      : e
    : e;
}
function Uw(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function jw(t = {}) {
  const e = t.locale,
    n = Vw(t),
    r =
      Se(t.pluralRules) && Y(e) && tt(t.pluralRules[e]) ? t.pluralRules[e] : mm,
    o = Se(t.pluralRules) && Y(e) && tt(t.pluralRules[e]) ? mm : void 0,
    i = (b) => b[r(n, b.length, o)],
    s = t.list || [],
    a = (b) => s[b],
    l = t.named || Be();
  st(t.pluralIndex) && Uw(n, l);
  const u = (b) => l[b];
  function c(b) {
    const _ = tt(t.messages)
      ? t.messages(b)
      : Se(t.messages)
      ? t.messages[b]
      : !1;
    return _ || (t.parent ? t.parent.message(b) : Bw);
  }
  const d = (b) => (t.modifiers ? t.modifiers[b] : $w),
    f =
      xe(t.processor) && tt(t.processor.normalize) ? t.processor.normalize : Fw,
    p =
      xe(t.processor) && tt(t.processor.interpolate)
        ? t.processor.interpolate
        : zw,
    h = xe(t.processor) && Y(t.processor.type) ? t.processor.type : Hw,
    g = {
      list: a,
      named: u,
      plural: i,
      linked: (b, ..._) => {
        const [v, y] = _;
        let w = "text",
          x = "";
        _.length === 1
          ? Se(v)
            ? ((x = v.modifier || x), (w = v.type || w))
            : Y(v) && (x = v || x)
          : _.length === 2 && (Y(v) && (x = v || x), Y(y) && (w = y || w));
        const M = c(b)(g),
          N =
            // The message in vnode resolved with linked are returned as an array by processor.nomalize
            w === "vnode" && ct(M) && x ? M[0] : M;
        return x ? d(x)(N, w) : N;
      },
      message: c,
      type: h,
      interpolate: p,
      normalize: f,
      values: Tt(Be(), s, l),
    };
  return g;
}
let Zs = null;
function Ww(t) {
  Zs = t;
}
function qw(t, e, n) {
  Zs &&
    Zs.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: t,
      version: e,
      meta: n,
    });
}
const Kw = /* @__PURE__ */ Gw(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function Gw(t) {
  return (e) => Zs && Zs.emit(t, e);
}
const jb = kh.__EXTEND_POINT__,
  $o = Fc(jb),
  Jw = {
    NOT_FOUND_KEY: jb,
    // 2
    FALLBACK_TO_TRANSLATE: $o(),
    // 3
    CANNOT_FORMAT_NUMBER: $o(),
    // 4
    FALLBACK_TO_NUMBER_FORMAT: $o(),
    // 5
    CANNOT_FORMAT_DATE: $o(),
    // 6
    FALLBACK_TO_DATE_FORMAT: $o(),
    // 7
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: $o(),
    // 8
    __EXTEND_POINT__: $o(),
    // 9
  },
  Wb = ie.__EXTEND_POINT__,
  Bo = Fc(Wb),
  ur = {
    INVALID_ARGUMENT: Wb,
    // 17
    INVALID_DATE_ARGUMENT: Bo(),
    // 18
    INVALID_ISO_DATE_ARGUMENT: Bo(),
    // 19
    NOT_SUPPORT_NON_STRING_MESSAGE: Bo(),
    // 20
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: Bo(),
    // 21
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: Bo(),
    // 22
    NOT_SUPPORT_LOCALE_TYPE: Bo(),
    // 23
    __EXTEND_POINT__: Bo(),
    // 24
  };
function Ir(t) {
  return ts(t, null, void 0);
}
function Ch(t, e) {
  return e.locale != null ? gm(e.locale) : gm(t.locale);
}
let Od;
function gm(t) {
  if (Y(t)) return t;
  if (tt(t)) {
    if (t.resolvedOnce && Od != null) return Od;
    if (t.constructor.name === "Function") {
      const e = t();
      if (Kk(e)) throw Ir(ur.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return (Od = e);
    } else throw Ir(ur.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else throw Ir(ur.NOT_SUPPORT_LOCALE_TYPE);
}
function Yw(t, e, n) {
  return [
    .../* @__PURE__ */ new Set([
      n,
      ...(ct(e) ? e : Se(e) ? Object.keys(e) : Y(e) ? [e] : [n]),
    ]),
  ];
}
function qb(t, e, n) {
  const r = Y(n) ? n : iu,
    o = t;
  o.__localeChainCache || (o.__localeChainCache = /* @__PURE__ */ new Map());
  let i = o.__localeChainCache.get(r);
  if (!i) {
    i = [];
    let s = [n];
    for (; ct(s); ) s = bm(i, s, e);
    const a = ct(e) || !xe(e) ? e : e.default ? e.default : null;
    (s = Y(a) ? [a] : a), ct(s) && bm(i, s, !1), o.__localeChainCache.set(r, i);
  }
  return i;
}
function bm(t, e, n) {
  let r = !0;
  for (let o = 0; o < e.length && Ye(r); o++) {
    const i = e[o];
    Y(i) && (r = Xw(t, e[o], n));
  }
  return r;
}
function Xw(t, e, n) {
  let r;
  const o = e.split("-");
  do {
    const i = o.join("-");
    (r = Zw(t, i, n)), o.splice(-1, 1);
  } while (o.length && r === !0);
  return r;
}
function Zw(t, e, n) {
  let r = !1;
  if (!t.includes(e) && ((r = !0), e)) {
    r = e[e.length - 1] !== "!";
    const o = e.replace(/!/g, "");
    t.push(o), (ct(n) || xe(n)) && n[o] && (r = n[o]);
  }
  return r;
}
const Qw = "9.14.2",
  zc = -1,
  iu = "en-US",
  ym = "",
  vm = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function e4() {
  return {
    upper: (t, e) =>
      e === "text" && Y(t)
        ? t.toUpperCase()
        : e === "vnode" && Se(t) && "__v_isVNode" in t
        ? t.children.toUpperCase()
        : t,
    lower: (t, e) =>
      e === "text" && Y(t)
        ? t.toLowerCase()
        : e === "vnode" && Se(t) && "__v_isVNode" in t
        ? t.children.toLowerCase()
        : t,
    capitalize: (t, e) =>
      e === "text" && Y(t)
        ? vm(t)
        : e === "vnode" && Se(t) && "__v_isVNode" in t
        ? vm(t.children)
        : t,
  };
}
let Kb;
function t4(t) {
  Kb = t;
}
let Gb;
function n4(t) {
  Gb = t;
}
let Jb;
function r4(t) {
  Jb = t;
}
let Yb = null;
const o4 = /* @__NO_SIDE_EFFECTS__ */ (t) => {
    Yb = t;
  },
  i4 = /* @__NO_SIDE_EFFECTS__ */ () => Yb;
let Xb = null;
const _m = (t) => {
    Xb = t;
  },
  s4 = () => Xb;
let xm = 0;
function a4(t = {}) {
  const e = tt(t.onWarn) ? t.onWarn : Yk,
    n = Y(t.version) ? t.version : Qw,
    r = Y(t.locale) || tt(t.locale) ? t.locale : iu,
    o = tt(r) ? iu : r,
    i =
      ct(t.fallbackLocale) ||
      xe(t.fallbackLocale) ||
      Y(t.fallbackLocale) ||
      t.fallbackLocale === !1
        ? t.fallbackLocale
        : o,
    s = xe(t.messages) ? t.messages : Dd(o),
    a = xe(t.datetimeFormats) ? t.datetimeFormats : Dd(o),
    l = xe(t.numberFormats) ? t.numberFormats : Dd(o),
    u = Tt(Be(), t.modifiers, e4()),
    c = t.pluralRules || Be(),
    d = tt(t.missing) ? t.missing : null,
    f = Ye(t.missingWarn) || ru(t.missingWarn) ? t.missingWarn : !0,
    p = Ye(t.fallbackWarn) || ru(t.fallbackWarn) ? t.fallbackWarn : !0,
    h = !!t.fallbackFormat,
    m = !!t.unresolving,
    g = tt(t.postTranslation) ? t.postTranslation : null,
    b = xe(t.processor) ? t.processor : null,
    _ = Ye(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
    v = !!t.escapeParameter,
    y = tt(t.messageCompiler) ? t.messageCompiler : Kb,
    w = tt(t.messageResolver) ? t.messageResolver : Gb || Iw,
    x = tt(t.localeFallbacker) ? t.localeFallbacker : Jb || Yw,
    M = Se(t.fallbackContext) ? t.fallbackContext : void 0,
    N = t,
    T = Se(N.__datetimeFormatters)
      ? N.__datetimeFormatters
      : /* @__PURE__ */ new Map(),
    P = Se(N.__numberFormatters)
      ? N.__numberFormatters
      : /* @__PURE__ */ new Map(),
    z = Se(N.__meta) ? N.__meta : {};
  xm++;
  const H = {
    version: n,
    cid: xm,
    locale: r,
    fallbackLocale: i,
    messages: s,
    modifiers: u,
    pluralRules: c,
    missing: d,
    missingWarn: f,
    fallbackWarn: p,
    fallbackFormat: h,
    unresolving: m,
    postTranslation: g,
    processor: b,
    warnHtmlMessage: _,
    escapeParameter: v,
    messageCompiler: y,
    messageResolver: w,
    localeFallbacker: x,
    fallbackContext: M,
    onWarn: e,
    __meta: z,
  };
  return (
    (H.datetimeFormats = a),
    (H.numberFormats = l),
    (H.__datetimeFormatters = T),
    (H.__numberFormatters = P),
    __INTLIFY_PROD_DEVTOOLS__ && qw(H, n, z),
    H
  );
}
const Dd = (t) => ({ [t]: Be() });
function Ah(t, e, n, r, o) {
  const { missing: i, onWarn: s } = t;
  if (i !== null) {
    const a = i(t, n, e, o);
    return Y(a) ? a : e;
  } else return e;
}
function cs(t, e, n) {
  const r = t;
  (r.__localeChainCache = /* @__PURE__ */ new Map()),
    t.localeFallbacker(t, n, e);
}
function l4(t, e) {
  return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
}
function u4(t, e) {
  const n = e.indexOf(t);
  if (n === -1) return !1;
  for (let r = n + 1; r < e.length; r++) if (l4(t, e[r])) return !0;
  return !1;
}
function Nd(t) {
  return (n) => c4(n, t);
}
function c4(t, e) {
  const n = f4(e);
  if (n == null)
    throw Qs(
      0
      /* NodeTypes.Resource */
    );
  if (Sh(n) === 1) {
    const i = h4(n);
    return t.plural(i.reduce((s, a) => [...s, km(t, a)], []));
  } else return km(t, n);
}
const d4 = ["b", "body"];
function f4(t) {
  return To(t, d4);
}
const p4 = ["c", "cases"];
function h4(t) {
  return To(t, p4, []);
}
function km(t, e) {
  const n = g4(e);
  if (n != null) return t.type === "text" ? n : t.normalize([n]);
  {
    const r = y4(e).reduce((o, i) => [...o, jf(t, i)], []);
    return t.normalize(r);
  }
}
const m4 = ["s", "static"];
function g4(t) {
  return To(t, m4);
}
const b4 = ["i", "items"];
function y4(t) {
  return To(t, b4, []);
}
function jf(t, e) {
  const n = Sh(e);
  switch (n) {
    case 3:
      return el(e, n);
    case 9:
      return el(e, n);
    case 4: {
      const r = e;
      if (zn(r, "k") && r.k) return t.interpolate(t.named(r.k));
      if (zn(r, "key") && r.key) return t.interpolate(t.named(r.key));
      throw Qs(n);
    }
    case 5: {
      const r = e;
      if (zn(r, "i") && st(r.i)) return t.interpolate(t.list(r.i));
      if (zn(r, "index") && st(r.index)) return t.interpolate(t.list(r.index));
      throw Qs(n);
    }
    case 6: {
      const r = e,
        o = k4(r),
        i = C4(r);
      return t.linked(jf(t, i), o ? jf(t, o) : void 0, t.type);
    }
    case 7:
      return el(e, n);
    case 8:
      return el(e, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`);
  }
}
const v4 = ["t", "type"];
function Sh(t) {
  return To(t, v4);
}
const _4 = ["v", "value"];
function el(t, e) {
  const n = To(t, _4);
  if (n) return n;
  throw Qs(e);
}
const x4 = ["m", "modifier"];
function k4(t) {
  return To(t, x4);
}
const w4 = ["k", "key"];
function C4(t) {
  const e = To(t, w4);
  if (e) return e;
  throw Qs(
    6
    /* NodeTypes.Linked */
  );
}
function To(t, e, n) {
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    if (zn(t, o) && t[o] != null) return t[o];
  }
  return n;
}
function Qs(t) {
  return new Error(`unhandled node type: ${t}`);
}
const A4 = (t) => t;
let tl = Be();
function Vi(t) {
  return Se(t) && Sh(t) === 0 && (zn(t, "b") || zn(t, "body"));
}
function S4(t, e = {}) {
  let n = !1;
  const r = e.onError || rw;
  return (
    (e.onError = (o) => {
      (n = !0), r(o);
    }),
    { ...Sw(t, e), detectError: n }
  );
}
function E4(t, e) {
  if (Y(t)) {
    Ye(e.warnHtmlMessage) && e.warnHtmlMessage;
    const r = (e.onCacheKey || A4)(t),
      o = tl[r];
    if (o) return o;
    const { ast: i, detectError: s } = S4(t, {
        ...e,
        location: Ew.NODE_ENV !== "production",
        jit: !0,
      }),
      a = Nd(i);
    return s ? a : (tl[r] = a);
  } else {
    const n = t.cacheKey;
    if (n) {
      const r = tl[n];
      return r || (tl[n] = Nd(t));
    } else return Nd(t);
  }
}
const wm = () => "",
  xn = (t) => tt(t);
function Cm(t, ...e) {
  const {
      fallbackFormat: n,
      postTranslation: r,
      unresolving: o,
      messageCompiler: i,
      fallbackLocale: s,
      messages: a,
    } = t,
    [l, u] = Wf(...e),
    c = Ye(u.missingWarn) ? u.missingWarn : t.missingWarn,
    d = Ye(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn,
    f = Ye(u.escapeParameter) ? u.escapeParameter : t.escapeParameter,
    p = !!u.resolvedMessage,
    h =
      Y(u.default) || Ye(u.default)
        ? Ye(u.default)
          ? i
            ? l
            : () => l
          : u.default
        : n
        ? i
          ? l
          : () => l
        : "",
    m = n || h !== "",
    g = Ch(t, u);
  f && M4(u);
  let [b, _, v] = p ? [l, g, a[g] || Be()] : Zb(t, l, g, s, d, c),
    y = b,
    w = l;
  if (
    (!p && !(Y(y) || Vi(y) || xn(y)) && m && ((y = h), (w = y)),
    !p && (!(Y(y) || Vi(y) || xn(y)) || !Y(_)))
  )
    return o ? zc : l;
  let x = !1;
  const M = () => {
      x = !0;
    },
    N = xn(y) ? y : Qb(t, l, _, y, w, M);
  if (x) return y;
  const T = D4(t, _, v, u),
    P = jw(T),
    z = T4(t, N, P),
    H = r ? r(z, l) : z;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const U = {
      timestamp: Date.now(),
      key: Y(l) ? l : xn(y) ? y.key : "",
      locale: _ || (xn(y) ? y.locale : ""),
      format: Y(y) ? y : xn(y) ? y.source : "",
      message: H,
    };
    (U.meta = Tt({}, t.__meta, /* @__PURE__ */ i4() || {})), Kw(U);
  }
  return H;
}
function M4(t) {
  ct(t.list)
    ? (t.list = t.list.map((e) => (Y(e) ? um(e) : e)))
    : Se(t.named) &&
      Object.keys(t.named).forEach((e) => {
        Y(t.named[e]) && (t.named[e] = um(t.named[e]));
      });
}
function Zb(t, e, n, r, o, i) {
  const { messages: s, onWarn: a, messageResolver: l, localeFallbacker: u } = t,
    c = u(t, r, n);
  let d = Be(),
    f,
    p = null;
  const h = "translate";
  for (
    let m = 0;
    m < c.length &&
    ((f = c[m]),
    (d = s[f] || Be()),
    (p = l(d, e)) === null && (p = d[e]),
    !(Y(p) || Vi(p) || xn(p)));
    m++
  )
    if (!u4(f, c)) {
      const g = Ah(
        t,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        f,
        i,
        h
      );
      g !== e && (p = g);
    }
  return [p, f, d];
}
function Qb(t, e, n, r, o, i) {
  const { messageCompiler: s, warnHtmlMessage: a } = t;
  if (xn(r)) {
    const u = r;
    return (u.locale = u.locale || n), (u.key = u.key || e), u;
  }
  if (s == null) {
    const u = () => r;
    return (u.locale = n), (u.key = e), u;
  }
  const l = s(r, O4(t, n, o, r, a, i));
  return (l.locale = n), (l.key = e), (l.source = r), l;
}
function T4(t, e, n) {
  return e(n);
}
function Wf(...t) {
  const [e, n, r] = t,
    o = Be();
  if (!Y(e) && !st(e) && !xn(e) && !Vi(e)) throw Ir(ur.INVALID_ARGUMENT);
  const i = st(e) ? String(e) : (xn(e), e);
  return (
    st(n)
      ? (o.plural = n)
      : Y(n)
      ? (o.default = n)
      : xe(n) && !Hc(n)
      ? (o.named = n)
      : ct(n) && (o.list = n),
    st(r) ? (o.plural = r) : Y(r) ? (o.default = r) : xe(r) && Tt(o, r),
    [i, o]
  );
}
function O4(t, e, n, r, o, i) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: o,
    onError: (s) => {
      throw (i && i(s), s);
    },
    onCacheKey: (s) => Vk(e, n, s),
  };
}
function D4(t, e, n, r) {
  const {
      modifiers: o,
      pluralRules: i,
      messageResolver: s,
      fallbackLocale: a,
      fallbackWarn: l,
      missingWarn: u,
      fallbackContext: c,
    } = t,
    f = {
      locale: e,
      modifiers: o,
      pluralRules: i,
      messages: (p) => {
        let h = s(n, p);
        if (h == null && c) {
          const [, , m] = Zb(c, p, e, a, l, u);
          h = s(m, p);
        }
        if (Y(h) || Vi(h)) {
          let m = !1;
          const b = Qb(t, p, e, h, p, () => {
            m = !0;
          });
          return m ? wm : b;
        } else return xn(h) ? h : wm;
      },
    };
  return (
    t.processor && (f.processor = t.processor),
    r.list && (f.list = r.list),
    r.named && (f.named = r.named),
    st(r.plural) && (f.pluralIndex = r.plural),
    f
  );
}
function Am(t, ...e) {
  const {
      datetimeFormats: n,
      unresolving: r,
      fallbackLocale: o,
      onWarn: i,
      localeFallbacker: s,
    } = t,
    { __datetimeFormatters: a } = t,
    [l, u, c, d] = qf(...e),
    f = Ye(c.missingWarn) ? c.missingWarn : t.missingWarn;
  Ye(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn;
  const p = !!c.part,
    h = Ch(t, c),
    m = s(
      t,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      o,
      h
    );
  if (!Y(l) || l === "") return new Intl.DateTimeFormat(h, d).format(u);
  let g = {},
    b,
    _ = null;
  const v = "datetime format";
  for (
    let x = 0;
    x < m.length && ((b = m[x]), (g = n[b] || {}), (_ = g[l]), !xe(_));
    x++
  )
    Ah(t, l, b, f, v);
  if (!xe(_) || !Y(b)) return r ? zc : l;
  let y = `${b}__${l}`;
  Hc(d) || (y = `${y}__${JSON.stringify(d)}`);
  let w = a.get(y);
  return (
    w || ((w = new Intl.DateTimeFormat(b, Tt({}, _, d))), a.set(y, w)),
    p ? w.formatToParts(u) : w.format(u)
  );
}
const ey = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits",
];
function qf(...t) {
  const [e, n, r, o] = t,
    i = Be();
  let s = Be(),
    a;
  if (Y(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l) throw Ir(ur.INVALID_ISO_DATE_ARGUMENT);
    const u = l[3]
      ? l[3].trim().startsWith("T")
        ? `${l[1].trim()}${l[3].trim()}`
        : `${l[1].trim()}T${l[3].trim()}`
      : l[1].trim();
    a = new Date(u);
    try {
      a.toISOString();
    } catch {
      throw Ir(ur.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (jk(e)) {
    if (isNaN(e.getTime())) throw Ir(ur.INVALID_DATE_ARGUMENT);
    a = e;
  } else if (st(e)) a = e;
  else throw Ir(ur.INVALID_ARGUMENT);
  return (
    Y(n)
      ? (i.key = n)
      : xe(n) &&
        Object.keys(n).forEach((l) => {
          ey.includes(l) ? (s[l] = n[l]) : (i[l] = n[l]);
        }),
    Y(r) ? (i.locale = r) : xe(r) && (s = r),
    xe(o) && (s = o),
    [i.key || "", a, i, s]
  );
}
function Sm(t, e, n) {
  const r = t;
  for (const o in n) {
    const i = `${e}__${o}`;
    r.__datetimeFormatters.has(i) && r.__datetimeFormatters.delete(i);
  }
}
function Em(t, ...e) {
  const {
      numberFormats: n,
      unresolving: r,
      fallbackLocale: o,
      onWarn: i,
      localeFallbacker: s,
    } = t,
    { __numberFormatters: a } = t,
    [l, u, c, d] = Kf(...e),
    f = Ye(c.missingWarn) ? c.missingWarn : t.missingWarn;
  Ye(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn;
  const p = !!c.part,
    h = Ch(t, c),
    m = s(
      t,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      o,
      h
    );
  if (!Y(l) || l === "") return new Intl.NumberFormat(h, d).format(u);
  let g = {},
    b,
    _ = null;
  const v = "number format";
  for (
    let x = 0;
    x < m.length && ((b = m[x]), (g = n[b] || {}), (_ = g[l]), !xe(_));
    x++
  )
    Ah(t, l, b, f, v);
  if (!xe(_) || !Y(b)) return r ? zc : l;
  let y = `${b}__${l}`;
  Hc(d) || (y = `${y}__${JSON.stringify(d)}`);
  let w = a.get(y);
  return (
    w || ((w = new Intl.NumberFormat(b, Tt({}, _, d))), a.set(y, w)),
    p ? w.formatToParts(u) : w.format(u)
  );
}
const ty = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay",
];
function Kf(...t) {
  const [e, n, r, o] = t,
    i = Be();
  let s = Be();
  if (!st(e)) throw Ir(ur.INVALID_ARGUMENT);
  const a = e;
  return (
    Y(n)
      ? (i.key = n)
      : xe(n) &&
        Object.keys(n).forEach((l) => {
          ty.includes(l) ? (s[l] = n[l]) : (i[l] = n[l]);
        }),
    Y(r) ? (i.locale = r) : xe(r) && (s = r),
    xe(o) && (s = o),
    [i.key || "", a, i, s]
  );
}
function Mm(t, e, n) {
  const r = t;
  for (const o in n) {
    const i = `${e}__${o}`;
    r.__numberFormatters.has(i) && r.__numberFormatters.delete(i);
  }
}
Mw();
var N4 = {
  LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
  COREPACK_ROOT:
    "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
  WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
  npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
  TERM_PROGRAM: "vscode",
  npm_package_scripts_prettier:
    "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
  npm_package_dependencies__tiptap_extension_link: "^2.11.2",
  npm_package_scripts_test_unit_coverage:
    "vitest run --environment jsdom --coverage",
  NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
  ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
  WASMER_DIR: "/Users/ryanwang/.wasmer",
  _P9K_TTY: "/dev/ttys005",
  npm_package_homepage:
    "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
  npm_package_dependencies__tiptap_vue_3: "^2.11.2",
  INIT_CWD:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  SHELL: "/bin/zsh",
  TERM: "xterm-256color",
  npm_package_unpkg: "./dist/rich-text-editor.iife.js",
  npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
  npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
  TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
  CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
  npm_package_dependencies_linkifyjs: "^4.1.3",
  npm_package_scripts_lint:
    "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
  npm_package_scripts_release: "release-it",
  TERM_PROGRAM_VERSION: "0.48.7",
  npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
  npm_package_dependencies_floating_vue: "^5.2.2",
  npm_package_scripts_dev: "vite",
  MallocNanoZone: "0",
  ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
  CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
  ZDOTDIR: "/Users/ryanwang",
  npm_package_dependencies__tiptap_extension_document: "^2.11.2",
  npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
  SDKMAN_PLATFORM: "darwinarm64",
  npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
  npm_config_registry: "https://registry.npmjs.org/",
  ZSH: "/Users/ryanwang/.oh-my-zsh",
  PNPM_HOME: "/Users/ryanwang/Library/pnpm",
  npm_package_repository_url: "https://github.com/halo-dev/halo.git",
  npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
  npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
  npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
  npm_package_scripts_test_unit_ui: "vitest --environment jsdom --watch --ui",
  npm_package_dependencies__tiptap_pm: "^2.11.2",
  USER: "ryanwang",
  DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
  npm_package_description: "Default editor for Halo",
  LS_COLORS:
    "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
  npm_package_license: "GPL-3.0",
  COMMAND_MODE: "unix2003",
  npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
  SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
  npm_package_exports___import: "./dist/rich-text-editor.es.js",
  PNPM_SCRIPT_SRC_DIR:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  npm_package_repository_directory: "ui/packages/editor",
  npm_package_dependencies__tiptap_extension_history: "^2.11.2",
  npm_config_strict_peer_dependencies: "",
  SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
  __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
  npm_execpath:
    "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
  PAGER: "less",
  npm_package_module: "./dist/rich-text-editor.es.js",
  npm_package_dependencies__tiptap_extension_text: "^2.11.2",
  LSCOLORS: "Gxfxcxdxbxegedabagacad",
  npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
  npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
  npm_config_frozen_lockfile: "",
  npm_package_dependencies__tiptap_extension_horizontal_rule: "^2.11.2",
  npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
  npm_package_devDependencies__types_linkifyjs: "^2.1.7",
  PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
  MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
  npm_package_devDependencies_release_it: "^16.1.5",
  npm_package_scripts_typecheck:
    "vue-tsc --noEmit -p tsconfig.app.json --composite false",
  npm_package_peerDependencies_vue: "^3.5.13",
  __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
  USER_ZDOTDIR: "/Users/ryanwang",
  COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
  npm_package_author: "@halo-dev",
  npm_package_dependencies__ckpack_vue_color: "^1.5.0",
  npm_config_auto_install_peers: "true",
  PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
  npm_command: "run-script",
  JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
  VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
  npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
  npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
  EDITOR: "nvim",
  P9K_SSH: "0",
  npm_lifecycle_event: "build",
  LANG: "en_US.UTF-8",
  P9K_TTY: "old",
  npm_package_name: "@halo-dev/richtext-editor",
  npm_package_repository_type: "git",
  npm_package_types: "./dist/index.d.ts",
  npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
  npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
  npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
  npm_package_dependencies__tiptap_suggestion: "^2.11.2",
  NODE_PATH:
    "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
  npm_package_exports___types: "./dist/index.d.ts",
  npm_package_scripts_build: "vite build --config ./vite.lib.config.ts",
  XPC_FLAGS: "0x0",
  VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
  npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
  npm_package_dependencies_tippy_js: "^6.3.7",
  npm_package_main: "./dist/rich-text-editor.iife.js",
  npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
  npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
  npm_config_node_gyp:
    "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
  XPC_SERVICE_NAME: "0",
  npm_package_version: "2.20.0",
  npm_package_devDependencies__iconify_json: "^2.2.117",
  VSCODE_INJECTION: "1",
  npm_package_dependencies__tiptap_core: "^2.11.2",
  npm_package_dependencies__tiptap_extension_code: "^2.11.2",
  HOME: "/Users/ryanwang",
  SHLVL: "2",
  npm_package_exports___dist_style_css: "./dist/style.css",
  VSCODE_GIT_ASKPASS_MAIN:
    "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
  npm_package_dependencies__tiptap_extension_image: "^2.11.2",
  npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
  npm_package_dependencies_github_markdown_css: "^5.2.0",
  npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
  npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
  LOGNAME: "ryanwang",
  LESS: "-R",
  SDKMAN_DIR: "/Users/ryanwang/.sdkman",
  npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
  VSCODE_GIT_IPC_HANDLE:
    "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
  npm_package_dependencies__tiptap_extension_table: "^2.11.2",
  npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
  BUN_INSTALL: "/Users/ryanwang/.bun",
  npm_package_scripts_test_unit_watch: "vitest --environment jsdom --watch",
  npm_package_dependencies__tiptap_extension_color: "^2.11.2",
  npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
  npm_config_user_agent: "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
  SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
  GIT_ASKPASS:
    "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
  VSCODE_GIT_ASKPASS_NODE:
    "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
  _P9K_SSH_TTY: "/dev/ttys005",
  npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
  npm_package_files_0: "dist",
  npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
  OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
  COLORTERM: "truecolor",
  npm_node_execpath: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
  NODE_ENV: "production",
};
const L4 = "9.14.2";
function R4() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" &&
    (xh().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const ny = Jw.__EXTEND_POINT__,
  Ar = Fc(ny);
Ar(), Ar(), Ar(), Ar(), Ar(), Ar(), Ar(), Ar(), Ar();
const ry = ur.__EXTEND_POINT__,
  zt = Fc(ry),
  Mn = {
    // composer module errors
    UNEXPECTED_RETURN_TYPE: ry,
    // 24
    // legacy module errors
    INVALID_ARGUMENT: zt(),
    // 25
    // i18n module errors
    MUST_BE_CALL_SETUP_TOP: zt(),
    // 26
    NOT_INSTALLED: zt(),
    // 27
    NOT_AVAILABLE_IN_LEGACY_MODE: zt(),
    // 28
    // directive module errors
    REQUIRED_VALUE: zt(),
    // 29
    INVALID_VALUE: zt(),
    // 30
    // vue-devtools errors
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: zt(),
    // 31
    NOT_INSTALLED_WITH_PROVIDE: zt(),
    // 32
    // unexpected error
    UNEXPECTED_ERROR: zt(),
    // 33
    // not compatible legacy vue-i18n constructor
    NOT_COMPATIBLE_LEGACY_VUE_I18N: zt(),
    // 34
    // bridge support vue 2.x only
    BRIDGE_SUPPORT_VUE_2_ONLY: zt(),
    // 35
    // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: zt(),
    // 36
    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: zt(),
    // 37
    // for enhancement
    __EXTEND_POINT__: zt(),
    // 38
  };
function Gn(t, ...e) {
  return ts(t, null, void 0);
}
const Gf = /* @__PURE__ */ Eo("__translateVNode"),
  Jf = /* @__PURE__ */ Eo("__datetimeParts"),
  Yf = /* @__PURE__ */ Eo("__numberParts"),
  I4 = Eo("__setPluralRules"),
  P4 = /* @__PURE__ */ Eo("__injectWithOption"),
  Xf = /* @__PURE__ */ Eo("__dispose");
function ea(t) {
  if (!Se(t)) return t;
  for (const e in t)
    if (zn(t, e))
      if (!e.includes(".")) Se(t[e]) && ea(t[e]);
      else {
        const n = e.split("."),
          r = n.length - 1;
        let o = t,
          i = !1;
        for (let s = 0; s < r; s++) {
          if ((n[s] in o || (o[n[s]] = Be()), !Se(o[n[s]]))) {
            i = !0;
            break;
          }
          o = o[n[s]];
        }
        i || ((o[n[r]] = t[e]), delete t[e]), Se(o[n[r]]) && ea(o[n[r]]);
      }
  return t;
}
function oy(t, e) {
  const { messages: n, __i18n: r, messageResolver: o, flatJson: i } = e,
    s = xe(n) ? n : ct(r) ? Be() : { [t]: Be() };
  if (
    (ct(r) &&
      r.forEach((a) => {
        if ("locale" in a && "resource" in a) {
          const { locale: l, resource: u } = a;
          l ? ((s[l] = s[l] || Be()), Fl(u, s[l])) : Fl(u, s);
        } else Y(a) && Fl(JSON.parse(a), s);
      }),
    o == null && i)
  )
    for (const a in s) zn(s, a) && ea(s[a]);
  return s;
}
function iy(t) {
  return t.type;
}
function $4(t, e, n) {
  let r = Se(e.messages) ? e.messages : Be();
  "__i18nGlobal" in n &&
    (r = oy(t.locale.value, {
      messages: r,
      __i18n: n.__i18nGlobal,
    }));
  const o = Object.keys(r);
  o.length &&
    o.forEach((i) => {
      t.mergeLocaleMessage(i, r[i]);
    });
  {
    if (Se(e.datetimeFormats)) {
      const i = Object.keys(e.datetimeFormats);
      i.length &&
        i.forEach((s) => {
          t.mergeDateTimeFormat(s, e.datetimeFormats[s]);
        });
    }
    if (Se(e.numberFormats)) {
      const i = Object.keys(e.numberFormats);
      i.length &&
        i.forEach((s) => {
          t.mergeNumberFormat(s, e.numberFormats[s]);
        });
    }
  }
}
function Tm(t) {
  return J(Ex, null, t, 0);
}
const Om = "__INTLIFY_META__",
  Dm = () => [],
  B4 = () => !1;
let Nm = 0;
function Lm(t) {
  return (e, n, r, o) => t(n, r, Lc() || void 0, o);
}
const H4 = /* @__NO_SIDE_EFFECTS__ */ () => {
  const t = Lc();
  let e = null;
  return t && (e = iy(t)[Om]) ? { [Om]: e } : null;
};
function sy(t = {}, e) {
  const { __root: n, __injectWithOption: r } = t,
    o = n === void 0,
    i = t.flatJson,
    s = nu ? Te : gb,
    a = !!t.translateExistCompatible;
  let l = Ye(t.inheritLocale) ? t.inheritLocale : !0;
  const u = s(
      // prettier-ignore
      n && l ? n.locale.value : Y(t.locale) ? t.locale : iu
    ),
    c = s(
      // prettier-ignore
      n && l ? n.fallbackLocale.value : Y(t.fallbackLocale) || ct(t.fallbackLocale) || xe(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : u.value
    ),
    d = s(oy(u.value, t)),
    f = s(xe(t.datetimeFormats) ? t.datetimeFormats : { [u.value]: {} }),
    p = s(xe(t.numberFormats) ? t.numberFormats : { [u.value]: {} });
  let h = n
      ? n.missingWarn
      : Ye(t.missingWarn) || ru(t.missingWarn)
      ? t.missingWarn
      : !0,
    m = n
      ? n.fallbackWarn
      : Ye(t.fallbackWarn) || ru(t.fallbackWarn)
      ? t.fallbackWarn
      : !0,
    g = n ? n.fallbackRoot : Ye(t.fallbackRoot) ? t.fallbackRoot : !0,
    b = !!t.fallbackFormat,
    _ = tt(t.missing) ? t.missing : null,
    v = tt(t.missing) ? Lm(t.missing) : null,
    y = tt(t.postTranslation) ? t.postTranslation : null,
    w = n ? n.warnHtmlMessage : Ye(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
    x = !!t.escapeParameter;
  const M = n ? n.modifiers : xe(t.modifiers) ? t.modifiers : {};
  let N = t.pluralRules || (n && n.pluralRules),
    T;
  (T = (() => {
    o && _m(null);
    const L = {
      version: L4,
      locale: u.value,
      fallbackLocale: c.value,
      messages: d.value,
      modifiers: M,
      pluralRules: N,
      missing: v === null ? void 0 : v,
      missingWarn: h,
      fallbackWarn: m,
      fallbackFormat: b,
      unresolving: !0,
      postTranslation: y === null ? void 0 : y,
      warnHtmlMessage: w,
      escapeParameter: x,
      messageResolver: t.messageResolver,
      messageCompiler: t.messageCompiler,
      __meta: { framework: "vue" },
    };
    (L.datetimeFormats = f.value),
      (L.numberFormats = p.value),
      (L.__datetimeFormatters = xe(T) ? T.__datetimeFormatters : void 0),
      (L.__numberFormatters = xe(T) ? T.__numberFormatters : void 0);
    const F = a4(L);
    return o && _m(F), F;
  })()),
    cs(T, u.value, c.value);
  function z() {
    return [u.value, c.value, d.value, f.value, p.value];
  }
  const H = ce({
      get: () => u.value,
      set: (L) => {
        (u.value = L), (T.locale = u.value);
      },
    }),
    U = ce({
      get: () => c.value,
      set: (L) => {
        (c.value = L), (T.fallbackLocale = c.value), cs(T, u.value, L);
      },
    }),
    re = ce(() => d.value),
    te = /* @__PURE__ */ ce(() => f.value),
    Q = /* @__PURE__ */ ce(() => p.value);
  function ne() {
    return tt(y) ? y : null;
  }
  function fe(L) {
    (y = L), (T.postTranslation = L);
  }
  function Le() {
    return _;
  }
  function We(L) {
    L !== null && (v = Lm(L)), (_ = L), (T.missing = v);
  }
  const Ee = (L, F, Ce, Je, tr, bi) => {
    z();
    let Gr;
    try {
      N4.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__,
        o || (T.fallbackContext = n ? s4() : void 0),
        (Gr = L(T));
    } finally {
      __INTLIFY_PROD_DEVTOOLS__, o || (T.fallbackContext = void 0);
    }
    if (
      (Ce !== "translate exists" && // for not `te` (e.g `t`)
        st(Gr) &&
        Gr === zc) ||
      (Ce === "translate exists" && !Gr)
    ) {
      const [Cd, R] = F();
      return n && g ? Je(n) : tr(Cd);
    } else {
      if (bi(Gr)) return Gr;
      throw Gn(Mn.UNEXPECTED_RETURN_TYPE);
    }
  };
  function ze(...L) {
    return Ee(
      (F) => Reflect.apply(Cm, null, [F, ...L]),
      () => Wf(...L),
      "translate",
      (F) => Reflect.apply(F.t, F, [...L]),
      (F) => F,
      (F) => Y(F)
    );
  }
  function Ge(...L) {
    const [F, Ce, Je] = L;
    if (Je && !Se(Je)) throw Gn(Mn.INVALID_ARGUMENT);
    return ze(F, Ce, Tt({ resolvedMessage: !0 }, Je || {}));
  }
  function Qe(...L) {
    return Ee(
      (F) => Reflect.apply(Am, null, [F, ...L]),
      () => qf(...L),
      "datetime format",
      (F) => Reflect.apply(F.d, F, [...L]),
      () => ym,
      (F) => Y(F)
    );
  }
  function He(...L) {
    return Ee(
      (F) => Reflect.apply(Em, null, [F, ...L]),
      () => Kf(...L),
      "number format",
      (F) => Reflect.apply(F.n, F, [...L]),
      () => ym,
      (F) => Y(F)
    );
  }
  function qe(L) {
    return L.map((F) => (Y(F) || st(F) || Ye(F) ? Tm(String(F)) : F));
  }
  const nt = {
    normalize: qe,
    interpolate: (L) => L,
    type: "vnode",
  };
  function Ct(...L) {
    return Ee(
      (F) => {
        let Ce;
        const Je = F;
        try {
          (Je.processor = nt), (Ce = Reflect.apply(Cm, null, [Je, ...L]));
        } finally {
          Je.processor = null;
        }
        return Ce;
      },
      () => Wf(...L),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (F) => F[Gf](...L),
      (F) => [Tm(F)],
      (F) => ct(F)
    );
  }
  function ut(...L) {
    return Ee(
      (F) => Reflect.apply(Em, null, [F, ...L]),
      () => Kf(...L),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (F) => F[Yf](...L),
      Dm,
      (F) => Y(F) || ct(F)
    );
  }
  function nn(...L) {
    return Ee(
      (F) => Reflect.apply(Am, null, [F, ...L]),
      () => qf(...L),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (F) => F[Jf](...L),
      Dm,
      (F) => Y(F) || ct(F)
    );
  }
  function Rn(L) {
    (N = L), (T.pluralRules = N);
  }
  function wr(L, F) {
    return Ee(
      () => {
        if (!L) return !1;
        const Ce = Y(F) ? F : u.value,
          Je = fn(Ce),
          tr = T.messageResolver(Je, L);
        return a ? tr != null : Vi(tr) || xn(tr) || Y(tr);
      },
      () => [L],
      "translate exists",
      (Ce) => Reflect.apply(Ce.te, Ce, [L, F]),
      B4,
      (Ce) => Ye(Ce)
    );
  }
  function qr(L) {
    let F = null;
    const Ce = qb(T, c.value, u.value);
    for (let Je = 0; Je < Ce.length; Je++) {
      const tr = d.value[Ce[Je]] || {},
        bi = T.messageResolver(tr, L);
      if (bi != null) {
        F = bi;
        break;
      }
    }
    return F;
  }
  function Qn(L) {
    const F = qr(L);
    return F ?? (n ? n.tm(L) || {} : {});
  }
  function fn(L) {
    return d.value[L] || {};
  }
  function pn(L, F) {
    if (i) {
      const Ce = { [L]: F };
      for (const Je in Ce) zn(Ce, Je) && ea(Ce[Je]);
      F = Ce[L];
    }
    (d.value[L] = F), (T.messages = d.value);
  }
  function er(L, F) {
    d.value[L] = d.value[L] || {};
    const Ce = { [L]: F };
    if (i) for (const Je in Ce) zn(Ce, Je) && ea(Ce[Je]);
    (F = Ce[L]), Fl(F, d.value[L]), (T.messages = d.value);
  }
  function Kr(L) {
    return f.value[L] || {};
  }
  function A(L, F) {
    (f.value[L] = F), (T.datetimeFormats = f.value), Sm(T, L, F);
  }
  function E(L, F) {
    (f.value[L] = Tt(f.value[L] || {}, F)),
      (T.datetimeFormats = f.value),
      Sm(T, L, F);
  }
  function B(L) {
    return p.value[L] || {};
  }
  function G(L, F) {
    (p.value[L] = F), (T.numberFormats = p.value), Mm(T, L, F);
  }
  function Me(L, F) {
    (p.value[L] = Tt(p.value[L] || {}, F)),
      (T.numberFormats = p.value),
      Mm(T, L, F);
  }
  Nm++,
    n &&
      nu &&
      (jt(n.locale, (L) => {
        l && ((u.value = L), (T.locale = L), cs(T, u.value, c.value));
      }),
      jt(n.fallbackLocale, (L) => {
        l && ((c.value = L), (T.fallbackLocale = L), cs(T, u.value, c.value));
      }));
  const oe = {
    id: Nm,
    locale: H,
    fallbackLocale: U,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(L) {
      (l = L),
        L &&
          n &&
          ((u.value = n.locale.value),
          (c.value = n.fallbackLocale.value),
          cs(T, u.value, c.value));
    },
    get availableLocales() {
      return Object.keys(d.value).sort();
    },
    messages: re,
    get modifiers() {
      return M;
    },
    get pluralRules() {
      return N || {};
    },
    get isGlobal() {
      return o;
    },
    get missingWarn() {
      return h;
    },
    set missingWarn(L) {
      (h = L), (T.missingWarn = h);
    },
    get fallbackWarn() {
      return m;
    },
    set fallbackWarn(L) {
      (m = L), (T.fallbackWarn = m);
    },
    get fallbackRoot() {
      return g;
    },
    set fallbackRoot(L) {
      g = L;
    },
    get fallbackFormat() {
      return b;
    },
    set fallbackFormat(L) {
      (b = L), (T.fallbackFormat = b);
    },
    get warnHtmlMessage() {
      return w;
    },
    set warnHtmlMessage(L) {
      (w = L), (T.warnHtmlMessage = L);
    },
    get escapeParameter() {
      return x;
    },
    set escapeParameter(L) {
      (x = L), (T.escapeParameter = L);
    },
    t: ze,
    getLocaleMessage: fn,
    setLocaleMessage: pn,
    mergeLocaleMessage: er,
    getPostTranslationHandler: ne,
    setPostTranslationHandler: fe,
    getMissingHandler: Le,
    setMissingHandler: We,
    [I4]: Rn,
  };
  return (
    (oe.datetimeFormats = te),
    (oe.numberFormats = Q),
    (oe.rt = Ge),
    (oe.te = wr),
    (oe.tm = Qn),
    (oe.d = Qe),
    (oe.n = He),
    (oe.getDateTimeFormat = Kr),
    (oe.setDateTimeFormat = A),
    (oe.mergeDateTimeFormat = E),
    (oe.getNumberFormat = B),
    (oe.setNumberFormat = G),
    (oe.mergeNumberFormat = Me),
    (oe[P4] = r),
    (oe[Gf] = Ct),
    (oe[Jf] = nn),
    (oe[Yf] = ut),
    oe
  );
}
const Eh = {
  tag: {
    type: [String, Object],
  },
  locale: {
    type: String,
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent",
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object,
  },
};
function F4({ slots: t }, e) {
  return e.length === 1 && e[0] === "default"
    ? (t.default ? t.default() : []).reduce(
        (r, o) => [
          ...r,
          // prettier-ignore
          ...o.type === gt ? o.children : [o],
        ],
        []
      )
    : e.reduce((n, r) => {
        const o = t[r];
        return o && (n[r] = o()), n;
      }, Be());
}
function ay(t) {
  return gt;
}
const z4 = /* @__PURE__ */ se({
    /* eslint-disable */
    name: "i18n-t",
    props: Tt(
      {
        keypath: {
          type: String,
          required: !0,
        },
        plural: {
          type: [Number, String],
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          validator: (t) => st(t) || !isNaN(t),
        },
      },
      Eh
    ),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(t, e) {
      const { slots: n, attrs: r } = e,
        o =
          t.i18n ||
          Mh({
            useScope: t.scope,
            __useComponent: !0,
          });
      return () => {
        const i = Object.keys(n).filter((d) => d !== "_"),
          s = Be();
        t.locale && (s.locale = t.locale),
          t.plural !== void 0 &&
            (s.plural = Y(t.plural) ? +t.plural : t.plural);
        const a = F4(e, i),
          l = o[Gf](t.keypath, a, s),
          u = Tt(Be(), r),
          c = Y(t.tag) || Se(t.tag) ? t.tag : ay();
        return Zt(c, u, l);
      };
    },
  }),
  Rm = z4;
function V4(t) {
  return ct(t) && !Y(t[0]);
}
function ly(t, e, n, r) {
  const { slots: o, attrs: i } = e;
  return () => {
    const s = { part: !0 };
    let a = Be();
    t.locale && (s.locale = t.locale),
      Y(t.format)
        ? (s.key = t.format)
        : Se(t.format) &&
          (Y(t.format.key) && (s.key = t.format.key),
          (a = Object.keys(t.format).reduce(
            (f, p) => (n.includes(p) ? Tt(Be(), f, { [p]: t.format[p] }) : f),
            Be()
          )));
    const l = r(t.value, s, a);
    let u = [s.key];
    ct(l)
      ? (u = l.map((f, p) => {
          const h = o[f.type],
            m = h ? h({ [f.type]: f.value, index: p, parts: l }) : [f.value];
          return V4(m) && (m[0].key = `${f.type}-${p}`), m;
        }))
      : Y(l) && (u = [l]);
    const c = Tt(Be(), i),
      d = Y(t.tag) || Se(t.tag) ? t.tag : ay();
    return Zt(d, c, u);
  };
}
const U4 = /* @__PURE__ */ se({
    /* eslint-disable */
    name: "i18n-n",
    props: Tt(
      {
        value: {
          type: Number,
          required: !0,
        },
        format: {
          type: [String, Object],
        },
      },
      Eh
    ),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(t, e) {
      const n =
        t.i18n ||
        Mh({
          useScope: t.scope,
          __useComponent: !0,
        });
      return ly(t, e, ty, (...r) =>
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        n[Yf](...r)
      );
    },
  }),
  Im = U4,
  j4 = /* @__PURE__ */ se({
    /* eslint-disable */
    name: "i18n-d",
    props: Tt(
      {
        value: {
          type: [Number, Date],
          required: !0,
        },
        format: {
          type: [String, Object],
        },
      },
      Eh
    ),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(t, e) {
      const n =
        t.i18n ||
        Mh({
          useScope: t.scope,
          __useComponent: !0,
        });
      return ly(t, e, ey, (...r) =>
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        n[Jf](...r)
      );
    },
  }),
  Pm = j4;
function W4(t, e) {
  const n = t;
  if (t.mode === "composition") return n.__getInstance(e) || t.global;
  {
    const r = n.__getInstance(e);
    return r != null ? r.__composer : t.global.__composer;
  }
}
function q4(t) {
  const e = (s) => {
    const { instance: a, modifiers: l, value: u } = s;
    if (!a || !a.$) throw Gn(Mn.UNEXPECTED_ERROR);
    const c = W4(t, a.$),
      d = $m(u);
    return [Reflect.apply(c.t, c, [...Bm(d)]), c];
  };
  return {
    created: (s, a) => {
      const [l, u] = e(a);
      nu &&
        t.global === u &&
        (s.__i18nWatcher = jt(u.locale, () => {
          a.instance && a.instance.$forceUpdate();
        })),
        (s.__composer = u),
        (s.textContent = l);
    },
    unmounted: (s) => {
      nu &&
        s.__i18nWatcher &&
        (s.__i18nWatcher(), (s.__i18nWatcher = void 0), delete s.__i18nWatcher),
        s.__composer && ((s.__composer = void 0), delete s.__composer);
    },
    beforeUpdate: (s, { value: a }) => {
      if (s.__composer) {
        const l = s.__composer,
          u = $m(a);
        s.textContent = Reflect.apply(l.t, l, [...Bm(u)]);
      }
    },
    getSSRProps: (s) => {
      const [a] = e(s);
      return { textContent: a };
    },
  };
}
function $m(t) {
  if (Y(t)) return { path: t };
  if (xe(t)) {
    if (!("path" in t)) throw Gn(Mn.REQUIRED_VALUE, "path");
    return t;
  } else throw Gn(Mn.INVALID_VALUE);
}
function Bm(t) {
  const { path: e, locale: n, args: r, choice: o, plural: i } = t,
    s = {},
    a = r || {};
  return (
    Y(n) && (s.locale = n),
    st(o) && (s.plural = o),
    st(i) && (s.plural = i),
    [e, a, s]
  );
}
function K4(t, e, ...n) {
  const r = xe(n[0]) ? n[0] : {},
    o = !!r.useI18nComponentName;
  (Ye(r.globalInstall) ? r.globalInstall : !0) &&
    ([o ? "i18n" : Rm.name, "I18nT"].forEach((s) => t.component(s, Rm)),
    [Im.name, "I18nN"].forEach((s) => t.component(s, Im)),
    [Pm.name, "I18nD"].forEach((s) => t.component(s, Pm))),
    t.directive("t", q4(e));
}
const G4 = /* @__PURE__ */ Eo("global-vue-i18n");
function J4(t = {}, e) {
  const n = Ye(t.globalInjection) ? t.globalInjection : !0,
    r = !0,
    o = /* @__PURE__ */ new Map(),
    [i, s] = Y4(t),
    a = /* @__PURE__ */ Eo("");
  function l(d) {
    return o.get(d) || null;
  }
  function u(d, f) {
    o.set(d, f);
  }
  function c(d) {
    o.delete(d);
  }
  {
    const d = {
      // mode
      get mode() {
        return "composition";
      },
      // allowComposition
      get allowComposition() {
        return r;
      },
      // install plugin
      async install(f, ...p) {
        if (
          ((f.__VUE_I18N_SYMBOL__ = a),
          f.provide(f.__VUE_I18N_SYMBOL__, d),
          xe(p[0]))
        ) {
          const g = p[0];
          (d.__composerExtend = g.__composerExtend),
            (d.__vueI18nExtend = g.__vueI18nExtend);
        }
        let h = null;
        n && (h = o5(f, d.global)), K4(f, d, ...p);
        const m = f.unmount;
        f.unmount = () => {
          h && h(), d.dispose(), m();
        };
      },
      // global accessor
      get global() {
        return s;
      },
      dispose() {
        i.stop();
      },
      // @internal
      __instances: o,
      // @internal
      __getInstance: l,
      // @internal
      __setInstance: u,
      // @internal
      __deleteInstance: c,
    };
    return d;
  }
}
function Mh(t = {}) {
  const e = Lc();
  if (e == null) throw Gn(Mn.MUST_BE_CALL_SETUP_TOP);
  if (
    !e.isCE &&
    e.appContext.app != null &&
    !e.appContext.app.__VUE_I18N_SYMBOL__
  )
    throw Gn(Mn.NOT_INSTALLED);
  const n = X4(e),
    r = Q4(n),
    o = iy(e),
    i = Z4(t, o);
  if (i === "global") return $4(r, t, o), r;
  if (i === "parent") {
    let l = e5(n, e, t.__useComponent);
    return l == null && (l = r), l;
  }
  const s = n;
  let a = s.__getInstance(e);
  if (a == null) {
    const l = Tt({}, t);
    "__i18n" in o && (l.__i18n = o.__i18n),
      r && (l.__root = r),
      (a = sy(l)),
      s.__composerExtend && (a[Xf] = s.__composerExtend(a)),
      n5(s, e, a),
      s.__setInstance(e, a);
  }
  return a;
}
function Y4(t, e, n) {
  const r = wx();
  {
    const o = r.run(() => sy(t));
    if (o == null) throw Gn(Mn.UNEXPECTED_ERROR);
    return [r, o];
  }
}
function X4(t) {
  {
    const e = Cx(t.isCE ? G4 : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw Gn(t.isCE ? Mn.NOT_INSTALLED_WITH_PROVIDE : Mn.UNEXPECTED_ERROR);
    return e;
  }
}
function Z4(t, e) {
  return Hc(t)
    ? "__i18n" in e
      ? "local"
      : "global"
    : t.useScope
    ? t.useScope
    : "local";
}
function Q4(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function e5(t, e, n = !1) {
  let r = null;
  const o = e.root;
  let i = t5(e, n);
  for (; i != null; ) {
    const s = t;
    if (
      (t.mode === "composition" && (r = s.__getInstance(i)),
      r != null || o === i)
    )
      break;
    i = i.parent;
  }
  return r;
}
function t5(t, e = !1) {
  return t == null ? null : (e && t.vnode.ctx) || t.parent;
}
function n5(t, e, n) {
  Wr(() => {}, e),
    Ax(() => {
      const r = n;
      t.__deleteInstance(e);
      const o = r[Xf];
      o && (o(), delete r[Xf]);
    }, e);
}
const r5 = ["locale", "fallbackLocale", "availableLocales"],
  Hm = ["t", "rt", "d", "n", "tm", "te"];
function o5(t, e) {
  const n = /* @__PURE__ */ Object.create(null);
  return (
    r5.forEach((o) => {
      const i = Object.getOwnPropertyDescriptor(e, o);
      if (!i) throw Gn(Mn.UNEXPECTED_ERROR);
      const s = Sx(i.value)
        ? {
            get() {
              return i.value.value;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            set(a) {
              i.value.value = a;
            },
          }
        : {
            get() {
              return i.get && i.get();
            },
          };
      Object.defineProperty(n, o, s);
    }),
    (t.config.globalProperties.$i18n = n),
    Hm.forEach((o) => {
      const i = Object.getOwnPropertyDescriptor(e, o);
      if (!i || !i.value) throw Gn(Mn.UNEXPECTED_ERROR);
      Object.defineProperty(t.config.globalProperties, `$${o}`, i);
    }),
    () => {
      delete t.config.globalProperties.$i18n,
        Hm.forEach((o) => {
          delete t.config.globalProperties[`$${o}`];
        });
    }
  );
}
R4();
t4(E4);
n4(Pw);
r4(qb);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const t = xh();
  (t.__INTLIFY__ = !0), Ww(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const Fm = {
    editor: {
      menus: {
        undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Undo" } },
        redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Redo" } },
        table: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
          add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add table" } },
          add_column_before: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add column before" },
          },
          add_column_after: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add column after" },
          },
          delete_column: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Delete column" },
          },
          add_row_before: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add row before" },
          },
          add_row_after: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add row after" },
          },
          toggle_header_column: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Column Header" },
          },
          toggle_header_row: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Row Header" },
          },
          toggle_header_cell: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Set/Unset Current Cell as Header" },
          },
          delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete row" } },
          merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Merge cells" } },
          split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Split cell" } },
          delete_table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete table" } },
        },
      },
      extensions: {
        commands_menu: {
          columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Column Card" } },
          iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Iframe" } },
          image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "image" } },
          video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Video" } },
          audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Audio" } },
          table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
          no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No results" } },
          placeholder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Enter / to select input type" },
          },
        },
        link: {
          add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add link" } },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
          placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link address" } },
          open_in_new_window: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Open in new window" },
          },
          cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cancel link" } },
        },
        audio: {
          disable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" },
          },
          enable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" },
          },
          disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } },
          enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } },
        },
        iframe: {
          disable_frameborder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Hide frameborder" },
          },
          enable_frameborder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Show frameborder" },
          },
          phone_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Mobile phone size" },
          },
          tablet_vertical_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Tablet portrait size" },
          },
          tablet_horizontal_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Tablet landscape size" },
          },
          desktop_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desktop size" } },
        },
        image: {
          small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
          medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
          large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } },
          restore_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Restore original size" },
          },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
          edit_alt: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit alt" } },
          edit_href: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Edit the image hyperlink" },
          },
        },
        video: {
          disable_controls: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Hide controls" },
          },
          enable_controls: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Show controls" },
          },
          disable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" },
          },
          enable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" },
          },
          disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } },
          enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enable loop" } },
          small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
          medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
          large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } },
        },
        highlight: {
          unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Unset" } },
        },
        columns: {
          add_column_before: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add column before" },
          },
          add_column_after: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Add column after" },
          },
          delete_column: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Delete column" },
          },
        },
        search_and_replace: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Search and Replace" } },
          search_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Search" } },
          not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Not Found" } },
          occurrence_found: {
            t: 0,
            b: {
              t: 2,
              i: [
                { t: 4, k: "index" },
                { t: 3, v: " of " },
                { t: 4, k: "total" },
                { t: 3, v: " occurrences" },
              ],
            },
          },
          find_previous: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Find Previous" },
          },
          find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Find Next" } },
          replace_placeholder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Replace" },
          },
          replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace" } },
          replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace All" } },
          case_sensitive: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Case Sensitive" },
          },
          match_word: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Match Whole Word" },
          },
          use_regex: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Use Regular Expression" },
          },
          close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Close" } },
        },
        format_brush: {
          toolbar_item: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Format Brush" } },
            cancel: {
              t: 0,
              b: { t: 2, i: [{ t: 3 }], s: "Cancel Format Brush" },
            },
          },
        },
      },
      components: {
        color_picker: {
          more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "More" } },
        },
      },
      common: {
        align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align method" } },
        align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align left" } },
        align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align center" } },
        align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align right" } },
        align_justify: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align justify" } },
        bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bold" } },
        italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Italic" } },
        underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Underline" } },
        strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Strike" } },
        quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quote" } },
        code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code" } },
        superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Super Script" } },
        subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sub Script" } },
        codeblock: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code block" } },
          copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Copy code" } },
          copy_code_success: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Copy success" },
          },
        },
        image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image" } },
        heading: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Text type" } },
          paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Paragraph" } },
          header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 1" } },
          header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 2" } },
          header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 3" } },
          header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 4" } },
          header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 5" } },
          header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 6" } },
        },
        bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bullet list" } },
        ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ordered list" } },
        task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Task list" } },
        highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Highlight" } },
        color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Color" } },
        tooltip: {
          custom_width_input: {
            t: 0,
            b: {
              t: 2,
              i: [{ t: 3 }],
              s: "Custom width, press Enter to take effect",
            },
          },
          custom_height_input: {
            t: 0,
            b: {
              t: 2,
              i: [{ t: 3 }],
              s: "Customize height, press Enter to take effect",
            },
          },
          open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Open link" } },
        },
        placeholder: {
          link_input: {
            t: 0,
            b: {
              t: 2,
              i: [{ t: 3 }],
              s: "Enter the link and press enter to confirm.",
            },
          },
          alt_input: {
            t: 0,
            b: {
              t: 2,
              i: [{ t: 3 }],
              s: "Enter the image alt and press enter to confirm.",
            },
          },
          alt_href: {
            t: 0,
            b: {
              t: 2,
              i: [{ t: 3 }],
              s: "Enter the image hyperlink and press enter to confirm.",
            },
          },
        },
        button: {
          new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "New line" } },
          delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
          refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Refresh" } },
          restore_default: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "Restore default" },
          },
        },
        text: {
          default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Default" } },
        },
        line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Line height" } },
        clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear format" } },
      },
    },
  },
  zm = {
    editor: {
      menus: {
        undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        table: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          add_column_before: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          add_column_after: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          add_row_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          add_row_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          toggle_header_column: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "/" },
          },
          toggle_header_row: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "/" },
          },
          toggle_header_cell: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "/" },
          },
          delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          delete_table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
      },
      extensions: {
        commands_menu: {
          columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          placeholder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: " / " },
          },
        },
        link: {
          add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          open_in_new_window: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        audio: {
          disable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          enable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        iframe: {
          disable_frameborder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          enable_frameborder: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          phone_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          tablet_vertical_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          tablet_horizontal_size: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          desktop_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        image: {
          small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          restore_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          edit_alt: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: " alt " },
          },
          edit_href: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
        },
        video: {
          disable_controls: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          enable_controls: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          disable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          enable_autoplay: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        highlight: {
          unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        columns: {
          add_column_before: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          add_column_after: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        search_and_replace: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          search_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          occurrence_found: {
            t: 0,
            b: {
              t: 2,
              i: [
                { t: 3, v: " " },
                { t: 4, k: "index" },
                { t: 3, v: "  " },
                { t: 4, k: "total" },
                { t: 3, v: " " },
              ],
            },
          },
          find_previous: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          replace_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          case_sensitive: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          match_word: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          use_regex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        format_brush: {
          toolbar_item: {
            title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
            cancel: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          },
        },
      },
      components: {
        color_picker: {
          more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
      },
      common: {
        align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        align_justify: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        codeblock: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          copy_code_success: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
        },
        image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        heading: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        tooltip: {
          custom_width_input: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          custom_height_input: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        placeholder: {
          link_input: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
          alt_input: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: " alt " },
          },
          alt_href: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
        },
        button: {
          new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          restore_default: {
            t: 0,
            b: { t: 2, i: [{ t: 3 }], s: "" },
          },
        },
        text: {
          default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        },
        line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      },
    },
  },
  i5 = {
    en: Fm,
    zh: zm,
    "en-US": Fm,
    "zh-CN": zm,
  },
  D = J4({
    legacy: !1,
    locale: "en",
    fallbackLocale: "zh-CN",
    messages: i5,
  }),
  s5 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function a5(t, e) {
  return (
    S(),
    O(
      "svg",
      s5,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M20 10.5a6.5 6.5 0 0 1-6.5 6.5H7.83l3.09 3.09L9.5 21.5L4 16l5.5-5.5l1.41 1.41L7.83 15h5.67c2.5 0 4.5-2 4.5-4.5S16 6 13.5 6H6V4h7.5a6.5 6.5 0 0 1 6.5 6.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const l5 = k({ name: "mdi-arrow-u-left-bottom", render: a5 }),
  u5 = { class: "editor-block__content" },
  c5 = { class: "editor-block__actions" },
  Xz = /* @__PURE__ */ se({
    __name: "BlockCard",
    props: {
      selected: { type: Boolean, default: !1 },
      editor: {},
      getPos: {},
      deleteNode: {},
    },
    setup(t) {
      const e = t;
      function n() {
        e.editor.commands.insertContentAt(
          e.getPos() + 1,
          [{ type: "paragraph", content: "" }],
          {
            updateSelection: !0,
          }
        ),
          e.editor.commands.focus(e.getPos() + 2, {
            scrollIntoView: !0,
          });
      }
      return (r, o) => (
        S(),
        O(
          "section",
          {
            class: $e([
              "editor-block group",
              { "editor-block--selected": r.selected },
            ]),
          },
          [
            C("div", u5, [Kn(r.$slots, "content")]),
            C(
              "div",
              {
                class: $e([
                  "invisible group-hover:visible pb-2 absolute -top-12 right-0",
                  { "!visible": r.selected },
                ]),
              },
              [
                C("div", c5, [
                  Kn(r.$slots, "actions"),
                  J(
                    Li,
                    {
                      tooltip: I(D).global.t("editor.common.button.new_line"),
                      onClick: n,
                    },
                    {
                      icon: me(() => [J(I(l5))]),
                      _: 1,
                    },
                    8,
                    ["tooltip"]
                  ),
                  J(ot),
                  J(
                    Li,
                    {
                      tooltip: I(D).global.t("editor.common.button.delete"),
                      onClick: r.deleteNode,
                    },
                    {
                      icon: me(() => [J(pi)]),
                      _: 1,
                    },
                    8,
                    ["tooltip", "onClick"]
                  ),
                ]),
              ],
              2
            ),
          ],
          2
        )
      );
    },
  }),
  d5 = ["title"],
  f5 = {
    class:
      "relative rounded-md bg-white overflow-hidden shadow w-96 p-1 max-h-72 overflow-y-auto",
  },
  Th = /* @__PURE__ */ se({
    __name: "BubbleItem",
    props: {
      editor: {},
      isActive: { type: Function, default: () => !1 },
      visible: { type: Function, default: () => !0 },
      icon: { default: void 0 },
      iconStyle: { default: void 0 },
      title: { default: void 0 },
      action: { type: Function, default: void 0 },
    },
    setup(t) {
      const e = t,
        n = Te(),
        r = (o) => {
          var s;
          if (!e.action) return;
          const i = (s = e.action) == null ? void 0 : s.call(e, { editor: o });
          typeof i == "object" && (n.value = i);
        };
      return (o, i) => (
        S(),
        de(
          I(ii),
          {
            class: "inline-flex",
            triggers: [],
            "auto-hide": !0,
            shown: !!n.value,
            distance: 10,
            onHide: i[1] || (i[1] = (s) => (n.value = void 0)),
          },
          {
            popper: me(() => [
              C("div", f5, [
                (S(),
                de(
                  Mx,
                  null,
                  [(S(), de(wn(n.value), ph(hh(e)), null, 16))],
                  1024
                )),
              ]),
            ]),
            default: me(() => [
              o.visible({ editor: o.editor })
                ? je(
                    (S(),
                    O(
                      "button",
                      {
                        key: 0,
                        class: $e([
                          {
                            "bg-gray-200 !text-black": o.isActive({
                              editor: o.editor,
                            }),
                          },
                          "text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md",
                        ]),
                        title: o.title,
                        onClick: i[0] || (i[0] = (s) => r(o.editor)),
                      },
                      [
                        (S(),
                        de(
                          wn(o.icon),
                          {
                            style: mt(o.iconStyle),
                            class: "w-5 h-5",
                          },
                          null,
                          8,
                          ["style"]
                        )),
                      ],
                      10,
                      d5
                    )),
                    [
                      [
                        I(Sa),
                        {
                          content: o.title,
                          distance: 8,
                          delay: {
                            show: 0,
                          },
                        },
                      ],
                    ]
                  )
                : un("", !0),
            ]),
            _: 1,
          },
          8,
          ["shown"]
        )
      );
    },
  });
function Zf(t, e, n, r) {
  for (let o = 0, i = 0; o < t.childCount; o++) {
    let s = t.child(o),
      a = i + s.nodeSize,
      l = Math.max(i, e),
      u = Math.min(a, n);
    if (l < u)
      if (s.isText)
        for (let c = l; c < u; c++) r.push(s.text.charCodeAt(c - i));
      else
        s.isLeaf
          ? r.push(s.type.name)
          : (l == i && r.push(s.type.name),
            Zf(
              s.content,
              Math.max(i + 1, l) - i - 1,
              Math.min(a - 1, u) - i - 1,
              r
            ),
            u == a && r.push(-1));
    i = a;
  }
  return r;
}
const p5 = 5e3;
function h5(t, e) {
  return Math.min(15, Math.max(2, Math.floor(Math.max(t, e) / 10)));
}
function uy(t, e, n) {
  let r = Zf(t, n.fromA, n.toA, []),
    o = Zf(e, n.fromB, n.toB, []),
    i = 0,
    s = r.length,
    a = o.length;
  for (; i < r.length && i < o.length && r[i] === o[i]; ) i++;
  if (i == r.length && i == o.length) return [];
  for (; s > i && a > i && r[s - 1] === o[a - 1]; ) s--, a--;
  if (s == i || a == i || (s == a && s == i + 1)) return [n.slice(i, s, i, a)];
  let l = s - i,
    u = a - i,
    c = Math.min(p5, l + u),
    d = c + 1,
    f = [],
    p = [];
  for (let h = d * 2, m = 0; m < h; m++) p[m] = -1;
  for (let h = 0; h <= c; h++) {
    for (let m = -h; m <= h; m += 2) {
      let g = p[m + 1 + c],
        b = p[m - 1 + c],
        _ = g < b ? b : g + 1,
        v = _ + m;
      for (; _ < l && v < u && r[i + _] === o[i + v]; ) _++, v++;
      if (((p[m + c] = _), _ >= l && v >= u)) {
        let y = [],
          w = h5(s - i, a - i),
          x = -1,
          M = -1,
          N = -1,
          T = -1,
          P = (z, H, U, re) => {
            x > -1 && x < H + w
              ? ((x = z), (N = U))
              : (x > -1 && y.push(n.slice(x, M, N, T)),
                (x = z),
                (M = H),
                (N = U),
                (T = re));
          };
        for (let z = h - 1; z >= 0; z--) {
          let H = p[m + 1 + c],
            U = p[m - 1 + c];
          H < U
            ? (m--, (_ = U + i), (v = _ + m), P(_, _, v, v + 1))
            : (m++, (_ = H + i), (v = _ + m), P(_, _ + 1, v, v)),
            (p = f[z >> 1]);
        }
        return x > -1 && y.push(n.slice(x, M, N, T)), y.reverse();
      }
    }
    h % 2 == 0 && f.push(p.slice());
  }
  return [n.slice(i, s, i, a)];
}
class Ie {
  /**
  @internal
  */
  constructor(e, n) {
    (this.length = e), (this.data = n);
  }
  /**
  @internal
  */
  cut(e) {
    return e == this.length ? this : new Ie(e, this.data);
  }
  /**
  @internal
  */
  static slice(e, n, r) {
    if (n == r) return Ie.none;
    if (n == 0 && r == Ie.len(e)) return e;
    let o = [];
    for (let i = 0, s = 0; s < r; i++) {
      let a = e[i],
        l = s + a.length,
        u = Math.min(r, l) - Math.max(n, s);
      u > 0 && o.push(a.cut(u)), (s = l);
    }
    return o;
  }
  /**
  @internal
  */
  static join(e, n, r) {
    if (e.length == 0) return n;
    if (n.length == 0) return e;
    let o = r(e[e.length - 1].data, n[0].data);
    if (o == null) return e.concat(n);
    let i = e.slice(0, e.length - 1);
    i.push(new Ie(e[e.length - 1].length + n[0].length, o));
    for (let s = 1; s < n.length; s++) i.push(n[s]);
    return i;
  }
  /**
  @internal
  */
  static len(e) {
    let n = 0;
    for (let r = 0; r < e.length; r++) n += e[r].length;
    return n;
  }
}
Ie.none = [];
class Vn {
  /**
  @internal
  */
  constructor(e, n, r, o, i, s) {
    (this.fromA = e),
      (this.toA = n),
      (this.fromB = r),
      (this.toB = o),
      (this.deleted = i),
      (this.inserted = s);
  }
  /**
  @internal
  */
  get lenA() {
    return this.toA - this.fromA;
  }
  /**
  @internal
  */
  get lenB() {
    return this.toB - this.fromB;
  }
  /**
  @internal
  */
  slice(e, n, r, o) {
    return e == 0 &&
      r == 0 &&
      n == this.toA - this.fromA &&
      o == this.toB - this.fromB
      ? this
      : new Vn(
          this.fromA + e,
          this.fromA + n,
          this.fromB + r,
          this.fromB + o,
          Ie.slice(this.deleted, e, n),
          Ie.slice(this.inserted, r, o)
        );
  }
  /**
  This merges two changesets (the end document of x should be the
  start document of y) into a single one spanning the start of x to
  the end of y.
  */
  static merge(e, n, r) {
    if (e.length == 0) return n;
    if (n.length == 0) return e;
    let o = [];
    for (let i = 0, s = 0, a = e[0], l = n[0]; ; ) {
      if (!a && !l) return o;
      if (a && (!l || a.toB < l.fromA)) {
        let u = s ? n[s - 1].toB - n[s - 1].toA : 0;
        o.push(
          u == 0
            ? a
            : new Vn(
                a.fromA,
                a.toA,
                a.fromB + u,
                a.toB + u,
                a.deleted,
                a.inserted
              )
        ),
          (a = i++ == e.length ? null : e[i]);
      } else if (l && (!a || l.toA < a.fromB)) {
        let u = i ? e[i - 1].toB - e[i - 1].toA : 0;
        o.push(
          u == 0
            ? l
            : new Vn(
                l.fromA - u,
                l.toA - u,
                l.fromB,
                l.toB,
                l.deleted,
                l.inserted
              )
        ),
          (l = s++ == n.length ? null : n[s]);
      } else {
        let u = Math.min(a.fromB, l.fromA),
          c = Math.min(
            a.fromA,
            l.fromA - (i ? e[i - 1].toB - e[i - 1].toA : 0)
          ),
          d = c,
          f = Math.min(
            l.fromB,
            a.fromB + (s ? n[s - 1].toB - n[s - 1].toA : 0)
          ),
          p = f,
          h = Ie.none,
          m = Ie.none,
          g = !1,
          b = !1;
        for (;;) {
          let _ = a ? (u >= a.fromB ? a.toB : a.fromB) : 2e8,
            v = l ? (u >= l.fromA ? l.toA : l.fromA) : 2e8,
            y = Math.min(_, v),
            w = a && u >= a.fromB,
            x = l && u >= l.fromA;
          if (!w && !x) break;
          w &&
            u == a.fromB &&
            !g &&
            ((h = Ie.join(h, a.deleted, r)), (d += a.lenA), (g = !0)),
            w &&
              !x &&
              ((m = Ie.join(
                m,
                Ie.slice(a.inserted, u - a.fromB, y - a.fromB),
                r
              )),
              (p += y - u)),
            x &&
              u == l.fromA &&
              !b &&
              ((m = Ie.join(m, l.inserted, r)), (p += l.lenB), (b = !0)),
            x &&
              !w &&
              ((h = Ie.join(
                h,
                Ie.slice(l.deleted, u - l.fromA, y - l.fromA),
                r
              )),
              (d += y - u)),
            w && y == a.toB && ((a = i++ == e.length ? null : e[i]), (g = !1)),
            x && y == l.toA && ((l = s++ == n.length ? null : n[s]), (b = !1)),
            (u = y);
        }
        (c < d || f < p) && o.push(new Vn(c, d, f, p, h, m));
      }
    }
  }
}
let Qf;
try {
  Qf = new RegExp("[\\p{Alphabetic}_]", "u");
} catch {}
const m5 =
  /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function _i(t) {
  if (t < 128)
    return (
      (t >= 48 && t <= 57) || (t >= 65 && t <= 90) || (t >= 79 && t <= 122)
    );
  let e = String.fromCharCode(t);
  return Qf ? Qf.test(e) : e.toUpperCase() != e.toLowerCase() || m5.test(e);
}
function g5(t, e, n) {
  let r = "";
  function o(i, s, a) {
    for (let l = 0, u = 0; l < i.childCount; l++) {
      let c = i.child(l),
        d = u + c.nodeSize,
        f = Math.max(u, s),
        p = Math.min(d, a);
      f < p &&
        (c.isText
          ? (r += c.text.slice(
              Math.max(0, s - u),
              Math.min(c.text.length, a - u)
            ))
          : c.isLeaf
          ? (r += " ")
          : (f == u && (r += " "),
            o(
              c.content,
              Math.max(0, f - u - 1),
              Math.min(c.content.size, a - u)
            ),
            p == d && (r += " "))),
        (u = d);
    }
  }
  return o(t, e, n), r;
}
const ep = 30;
function Zz(t, e) {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let o = t[r].toB,
      i = r;
    for (; r < t.length - 1 && t[r + 1].fromB <= o + ep; ) o = t[++r].toB;
    b5(t, i, r + 1, e, n);
  }
  return n;
}
function b5(t, e, n, r, o) {
  let i = Math.max(0, t[e].fromB - ep),
    s = Math.min(r.content.size, t[n - 1].toB + ep),
    a = g5(r.content, i, s);
  for (let l = e; l < n; l++) {
    let u = l,
      c = t[l],
      d = c.lenA,
      f = c.lenB;
    for (; l < n - 1; ) {
      let p = t[l + 1],
        h = !1,
        m = c.toB == s ? !1 : _i(a.charCodeAt(c.toB - 1 - i));
      for (let g = c.toB; !h && g < p.fromB; g++) {
        let b = g == s ? !1 : _i(a.charCodeAt(g - i));
        (!m || !b) && g != t[u].fromB && (h = !0), (m = b);
      }
      if (h) break;
      (d += p.lenA), (f += p.lenB), (c = p), l++;
    }
    if (f > 0 && d > 0 && !(f == 1 && d == 1)) {
      let p = t[u].fromB,
        h = t[l].toB;
      if (p < s && _i(a.charCodeAt(p - i)))
        for (; p > i && _i(a.charCodeAt(p - 1 - i)); ) p--;
      if (h > i && _i(a.charCodeAt(h - 1 - i)))
        for (; h < s && _i(a.charCodeAt(h - i)); ) h++;
      let m = y5(t.slice(u, l + 1), p, h),
        g = o.length ? o[o.length - 1] : null;
      g && g.toA == m.fromA
        ? (o[o.length - 1] = new Vn(
            g.fromA,
            m.toA,
            g.fromB,
            m.toB,
            g.deleted.concat(m.deleted),
            g.inserted.concat(m.inserted)
          ))
        : o.push(m);
    } else for (let p = u; p <= l; p++) o.push(t[p]);
  }
  return t;
}
function nl(t, e) {
  return t === e ? t : null;
}
function y5(t, e, n) {
  let r = t[0].fromA - (t[0].fromB - e),
    o = t[t.length - 1],
    i = o.toA + (n - o.toB),
    s = Ie.none,
    a = Ie.none,
    l = (t[0].deleted.length ? t[0].deleted : t[0].inserted)[0].data,
    u = (t[0].inserted.length ? t[0].inserted : t[0].deleted)[0].data;
  for (let c = r, d = e, f = 0; ; f++) {
    let p = f == t.length ? null : t[f],
      h = p ? p.fromA : i,
      m = p ? p.fromB : n;
    if (
      (h > c && (s = Ie.join(s, [new Ie(h - c, l)], nl)),
      m > d && (a = Ie.join(a, [new Ie(m - d, u)], nl)),
      !p)
    )
      break;
    (s = Ie.join(s, p.deleted, nl)),
      (a = Ie.join(a, p.inserted, nl)),
      s.length && (l = s[s.length - 1].data),
      a.length && (u = a[a.length - 1].data),
      (c = p.toA),
      (d = p.toB);
  }
  return new Vn(r, i, e, n, s, a);
}
class Ss {
  /**
  @internal
  */
  constructor(e, n) {
    (this.config = e), (this.changes = n);
  }
  /**
  Computes a new changeset by adding the given step maps and
  metadata (either as an array, per-map, or as a single value to be
  associated with all maps) to the current set. Will not mutate the
  old set.
  
  Note that due to simplification that happens after each add,
  incrementally adding steps might create a different final set
  than adding all those changes at once, since different document
  tokens might be matched during simplification depending on the
  boundaries of the current changed ranges.
  */
  addSteps(e, n, r) {
    let o = [];
    for (let l = 0; l < n.length; l++) {
      let u = Array.isArray(r) ? r[l] : r,
        c = 0;
      n[l].forEach((d, f, p, h) => {
        o.push(
          new Vn(
            d + c,
            f + c,
            p,
            h,
            d == f ? Ie.none : [new Ie(f - d, u)],
            p == h ? Ie.none : [new Ie(h - p, u)]
          )
        ),
          (c = h - p - (f - d));
      });
    }
    if (o.length == 0) return this;
    let i = tp(o, this.config.combine),
      s = Vn.merge(this.changes, i, this.config.combine),
      a = s;
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (
        u.fromA == u.toA ||
        u.fromB == u.toB || // Only look at changes that touch newly added changed ranges
        !i.some((d) => d.toB > u.fromB && d.fromB < u.toB)
      )
        continue;
      let c = uy(this.config.doc.content, e.content, u);
      (c.length == 1 && c[0].fromB == 0 && c[0].toB == u.toB - u.fromB) ||
        (a == s && (a = s.slice()),
        c.length == 1
          ? (a[l] = c[0])
          : (a.splice(l, 1, ...c), (l += c.length - 1)));
    }
    return new Ss(this.config, a);
  }
  /**
  The starting document of the change set.
  */
  get startDoc() {
    return this.config.doc;
  }
  /**
  Map the span's data values in the given set through a function
  and construct a new set with the resulting data.
  */
  map(e) {
    let n = (r) => {
      let o = e(r);
      return o === r.data ? r : new Ie(r.length, o);
    };
    return new Ss(
      this.config,
      this.changes.map(
        (r) =>
          new Vn(
            r.fromA,
            r.toA,
            r.fromB,
            r.toB,
            r.deleted.map(n),
            r.inserted.map(n)
          )
      )
    );
  }
  /**
  Compare two changesets and return the range in which they are
  changed, if any. If the document changed between the maps, pass
  the maps for the steps that changed it as second argument, and
  make sure the method is called on the old set and passed the new
  set. The returned positions will be in new document coordinates.
  */
  changedRange(e, n) {
    if (e == this) return null;
    let r = n && v5(n),
      o = r ? r.toB - r.fromB - (r.toA - r.fromA) : 0;
    function i(d) {
      return !r || d <= r.fromA ? d : d + o;
    }
    let s = r ? r.fromB : 2e8,
      a = r ? r.toB : -2e8;
    function l(d, f = d) {
      (s = Math.min(d, s)), (a = Math.max(f, a));
    }
    let u = this.changes,
      c = e.changes;
    for (let d = 0, f = 0; d < u.length && f < c.length; ) {
      let p = u[d],
        h = c[f];
      p && h && _5(p, h, i)
        ? (d++, f++)
        : h && (!p || i(p.fromB) >= h.fromB)
        ? (l(h.fromB, h.toB), f++)
        : (l(i(p.fromB), i(p.toB)), d++);
    }
    return s <= a ? { from: s, to: a } : null;
  }
  /**
  Create a changeset with the given base object and configuration.
  The `combine` function is used to compare and combine metadatait
  should return null when metadata isn't compatible, and a combined
  version for a merged range when it is.
  */
  static create(e, n = (r, o) => (r === o ? r : null)) {
    return new Ss({ combine: n, doc: e }, []);
  }
}
Ss.computeDiff = uy;
function tp(t, e, n = 0, r = t.length) {
  if (r == n + 1) return [t[n]];
  let o = (n + r) >> 1;
  return Vn.merge(tp(t, e, n, o), tp(t, e, o, r), e);
}
function Vm(t) {
  let e = 2e8,
    n = -2e8;
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    e != 2e8 && ((e = o.map(e, -1)), (n = o.map(n, 1))),
      o.forEach((i, s, a, l) => {
        (e = Math.min(e, a)), (n = Math.max(n, l));
      });
  }
  return e == 2e8 ? null : { from: e, to: n };
}
function v5(t) {
  let e = Vm(t);
  if (!e) return null;
  let n = Vm(t.map((r) => r.invert()).reverse());
  return { fromA: n.from, toA: n.to, fromB: e.from, toB: e.to };
}
function _5(t, e, n) {
  return (
    n(t.fromB) == e.fromB &&
    n(t.toB) == e.toB &&
    Um(t.deleted, e.deleted) &&
    Um(t.inserted, e.inserted)
  );
}
function Um(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n].length != e[n].length || t[n].data !== e[n].data) return !1;
  return !0;
}
function vt(t) {
  this.content = t;
}
vt.prototype = {
  constructor: vt,
  find: function (t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function (t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function (t, e, n) {
    var r = n && n != t ? this.remove(n) : this,
      o = r.find(t),
      i = r.content.slice();
    return (
      o == -1 ? i.push(n || t, e) : ((i[o + 1] = e), n && (i[o] = n)), new vt(i)
    );
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function (t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new vt(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function (t, e) {
    return new vt([t, e].concat(this.remove(t).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function (t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new vt(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function (t, e, n) {
    var r = this.remove(e),
      o = r.content.slice(),
      i = r.find(t);
    return o.splice(i == -1 ? o.length : i, 0, e, n), new vt(o);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function (t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function (t) {
    return (
      (t = vt.from(t)),
      t.size ? new vt(t.content.concat(this.subtract(t).content)) : this
    );
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function (t) {
    return (
      (t = vt.from(t)),
      t.size ? new vt(this.subtract(t).content.concat(t.content)) : this
    );
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function (t) {
    var e = this;
    t = vt.from(t);
    for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n]);
    return e;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function () {
    var t = {};
    return (
      this.forEach(function (e, n) {
        t[e] = n;
      }),
      t
    );
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  },
};
vt.from = function (t) {
  if (t instanceof vt) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new vt(e);
};
function cy(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let o = t.child(r),
      i = e.child(r);
    if (o == i) {
      n += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(i)) return n;
    if (o.isText && o.text != i.text) {
      for (let s = 0; o.text[s] == i.text[s]; s++) n++;
      return n;
    }
    if (o.content.size || i.content.size) {
      let s = cy(o.content, i.content, n + 1);
      if (s != null) return s;
    }
    n += o.nodeSize;
  }
}
function dy(t, e, n, r) {
  for (let o = t.childCount, i = e.childCount; ; ) {
    if (o == 0 || i == 0) return o == i ? null : { a: n, b: r };
    let s = t.child(--o),
      a = e.child(--i),
      l = s.nodeSize;
    if (s == a) {
      (n -= l), (r -= l);
      continue;
    }
    if (!s.sameMarkup(a)) return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let u = 0,
        c = Math.min(s.text.length, a.text.length);
      for (
        ;
        u < c && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1];

      )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let u = dy(s.content, a.content, n - 1, r - 1);
      if (u) return u;
    }
    (n -= l), (r -= l);
  }
}
class $ {
  /**
  @internal
  */
  constructor(e, n) {
    if (((this.content = e), (this.size = n || 0), n == null))
      for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, o = 0, i) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s],
        u = a + l.nodeSize;
      if (u > e && r(l, o + a, i || null, s) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(
          Math.max(0, e - c),
          Math.min(l.content.size, n - c),
          r,
          o + c
        );
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, o) {
    let i = "",
      s = !0;
    return (
      this.nodesBetween(
        e,
        n,
        (a, l) => {
          let u = a.isText
            ? a.text.slice(Math.max(e, l) - l, n - l)
            : a.isLeaf
            ? o
              ? typeof o == "function"
                ? o(a)
                : o
              : a.type.spec.leafText
              ? a.type.spec.leafText(a)
              : ""
            : "";
          a.isBlock &&
            ((a.isLeaf && u) || a.isTextblock) &&
            r &&
            (s ? (s = !1) : (i += r)),
            (i += u);
        },
        0
      ),
      i
    );
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size) return this;
    if (!this.size) return e;
    let n = this.lastChild,
      r = e.firstChild,
      o = this.content.slice(),
      i = 0;
    for (
      n.isText &&
      n.sameMarkup(r) &&
      ((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
      i < e.content.length;
      i++
    )
      o.push(e.content[i]);
    return new $(o, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size) return this;
    let r = [],
      o = 0;
    if (n > e)
      for (let i = 0, s = 0; s < n; i++) {
        let a = this.content[i],
          l = s + a.nodeSize;
        l > e &&
          ((s < e || l > n) &&
            (a.isText
              ? (a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)))
              : (a = a.cut(
                  Math.max(0, e - s - 1),
                  Math.min(a.content.size, n - s - 1)
                ))),
          r.push(a),
          (o += a.nodeSize)),
          (s = l);
      }
    return new $(r, o);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n
      ? $.empty
      : e == 0 && n == this.content.length
      ? this
      : new $(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n) return this;
    let o = this.content.slice(),
      i = this.size + n.nodeSize - r.nodeSize;
    return (o[e] = n), new $(o, i);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new $([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new $(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length) return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n])) return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n) throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let o = this.content[n];
      e(o, r, n), (r += o.nodeSize);
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return cy(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return dy(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0) return rl(0, e);
    if (e == this.size) return rl(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, o = 0; ; r++) {
      let i = this.child(r),
        s = o + i.nodeSize;
      if (s >= e) return s == e || n > 0 ? rl(r + 1, s) : rl(r, o);
      o = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n) return $.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length) return $.empty;
    let n,
      r = 0;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      (r += i.nodeSize),
        o && i.isText && e[o - 1].sameMarkup(i)
          ? (n || (n = e.slice(0, o)),
            (n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)))
          : n && n.push(i);
    }
    return new $(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e) return $.empty;
    if (e instanceof $) return e;
    if (Array.isArray(e)) return this.fromArray(e);
    if (e.attrs) return new $([e], e.nodeSize);
    throw new RangeError(
      "Can not convert " +
        e +
        " to a Fragment" +
        (e.nodesBetween
          ? " (looks like multiple versions of prosemirror-model were loaded)"
          : "")
    );
  }
}
$.empty = new $([], 0);
const Ld = { index: 0, offset: 0 };
function rl(t, e) {
  return (Ld.index = t), (Ld.offset = e), Ld;
}
function su(t, e) {
  if (t === e) return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n) return !1;
  if (n) {
    if (t.length != e.length) return !1;
    for (let r = 0; r < t.length; r++) if (!su(t[r], e[r])) return !1;
  } else {
    for (let r in t) if (!(r in e) || !su(t[r], e[r])) return !1;
    for (let r in e) if (!(r in t)) return !1;
  }
  return !0;
}
let Oe = class np {
  /**
  @internal
  */
  constructor(e, n) {
    (this.type = e), (this.attrs = n);
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n,
      r = !1;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      if (this.eq(i)) return e;
      if (this.type.excludes(i.type)) n || (n = e.slice(0, o));
      else {
        if (i.type.excludes(this.type)) return e;
        !r &&
          i.type.rank > this.type.rank &&
          (n || (n = e.slice(0, o)), n.push(this), (r = !0)),
          n && n.push(i);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || (this.type == e.type && su(this.attrs, e.attrs));
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let o = r.create(n.attrs);
    return r.checkAttrs(o.attrs), o;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n) return !0;
    if (e.length != n.length) return !1;
    for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || (Array.isArray(e) && e.length == 0)) return np.none;
    if (e instanceof np) return [e];
    let n = e.slice();
    return n.sort((r, o) => r.type.rank - o.type.rank), n;
  }
};
Oe.none = [];
class au extends Error {}
class W {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    (this.content = e), (this.openStart = n), (this.openEnd = r);
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = py(this.content, e + this.openStart, n);
    return r && new W(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new W(
      fy(this.content, e + this.openStart, n + this.openStart),
      this.openStart,
      this.openEnd
    );
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return (
      this.content.eq(e.content) &&
      this.openStart == e.openStart &&
      this.openEnd == e.openEnd
    );
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size) return null;
    let e = { content: this.content.toJSON() };
    return (
      this.openStart > 0 && (e.openStart = this.openStart),
      this.openEnd > 0 && (e.openEnd = this.openEnd),
      e
    );
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n) return W.empty;
    let r = n.openStart || 0,
      o = n.openEnd || 0;
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new W($.fromJSON(e, n.content), r, o);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0,
      o = 0;
    for (
      let i = e.firstChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.firstChild
    )
      r++;
    for (
      let i = e.lastChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.lastChild
    )
      o++;
    return new W(e, r, o);
  }
}
W.empty = new W($.empty, 0, 0);
function fy(t, e, n) {
  let { index: r, offset: o } = t.findIndex(e),
    i = t.maybeChild(r),
    { index: s, offset: a } = t.findIndex(n);
  if (o == e || i.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != s) throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, i.copy(fy(i.content, e - o - 1, n - o - 1)));
}
function py(t, e, n, r) {
  let { index: o, offset: i } = t.findIndex(e),
    s = t.maybeChild(o);
  if (i == e || s.isText) return t.cut(0, e).append(n).append(t.cut(e));
  let a = py(s.content, e - i - 1, n);
  return a && t.replaceChild(o, s.copy(a));
}
function x5(t, e, n) {
  if (n.openStart > t.depth)
    throw new au("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new au("Inconsistent open depths");
  return hy(t, e, n, 0);
}
function hy(t, e, n, r) {
  let o = t.index(r),
    i = t.node(r);
  if (o == e.index(r) && r < t.depth - n.openStart) {
    let s = hy(t, e, n, r + 1);
    return i.copy(i.content.replaceChild(o, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let s = t.parent,
        a = s.content;
      return Qo(
        s,
        a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset))
      );
    } else {
      let { start: s, end: a } = k5(n, t);
      return Qo(i, gy(t, s, a, e, r));
    }
  else return Qo(i, lu(t, e, r));
}
function my(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new au("Cannot join " + e.type.name + " onto " + t.type.name);
}
function rp(t, e, n) {
  let r = t.node(n);
  return my(r, e.node(n)), r;
}
function Zo(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n])
    ? (e[n] = t.withText(e[n].text + t.text))
    : e.push(t);
}
function Es(t, e, n, r) {
  let o = (e || t).node(n),
    i = 0,
    s = e ? e.index(n) : o.childCount;
  t &&
    ((i = t.index(n)),
    t.depth > n ? i++ : t.textOffset && (Zo(t.nodeAfter, r), i++));
  for (let a = i; a < s; a++) Zo(o.child(a), r);
  e && e.depth == n && e.textOffset && Zo(e.nodeBefore, r);
}
function Qo(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function gy(t, e, n, r, o) {
  let i = t.depth > o && rp(t, e, o + 1),
    s = r.depth > o && rp(n, r, o + 1),
    a = [];
  return (
    Es(null, t, o, a),
    i && s && e.index(o) == n.index(o)
      ? (my(i, s), Zo(Qo(i, gy(t, e, n, r, o + 1)), a))
      : (i && Zo(Qo(i, lu(t, e, o + 1)), a),
        Es(e, n, o, a),
        s && Zo(Qo(s, lu(n, r, o + 1)), a)),
    Es(r, null, o, a),
    new $(a)
  );
}
function lu(t, e, n) {
  let r = [];
  if ((Es(null, t, n, r), t.depth > n)) {
    let o = rp(t, e, n + 1);
    Zo(Qo(o, lu(t, e, n + 1)), r);
  }
  return Es(e, null, n, r), new $(r);
}
function k5(t, e) {
  let n = e.depth - t.openStart,
    o = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--) o = e.node(i).copy($.from(o));
  return {
    start: o.resolveNoCache(t.openStart + n),
    end: o.resolveNoCache(o.content.size - t.openEnd - n),
  };
}
class ta {
  /**
  @internal
  */
  constructor(e, n, r) {
    (this.pos = e),
      (this.path = n),
      (this.parentOffset = r),
      (this.depth = n.length / 3 - 1);
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return (
      (e = this.resolveDepth(e)),
      this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    );
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return (
      (e = this.resolveDepth(e)), this.start(e) + this.node(e).content.size
    );
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1
      ? this.pos
      : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent,
      n = this.index(this.depth);
    if (n == e.childCount) return null;
    let r = this.pos - this.path[this.path.length - 1],
      o = e.child(n);
    return r ? e.child(n).cut(r) : o;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth),
      n = this.pos - this.path[this.path.length - 1];
    return n
      ? this.parent.child(e).cut(0, n)
      : e == 0
      ? null
      : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3],
      o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++) o += r.child(i).nodeSize;
    return o;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent,
      n = this.index();
    if (e.content.size == 0) return Oe.none;
    if (this.textOffset) return e.child(n).marks;
    let r = e.maybeChild(n - 1),
      o = e.maybeChild(n);
    if (!r) {
      let a = r;
      (r = o), (o = a);
    }
    let i = r.marks;
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 &&
        (!o || !i[s].isInSet(o.marks)) &&
        (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline) return null;
    let r = n.marks,
      o = e.parent.maybeChild(e.index());
    for (var i = 0; i < r.length; i++)
      r[i].type.spec.inclusive === !1 &&
        (!o || !r[i].isInSet(o.marks)) &&
        (r = r[i--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e) return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos) return e.blockRange(this);
    for (
      let r =
        this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
      r >= 0;
      r--
    )
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new uu(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [],
      o = 0,
      i = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(i),
        u = i - l;
      if ((r.push(s, a, o + l), !u || ((s = s.child(a)), s.isText))) break;
      (i = u - 1), (o += l + 1);
    }
    return new ta(n, r, i);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = jm.get(e);
    if (r)
      for (let i = 0; i < r.elts.length; i++) {
        let s = r.elts[i];
        if (s.pos == n) return s;
      }
    else jm.set(e, (r = new w5()));
    let o = (r.elts[r.i] = ta.resolve(e, n));
    return (r.i = (r.i + 1) % C5), o;
  }
}
class w5 {
  constructor() {
    (this.elts = []), (this.i = 0);
  }
}
const C5 = 12,
  jm = /* @__PURE__ */ new WeakMap();
class uu {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    (this.$from = e), (this.$to = n), (this.depth = r);
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const A5 = /* @__PURE__ */ Object.create(null);
let qn = class op {
  /**
  @internal
  */
  constructor(e, n, r, o = Oe.none) {
    (this.type = e),
      (this.attrs = n),
      (this.marks = o),
      (this.content = r || $.empty);
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, o = 0) {
    this.content.nodesBetween(e, n, r, o, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, o) {
    return this.content.textBetween(e, n, r, o);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return (
      this.type == e &&
      su(this.attrs, n || e.defaultAttrs || A5) &&
      Oe.sameSet(this.marks, r || Oe.none)
    );
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content
      ? this
      : new op(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks
      ? this
      : new op(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size
      ? this
      : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n) return W.empty;
    let o = this.resolve(e),
      i = this.resolve(n),
      s = r ? 0 : o.sharedDepth(n),
      a = o.start(s),
      u = o.node(s).content.cut(o.pos - a, i.pos - a);
    return new W(u, o.depth - s, i.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return x5(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: o } = n.content.findIndex(e);
      if (((n = n.maybeChild(r)), !n)) return null;
      if (o == e || n.isText) return n;
      e -= o + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0) return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e) return { node: this.content.child(n), index: n, offset: r };
    let o = this.content.child(n - 1);
    return { node: o, index: n - 1, offset: r - o.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return ta.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return ta.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let o = !1;
    return (
      n > e &&
        this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)),
      o
    );
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return (
      this.content.size && (e += "(" + this.content.toStringInner() + ")"),
      by(this.marks, e)
    );
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = $.empty, o = 0, i = r.childCount) {
    let s = this.contentMatchAt(e).matchFragment(r, o, i),
      a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd) return !1;
    for (let l = o; l < i; l++)
      if (!this.type.allowsMarks(r.child(l).marks)) return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, o) {
    if (o && !this.type.allowsMarks(o)) return !1;
    let i = this.contentMatchAt(e).matchType(r),
      s = i && i.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size
      ? this.canReplace(this.childCount, this.childCount, e.content)
      : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Oe.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), (e = r.addToSet(e));
    }
    if (!Oe.sameSet(e, this.marks))
      throw new RangeError(
        `Invalid collection of marks for node ${
          this.type.name
        }: ${this.marks.map((n) => n.type.name)}`
      );
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return (
      this.content.size && (e.content = this.content.toJSON()),
      this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
      e
    );
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n) throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let o = $.fromJSON(e, n.content),
      i = e.nodeType(n.type).create(n.attrs, o, r);
    return i.type.checkAttrs(i.attrs), i;
  }
};
qn.prototype.text = void 0;
class cu extends qn {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    if ((super(e, n, null, o), !r))
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : by(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new cu(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new cu(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length
      ? this
      : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.text = this.text), e;
  }
}
function by(t, e) {
  for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
  return e;
}
class si {
  /**
  @internal
  */
  constructor(e) {
    (this.validEnd = e), (this.next = []), (this.wrapCache = []);
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new S5(e, n);
    if (r.next == null) return si.empty;
    let o = yy(r);
    r.next && r.err("Unexpected trailing text");
    let i = L5(N5(o));
    return R5(i, r), i;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e) return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let o = this;
    for (let i = n; o && i < r; i++) o = o.matchType(e.child(i).type);
    return o;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs())) return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type) return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let o = [this];
    function i(s, a) {
      let l = s.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return $.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: c, next: d } = s.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && o.indexOf(d) == -1) {
          o.push(d);
          let f = i(d, a.concat(c));
          if (f) return f;
        }
      }
      return null;
    }
    return i(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null),
      r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let o = r.shift(),
        i = o.match;
      if (i.matchType(e)) {
        let s = [];
        for (let a = o; a.type; a = a.via) s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: a, next: l } = i.next[s];
        !a.isLeaf &&
          !a.hasRequiredAttrs() &&
          !(a.name in n) &&
          (!o.type || l.validEnd) &&
          (r.push({ match: a.contentMatch, type: a, via: o }),
          (n[a.name] = !0));
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let o = 0; o < r.next.length; o++)
        e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
    }
    return (
      n(this),
      e.map((r, o) => {
        let i = o + (r.validEnd ? "*" : " ") + " ";
        for (let s = 0; s < r.next.length; s++)
          i +=
            (s ? ", " : "") +
            r.next[s].type.name +
            "->" +
            e.indexOf(r.next[s].next);
        return i;
      }).join(`
`)
    );
  }
}
si.empty = new si(!0);
class S5 {
  constructor(e, n) {
    (this.string = e),
      (this.nodeTypes = n),
      (this.inline = null),
      (this.pos = 0),
      (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
      this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
      this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function yy(t) {
  let e = [];
  do e.push(E5(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function E5(t) {
  let e = [];
  do e.push(M5(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function M5(t) {
  let e = D5(t);
  for (;;)
    if (t.eat("+")) e = { type: "plus", expr: e };
    else if (t.eat("*")) e = { type: "star", expr: e };
    else if (t.eat("?")) e = { type: "opt", expr: e };
    else if (t.eat("{")) e = T5(t, e);
    else break;
  return e;
}
function Wm(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function T5(t, e) {
  let n = Wm(t),
    r = n;
  return (
    t.eat(",") && (t.next != "}" ? (r = Wm(t)) : (r = -1)),
    t.eat("}") || t.err("Unclosed braced range"),
    { type: "range", min: n, max: r, expr: e }
  );
}
function O5(t, e) {
  let n = t.nodeTypes,
    r = n[e];
  if (r) return [r];
  let o = [];
  for (let i in n) {
    let s = n[i];
    s.isInGroup(e) && o.push(s);
  }
  return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function D5(t) {
  if (t.eat("(")) {
    let e = yy(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
  else {
    let e = O5(t, t.next).map(
      (n) => (
        t.inline == null
          ? (t.inline = n.isInline)
          : t.inline != n.isInline && t.err("Mixing inline and block content"),
        { type: "name", value: n }
      )
    );
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function N5(t) {
  let e = [[]];
  return o(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(s, a, l) {
    let u = { term: l, to: a };
    return e[s].push(u), u;
  }
  function o(s, a) {
    s.forEach((l) => (l.to = a));
  }
  function i(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, u) => l.concat(i(u, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let u = i(s.exprs[l], a);
        if (l == s.exprs.length - 1) return u;
        o(u, (a = n()));
      }
    else if (s.type == "star") {
      let l = n();
      return r(a, l), o(i(s.expr, l), l), [r(l)];
    } else if (s.type == "plus") {
      let l = n();
      return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)];
    } else {
      if (s.type == "opt") return [r(a)].concat(i(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let u = 0; u < s.min; u++) {
          let c = n();
          o(i(s.expr, l), c), (l = c);
        }
        if (s.max == -1) o(i(s.expr, l), l);
        else
          for (let u = s.min; u < s.max; u++) {
            let c = n();
            r(l, c), o(i(s.expr, l), c), (l = c);
          }
        return [r(l)];
      } else {
        if (s.type == "name") return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function vy(t, e) {
  return e - t;
}
function qm(t, e) {
  let n = [];
  return r(e), n.sort(vy);
  function r(o) {
    let i = t[o];
    if (i.length == 1 && !i[0].term) return r(i[0].to);
    n.push(o);
    for (let s = 0; s < i.length; s++) {
      let { term: a, to: l } = i[s];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function L5(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(qm(t, 0));
  function n(r) {
    let o = [];
    r.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a) return;
        let u;
        for (let c = 0; c < o.length; c++) o[c][0] == a && (u = o[c][1]);
        qm(t, l).forEach((c) => {
          u || o.push([a, (u = [])]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let i = (e[r.join(",")] = new si(r.indexOf(t.length - 1) > -1));
    for (let s = 0; s < o.length; s++) {
      let a = o[s][1].sort(vy);
      i.next.push({ type: o[s][0], next: e[a.join(",")] || n(a) });
    }
    return i;
  }
}
function R5(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let o = r[n],
      i = !o.validEnd,
      s = [];
    for (let a = 0; a < o.next.length; a++) {
      let { type: l, next: u } = o.next[a];
      s.push(l.name),
        i && !(l.isText || l.hasRequiredAttrs()) && (i = !1),
        r.indexOf(u) == -1 && r.push(u);
    }
    i &&
      e.err(
        "Only non-generatable nodes (" +
          s.join(", ") +
          ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
      );
  }
}
function _y(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault) return null;
    e[n] = r.default;
  }
  return e;
}
function xy(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let o = e && e[r];
    if (o === void 0) {
      let i = t[r];
      if (i.hasDefault) o = i.default;
      else throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = o;
  }
  return n;
}
function ky(t, e, n, r) {
  for (let o in e)
    if (!(o in t))
      throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
  for (let o in t) {
    let i = t[o];
    i.validate && i.validate(e[o]);
  }
}
function wy(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e) for (let r in e) n[r] = new P5(t, r, e[r]);
  return n;
}
let Km = class Cy {
  /**
  @internal
  */
  constructor(e, n, r) {
    (this.name = e),
      (this.schema = n),
      (this.spec = r),
      (this.markSet = null),
      (this.groups = r.group ? r.group.split(" ") : []),
      (this.attrs = wy(e, r.attrs)),
      (this.defaultAttrs = _y(this.attrs)),
      (this.contentMatch = null),
      (this.inlineContent = null),
      (this.isBlock = !(r.inline || e == "text")),
      (this.isText = e == "text");
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == si.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : xy(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new qn(this, this.computeAttrs(e), $.from(n), Oe.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return (
      (n = $.from(n)),
      this.checkContent(n),
      new qn(this, this.computeAttrs(e), n, Oe.setFrom(r))
    );
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (((e = this.computeAttrs(e)), (n = $.from(n)), n.size)) {
      let s = this.contentMatch.fillBefore(n);
      if (!s) return null;
      n = s.append(n);
    }
    let o = this.contentMatch.matchFragment(n),
      i = o && o.fillBefore($.empty, !0);
    return i ? new qn(this, e, n.append(i), Oe.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd) return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks)) return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(
        `Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`
      );
  }
  /**
  @internal
  */
  checkAttrs(e) {
    ky(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null) return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type)) return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null) return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type)
        ? n && n.push(e[r])
        : n || (n = e.slice(0, r));
    return n ? (n.length ? n : Oe.none) : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((i, s) => (r[i] = new Cy(i, n, s)));
    let o = n.spec.topNode || "doc";
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!r.text) throw new RangeError("Every schema needs a 'text' type");
    for (let i in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function I5(t, e, n) {
  let r = n.split("|");
  return (o) => {
    let i = o === null ? "null" : typeof o;
    if (r.indexOf(i) < 0)
      throw new RangeError(
        `Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`
      );
  };
}
class P5 {
  constructor(e, n, r) {
    (this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default")),
      (this.default = r.default),
      (this.validate =
        typeof r.validate == "string" ? I5(e, n, r.validate) : r.validate);
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Vc {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    (this.name = e),
      (this.rank = n),
      (this.schema = r),
      (this.spec = o),
      (this.attrs = wy(e, o.attrs)),
      (this.excluded = null);
    let i = _y(this.attrs);
    this.instance = i ? new Oe(this, i) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance
      ? this.instance
      : new Oe(this, xy(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null),
      o = 0;
    return e.forEach((i, s) => (r[i] = new Vc(i, o++, n, s))), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && ((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    ky(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Uc {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    (this.linebreakReplacement = null),
      (this.cached = /* @__PURE__ */ Object.create(null));
    let n = (this.spec = {});
    for (let o in e) n[o] = e[o];
    (n.nodes = vt.from(e.nodes)),
      (n.marks = vt.from(e.marks || {})),
      (this.nodes = Km.compile(this.spec.nodes, this)),
      (this.marks = Vc.compile(this.spec.marks, this));
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let i = this.nodes[o],
        s = i.spec.content || "",
        a = i.spec.marks;
      if (
        ((i.contentMatch = r[s] || (r[s] = si.parse(s, this.nodes))),
        (i.inlineContent = i.contentMatch.inlineContent),
        i.spec.linebreakReplacement)
      ) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError(
            "Linebreak replacement nodes must be inline leaf nodes"
          );
        this.linebreakReplacement = i;
      }
      i.markSet =
        a == "_"
          ? null
          : a
          ? Gm(this, a.split(" "))
          : a == "" || !i.inlineContent
          ? []
          : null;
    }
    for (let o in this.marks) {
      let i = this.marks[o],
        s = i.spec.excludes;
      i.excluded = s == null ? [i] : s == "" ? [] : Gm(this, s.split(" "));
    }
    (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
      (this.markFromJSON = this.markFromJSON.bind(this)),
      (this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
      (this.cached.wrappings = /* @__PURE__ */ Object.create(null));
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, o) {
    if (typeof e == "string") e = this.nodeType(e);
    else if (e instanceof Km) {
      if (e.schema != this)
        throw new RangeError(
          "Node type from different schema used (" + e.name + ")"
        );
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, o);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new cu(r, r.defaultAttrs, e, Oe.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return qn.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Oe.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n) throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function Gm(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let o = e[r],
      i = t.marks[o],
      s = i;
    if (i) n.push(i);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (o == "_" ||
          (l.spec.group && l.spec.group.split(" ").indexOf(o) > -1)) &&
          n.push((s = l));
      }
    if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function $5(t) {
  return t.tag != null;
}
function B5(t) {
  return t.style != null;
}
class zr {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    (this.schema = e), (this.rules = n), (this.tags = []), (this.styles = []);
    let r = (this.matchedStyles = []);
    n.forEach((o) => {
      if ($5(o)) this.tags.push(o);
      else if (B5(o)) {
        let i = /[^=]*/.exec(o.style)[0];
        r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
      }
    }),
      (this.normalizeLists = !this.tags.some((o) => {
        if (!/^(ul|ol)\b/.test(o.tag) || !o.node) return !1;
        let i = e.nodes[o.node];
        return i.contentMatch.matchType(i);
      }));
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new Ym(this, n, !1);
    return r.addAll(e, Oe.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new Ym(this, n, !0);
    return r.addAll(e, Oe.none, n.from, n.to), W.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let i = this.tags[o];
      if (
        z5(e, i.tag) &&
        (i.namespace === void 0 || e.namespaceURI == i.namespace) &&
        (!i.context || n.matchesContext(i.context))
      ) {
        if (i.getAttrs) {
          let s = i.getAttrs(e);
          if (s === !1) continue;
          i.attrs = s || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, o) {
    for (
      let i = o ? this.styles.indexOf(o) + 1 : 0;
      i < this.styles.length;
      i++
    ) {
      let s = this.styles[i],
        a = s.style;
      if (
        !(
          a.indexOf(e) != 0 ||
          (s.context && !r.matchesContext(s.context)) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          (a.length > e.length &&
            (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))
        )
      ) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1) continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(o) {
      let i = o.priority == null ? 50 : o.priority,
        s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < i) break;
      }
      n.splice(s, 0, o);
    }
    for (let o in e.marks) {
      let i = e.marks[o].spec.parseDOM;
      i &&
        i.forEach((s) => {
          r((s = Xm(s))), s.mark || s.ignore || s.clearMark || (s.mark = o);
        });
    }
    for (let o in e.nodes) {
      let i = e.nodes[o].spec.parseDOM;
      i &&
        i.forEach((s) => {
          r((s = Xm(s))), s.node || s.ignore || s.mark || (s.node = o);
        });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return (
      e.cached.domParser || (e.cached.domParser = new zr(e, zr.schemaRules(e)))
    );
  }
}
const Ay = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0,
  },
  H5 = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0,
  },
  Sy = { ol: !0, ul: !0 },
  du = 1,
  fu = 2,
  Ms = 4;
function Jm(t, e, n) {
  return e != null
    ? (e ? du : 0) | (e === "full" ? fu : 0)
    : t && t.whitespace == "pre"
    ? du | fu
    : n & ~Ms;
}
class ol {
  constructor(e, n, r, o, i, s) {
    (this.type = e),
      (this.attrs = n),
      (this.marks = r),
      (this.solid = o),
      (this.options = s),
      (this.content = []),
      (this.activeMarks = Oe.none),
      (this.match = i || (s & Ms ? null : e.contentMatch));
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type) return [];
      let n = this.type.contentMatch.fillBefore($.from(e));
      if (n) this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch,
          o;
        return (o = r.findWrapping(e.type)) ? ((this.match = r), o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & du)) {
      let r = this.content[this.content.length - 1],
        o;
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let i = r;
        r.text.length == o[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = i.withText(
              i.text.slice(0, i.text.length - o[0].length)
            ));
      }
    }
    let n = $.from(this.content);
    return (
      !e && this.match && (n = n.append(this.match.fillBefore($.empty, !0))),
      this.type ? this.type.create(this.attrs, n, this.marks) : n
    );
  }
  inlineContext(e) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
      ? this.content[0].isInline
      : e.parentNode && !Ay.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Ym {
  constructor(e, n, r) {
    (this.parser = e), (this.options = n), (this.isOpen = r), (this.open = 0);
    let o = n.topNode,
      i,
      s = Jm(null, n.preserveWhitespace, 0) | (r ? Ms : 0);
    o
      ? (i = new ol(
          o.type,
          o.attrs,
          Oe.none,
          !0,
          n.topMatch || o.type.contentMatch,
          s
        ))
      : r
      ? (i = new ol(null, null, Oe.none, !0, null, s))
      : (i = new ol(e.schema.topNodeType, null, Oe.none, !0, null, s)),
      (this.nodes = [i]),
      (this.find = n.findPositions),
      (this.needsBlock = !1);
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3
      ? this.addTextNode(e, n)
      : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue,
      o = this.top;
    if (o.options & fu || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o.options & du)
        o.options & fu
          ? (r = r.replace(
              /\r\n?/g,
              `
`
            ))
          : (r = r.replace(/\r?\n|\r/g, " "));
      else if (
        ((r = r.replace(/[ \t\r\n\u000c]+/g, " ")),
        /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1)
      ) {
        let i = o.content[o.content.length - 1],
          s = e.previousSibling;
        (!i ||
          (s && s.nodeName == "BR") ||
          (i.isText && /[ \t\r\n\u000c]$/.test(i.text))) &&
          (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
    } else this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let o = e.nodeName.toLowerCase(),
      i;
    Sy.hasOwnProperty(o) && this.parser.normalizeLists && F5(e);
    let s =
      (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
      (i = this.parser.matchTag(e, this, r));
    if (s ? s.ignore : H5.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : s && s.skip.nodeType && (e = s.skip);
      let a,
        l = this.top,
        u = this.needsBlock;
      if (Ay.hasOwnProperty(o))
        l.content.length &&
          l.content[0].isInline &&
          this.open &&
          (this.open--, (l = this.top)),
          (a = !0),
          l.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        return;
      }
      let c = s && s.skip ? n : this.readStyles(e, n);
      c && this.addAll(e, c), a && this.sync(l), (this.needsBlock = u);
    } else {
      let a = this.readStyles(e, n);
      a && this.addElementByRule(e, s, a, s.consuming === !1 ? i : void 0);
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" &&
      this.top.type &&
      this.top.type.inlineContent &&
      this.addTextNode(
        e.ownerDocument.createTextNode(`
`),
        n
      );
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" &&
      (!this.top.type || !this.top.type.inlineContent) &&
      this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let i = this.parser.matchedStyles[o],
          s = r.getPropertyValue(i);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(i, s, this, a);
            if (!l) break;
            if (l.ignore) return null;
            if (
              (l.clearMark
                ? (n = n.filter((u) => !l.clearMark(u)))
                : (n = n.concat(
                    this.parser.schema.marks[l.mark].create(l.attrs)
                  )),
              l.consuming === !1)
            )
              a = l;
            else break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, o) {
    let i, s;
    if (n.node)
      if (((s = this.parser.schema.nodes[n.node]), s.isLeaf))
        this.insertNode(s.create(n.attrs), r) || this.leafFallback(e, r);
      else {
        let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        l && ((i = !0), (r = l));
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf) this.findInside(e);
    else if (o) this.addElement(e, r, o);
    else if (n.getContent)
      this.findInside(e),
        n
          .getContent(e, this.parser.schema)
          .forEach((l) => this.insertNode(l, r));
    else {
      let l = e;
      typeof n.contentElement == "string"
        ? (l = e.querySelector(n.contentElement))
        : typeof n.contentElement == "function"
        ? (l = n.contentElement(e))
        : n.contentElement && (l = n.contentElement),
        this.findAround(e, l, !0),
        this.addAll(l, r),
        this.findAround(e, l, !1);
    }
    i && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, o) {
    let i = r || 0;
    for (
      let s = r ? e.childNodes[r] : e.firstChild,
        a = o == null ? null : e.childNodes[o];
      s != a;
      s = s.nextSibling, ++i
    )
      this.findAtPoint(e, i), this.addDOM(s, n);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let r, o;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i],
        a = s.findWrapping(e);
      if (
        (a && (!r || r.length > a.length) && ((r = a), (o = s), !a.length)) ||
        s.solid
      )
        break;
    }
    if (!r) return null;
    this.sync(o);
    for (let i = 0; i < r.length; i++) n = this.enterInner(r[i], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let r = this.findPlace(e, n);
    if (r) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(e.type));
      let i = Oe.none;
      for (let s of r.concat(e.marks))
        (o.type ? o.type.allowsMarkType(s.type) : Zm(s.type, e.type)) &&
          (i = s.addToSet(i));
      return o.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, o) {
    let i = this.findPlace(e.create(n), r);
    return i && (i = this.enterInner(e, n, r, !0, o)), i;
  }
  // Open a node of the given type
  enterInner(e, n, r, o = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = Jm(e, i, s.options);
    s.options & Ms && s.content.length == 0 && (a |= Ms);
    let l = Oe.none;
    return (
      (r = r.filter((u) =>
        (s.type ? s.type.allowsMarkType(u.type) : Zm(u.type, e))
          ? ((l = u.addToSet(l)), !1)
          : !0
      )),
      this.nodes.push(new ol(e, n, l, o, null, a)),
      this.open++,
      r
    );
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(this.isOpen || this.options.topOpen)
    );
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e) return (this.open = n), !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let o = r.length - 1; o >= 0; o--) e += r[o].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e &&
          this.find[r].offset == n &&
          (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[n].node) &&
          (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[o].node) &&
          n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) &&
          (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e &&
          (this.find[n].pos =
            this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"),
      r = this.options.context,
      o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
      i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
      s = (a, l) => {
        for (; a >= 0; a--) {
          let u = n[a];
          if (u == "") {
            if (a == n.length - 1 || a == 0) continue;
            for (; l >= i; l--) if (s(a - 1, l)) return !0;
            return !1;
          } else {
            let c =
              l > 0 || (l == 0 && o)
                ? this.nodes[l].type
                : r && l >= i
                ? r.node(l - i).type
                : null;
            if (!c || (c.name != u && !c.isInGroup(u))) return !1;
            l--;
          }
        }
        return !0;
      };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs) return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs) return r;
    }
  }
}
function F5(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Sy.hasOwnProperty(r) && n
      ? (n.appendChild(e), (e = n))
      : r == "li"
      ? (n = e)
      : r && (n = null);
  }
}
function z5(t, e) {
  return (
    t.matches ||
    t.msMatchesSelector ||
    t.webkitMatchesSelector ||
    t.mozMatchesSelector
  ).call(t, e);
}
function Xm(t) {
  let e = {};
  for (let n in t) e[n] = t[n];
  return e;
}
function Zm(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let o = n[r];
    if (!o.allowsMarkType(t)) continue;
    let i = [],
      s = (a) => {
        i.push(a);
        for (let l = 0; l < a.edgeCount; l++) {
          let { type: u, next: c } = a.edge(l);
          if (u == e || (i.indexOf(c) < 0 && s(c))) return !0;
        }
      };
    if (s(o.contentMatch)) return !0;
  }
}
class hi {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    (this.nodes = e), (this.marks = n);
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = Rd(n).createDocumentFragment());
    let o = r,
      i = [];
    return (
      e.forEach((s) => {
        if (i.length || s.marks.length) {
          let a = 0,
            l = 0;
          for (; a < i.length && l < s.marks.length; ) {
            let u = s.marks[l];
            if (!this.marks[u.type.name]) {
              l++;
              continue;
            }
            if (!u.eq(i[a][0]) || u.type.spec.spanning === !1) break;
            a++, l++;
          }
          for (; a < i.length; ) o = i.pop()[1];
          for (; l < s.marks.length; ) {
            let u = s.marks[l++],
              c = this.serializeMark(u, s.isInline, n);
            c &&
              (i.push([u, o]),
              o.appendChild(c.dom),
              (o = c.contentDOM || c.dom));
          }
        }
        o.appendChild(this.serializeNodeInner(s, n));
      }),
      r
    );
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: o } = zl(
      Rd(n),
      this.nodes[e.type.name](e),
      null,
      e.attrs
    );
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, o);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let i = this.serializeMark(e.marks[o], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom));
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let o = this.marks[e.type.name];
    return o && zl(Rd(r), o(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, o) {
    return zl(e, n, r, o);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return (
      e.cached.domSerializer ||
      (e.cached.domSerializer = new hi(
        this.nodesFromSchema(e),
        this.marksFromSchema(e)
      ))
    );
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Qm(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Qm(e.marks);
  }
}
function Qm(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function Rd(t) {
  return t.document || window.document;
}
const e1 = /* @__PURE__ */ new WeakMap();
function V5(t) {
  let e = e1.get(t);
  return e === void 0 && e1.set(t, (e = U5(t))), e;
}
function U5(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string") e || (e = []), e.push(r);
        else for (let o = 0; o < r.length; o++) n(r[o]);
      else for (let o in r) n(r[o]);
  }
  return n(t), e;
}
function zl(t, e, n, r) {
  if (typeof e == "string") return { dom: t.createTextNode(e) };
  if (e.nodeType != null) return { dom: e };
  if (e.dom && e.dom.nodeType != null) return e;
  let o = e[0],
    i;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (i = V5(r)) && i.indexOf(e) > -1)
    throw new RangeError(
      "Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."
    );
  let s = o.indexOf(" ");
  s > 0 && ((n = o.slice(0, s)), (o = o.slice(s + 1)));
  let a,
    l = n ? t.createElementNS(n, o) : t.createElement(o),
    u = e[1],
    c = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    c = 2;
    for (let d in u)
      if (u[d] != null) {
        let f = d.indexOf(" ");
        f > 0
          ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), u[d])
          : l.setAttribute(d, u[d]);
      }
  }
  for (let d = c; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > c)
        throw new RangeError(
          "Content hole must be the only child of its parent node"
        );
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: h } = zl(t, f, n, r);
      if ((l.appendChild(p), h)) {
        if (a) throw new RangeError("Multiple content holes");
        a = h;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const Ey = 65535,
  My = Math.pow(2, 16);
function j5(t, e) {
  return t + e * My;
}
function t1(t) {
  return t & Ey;
}
function W5(t) {
  return (t - (t & Ey)) / My;
}
const Ty = 1,
  Oy = 2,
  Vl = 4,
  Dy = 8;
class ip {
  /**
  @internal
  */
  constructor(e, n, r) {
    (this.pos = e), (this.delInfo = n), (this.recover = r);
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Dy) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Ty | Vl)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Oy | Vl)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Vl) > 0;
  }
}
class an {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (((this.ranges = e), (this.inverted = n), !e.length && an.empty))
      return an.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0,
      r = t1(e);
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[r * 3] + n + W5(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0,
      i = this.inverted ? 2 : 1,
      s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0);
      if (l > e) break;
      let u = this.ranges[a + i],
        c = this.ranges[a + s],
        d = l + u;
      if (e <= d) {
        let f = u ? (e == l ? -1 : e == d ? 1 : n) : n,
          p = l + o + (f < 0 ? 0 : c);
        if (r) return p;
        let h = e == (n < 0 ? l : d) ? null : j5(a / 3, e - l),
          m = e == l ? Oy : e == d ? Ty : Vl;
        return (n < 0 ? e != l : e != d) && (m |= Dy), new ip(p, m, h);
      }
      o += c - u;
    }
    return r ? e + o : new ip(e + o, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0,
      o = t1(n),
      i = this.inverted ? 2 : 1,
      s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e) break;
      let u = this.ranges[a + i],
        c = l + u;
      if (e <= c && a == o * 3) return !0;
      r += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1,
      r = this.inverted ? 1 : 2;
    for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
      let s = this.ranges[o],
        a = s - (this.inverted ? i : 0),
        l = s + (this.inverted ? 0 : i),
        u = this.ranges[o + n],
        c = this.ranges[o + r];
      e(a, a + u, l, l + c), (i += c - u);
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new an(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? an.empty : new an(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
an.empty = new an([]);
class $i {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, o = e.length) {
    (this.maps = e), (this.mirror = n), (this.from = r), (this.to = o);
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new $i(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new $i(
      this.maps.slice(),
      this.mirror && this.mirror.slice(),
      this.from,
      this.to
    );
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    (this.to = this.maps.push(e)),
      n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let o = e.getMirror(n);
      this.appendMap(e.maps[n], o != null && o < n ? r + o : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (
      let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
      n >= 0;
      n--
    ) {
      let o = e.getMirror(n);
      this.appendMap(
        e.maps[n].invert(),
        o != null && o > n ? r - o - 1 : void 0
      );
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new $i();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror) return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0;
    for (let i = this.from; i < this.to; i++) {
      let s = this.maps[i],
        a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(i);
        if (l != null && l > i && l < this.to) {
          (i = l), (e = this.maps[l].recover(a.recover));
          continue;
        }
      }
      (o |= a.delInfo), (e = a.pos);
    }
    return r ? e : new ip(e, o, null);
  }
}
const Id = /* @__PURE__ */ Object.create(null);
class Nt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return an.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Id[n.stepType];
    if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Id) throw new RangeError("Duplicate use of step JSON ID " + e);
    return (Id[e] = n), (n.prototype.jsonID = e), n;
  }
}
class at {
  /**
  @internal
  */
  constructor(e, n) {
    (this.doc = e), (this.failed = n);
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new at(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new at(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, o) {
    try {
      return at.ok(e.replace(n, r, o));
    } catch (i) {
      if (i instanceof au) return at.fail(i.message);
      throw i;
    }
  }
}
function Oh(t, e, n) {
  let r = [];
  for (let o = 0; o < t.childCount; o++) {
    let i = t.child(o);
    i.content.size && (i = i.copy(Oh(i.content, e, i))),
      i.isInline && (i = e(i, n, o)),
      r.push(i);
  }
  return $.fromArray(r);
}
class Pr extends Nt {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r);
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = e.resolve(this.from),
      o = r.node(r.sharedDepth(this.to)),
      i = new W(
        Oh(
          n.content,
          (s, a) =>
            !s.isAtom || !a.type.allowsMarkType(this.mark.type)
              ? s
              : s.mark(this.mark.addToSet(s.marks)),
          o
        ),
        n.openStart,
        n.openEnd
      );
    return at.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new Un(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new Pr(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Pr &&
      e.mark.eq(this.mark) &&
      this.from <= e.to &&
      this.to >= e.from
      ? new Pr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Pr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Nt.jsonID("addMark", Pr);
class Un extends Nt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r);
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = new W(
        Oh(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e),
        n.openStart,
        n.openEnd
      );
    return at.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Pr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new Un(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Un &&
      e.mark.eq(this.mark) &&
      this.from <= e.to &&
      this.to >= e.from
      ? new Un(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Un(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Nt.jsonID("removeMark", Un);
class ho extends Nt {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return at.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return at.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new W($.from(r), 0, n.isLeaf ? 0 : 1)
    );
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let o = 0; o < n.marks.length; o++)
          if (!n.marks[o].isInSet(r)) return new ho(this.pos, n.marks[o]);
        return new ho(this.pos, this.mark);
      }
    }
    return new Ui(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ho(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new ho(n.pos, e.markFromJSON(n.mark));
  }
}
Nt.jsonID("addNodeMark", ho);
class Ui extends Nt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return at.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return at.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new W($.from(r), 0, n.isLeaf ? 0 : 1)
    );
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks)
      ? this
      : new ho(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Ui(n.pos, this.mark);
  }
  toJSON() {
    return {
      stepType: "removeNodeMark",
      pos: this.pos,
      mark: this.mark.toJSON(),
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Ui(n.pos, e.markFromJSON(n.mark));
  }
}
Nt.jsonID("removeNodeMark", Ui);
class pt extends Nt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, o = !1) {
    super(),
      (this.from = e),
      (this.to = n),
      (this.slice = r),
      (this.structure = o);
  }
  apply(e) {
    return this.structure && sp(e, this.from, this.to)
      ? at.fail("Structure replace would overwrite content")
      : at.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new an([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new pt(
      this.from,
      this.from + this.slice.size,
      e.slice(this.from, this.to)
    );
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross
      ? null
      : new pt(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof pt) || e.structure || this.structure) return null;
    if (
      this.from + this.slice.size == e.from &&
      !this.slice.openEnd &&
      !e.slice.openStart
    ) {
      let n =
        this.slice.size + e.slice.size == 0
          ? W.empty
          : new W(
              this.slice.content.append(e.slice.content),
              this.slice.openStart,
              e.slice.openEnd
            );
      return new pt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n =
        this.slice.size + e.slice.size == 0
          ? W.empty
          : new W(
              e.slice.content.append(this.slice.content),
              e.slice.openStart,
              this.slice.openEnd
            );
      return new pt(e.from, this.to, n, this.structure);
    } else return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    );
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new pt(n.from, n.to, W.fromJSON(e, n.slice), !!n.structure);
  }
}
Nt.jsonID("replace", pt);
class bt extends Nt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, o, i, s, a = !1) {
    super(),
      (this.from = e),
      (this.to = n),
      (this.gapFrom = r),
      (this.gapTo = o),
      (this.slice = i),
      (this.insert = s),
      (this.structure = a);
  }
  apply(e) {
    if (
      this.structure &&
      (sp(e, this.from, this.gapFrom) || sp(e, this.gapTo, this.to))
    )
      return at.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd) return at.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r
      ? at.fromReplace(e, this.from, this.to, r)
      : at.fail("Content does not fit in gap");
  }
  getMap() {
    return new an([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert,
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new bt(
      this.from,
      this.from + this.slice.size + n,
      this.from + this.insert,
      this.from + this.insert + n,
      e
        .slice(this.from, this.to)
        .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure
    );
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1),
      o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1),
      i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
      ? null
      : new bt(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert,
    };
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    );
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (
      typeof n.from != "number" ||
      typeof n.to != "number" ||
      typeof n.gapFrom != "number" ||
      typeof n.gapTo != "number" ||
      typeof n.insert != "number"
    )
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new bt(
      n.from,
      n.to,
      n.gapFrom,
      n.gapTo,
      W.fromJSON(e, n.slice),
      n.insert,
      !!n.structure
    );
  }
}
Nt.jsonID("replaceAround", bt);
function sp(t, e, n) {
  let r = t.resolve(e),
    o = n - e,
    i = r.depth;
  for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; ) i--, o--;
  if (o > 0) {
    let s = r.node(i).maybeChild(r.indexAfter(i));
    for (; o > 0; ) {
      if (!s || s.isLeaf) return !0;
      (s = s.firstChild), o--;
    }
  }
  return !1;
}
function q5(t, e, n, r) {
  let o = [],
    i = [],
    s,
    a;
  t.doc.nodesBetween(e, n, (l, u, c) => {
    if (!l.isInline) return;
    let d = l.marks;
    if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
      let f = Math.max(u, e),
        p = Math.min(u + l.nodeSize, n),
        h = r.addToSet(d);
      for (let m = 0; m < d.length; m++)
        d[m].isInSet(h) ||
          (s && s.to == f && s.mark.eq(d[m])
            ? (s.to = p)
            : o.push((s = new Un(f, p, d[m]))));
      a && a.to == f ? (a.to = p) : i.push((a = new Pr(f, p, r)));
    }
  }),
    o.forEach((l) => t.step(l)),
    i.forEach((l) => t.step(l));
}
function K5(t, e, n, r) {
  let o = [],
    i = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline) return;
    i++;
    let l = null;
    if (r instanceof Vc) {
      let u = s.marks,
        c;
      for (; (c = r.isInSet(u)); )
        (l || (l = [])).push(c), (u = c.removeFromSet(u));
    } else r ? r.isInSet(s.marks) && (l = [r]) : (l = s.marks);
    if (l && l.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let c = 0; c < l.length; c++) {
        let d = l[c],
          f;
        for (let p = 0; p < o.length; p++) {
          let h = o[p];
          h.step == i - 1 && d.eq(o[p].style) && (f = h);
        }
        f
          ? ((f.to = u), (f.step = i))
          : o.push({ style: d, from: Math.max(a, e), to: u, step: i });
      }
    }
  }),
    o.forEach((s) => t.step(new Un(s.from, s.to, s.style)));
}
function Dh(t, e, n, r = n.contentMatch, o = !0) {
  let i = t.doc.nodeAt(e),
    s = [],
    a = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let u = i.child(l),
      c = a + u.nodeSize,
      d = r.matchType(u.type);
    if (!d) s.push(new pt(a, c, W.empty));
    else {
      r = d;
      for (let f = 0; f < u.marks.length; f++)
        n.allowsMarkType(u.marks[f].type) || t.step(new Un(a, c, u.marks[f]));
      if (o && u.isText && n.whitespace != "pre") {
        let f,
          p = /\r?\n|\r/g,
          h;
        for (; (f = p.exec(u.text)); )
          h ||
            (h = new W(
              $.from(n.schema.text(" ", n.allowedMarks(u.marks))),
              0,
              0
            )),
            s.push(new pt(a + f.index, a + f.index + f[0].length, h));
      }
    }
    a = c;
  }
  if (!r.validEnd) {
    let l = r.fillBefore($.empty, !0);
    t.replace(a, a, new W(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--) t.step(s[l]);
}
function G5(t, e, n) {
  return (
    (e == 0 || t.canReplace(e, t.childCount)) &&
    (n == t.childCount || t.canReplace(0, n))
  );
}
function ns(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let o = t.$from.node(r),
      i = t.$from.index(r),
      s = t.$to.indexAfter(r);
    if (r < t.depth && o.canReplace(i, s, n)) return r;
    if (r == 0 || o.type.spec.isolating || !G5(o, i, s)) break;
  }
  return null;
}
function J5(t, e, n) {
  let { $from: r, $to: o, depth: i } = e,
    s = r.before(i + 1),
    a = o.after(i + 1),
    l = s,
    u = a,
    c = $.empty,
    d = 0;
  for (let h = i, m = !1; h > n; h--)
    m || r.index(h) > 0
      ? ((m = !0), (c = $.from(r.node(h).copy(c))), d++)
      : l--;
  let f = $.empty,
    p = 0;
  for (let h = i, m = !1; h > n; h--)
    m || o.after(h + 1) < o.end(h)
      ? ((m = !0), (f = $.from(o.node(h).copy(f))), p++)
      : u++;
  t.step(new bt(l, u, s, a, new W(c.append(f), d, p), c.size - d, !0));
}
function jc(t, e, n = null, r = t) {
  let o = Y5(t, e),
    i = o && X5(r, e);
  return i ? o.map(n1).concat({ type: e, attrs: n }).concat(i.map(n1)) : null;
}
function n1(t) {
  return { type: t, attrs: null };
}
function Y5(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t,
    i = n.contentMatchAt(r).findWrapping(e);
  if (!i) return null;
  let s = i.length ? i[0] : e;
  return n.canReplaceWith(r, o, s) ? i : null;
}
function X5(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t,
    i = n.child(r),
    s = e.contentMatch.findWrapping(i.type);
  if (!s) return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let u = r; l && u < o; u++) l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : s;
}
function Z5(t, e, n) {
  let r = $.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError(
          "Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
        );
    }
    r = $.from(n[s].type.create(n[s].attrs, r));
  }
  let o = e.start,
    i = e.end;
  t.step(new bt(o, i, o, i, new W(r, 0, 0), n.length, !0));
}
function Q5(t, e, n, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof o == "function" ? o(s) : o;
    if (
      s.isTextblock &&
      !s.hasMarkup(r, l) &&
      eC(t.doc, t.mapping.slice(i).map(a), r)
    ) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre",
          h = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !h ? (u = !1) : !p && h && (u = !0);
      }
      u === !1 && Ly(t, s, a, i),
        Dh(t, t.mapping.slice(i).map(a, 1), r, void 0, u === null);
      let c = t.mapping.slice(i),
        d = c.map(a, 1),
        f = c.map(a + s.nodeSize, 1);
      return (
        t.step(
          new bt(
            d,
            f,
            d + 1,
            f - 1,
            new W($.from(r.create(l, null, s.marks)), 0, 0),
            1,
            !0
          )
        ),
        u === !0 && Ny(t, s, a, i),
        !1
      );
    }
  });
}
function Ny(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.isText) {
      let s,
        a = /\r?\n|\r/g;
      for (; (s = a.exec(o.text)); ) {
        let l = t.mapping.slice(r).map(n + 1 + i + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function Ly(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(r).map(n + 1 + i);
      t.replaceWith(
        s,
        s + 1,
        e.type.schema.text(`
`)
      );
    }
  });
}
function eC(t, e, n) {
  let r = t.resolve(e),
    o = r.index();
  return r.parent.canReplaceWith(o, o + 1, n);
}
function tC(t, e, n, r, o) {
  let i = t.doc.nodeAt(e);
  if (!i) throw new RangeError("No node at given position");
  n || (n = i.type);
  let s = n.create(r, null, o || i.marks);
  if (i.isLeaf) return t.replaceWith(e, e + i.nodeSize, s);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(
    new bt(
      e,
      e + i.nodeSize,
      e + 1,
      e + i.nodeSize - 1,
      new W($.from(s), 0, 0),
      1,
      !0
    )
  );
}
function hr(t, e, n = 1, r) {
  let o = t.resolve(e),
    i = o.depth - n,
    s = (r && r[r.length - 1]) || o.parent;
  if (
    i < 0 ||
    o.parent.type.spec.isolating ||
    !o.parent.canReplace(o.index(), o.parent.childCount) ||
    !s.type.validContent(
      o.parent.content.cutByIndex(o.index(), o.parent.childCount)
    )
  )
    return !1;
  for (let u = o.depth - 1, c = n - 2; u > i; u--, c--) {
    let d = o.node(u),
      f = o.index(u);
    if (d.type.spec.isolating) return !1;
    let p = d.content.cutByIndex(f, d.childCount),
      h = r && r[c + 1];
    h && (p = p.replaceChild(0, h.type.create(h.attrs)));
    let m = (r && r[c]) || d;
    if (!d.canReplace(f + 1, d.childCount) || !m.type.validContent(p))
      return !1;
  }
  let a = o.indexAfter(i),
    l = r && r[0];
  return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
}
function nC(t, e, n = 1, r) {
  let o = t.doc.resolve(e),
    i = $.empty,
    s = $.empty;
  for (let a = o.depth, l = o.depth - n, u = n - 1; a > l; a--, u--) {
    i = $.from(o.node(a).copy(i));
    let c = r && r[u];
    s = $.from(c ? c.type.create(c.attrs, s) : o.node(a).copy(s));
  }
  t.step(new pt(e, e, new W(i.append(s), n, n), !0));
}
function _r(t, e) {
  let n = t.resolve(e),
    r = n.index();
  return Ry(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function rC(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount),
    { linebreakReplacement: r } = t.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let i = e.child(o),
      s = i.type == r ? t.type.schema.nodes.text : i.type;
    if (((n = n.matchType(s)), !n || !t.type.allowsMarks(i.marks))) return !1;
  }
  return n.validEnd;
}
function Ry(t, e) {
  return !!(t && e && !t.isLeaf && rC(t, e));
}
function Wc(t, e, n = -1) {
  let r = t.resolve(e);
  for (let o = r.depth; ; o--) {
    let i,
      s,
      a = r.index(o);
    if (
      (o == r.depth
        ? ((i = r.nodeBefore), (s = r.nodeAfter))
        : n > 0
        ? ((i = r.node(o + 1)), a++, (s = r.node(o).maybeChild(a)))
        : ((i = r.node(o).maybeChild(a - 1)), (s = r.node(o + 1))),
      i && !i.isTextblock && Ry(i, s) && r.node(o).canReplace(a, a + 1))
    )
      return e;
    if (o == 0) break;
    e = n < 0 ? r.before(o) : r.after(o);
  }
}
function oC(t, e, n) {
  let r = null,
    { linebreakReplacement: o } = t.doc.type.schema,
    i = t.doc.resolve(e - n),
    s = i.node().type;
  if (o && s.inlineContent) {
    let c = s.whitespace == "pre",
      d = !!s.contentMatch.matchType(o);
    c && !d ? (r = !1) : !c && d && (r = !0);
  }
  let a = t.steps.length;
  if (r === !1) {
    let c = t.doc.resolve(e + n);
    Ly(t, c.node(), c.before(), a);
  }
  s.inlineContent &&
    Dh(t, e + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
  let l = t.mapping.slice(a),
    u = l.map(e - n);
  if ((t.step(new pt(u, l.map(e + n, -1), W.empty, !0)), r === !0)) {
    let c = t.doc.resolve(u);
    Ny(t, c.node(), c.before(), t.steps.length);
  }
  return t;
}
function iC(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.index(o);
      if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1);
      if (i > 0) return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.indexAfter(o);
      if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1);
      if (i < r.node(o).childCount) return null;
    }
  return null;
}
function Iy(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size) return e;
  let o = n.content;
  for (let i = 0; i < n.openStart; i++) o = o.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = r.depth; s >= 0; s--) {
      let a =
          s == r.depth
            ? 0
            : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
            ? -1
            : 1,
        l = r.index(s) + (a > 0 ? 1 : 0),
        u = r.node(s),
        c = !1;
      if (i == 1) c = u.canReplace(l, l, o);
      else {
        let d = u.contentMatchAt(l).findWrapping(o.firstChild.type);
        c = d && u.canReplaceWith(l, l, d[0]);
      }
      if (c) return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function qc(t, e, n = e, r = W.empty) {
  if (e == n && !r.size) return null;
  let o = t.resolve(e),
    i = t.resolve(n);
  return Py(o, i, r) ? new pt(e, n, r) : new sC(o, i, r).fit();
}
function Py(t, e, n) {
  return (
    !n.openStart &&
    !n.openEnd &&
    t.start() == e.start() &&
    t.parent.canReplace(t.index(), e.index(), n.content)
  );
}
class sC {
  constructor(e, n, r) {
    (this.$from = e),
      (this.$to = n),
      (this.unplaced = r),
      (this.frontier = []),
      (this.placed = $.empty);
    for (let o = 0; o <= e.depth; o++) {
      let i = e.node(o);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(o)),
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = $.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(),
      n = this.placed.size - this.depth - this.$from.depth,
      r = this.$from,
      o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!o) return null;
    let i = this.placed,
      s = r.depth,
      a = o.depth;
    for (; s && a && i.childCount == 1; ) (i = i.firstChild.content), s--, a--;
    let l = new W(i, s, a);
    return e > -1
      ? new bt(r.pos, e, this.$to.pos, this.$to.end(), l, n)
      : l.size || r.pos != this.$to.pos
      ? new pt(r.pos, o.pos, l)
      : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (
      let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
      r < e;
      r++
    ) {
      let i = n.firstChild;
      if ((n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)) {
        e = r;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let o,
          i = null;
        r
          ? ((i = Pd(this.unplaced.content, r - 1).firstChild), (o = i.content))
          : (o = this.unplaced.content);
        let s = o.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: u } = this.frontier[a],
            c,
            d = null;
          if (
            n == 1 &&
            (s
              ? u.matchType(s.type) || (d = u.fillBefore($.from(s), !1))
              : i && l.compatibleContent(i.type))
          )
            return { sliceDepth: r, frontierDepth: a, parent: i, inject: d };
          if (n == 2 && s && (c = u.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: i, wrap: c };
          if (i && u.matchType(i.type)) break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      o = Pd(e, n);
    return !o.childCount || o.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new W(
          e,
          n + 1,
          Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)
        )),
        !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      o = Pd(e, n);
    if (o.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + o.size;
      this.unplaced = new W(ms(e, n - 1, 1), n - 1, i ? n - 1 : r);
    } else this.unplaced = new W(ms(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({
    sliceDepth: e,
    frontierDepth: n,
    parent: r,
    inject: o,
    wrap: i,
  }) {
    for (; this.depth > n; ) this.closeFrontierNode();
    if (i) for (let m = 0; m < i.length; m++) this.openFrontierNode(i[m]);
    let s = this.unplaced,
      a = r ? r.content : s.content,
      l = s.openStart - e,
      u = 0,
      c = [],
      { match: d, type: f } = this.frontier[n];
    if (o) {
      for (let m = 0; m < o.childCount; m++) c.push(o.child(m));
      d = d.matchFragment(o);
    }
    let p = a.size + e - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let m = a.child(u),
        g = d.matchType(m.type);
      if (!g) break;
      u++,
        (u > 1 || l == 0 || m.content.size) &&
          ((d = g),
          c.push(
            $y(
              m.mark(f.allowedMarks(m.marks)),
              u == 1 ? l : 0,
              u == a.childCount ? p : -1
            )
          ));
    }
    let h = u == a.childCount;
    h || (p = -1),
      (this.placed = gs(this.placed, n, $.from(c))),
      (this.frontier[n].match = d),
      h &&
        p < 0 &&
        r &&
        r.type == this.frontier[this.depth].type &&
        this.frontier.length > 1 &&
        this.closeFrontierNode();
    for (let m = 0, g = a; m < p; m++) {
      let b = g.lastChild;
      this.frontier.push({
        type: b.type,
        match: b.contentMatchAt(b.childCount),
      }),
        (g = b.content);
    }
    this.unplaced = h
      ? e == 0
        ? W.empty
        : new W(ms(s.content, e - 1, 1), e - 1, p < 0 ? s.openEnd : e - 1)
      : new W(ms(s.content, e, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock) return -1;
    let e = this.frontier[this.depth],
      n;
    if (
      !e.type.isTextblock ||
      !$d(this.$to, this.$to.depth, e.type, e.match, !1) ||
      (this.$to.depth == this.depth &&
        (n = this.findCloseLevel(this.$to)) &&
        n.depth == this.depth)
    )
      return -1;
    let { depth: r } = this.$to,
      o = this.$to.after(r);
    for (; r > 1 && o == this.$to.end(--r); ) ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: o } = this.frontier[n],
        i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
        s = $d(e, n, o, r, i);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: u } = this.frontier[a],
            c = $d(e, a, u, l, !0);
          if (!c || c.childCount) continue e;
        }
        return {
          depth: n,
          fit: s,
          move: i ? e.doc.resolve(e.after(n + 1)) : e,
        };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n) return null;
    for (; this.depth > n.depth; ) this.closeFrontierNode();
    n.fit.childCount && (this.placed = gs(this.placed, n.depth, n.fit)),
      (e = n.move);
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let o = e.node(r),
        i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
      this.openFrontierNode(o.type, o.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let o = this.frontier[this.depth];
    (o.match = o.match.matchType(e)),
      (this.placed = gs(this.placed, this.depth, $.from(e.create(n, r)))),
      this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore($.empty, !0);
    n.childCount && (this.placed = gs(this.placed, this.frontier.length, n));
  }
}
function ms(t, e, n) {
  return e == 0
    ? t.cutByIndex(n, t.childCount)
    : t.replaceChild(0, t.firstChild.copy(ms(t.firstChild.content, e - 1, n)));
}
function gs(t, e, n) {
  return e == 0
    ? t.append(n)
    : t.replaceChild(
        t.childCount - 1,
        t.lastChild.copy(gs(t.lastChild.content, e - 1, n))
      );
}
function Pd(t, e) {
  for (let n = 0; n < e; n++) t = t.firstChild.content;
  return t;
}
function $y(t, e, n) {
  if (e <= 0) return t;
  let r = t.content;
  return (
    e > 1 &&
      (r = r.replaceChild(
        0,
        $y(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
      )),
    e > 0 &&
      ((r = t.type.contentMatch.fillBefore(r).append(r)),
      n <= 0 &&
        (r = r.append(
          t.type.contentMatch.matchFragment(r).fillBefore($.empty, !0)
        ))),
    t.copy(r)
  );
}
function $d(t, e, n, r, o) {
  let i = t.node(e),
    s = o ? t.indexAfter(e) : t.index(e);
  if (s == i.childCount && !n.compatibleContent(i.type)) return null;
  let a = r.fillBefore(i.content, !0, s);
  return a && !aC(n, i.content, s) ? a : null;
}
function aC(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks)) return !0;
  return !1;
}
function lC(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function uC(t, e, n, r) {
  if (!r.size) return t.deleteRange(e, n);
  let o = t.doc.resolve(e),
    i = t.doc.resolve(n);
  if (Py(o, i, r)) return t.step(new pt(e, n, r));
  let s = Hy(o, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(o.depth + 1);
  s.unshift(a);
  for (let f = o.depth, p = o.pos - 1; f > 0; f--, p--) {
    let h = o.node(f).type.spec;
    if (h.defining || h.definingAsContext || h.isolating) break;
    s.indexOf(f) > -1 ? (a = f) : o.before(f) == p && s.splice(1, 0, -f);
  }
  let l = s.indexOf(a),
    u = [],
    c = r.openStart;
  for (let f = r.content, p = 0; ; p++) {
    let h = f.firstChild;
    if ((u.push(h), p == r.openStart)) break;
    f = h.content;
  }
  for (let f = c - 1; f >= 0; f--) {
    let p = u[f],
      h = lC(p.type);
    if (h && !p.sameMarkup(o.node(Math.abs(a) - 1))) c = f;
    else if (h || !p.type.isTextblock) break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + c + 1) % (r.openStart + 1),
      h = u[p];
    if (h)
      for (let m = 0; m < s.length; m++) {
        let g = s[(m + l) % s.length],
          b = !0;
        g < 0 && ((b = !1), (g = -g));
        let _ = o.node(g - 1),
          v = o.index(g - 1);
        if (_.canReplaceWith(v, v, h.type, h.marks))
          return t.replace(
            o.before(g),
            b ? i.after(g) : n,
            new W(By(r.content, 0, r.openStart, p), p, r.openEnd)
          );
      }
  }
  let d = t.steps.length;
  for (
    let f = s.length - 1;
    f >= 0 && (t.replace(e, n, r), !(t.steps.length > d));
    f--
  ) {
    let p = s[f];
    p < 0 || ((e = o.before(p)), (n = i.after(p)));
  }
}
function By(t, e, n, r, o) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(By(i.content, e + 1, n, r, i)));
  }
  if (e > r) {
    let i = o.contentMatchAt(0),
      s = i.fillBefore(t).append(t);
    t = s.append(i.matchFragment(s).fillBefore($.empty, !0));
  }
  return t;
}
function cC(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let o = iC(t.doc, e, r.type);
    o != null && (e = n = o);
  }
  t.replaceRange(e, n, new W($.from(r), 0, 0));
}
function dC(t, e, n) {
  let r = t.doc.resolve(e),
    o = t.doc.resolve(n),
    i = Hy(r, o);
  for (let s = 0; s < i.length; s++) {
    let a = i[s],
      l = s == i.length - 1;
    if ((l && a == 0) || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), o.end(a));
    if (
      a > 0 &&
      (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1)))
    )
      return t.delete(r.before(a), o.after(a));
  }
  for (let s = 1; s <= r.depth && s <= o.depth; s++)
    if (
      e - r.start(s) == r.depth - s &&
      n > r.end(s) &&
      o.end(s) - n != o.depth - s &&
      r.start(s - 1) == o.start(s - 1) &&
      r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1))
    )
      return t.delete(r.before(s), n);
  t.delete(e, n);
}
function Hy(t, e) {
  let n = [],
    r = Math.min(t.depth, e.depth);
  for (let o = r; o >= 0; o--) {
    let i = t.start(o);
    if (
      i < t.pos - (t.depth - o) ||
      e.end(o) > e.pos + (e.depth - o) ||
      t.node(o).type.spec.isolating ||
      e.node(o).type.spec.isolating
    )
      break;
    (i == e.start(o) ||
      (o == t.depth &&
        o == e.depth &&
        t.parent.inlineContent &&
        e.parent.inlineContent &&
        o &&
        e.start(o - 1) == i - 1)) &&
      n.push(o);
  }
  return n;
}
class ei extends Nt {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), (this.pos = e), (this.attr = n), (this.value = r);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return at.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in n.attrs) r[i] = n.attrs[i];
    r[this.attr] = this.value;
    let o = n.type.create(r, null, n.marks);
    return at.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new W($.from(o), 0, n.isLeaf ? 0 : 1)
    );
  }
  getMap() {
    return an.empty;
  }
  invert(e) {
    return new ei(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ei(n.pos, this.attr, this.value);
  }
  toJSON() {
    return {
      stepType: "attr",
      pos: this.pos,
      attr: this.attr,
      value: this.value,
    };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ei(n.pos, n.attr, n.value);
  }
}
Nt.jsonID("attr", ei);
class na extends Nt {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), (this.attr = e), (this.value = n);
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let o in e.attrs) n[o] = e.attrs[o];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return at.ok(r);
  }
  getMap() {
    return an.empty;
  }
  invert(e) {
    return new na(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new na(n.attr, n.value);
  }
}
Nt.jsonID("docAttr", na);
let ji = class extends Error {};
ji = function t(e) {
  let n = Error.call(this, e);
  return (n.__proto__ = t.prototype), n;
};
ji.prototype = Object.create(Error.prototype);
ji.prototype.constructor = ji;
ji.prototype.name = "TransformError";
class Nh {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    (this.doc = e),
      (this.steps = []),
      (this.docs = []),
      (this.mapping = new $i());
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed) throw new ji(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc),
      this.steps.push(e),
      this.mapping.appendMap(e.getMap()),
      (this.doc = n);
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = W.empty) {
    let o = qc(this.doc, e, n, r);
    return o && this.step(o), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new W($.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, W.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return uC(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return cC(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return dC(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return J5(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return oC(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return Z5(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, o = null) {
    return Q5(this, e, n, r, o), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, o) {
    return tC(this, e, n, r, o), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new ei(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new na(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new ho(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Oe)) {
      let r = this.doc.nodeAt(e);
      if (!r) throw new RangeError("No node at position " + e);
      if (((n = n.isInSet(r.marks)), !n)) return this;
    }
    return this.step(new Ui(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return nC(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return q5(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return K5(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return Dh(this, e, n, r), this;
  }
}
const Bd = /* @__PURE__ */ Object.create(null);
class ee {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    (this.$anchor = e),
      (this.$head = n),
      (this.ranges = r || [new pu(e.min(n), e.max(n))]);
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos) return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = W.empty) {
    let r = n.content.lastChild,
      o = null;
    for (let a = 0; a < n.openEnd; a++) (o = r), (r = r.lastChild);
    let i = e.steps.length,
      s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: u } = s[a],
        c = e.mapping.slice(i);
      e.replaceRange(c.map(l.pos), c.map(u.pos), a ? W.empty : n),
        a == 0 && i1(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length,
      o = this.ranges;
    for (let i = 0; i < o.length; i++) {
      let { $from: s, $to: a } = o[i],
        l = e.mapping.slice(r),
        u = l.map(s.pos),
        c = l.map(a.pos);
      i
        ? e.deleteRange(u, c)
        : (e.replaceRangeWith(u, c, n), i1(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let o = e.parent.inlineContent
      ? new q(e)
      : Ei(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (o) return o;
    for (let i = e.depth - 1; i >= 0; i--) {
      let s =
        n < 0
          ? Ei(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r)
          : Ei(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
      if (s) return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new $t(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Ei(e, e, 0, 0, 1) || new $t(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Ei(e, e, e.content.size, e.childCount, -1) || new $t(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Bd[n.type];
    if (!r) throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in Bd)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return (Bd[e] = n), (n.prototype.jsonID = e), n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return q.between(this.$anchor, this.$head).getBookmark();
  }
}
ee.prototype.visible = !0;
class pu {
  /**
  Create a range.
  */
  constructor(e, n) {
    (this.$from = e), (this.$to = n);
  }
}
let r1 = !1;
function o1(t) {
  !r1 &&
    !t.parent.inlineContent &&
    ((r1 = !0),
    console.warn(
      "TextSelection endpoint not pointing into a node with inline content (" +
        t.parent.type.name +
        ")"
    ));
}
class q extends ee {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    o1(e), o1(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent) return ee.near(r);
    let o = e.resolve(n.map(this.anchor));
    return new q(o.parent.inlineContent ? o : r, r);
  }
  replace(e, n = W.empty) {
    if ((super.replace(e, n), n == W.empty)) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof q && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Kc(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new q(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let o = e.resolve(n);
    return new this(o, r == n ? o : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let o = e.pos - n.pos;
    if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
      let i = ee.findFrom(n, r, !0) || ee.findFrom(n, -r, !0);
      if (i) n = i.$head;
      else return ee.near(n, r);
    }
    return (
      e.parent.inlineContent ||
        (o == 0
          ? (e = n)
          : ((e = (ee.findFrom(e, -r, !0) || ee.findFrom(e, r, !0)).$anchor),
            e.pos < n.pos != o < 0 && (e = n))),
      new q(e, n)
    );
  }
}
ee.jsonID("text", q);
class Kc {
  constructor(e, n) {
    (this.anchor = e), (this.head = n);
  }
  map(e) {
    return new Kc(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return q.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Z extends ee {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter,
      r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), (this.node = n);
  }
  map(e, n) {
    let { deleted: r, pos: o } = n.mapResult(this.anchor),
      i = e.resolve(o);
    return r ? ee.near(i) : new Z(i);
  }
  content() {
    return new W($.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Z && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Lh(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Z(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new Z(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Z.prototype.visible = !1;
ee.jsonID("node", Z);
class Lh {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Kc(r, r) : new Lh(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor),
      r = n.nodeAfter;
    return r && Z.isSelectable(r) ? new Z(n) : ee.near(n);
  }
}
class $t extends ee {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = W.empty) {
    if (n == W.empty) {
      e.delete(0, e.doc.content.size);
      let r = ee.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new $t(e);
  }
  map(e) {
    return new $t(e);
  }
  eq(e) {
    return e instanceof $t;
  }
  getBookmark() {
    return fC;
  }
}
ee.jsonID("all", $t);
const fC = {
  map() {
    return this;
  },
  resolve(t) {
    return new $t(t);
  },
};
function Ei(t, e, n, r, o, i = !1) {
  if (e.inlineContent) return q.create(t, n);
  for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < e.childCount : s >= 0; s += o) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!i && Z.isSelectable(a))
        return Z.create(t, n - (o < 0 ? a.nodeSize : 0));
    } else {
      let l = Ei(t, a, n + o, o < 0 ? a.childCount : 0, o, i);
      if (l) return l;
    }
    n += a.nodeSize * o;
  }
  return null;
}
function i1(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e) return;
  let o = t.steps[r];
  if (!(o instanceof pt || o instanceof bt)) return;
  let i = t.mapping.maps[r],
    s;
  i.forEach((a, l, u, c) => {
    s == null && (s = c);
  }),
    t.setSelection(ee.near(t.doc.resolve(s), n));
}
const s1 = 1,
  il = 2,
  a1 = 4;
class pC extends Nh {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc),
      (this.curSelectionFor = 0),
      (this.updated = 0),
      (this.meta = /* @__PURE__ */ Object.create(null)),
      (this.time = Date.now()),
      (this.curSelection = e.selection),
      (this.storedMarks = e.storedMarks);
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return (
      this.curSelectionFor < this.steps.length &&
        ((this.curSelection = this.curSelection.map(
          this.doc,
          this.mapping.slice(this.curSelectionFor)
        )),
        (this.curSelectionFor = this.steps.length)),
      this.curSelection
    );
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError(
        "Selection passed to setSelection must point at the current document"
      );
    return (
      (this.curSelection = e),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | s1) & ~il),
      (this.storedMarks = null),
      this
    );
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & s1) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return (this.storedMarks = e), (this.updated |= il), this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return (
      Oe.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
        this.setStoredMarks(e),
      this
    );
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(
      e.addToSet(this.storedMarks || this.selection.$head.marks())
    );
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(
      e.removeFromSet(this.storedMarks || this.selection.$head.marks())
    );
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & il) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n),
      (this.updated = this.updated & ~il),
      (this.storedMarks = null);
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return (this.time = e), this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return (
      n &&
        (e = e.mark(
          this.storedMarks ||
            (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Oe.none)
        )),
      r.replaceWith(this, e),
      this
    );
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let o = this.doc.type.schema;
    if (n == null)
      return e
        ? this.replaceSelectionWith(o.text(e), !0)
        : this.deleteSelection();
    {
      if ((r == null && (r = n), (r = r ?? n), !e))
        return this.deleteRange(n, r);
      let i = this.storedMarks;
      if (!i) {
        let s = this.doc.resolve(n);
        i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return (
        this.replaceRangeWith(n, r, o.text(e, i)),
        this.selection.empty || this.setSelection(ee.near(this.selection.$to)),
        this
      );
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return (this.meta[typeof e == "string" ? e : e.key] = n), this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta) return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return (this.updated |= a1), this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & a1) > 0;
  }
}
function l1(t, e) {
  return !e || !t ? t : t.bind(e);
}
class bs {
  constructor(e, n, r) {
    (this.name = e), (this.init = l1(n.init, r)), (this.apply = l1(n.apply, r));
  }
}
const hC = [
  new bs("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    },
  }),
  new bs("selection", {
    init(t, e) {
      return t.selection || ee.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    },
  }),
  new bs("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    },
  }),
  new bs("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    },
  }),
];
class Hd {
  constructor(e, n) {
    (this.schema = e),
      (this.plugins = []),
      (this.pluginsByKey = /* @__PURE__ */ Object.create(null)),
      (this.fields = hC.slice()),
      n &&
        n.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError(
              "Adding different instances of a keyed plugin (" + r.key + ")"
            );
          this.plugins.push(r),
            (this.pluginsByKey[r.key] = r),
            r.spec.state && this.fields.push(new bs(r.key, r.spec.state, r));
        });
  }
}
class Ri {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let o = this.config.plugins[r];
        if (
          o.spec.filterTransaction &&
          !o.spec.filterTransaction.call(o, e, this)
        )
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e)) return { state: this, transactions: [] };
    let n = [e],
      r = this.applyInner(e),
      o = null;
    for (;;) {
      let i = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = o ? o[s].n : 0,
            u = o ? o[s].state : this,
            c =
              l < n.length &&
              a.spec.appendTransaction.call(a, l ? n.slice(l) : n, u, r);
          if (c && r.filterTransaction(c, s)) {
            if ((c.setMeta("appendedTransaction", e), !o)) {
              o = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                o.push(
                  d < s ? { state: r, n: n.length } : { state: this, n: 0 }
                );
            }
            n.push(c), (r = r.applyInner(c)), (i = !0);
          }
          o && (o[s] = { state: r, n: n.length });
        }
      }
      if (!i) return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Ri(this.config),
      r = this.config.fields;
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new pC(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new Hd(e.doc ? e.doc.type.schema : e.schema, e.plugins),
      r = new Ri(n);
    for (let o = 0; o < n.fields.length; o++)
      r[n.fields[o].name] = n.fields[o].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new Hd(this.schema, e.plugins),
      r = n.fields,
      o = new Ri(n);
    for (let i = 0; i < r.length; i++) {
      let s = r[i].name;
      o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
    }
    return o;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (
      (this.storedMarks &&
        (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      e && typeof e == "object")
    )
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError(
            "The JSON fields `doc` and `selection` are reserved"
          );
        let o = e[r],
          i = o.spec.state;
        i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let o = new Hd(e.schema, e.plugins),
      i = new Ri(o);
    return (
      o.fields.forEach((s) => {
        if (s.name == "doc") i.doc = qn.fromJSON(e.schema, n.doc);
        else if (s.name == "selection")
          i.selection = ee.fromJSON(i.doc, n.selection);
        else if (s.name == "storedMarks")
          n.storedMarks &&
            (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
        else {
          if (r)
            for (let a in r) {
              let l = r[a],
                u = l.spec.state;
              if (
                l.key == s.name &&
                u &&
                u.fromJSON &&
                Object.prototype.hasOwnProperty.call(n, a)
              ) {
                i[s.name] = u.fromJSON.call(l, e, n[a], i);
                return;
              }
            }
          i[s.name] = s.init(e, i);
        }
      }),
      i
    );
  }
}
function Fy(t, e, n) {
  for (let r in t) {
    let o = t[r];
    o instanceof Function
      ? (o = o.bind(e))
      : r == "handleDOMEvents" && (o = Fy(o, e, {})),
      (n[r] = o);
  }
  return n;
}
class be {
  /**
  Create a plugin.
  */
  constructor(e) {
    (this.spec = e),
      (this.props = {}),
      e.props && Fy(e.props, this, this.props),
      (this.key = e.key ? e.key.key : zy("plugin"));
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Fd = /* @__PURE__ */ Object.create(null);
function zy(t) {
  return t in Fd ? t + "$" + ++Fd[t] : ((Fd[t] = 0), t + "$");
}
class ke {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = zy(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class Vy {
  constructor(e, n, r) {
    (this.step = e), (this.inverted = n), (this.origin = r);
  }
}
function mC(t, e, n) {
  for (let o = t.length - 1; o >= 0; o--) n.step(t[o].inverted);
  for (let o = 0; o < e.length; o++) n.step(e[o]);
  let r = [];
  for (let o = 0, i = t.length; o < t.length; o++) {
    let s = t[o].step.map(n.mapping.slice(i));
    i--,
      s &&
        !n.maybeStep(s).failed &&
        (n.mapping.setMirror(i, n.steps.length - 1),
        r.push(new Vy(s, s.invert(n.docs[n.docs.length - 1]), t[o].origin)));
  }
  return r;
}
class hu {
  constructor(e, n) {
    (this.version = e), (this.unconfirmed = n);
  }
}
function gC(t) {
  let e = [];
  for (let n = 0; n < t.steps.length; n++)
    e.push(new Vy(t.steps[n], t.steps[n].invert(t.docs[n]), t));
  return e;
}
const $r = new ke("collab");
function Qz(t = {}) {
  let e = {
    version: t.version || 0,
    clientID:
      t.clientID == null ? Math.floor(Math.random() * 4294967295) : t.clientID,
  };
  return new be({
    key: $r,
    state: {
      init: () => new hu(e.version, []),
      apply(n, r) {
        let o = n.getMeta($r);
        return (
          o ||
          (n.docChanged ? new hu(r.version, r.unconfirmed.concat(gC(n))) : r)
        );
      },
    },
    config: e,
    // This is used to notify the history plugin to not merge steps,
    // so that the history can be rebased.
    historyPreserveItems: !0,
  });
}
function eV(t, e, n, r = {}) {
  let o = $r.getState(t),
    i = o.version + e.length,
    s = $r.get(t).spec.config.clientID,
    a = 0;
  for (; a < n.length && n[a] == s; ) ++a;
  let l = o.unconfirmed.slice(a);
  if (((e = a ? e.slice(a) : e), !e.length))
    return t.tr.setMeta($r, new hu(i, l));
  let u = l.length,
    c = t.tr;
  if (u) l = mC(l, e, c);
  else {
    for (let f = 0; f < e.length; f++) c.step(e[f]);
    l = [];
  }
  let d = new hu(i, l);
  return (
    r &&
      r.mapSelectionBackward &&
      t.selection instanceof q &&
      (c.setSelection(
        q.between(
          c.doc.resolve(c.mapping.map(t.selection.anchor, -1)),
          c.doc.resolve(c.mapping.map(t.selection.head, -1)),
          -1
        )
      ),
      (c.updated &= -2)),
    c.setMeta("rebased", u).setMeta("addToHistory", !1).setMeta($r, d)
  );
}
function tV(t) {
  let e = $r.getState(t);
  return e.unconfirmed.length == 0
    ? null
    : {
        version: e.version,
        steps: e.unconfirmed.map((n) => n.step),
        clientID: $r.get(t).spec.config.clientID,
        get origins() {
          return (
            this._origins ||
            (this._origins = e.unconfirmed.map((n) => n.origin))
          );
        },
      };
}
function nV(t) {
  return $r.getState(t).version;
}
const Rh = (t, e) =>
  t.selection.empty
    ? !1
    : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Uy(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
    ? null
    : n;
}
const jy = (t, e, n) => {
    let r = Uy(t, n);
    if (!r) return !1;
    let o = Ih(r);
    if (!o) {
      let s = r.blockRange(),
        a = s && ns(s);
      return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
    }
    let i = o.nodeBefore;
    if (tv(t, o, e, -1)) return !0;
    if (r.parent.content.size == 0 && (Wi(i, "end") || Z.isSelectable(i)))
      for (let s = r.depth; ; s--) {
        let a = qc(t.doc, r.before(s), r.after(s), W.empty);
        if (a && a.slice.size < a.to - a.from) {
          if (e) {
            let l = t.tr.step(a);
            l.setSelection(
              Wi(i, "end")
                ? ee.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1)
                : Z.create(l.doc, o.pos - i.nodeSize)
            ),
              e(l.scrollIntoView());
          }
          return !0;
        }
        if (s == 1 || r.node(s - 1).childCount > 1) break;
      }
    return i.isAtom && o.depth == r.depth - 1
      ? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0)
      : !1;
  },
  bC = (t, e, n) => {
    let r = Uy(t, n);
    if (!r) return !1;
    let o = Ih(r);
    return o ? Wy(t, o, e) : !1;
  },
  yC = (t, e, n) => {
    let r = Ky(t, n);
    if (!r) return !1;
    let o = Ph(r);
    return o ? Wy(t, o, e) : !1;
  };
function Wy(t, e, n) {
  let r = e.nodeBefore,
    o = r,
    i = e.pos - 1;
  for (; !o.isTextblock; i--) {
    if (o.type.spec.isolating) return !1;
    let c = o.lastChild;
    if (!c) return !1;
    o = c;
  }
  let s = e.nodeAfter,
    a = s,
    l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating) return !1;
    let c = a.firstChild;
    if (!c) return !1;
    a = c;
  }
  let u = qc(t.doc, i, l, W.empty);
  if (!u || u.from != i || (u instanceof pt && u.slice.size >= l - i))
    return !1;
  if (n) {
    let c = t.tr.step(u);
    c.setSelection(q.create(c.doc, i)), n(c.scrollIntoView());
  }
  return !0;
}
function Wi(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0;
    if (n && r.childCount != 1) return !1;
  }
  return !1;
}
const qy = (t, e, n) => {
  let { $head: r, empty: o } = t.selection,
    i = r;
  if (!o) return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0) return !1;
    i = Ih(r);
  }
  let s = i && i.nodeBefore;
  return !s || !Z.isSelectable(s)
    ? !1
    : (e &&
        e(
          t.tr
            .setSelection(Z.create(t.doc, i.pos - s.nodeSize))
            .scrollIntoView()
        ),
      !0);
};
function Ih(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating) break;
    }
  return null;
}
function Ky(t, e) {
  let { $cursor: n } = t.selection;
  return !n ||
    (e
      ? !e.endOfTextblock("forward", t)
      : n.parentOffset < n.parent.content.size)
    ? null
    : n;
}
const Gy = (t, e, n) => {
    let r = Ky(t, n);
    if (!r) return !1;
    let o = Ph(r);
    if (!o) return !1;
    let i = o.nodeAfter;
    if (tv(t, o, e, 1)) return !0;
    if (r.parent.content.size == 0 && (Wi(i, "start") || Z.isSelectable(i))) {
      let s = qc(t.doc, r.before(), r.after(), W.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let a = t.tr.step(s);
          a.setSelection(
            Wi(i, "start")
              ? ee.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1)
              : Z.create(a.doc, a.mapping.map(o.pos))
          ),
            e(a.scrollIntoView());
        }
        return !0;
      }
    }
    return i.isAtom && o.depth == r.depth - 1
      ? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0)
      : !1;
  },
  Jy = (t, e, n) => {
    let { $head: r, empty: o } = t.selection,
      i = r;
    if (!o) return !1;
    if (r.parent.isTextblock) {
      if (
        n
          ? !n.endOfTextblock("forward", t)
          : r.parentOffset < r.parent.content.size
      )
        return !1;
      i = Ph(r);
    }
    let s = i && i.nodeAfter;
    return !s || !Z.isSelectable(s)
      ? !1
      : (e && e(t.tr.setSelection(Z.create(t.doc, i.pos)).scrollIntoView()),
        !0);
  };
function Ph(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating) break;
    }
  return null;
}
const ap = (t, e) => {
    let n = t.selection,
      r = n instanceof Z,
      o;
    if (r) {
      if (n.node.isTextblock || !_r(t.doc, n.from)) return !1;
      o = n.from;
    } else if (((o = Wc(t.doc, n.from, -1)), o == null)) return !1;
    if (e) {
      let i = t.tr.join(o);
      r &&
        i.setSelection(
          Z.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)
        ),
        e(i.scrollIntoView());
    }
    return !0;
  },
  vC = (t, e) => {
    let n = t.selection,
      r;
    if (n instanceof Z) {
      if (n.node.isTextblock || !_r(t.doc, n.to)) return !1;
      r = n.to;
    } else if (((r = Wc(t.doc, n.to, 1)), r == null)) return !1;
    return e && e(t.tr.join(r).scrollIntoView()), !0;
  },
  lp = (t, e) => {
    let { $from: n, $to: r } = t.selection,
      o = n.blockRange(r),
      i = o && ns(o);
    return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
  },
  Yy = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    return !n.parent.type.spec.code || !n.sameParent(r)
      ? !1
      : (e &&
          e(
            t.tr
              .insertText(
                `
`
              )
              .scrollIntoView()
          ),
        !0);
  };
function $h(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs()) return n;
  }
  return null;
}
const Xy = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
    let o = n.node(-1),
      i = n.indexAfter(-1),
      s = $h(o.contentMatchAt(i));
    if (!s || !o.canReplaceWith(i, i, s)) return !1;
    if (e) {
      let a = n.after(),
        l = t.tr.replaceWith(a, a, s.createAndFill());
      l.setSelection(ee.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
    }
    return !0;
  },
  Zy = (t, e) => {
    let n = t.selection,
      { $from: r, $to: o } = n;
    if (n instanceof $t || r.parent.inlineContent || o.parent.inlineContent)
      return !1;
    let i = $h(o.parent.contentMatchAt(o.indexAfter()));
    if (!i || !i.isTextblock) return !1;
    if (e) {
      let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos,
        a = t.tr.insert(s, i.createAndFill());
      a.setSelection(q.create(a.doc, s + 1)), e(a.scrollIntoView());
    }
    return !0;
  },
  Qy = (t, e) => {
    let { $cursor: n } = t.selection;
    if (!n || n.parent.content.size) return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
      let i = n.before();
      if (hr(t.doc, i)) return e && e(t.tr.split(i).scrollIntoView()), !0;
    }
    let r = n.blockRange(),
      o = r && ns(r);
    return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
  };
function _C(t) {
  return (e, n) => {
    let { $from: r, $to: o } = e.selection;
    if (e.selection instanceof Z && e.selection.node.isBlock)
      return !r.parentOffset || !hr(e.doc, r.pos)
        ? !1
        : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth) return !1;
    let i = [],
      s,
      a,
      l = !1,
      u = !1;
    for (let p = r.depth; ; p--)
      if (r.node(p).isBlock) {
        (l = r.end(p) == r.pos + (r.depth - p)),
          (u = r.start(p) == r.pos - (r.depth - p)),
          (a = $h(r.node(p - 1).contentMatchAt(r.indexAfter(p - 1))));
        let m = t && t(o.parent, l, r);
        i.unshift(m || (l && a ? { type: a } : null)), (s = p);
        break;
      } else {
        if (p == 1) return !1;
        i.unshift(null);
      }
    let c = e.tr;
    (e.selection instanceof q || e.selection instanceof $t) &&
      c.deleteSelection();
    let d = c.mapping.map(r.pos),
      f = hr(c.doc, d, i.length, i);
    if (
      (f || ((i[0] = a ? { type: a } : null), (f = hr(c.doc, d, i.length, i))),
      c.split(d, i.length, i),
      !l && u && r.node(s).type != a)
    ) {
      let p = c.mapping.map(r.before(s)),
        h = c.doc.resolve(p);
      a &&
        r.node(s - 1).canReplaceWith(h.index(), h.index() + 1, a) &&
        c.setNodeMarkup(c.mapping.map(r.before(s)), a);
    }
    return n && n(c.scrollIntoView()), !0;
  };
}
const ev = _C(),
  rV = (t, e) =>
    ev(
      t,
      e &&
        ((n) => {
          let r =
            t.storedMarks ||
            (t.selection.$to.parentOffset && t.selection.$from.marks());
          r && n.ensureMarks(r), e(n);
        })
    ),
  up = (t, e) => {
    let { $from: n, to: r } = t.selection,
      o,
      i = n.sharedDepth(r);
    return i == 0
      ? !1
      : ((o = n.before(i)), e && e(t.tr.setSelection(Z.create(t.doc, o))), !0);
  },
  xC = (t, e) => (e && e(t.tr.setSelection(new $t(t.doc))), !0);
function kC(t, e, n) {
  let r = e.nodeBefore,
    o = e.nodeAfter,
    i = e.index();
  return !r || !o || !r.type.compatibleContent(o.type)
    ? !1
    : !r.content.size && e.parent.canReplace(i - 1, i)
    ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
    : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || _r(t.doc, e.pos))
    ? !1
    : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function tv(t, e, n, r) {
  let o = e.nodeBefore,
    i = e.nodeAfter,
    s,
    a,
    l = o.type.spec.isolating || i.type.spec.isolating;
  if (!l && kC(t, e, n)) return !0;
  let u = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (
    u &&
    (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) &&
    a.matchType(s[0] || i.type).validEnd
  ) {
    if (n) {
      let p = e.pos + i.nodeSize,
        h = $.empty;
      for (let b = s.length - 1; b >= 0; b--) h = $.from(s[b].create(null, h));
      h = $.from(o.copy(h));
      let m = t.tr.step(
          new bt(e.pos - 1, p, e.pos, p, new W(h, 1, 0), s.length, !0)
        ),
        g = m.doc.resolve(p + 2 * s.length);
      g.nodeAfter &&
        g.nodeAfter.type == o.type &&
        _r(m.doc, g.pos) &&
        m.join(g.pos),
        n(m.scrollIntoView());
    }
    return !0;
  }
  let c = i.type.spec.isolating || (r > 0 && l) ? null : ee.findFrom(e, 1),
    d = c && c.$from.blockRange(c.$to),
    f = d && ns(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (u && Wi(i, "start", !0) && Wi(o, "end")) {
    let p = o,
      h = [];
    for (; h.push(p), !p.isTextblock; ) p = p.lastChild;
    let m = i,
      g = 1;
    for (; !m.isTextblock; m = m.firstChild) g++;
    if (p.canReplace(p.childCount, p.childCount, m.content)) {
      if (n) {
        let b = $.empty;
        for (let v = h.length - 1; v >= 0; v--) b = $.from(h[v].copy(b));
        let _ = t.tr.step(
          new bt(
            e.pos - h.length,
            e.pos + i.nodeSize,
            e.pos + g,
            e.pos + i.nodeSize - g,
            new W(b, h.length, 0),
            0,
            !0
          )
        );
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function nv(t) {
  return function (e, n) {
    let r = e.selection,
      o = t < 0 ? r.$from : r.$to,
      i = o.depth;
    for (; o.node(i).isInline; ) {
      if (!i) return !1;
      i--;
    }
    return o.node(i).isTextblock
      ? (n &&
          n(e.tr.setSelection(q.create(e.doc, t < 0 ? o.start(i) : o.end(i)))),
        !0)
      : !1;
  };
}
const rv = nv(-1),
  ov = nv(1);
function cp(t, e = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      s = o.blockRange(i),
      a = s && jc(s, t, e);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function dp(t, e = null) {
  return function (n, r) {
    let o = !1;
    for (let i = 0; i < n.selection.ranges.length && !o; i++) {
      let {
        $from: { pos: s },
        $to: { pos: a },
      } = n.selection.ranges[i];
      n.doc.nodesBetween(s, a, (l, u) => {
        if (o) return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t) o = !0;
          else {
            let c = n.doc.resolve(u),
              d = c.index();
            o = c.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!o) return !1;
    if (r) {
      let i = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let {
          $from: { pos: a },
          $to: { pos: l },
        } = n.selection.ranges[s];
        i.setBlockType(a, l, t, e);
      }
      r(i.scrollIntoView());
    }
    return !0;
  };
}
function wC(t, e, n, r) {
  for (let o = 0; o < e.length; o++) {
    let { $from: i, $to: s } = e[o],
      a = i.depth == 0 ? t.inlineContent && t.type.allowsMarkType(n) : !1;
    if (
      (t.nodesBetween(i.pos, s.pos, (l, u) => {
        if (
          a ||
          (!r &&
            l.isAtom &&
            l.isInline &&
            u >= i.pos &&
            u + l.nodeSize <= s.pos)
        )
          return !1;
        a = l.inlineContent && l.type.allowsMarkType(n);
      }),
      a)
    )
      return !0;
  }
  return !1;
}
function CC(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) {
    let { $from: r, $to: o } = t[n];
    r.doc.nodesBetween(r.pos, o.pos, (i, s) => {
      if (
        i.isAtom &&
        i.content.size &&
        i.isInline &&
        s >= r.pos &&
        s + i.nodeSize <= o.pos
      )
        return (
          s + 1 > r.pos && e.push(new pu(r, r.doc.resolve(s + 1))),
          (r = r.doc.resolve(s + 1 + i.content.size)),
          !1
        );
    }),
      r.pos < o.pos && e.push(new pu(r, o));
  }
  return e;
}
function oV(t, e = null, n) {
  let r = (n && n.removeWhenPresent) !== !1,
    o = (n && n.enterInlineAtoms) !== !1;
  return function (i, s) {
    let { empty: a, $cursor: l, ranges: u } = i.selection;
    if ((a && !l) || !wC(i.doc, u, t, o)) return !1;
    if (s)
      if (l)
        t.isInSet(i.storedMarks || l.marks())
          ? s(i.tr.removeStoredMark(t))
          : s(i.tr.addStoredMark(t.create(e)));
      else {
        let c,
          d = i.tr;
        o || (u = CC(u)),
          r
            ? (c = !u.some((f) =>
                i.doc.rangeHasMark(f.$from.pos, f.$to.pos, t)
              ))
            : (c = !u.every((f) => {
                let p = !1;
                return (
                  d.doc.nodesBetween(f.$from.pos, f.$to.pos, (h, m, g) => {
                    if (p) return !1;
                    p =
                      !t.isInSet(h.marks) &&
                      !!g &&
                      g.type.allowsMarkType(t) &&
                      !(
                        h.isText &&
                        /^\s*$/.test(
                          h.textBetween(
                            Math.max(0, f.$from.pos - m),
                            Math.min(h.nodeSize, f.$to.pos - m)
                          )
                        )
                      );
                  }),
                  !p
                );
              }));
        for (let f = 0; f < u.length; f++) {
          let { $from: p, $to: h } = u[f];
          if (!c) d.removeMark(p.pos, h.pos, t);
          else {
            let m = p.pos,
              g = h.pos,
              b = p.nodeAfter,
              _ = h.nodeBefore,
              v = b && b.isText ? /^\s*/.exec(b.text)[0].length : 0,
              y = _ && _.isText ? /\s*$/.exec(_.text)[0].length : 0;
            m + v < g && ((m += v), (g -= y)), d.addMark(m, g, t.create(e));
          }
        }
        s(d.scrollIntoView());
      }
    return !0;
  };
}
function AC(t, e) {
  return (n) => {
    if (!n.isGeneric) return t(n);
    let r = [];
    for (let i = 0; i < n.mapping.maps.length; i++) {
      let s = n.mapping.maps[i];
      for (let a = 0; a < r.length; a++) r[a] = s.map(r[a]);
      s.forEach((a, l, u, c) => r.push(u, c));
    }
    let o = [];
    for (let i = 0; i < r.length; i += 2) {
      let s = r[i],
        a = r[i + 1],
        l = n.doc.resolve(s),
        u = l.sharedDepth(a),
        c = l.node(u);
      for (let d = l.indexAfter(u), f = l.after(u + 1); f <= a; ++d) {
        let p = c.maybeChild(d);
        if (!p) break;
        if (d && o.indexOf(f) == -1) {
          let h = c.child(d - 1);
          h.type == p.type && e(h, p) && o.push(f);
        }
        f += p.nodeSize;
      }
    }
    o.sort((i, s) => i - s);
    for (let i = o.length - 1; i >= 0; i--) _r(n.doc, o[i]) && n.join(o[i]);
    t(n);
  };
}
function iV(t, e) {
  let n = Array.isArray(e) ? (r) => e.indexOf(r.type.name) > -1 : e;
  return (r, o, i) => t(r, o && AC(o, n), i);
}
function Bh(...t) {
  return function (e, n, r) {
    for (let o = 0; o < t.length; o++) if (t[o](e, n, r)) return !0;
    return !1;
  };
}
let zd = Bh(Rh, jy, qy),
  u1 = Bh(Rh, Gy, Jy);
const Rr = {
    Enter: Bh(Yy, Zy, Qy, ev),
    "Mod-Enter": Xy,
    Backspace: zd,
    "Mod-Backspace": zd,
    "Shift-Backspace": zd,
    Delete: u1,
    "Mod-Delete": u1,
    "Mod-a": xC,
  },
  iv = {
    "Ctrl-h": Rr.Backspace,
    "Alt-Backspace": Rr["Mod-Backspace"],
    "Ctrl-d": Rr.Delete,
    "Ctrl-Alt-Backspace": Rr["Mod-Delete"],
    "Alt-Delete": Rr["Mod-Delete"],
    "Alt-d": Rr["Mod-Delete"],
    "Ctrl-a": rv,
    "Ctrl-e": ov,
  };
for (let t in Rr) iv[t] = Rr[t];
const SC =
    typeof navigator < "u"
      ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
      : typeof os < "u" && os.platform
      ? os.platform() == "darwin"
      : !1,
  sV = SC ? iv : Rr;
function EC(t = {}) {
  return new be({
    view(e) {
      return new MC(e, t);
    },
  });
}
class MC {
  constructor(e, n) {
    var r;
    (this.editorView = e),
      (this.cursorPos = null),
      (this.element = null),
      (this.timeout = -1),
      (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
      (this.color = n.color === !1 ? void 0 : n.color || "black"),
      (this.class = n.class),
      (this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
        let i = (s) => {
          this[o](s);
        };
        return e.dom.addEventListener(o, i), { name: o, handler: i };
      }));
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) =>
      this.editorView.dom.removeEventListener(e, n)
    );
  }
  update(e, n) {
    this.cursorPos != null &&
      n.doc != e.state.doc &&
      (this.cursorPos > e.state.doc.content.size
        ? this.setCursor(null)
        : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos &&
      ((this.cursorPos = e),
      e == null
        ? (this.element.parentNode.removeChild(this.element),
          (this.element = null))
        : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos),
      n = !e.parent.inlineContent,
      r;
    if (n) {
      let a = e.nodeBefore,
        l = e.nodeAfter;
      if (a || l) {
        let u = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (u) {
          let c = u.getBoundingClientRect(),
            d = a ? c.bottom : c.top;
          a &&
            l &&
            (d =
              (d +
                this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect()
                  .top) /
              2),
            (r = {
              left: c.left,
              right: c.right,
              top: d - this.width / 2,
              bottom: d + this.width / 2,
            });
        }
      }
    }
    if (!r) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      r = {
        left: a.left - this.width / 2,
        right: a.left + this.width / 2,
        top: a.top,
        bottom: a.bottom,
      };
    }
    let o = this.editorView.dom.offsetParent;
    this.element ||
      ((this.element = o.appendChild(document.createElement("div"))),
      this.class && (this.element.className = this.class),
      (this.element.style.cssText =
        "position: absolute; z-index: 50; pointer-events: none;"),
      this.color && (this.element.style.backgroundColor = this.color)),
      this.element.classList.toggle("prosemirror-dropcursor-block", n),
      this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let i, s;
    if (!o || (o == document.body && getComputedStyle(o).position == "static"))
      (i = -pageXOffset), (s = -pageYOffset);
    else {
      let a = o.getBoundingClientRect();
      (i = a.left - o.scrollLeft), (s = a.top - o.scrollTop);
    }
    (this.element.style.left = r.left - i + "px"),
      (this.element.style.top = r.top - s + "px"),
      (this.element.style.width = r.right - r.left + "px"),
      (this.element.style.height = r.bottom - r.top + "px");
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout),
      (this.timeout = setTimeout(() => this.setCursor(null), e));
  }
  dragover(e) {
    if (!this.editorView.editable) return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
      r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
      o = r && r.type.spec.disableDropCursor,
      i = typeof o == "function" ? o(this.editorView, n, e) : o;
    if (n && !i) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = Iy(
          this.editorView.state.doc,
          s,
          this.editorView.dragging.slice
        );
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom ||
      !this.editorView.dom.contains(e.relatedTarget)) &&
      this.setCursor(null);
  }
}
var Co = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  },
  mu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  },
  c1 = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent),
  TC = typeof navigator < "u" && /Mac/.test(navigator.platform),
  OC =
    typeof navigator < "u" &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),
  DC = TC || (c1 && +c1[1] < 57);
for (var _t = 0; _t < 10; _t++) Co[48 + _t] = Co[96 + _t] = String(_t);
for (var _t = 1; _t <= 24; _t++) Co[_t + 111] = "F" + _t;
for (var _t = 65; _t <= 90; _t++)
  (Co[_t] = String.fromCharCode(_t + 32)), (mu[_t] = String.fromCharCode(_t));
for (var Vd in Co) mu.hasOwnProperty(Vd) || (mu[Vd] = Co[Vd]);
function NC(t) {
  var e =
      (DC && (t.ctrlKey || t.altKey || t.metaKey)) ||
      (OC && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == "Unidentified",
    n =
      (!e && t.key) ||
      (t.shiftKey ? mu : Co)[t.keyCode] ||
      t.key ||
      "Unidentified";
  return (
    n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
  );
}
const LC =
  typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function RC(t) {
  let e = t.split(/-(?!$)/),
    n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l)) s = !0;
    else if (/^a(lt)?$/i.test(l)) r = !0;
    else if (/^(c|ctrl|control)$/i.test(l)) o = !0;
    else if (/^s(hift)?$/i.test(l)) i = !0;
    else if (/^mod$/i.test(l)) LC ? (s = !0) : (o = !0);
    else throw new Error("Unrecognized modifier name: " + l);
  }
  return (
    r && (n = "Alt-" + n),
    o && (n = "Ctrl-" + n),
    s && (n = "Meta-" + n),
    i && (n = "Shift-" + n),
    n
  );
}
function IC(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) e[RC(n)] = t[n];
  return e;
}
function Ud(t, e, n = !0) {
  return (
    e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n && e.shiftKey && (t = "Shift-" + t),
    t
  );
}
function PC(t) {
  return new be({ props: { handleKeyDown: Gc(t) } });
}
function Gc(t) {
  let e = IC(t);
  return function (n, r) {
    let o = NC(r),
      i,
      s = e[Ud(o, r)];
    if (s && s(n.state, n.dispatch, n)) return !0;
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let a = e[Ud(o, r, !1)];
        if (a && a(n.state, n.dispatch, n)) return !0;
      }
      if (
        (r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) &&
        (i = Co[r.keyCode]) &&
        i != o
      ) {
        let a = e[Ud(i, r)];
        if (a && a(n.state, n.dispatch, n)) return !0;
      }
    }
    return !1;
  };
}
const xt = function (t) {
    for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
  },
  ra = function (t) {
    let e = t.assignedSlot || t.parentNode;
    return e && e.nodeType == 11 ? e.host : e;
  };
let fp = null;
const Lr = function (t, e, n) {
    let r = fp || (fp = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
  },
  $C = function () {
    fp = null;
  },
  ai = function (t, e, n, r) {
    return n && (d1(t, e, n, r, -1) || d1(t, e, n, r, 1));
  },
  BC = /^(img|br|input|textarea|hr)$/i;
function d1(t, e, n, r, o) {
  for (;;) {
    if (t == n && e == r) return !0;
    if (e == (o < 0 ? 0 : kn(t))) {
      let i = t.parentNode;
      if (
        !i ||
        i.nodeType != 1 ||
        Ea(t) ||
        BC.test(t.nodeName) ||
        t.contentEditable == "false"
      )
        return !1;
      (e = xt(t) + (o < 0 ? 0 : 1)), (t = i);
    } else if (t.nodeType == 1) {
      if (
        ((t = t.childNodes[e + (o < 0 ? -1 : 0)]), t.contentEditable == "false")
      )
        return !1;
      e = o < 0 ? kn(t) : 0;
    } else return !1;
  }
}
function kn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function HC(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e) return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false") return null;
      (t = t.childNodes[e - 1]), (e = kn(t));
    } else if (t.parentNode && !Ea(t)) (e = xt(t)), (t = t.parentNode);
    else return null;
  }
}
function FC(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e < t.nodeValue.length) return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false") return null;
      (t = t.childNodes[e]), (e = 0);
    } else if (t.parentNode && !Ea(t)) (e = xt(t) + 1), (t = t.parentNode);
    else return null;
  }
}
function zC(t, e, n) {
  for (let r = e == 0, o = e == kn(t); r || o; ) {
    if (t == n) return !0;
    let i = xt(t);
    if (((t = t.parentNode), !t)) return !1;
    (r = r && i == 0), (o = o && i == kn(t));
  }
}
function Ea(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Jc = function (t) {
  return (
    t.focusNode && ai(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
  );
};
function Uo(t, e) {
  let n = document.createEvent("Event");
  return (
    n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
  );
}
function VC(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function UC(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return {
          node: r.offsetNode,
          offset: Math.min(kn(r.offsetNode), r.offset),
        };
    } catch {}
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return {
        node: r.startContainer,
        offset: Math.min(kn(r.startContainer), r.startOffset),
      };
  }
}
const br = typeof navigator < "u" ? navigator : null,
  f1 = typeof document < "u" ? document : null,
  Oo = (br && br.userAgent) || "",
  pp = /Edge\/(\d+)/.exec(Oo),
  sv = /MSIE \d/.exec(Oo),
  hp = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Oo),
  Gt = !!(sv || hp || pp),
  _o = sv ? document.documentMode : hp ? +hp[1] : pp ? +pp[1] : 0,
  Jn = !Gt && /gecko\/(\d+)/i.test(Oo);
Jn && +(/Firefox\/(\d+)/.exec(Oo) || [0, 0])[1];
const mp = !Gt && /Chrome\/(\d+)/.exec(Oo),
  Mt = !!mp,
  av = mp ? +mp[1] : 0,
  Bt = !Gt && !!br && /Apple Computer/.test(br.vendor),
  qi = Bt && (/Mobile\/\w+/.test(Oo) || (!!br && br.maxTouchPoints > 2)),
  _n = qi || (br ? /Mac/.test(br.platform) : !1),
  jC = br ? /Win/.test(br.platform) : !1,
  Br = /Android \d/.test(Oo),
  Ma = !!f1 && "webkitFontSmoothing" in f1.documentElement.style,
  WC = Ma
    ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
    : 0;
function qC(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e
    ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height,
      }
    : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight,
      };
}
function Sr(t, e) {
  return typeof t == "number" ? t : t[e];
}
function KC(t) {
  let e = t.getBoundingClientRect(),
    n = e.width / t.offsetWidth || 1,
    r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r,
  };
}
function p1(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0,
    o = t.someProp("scrollMargin") || 5,
    i = t.dom.ownerDocument;
  for (let s = n || t.dom; s; s = ra(s)) {
    if (s.nodeType != 1) continue;
    let a = s,
      l = a == i.body,
      u = l ? qC(i) : KC(a),
      c = 0,
      d = 0;
    if (
      (e.top < u.top + Sr(r, "top")
        ? (d = -(u.top - e.top + Sr(o, "top")))
        : e.bottom > u.bottom - Sr(r, "bottom") &&
          (d =
            e.bottom - e.top > u.bottom - u.top
              ? e.top + Sr(o, "top") - u.top
              : e.bottom - u.bottom + Sr(o, "bottom")),
      e.left < u.left + Sr(r, "left")
        ? (c = -(u.left - e.left + Sr(o, "left")))
        : e.right > u.right - Sr(r, "right") &&
          (c = e.right - u.right + Sr(o, "right")),
      c || d)
    )
      if (l) i.defaultView.scrollBy(c, d);
      else {
        let f = a.scrollLeft,
          p = a.scrollTop;
        d && (a.scrollTop += d), c && (a.scrollLeft += c);
        let h = a.scrollLeft - f,
          m = a.scrollTop - p;
        e = {
          left: e.left - h,
          top: e.top - m,
          right: e.right - h,
          bottom: e.bottom - m,
        };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
  }
}
function GC(t) {
  let e = t.dom.getBoundingClientRect(),
    n = Math.max(0, e.top),
    r,
    o;
  for (
    let i = (e.left + e.right) / 2, s = n + 1;
    s < Math.min(innerHeight, e.bottom);
    s += 5
  ) {
    let a = t.root.elementFromPoint(i, s);
    if (!a || a == t.dom || !t.dom.contains(a)) continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      (r = a), (o = l.top);
      break;
    }
  }
  return { refDOM: r, refTop: o, stack: lv(t.dom) };
}
function lv(t) {
  let e = [],
    n = t.ownerDocument;
  for (
    let r = t;
    r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
    r = ra(r)
  );
  return e;
}
function JC({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  uv(n, r == 0 ? 0 : r - e);
}
function uv(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: o, left: i } = t[n];
    r.scrollTop != o + e && (r.scrollTop = o + e),
      r.scrollLeft != i && (r.scrollLeft = i);
  }
}
let xi = null;
function YC(t) {
  if (t.setActive) return t.setActive();
  if (xi) return t.focus(xi);
  let e = lv(t);
  t.focus(
    xi == null
      ? {
          get preventScroll() {
            return (xi = { preventScroll: !0 }), !0;
          },
        }
      : void 0
  ),
    xi || ((xi = !1), uv(e, 0));
}
function cv(t, e) {
  let n,
    r = 2e8,
    o,
    i = 0,
    s = e.top,
    a = e.top,
    l,
    u;
  for (let c = t.firstChild, d = 0; c; c = c.nextSibling, d++) {
    let f;
    if (c.nodeType == 1) f = c.getClientRects();
    else if (c.nodeType == 3) f = Lr(c).getClientRects();
    else continue;
    for (let p = 0; p < f.length; p++) {
      let h = f[p];
      if (h.top <= s && h.bottom >= a) {
        (s = Math.max(h.bottom, s)), (a = Math.min(h.top, a));
        let m =
          h.left > e.left
            ? h.left - e.left
            : h.right < e.left
            ? e.left - h.right
            : 0;
        if (m < r) {
          (n = c),
            (r = m),
            (o =
              m && n.nodeType == 3
                ? {
                    left: h.right < e.left ? h.right : h.left,
                    top: e.top,
                  }
                : e),
            c.nodeType == 1 &&
              m &&
              (i = d + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        h.top > e.top &&
          !l &&
          h.left <= e.left &&
          h.right >= e.left &&
          ((l = c),
          (u = {
            left: Math.max(h.left, Math.min(h.right, e.left)),
            top: h.top,
          }));
      !n &&
        ((e.left >= h.right && e.top >= h.top) ||
          (e.left >= h.left && e.top >= h.bottom)) &&
        (i = d + 1);
    }
  }
  return (
    !n && l && ((n = l), (o = u), (r = 0)),
    n && n.nodeType == 3
      ? XC(n, o)
      : !n || (r && n.nodeType == 1)
      ? { node: t, offset: i }
      : cv(n, o)
  );
}
function XC(t, e) {
  let n = t.nodeValue.length,
    r = document.createRange();
  for (let o = 0; o < n; o++) {
    r.setEnd(t, o + 1), r.setStart(t, o);
    let i = eo(r, 1);
    if (i.top != i.bottom && Hh(e, i))
      return {
        node: t,
        offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0),
      };
  }
  return { node: t, offset: 0 };
}
function Hh(t, e) {
  return (
    t.left >= e.left - 1 &&
    t.left <= e.right + 1 &&
    t.top >= e.top - 1 &&
    t.top <= e.bottom + 1
  );
}
function ZC(t, e) {
  let n = t.parentNode;
  return n &&
    /^li$/i.test(n.nodeName) &&
    e.left < t.getBoundingClientRect().left
    ? n
    : t;
}
function QC(t, e, n) {
  let { node: r, offset: o } = cv(e, n),
    i = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, o, i);
}
function e6(t, e, n, r) {
  let o = -1;
  for (let i = e, s = !1; i != t.dom; ) {
    let a = t.docView.nearestDesc(i, !0),
      l;
    if (!a) return null;
    if (
      a.dom.nodeType == 1 &&
      ((a.node.isBlock && a.parent) || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
      ((l = a.dom.getBoundingClientRect()).width || l.height) &&
      (a.node.isBlock &&
        a.parent &&
        ((!s && l.left > r.left) || l.top > r.top
          ? (o = a.posBefore)
          : ((!s && l.right < r.left) || l.bottom < r.top) && (o = a.posAfter),
        (s = !0)),
      !a.contentDOM && o < 0 && !a.node.isText)
    )
      return (
        a.node.isBlock
          ? r.top < (l.top + l.bottom) / 2
          : r.left < (l.left + l.right) / 2
      )
        ? a.posBefore
        : a.posAfter;
    i = a.dom.parentNode;
  }
  return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function dv(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (
      let o = Math.max(
          0,
          Math.min(
            r - 1,
            Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2
          )
        ),
        i = o;
      ;

    ) {
      let s = t.childNodes[i];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          if (Hh(e, u)) return dv(s, e, u);
        }
      }
      if ((i = (i + 1) % r) == o) break;
    }
  return t;
}
function t6(t, e) {
  let n = t.dom.ownerDocument,
    r,
    o = 0,
    i = UC(n, e.left, e.top);
  i && ({ node: r, offset: o } = i);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
      e.left,
      e.top
    ),
    a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = t.dom.getBoundingClientRect();
    if (!Hh(e, u) || ((s = dv(t.dom, e, u)), !s)) return null;
  }
  if (Bt) for (let u = s; r && u; u = ra(u)) u.draggable && (r = void 0);
  if (((s = ZC(s, e)), r)) {
    if (
      Jn &&
      r.nodeType == 1 &&
      ((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
    ) {
      let c = r.childNodes[o],
        d;
      c.nodeName == "IMG" &&
        (d = c.getBoundingClientRect()).right <= e.left &&
        d.bottom > e.top &&
        o++;
    }
    let u;
    Ma &&
      o &&
      r.nodeType == 1 &&
      (u = r.childNodes[o - 1]).nodeType == 1 &&
      u.contentEditable == "false" &&
      u.getBoundingClientRect().top >= e.top &&
      o--,
      r == t.dom &&
      o == r.childNodes.length - 1 &&
      r.lastChild.nodeType == 1 &&
      e.top > r.lastChild.getBoundingClientRect().bottom
        ? (a = t.state.doc.content.size)
        : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") &&
          (a = e6(t, r, o, e));
  }
  a == null && (a = QC(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function h1(t) {
  return t.top < t.bottom || t.left < t.right;
}
function eo(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (h1(r)) return r;
  }
  return Array.prototype.find.call(n, h1) || t.getBoundingClientRect();
}
const n6 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function fv(t, e, n) {
  let { node: r, offset: o, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
    s = Ma || Jn;
  if (r.nodeType == 3)
    if (s && (n6.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
      let l = eo(Lr(r, o, o), n);
      if (Jn && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let u = eo(Lr(r, o - 1, o - 1), -1);
        if (u.top == l.top) {
          let c = eo(Lr(r, o, o + 1), -1);
          if (c.top != l.top) return ds(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = o,
        u = o,
        c = n < 0 ? 1 : -1;
      return (
        n < 0 && !o
          ? (u++, (c = -1))
          : n >= 0 && o == r.nodeValue.length
          ? (l--, (c = 1))
          : n < 0
          ? l--
          : u++,
        ds(eo(Lr(r, l, u), c), c < 0)
      );
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && o && (n < 0 || o == kn(r))) {
      let l = r.childNodes[o - 1];
      if (l.nodeType == 1) return jd(l.getBoundingClientRect(), !1);
    }
    if (i == null && o < kn(r)) {
      let l = r.childNodes[o];
      if (l.nodeType == 1) return jd(l.getBoundingClientRect(), !0);
    }
    return jd(r.getBoundingClientRect(), n >= 0);
  }
  if (i == null && o && (n < 0 || o == kn(r))) {
    let l = r.childNodes[o - 1],
      u =
        l.nodeType == 3
          ? Lr(l, kn(l) - (s ? 0 : 1))
          : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling)
          ? l
          : null;
    if (u) return ds(eo(u, 1), !1);
  }
  if (i == null && o < kn(r)) {
    let l = r.childNodes[o];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling;
    let u = l
      ? l.nodeType == 3
        ? Lr(l, 0, s ? 0 : 1)
        : l.nodeType == 1
        ? l
        : null
      : null;
    if (u) return ds(eo(u, -1), !0);
  }
  return ds(eo(r.nodeType == 3 ? Lr(r) : r, -n), n >= 0);
}
function ds(t, e) {
  if (t.width == 0) return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function jd(t, e) {
  if (t.height == 0) return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function pv(t, e, n) {
  let r = t.state,
    o = t.root.activeElement;
  r != e && t.updateState(e), o != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), o != t.dom && o && o.focus();
  }
}
function r6(t, e, n) {
  let r = e.selection,
    o = n == "up" ? r.$from : r.$to;
  return pv(t, e, () => {
    let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
    for (;;) {
      let a = t.docView.nearestDesc(i, !0);
      if (!a) break;
      if (a.node.isBlock) {
        i = a.contentDOM || a.dom;
        break;
      }
      i = a.dom.parentNode;
    }
    let s = fv(t, o.pos, 1);
    for (let a = i.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1) l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Lr(a, 0, a.nodeValue.length).getClientRects();
      else continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (
          c.bottom > c.top + 1 &&
          (n == "up"
            ? s.top - c.top > (c.bottom - s.top) * 2
            : c.bottom - s.bottom > (s.bottom - c.top) * 2)
        )
          return !1;
      }
    }
    return !0;
  });
}
const o6 = /[\u0590-\u08ac]/;
function i6(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock) return !1;
  let o = r.parentOffset,
    i = !o,
    s = o == r.parent.content.size,
    a = t.domSelection();
  return a
    ? !o6.test(r.parent.textContent) || !a.modify
      ? n == "left" || n == "backward"
        ? i
        : s
      : pv(t, e, () => {
          let {
              focusNode: l,
              focusOffset: u,
              anchorNode: c,
              anchorOffset: d,
            } = t.domSelectionRange(),
            f = a.caretBidiLevel;
          a.modify("move", n, "character");
          let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
            { focusNode: h, focusOffset: m } = t.domSelectionRange(),
            g =
              (h && !p.contains(h.nodeType == 1 ? h : h.parentNode)) ||
              (l == h && u == m);
          try {
            a.collapse(c, d),
              l && (l != c || u != d) && a.extend && a.extend(l, u);
          } catch {}
          return f != null && (a.caretBidiLevel = f), g;
        })
    : r.pos == r.start() || r.pos == r.end();
}
let m1 = null,
  g1 = null,
  b1 = !1;
function s6(t, e, n) {
  return m1 == e && g1 == n
    ? b1
    : ((m1 = e),
      (g1 = n),
      (b1 = n == "up" || n == "down" ? r6(t, e, n) : i6(t, e, n)));
}
const An = 0,
  y1 = 1,
  Wo = 2,
  yr = 3;
class Ta {
  constructor(e, n, r, o) {
    (this.parent = e),
      (this.children = n),
      (this.dom = r),
      (this.contentDOM = o),
      (this.dirty = An),
      (r.pmViewDesc = this);
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++) e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    (this.parent = void 0),
      this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let o = this.children[n];
      if (o == e) return r;
      r += o.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (
      this.contentDOM &&
      this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
    )
      if (r < 0) {
        let i, s;
        if (e == this.contentDOM) i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let i, s;
        if (e == this.contentDOM) i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let o;
    if (e == this.dom && this.contentDOM) o = n > xt(this.contentDOM);
    else if (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      this.dom.contains(this.contentDOM)
    )
      o = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !1;
            break;
          }
          if (i.previousSibling) break;
        }
      if (o == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !0;
            break;
          }
          if (i.nextSibling) break;
        }
    }
    return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, o = e; o; o = o.parentNode) {
      let i = this.getDesc(o),
        s;
      if (i && (!n || i.node))
        if (
          r &&
          (s = i.nodeDOM) &&
          !(s.nodeType == 1
            ? s.contains(e.nodeType == 1 ? e : e.parentNode)
            : s == e)
        )
          r = !1;
        else return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent) if (r == this) return n;
  }
  posFromDOM(e, n, r) {
    for (let o = e; o; o = o.parentNode) {
      let i = this.getDesc(o);
      if (i) return i.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let o = this.children[n],
        i = r + o.size;
      if (r == e && i != r) {
        for (; !o.border && o.children.length; ) o = o.children[0];
        return o;
      }
      if (e < i) return o.descAt(e - r - o.border);
      r = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0,
      o = 0;
    for (let i = 0; r < this.children.length; r++) {
      let s = this.children[r],
        a = i + s.size;
      if (a > e || s instanceof mv) {
        o = e - i;
        break;
      }
      i = a;
    }
    if (o) return this.children[r].domFromPos(o - this.children[r].border, n);
    for (
      let i;
      r && !(i = this.children[r - 1]).size && i instanceof hv && i.side >= 0;
      r--
    );
    if (n <= 0) {
      let i,
        s = !0;
      for (
        ;
        (i = r ? this.children[r - 1] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r--, s = !1
      );
      return i && n && s && !i.border && !i.domAtom
        ? i.domFromPos(i.size, n)
        : { node: this.contentDOM, offset: i ? xt(i.dom) + 1 : 0 };
    } else {
      let i,
        s = !0;
      for (
        ;
        (i = r < this.children.length ? this.children[r] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r++, s = !1
      );
      return i && s && !i.border && !i.domAtom
        ? i.domFromPos(0, n)
        : {
            node: this.contentDOM,
            offset: i ? xt(i.dom) : this.contentDOM.childNodes.length,
          };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return {
        node: this.contentDOM,
        from: e,
        to: n,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length,
      };
    let o = -1,
      i = -1;
    for (let s = r, a = 0; ; a++) {
      let l = this.children[a],
        u = s + l.size;
      if (o == -1 && e <= u) {
        let c = s + l.border;
        if (
          e >= c &&
          n <= u - l.border &&
          l.node &&
          l.contentDOM &&
          this.contentDOM.contains(l.contentDOM)
        )
          return l.parseRange(e, n, c);
        e = s;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (
            f.size &&
            f.dom.parentNode == this.contentDOM &&
            !f.emptyChildAt(1)
          ) {
            o = xt(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        o == -1 && (o = 0);
      }
      if (o > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let c = a + 1; c < this.children.length; c++) {
          let d = this.children[c];
          if (
            d.size &&
            d.dom.parentNode == this.contentDOM &&
            !d.emptyChildAt(-1)
          ) {
            i = xt(d.dom);
            break;
          }
          n += d.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return {
      node: this.contentDOM,
      from: e,
      to: n,
      fromOffset: o,
      toOffset: i,
    };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length) return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, o = !1) {
    let i = Math.min(e, n),
      s = Math.max(e, n);
    for (let p = 0, h = 0; p < this.children.length; p++) {
      let m = this.children[p],
        g = h + m.size;
      if (i > h && s < g)
        return m.setSelection(e - h - m.border, n - h - m.border, r, o);
      h = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1),
      l = n == e ? a : this.domFromPos(n, n ? -1 : 1),
      u = r.root.getSelection(),
      c = r.domSelectionRange(),
      d = !1;
    if ((Jn || Bt) && e == n) {
      let { node: p, offset: h } = a;
      if (p.nodeType == 3) {
        if (
          ((d = !!(
            h &&
            p.nodeValue[h - 1] ==
              `
`
          )),
          d && h == p.nodeValue.length)
        )
          for (let m = p, g; m; m = m.parentNode) {
            if ((g = m.nextSibling)) {
              g.nodeName == "BR" &&
                (a = l = { node: g.parentNode, offset: xt(g) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock) break;
          }
      } else {
        let m = p.childNodes[h - 1];
        d = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (
      Jn &&
      c.focusNode &&
      c.focusNode != l.node &&
      c.focusNode.nodeType == 1
    ) {
      let p = c.focusNode.childNodes[c.focusOffset];
      p && p.contentEditable == "false" && (o = !0);
    }
    if (
      !(o || (d && Bt)) &&
      ai(a.node, a.offset, c.anchorNode, c.anchorOffset) &&
      ai(l.node, l.offset, c.focusNode, c.focusOffset)
    )
      return;
    let f = !1;
    if ((u.extend || e == n) && !d) {
      u.collapse(a.node, a.offset);
      try {
        e != n && u.extend(l.node, l.offset), (f = !0);
      } catch {}
    }
    if (!f) {
      if (e > n) {
        let h = a;
        (a = l), (l = h);
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset),
        p.setStart(a.node, a.offset),
        u.removeAllRanges(),
        u.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      !this.dom.contains(this.contentDOM)
    );
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let i = this.children[o],
        s = r + i.size;
      if (r == s ? e <= s && n >= r : e < s && n > r) {
        let a = r + i.border,
          l = s - i.border;
        if (e >= a && n <= l) {
          (this.dirty = e == r || n == s ? Wo : y1),
            e == a &&
            n == l &&
            (i.contentLost || i.dom.parentNode != this.contentDOM)
              ? (i.dirty = yr)
              : i.markDirty(e - a, n - a);
          return;
        } else
          i.dirty =
            i.dom == i.contentDOM &&
            i.dom.parentNode == this.contentDOM &&
            !i.children.length
              ? Wo
              : yr;
      }
      r = s;
    }
    this.dirty = Wo;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Wo : y1;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class hv extends Ta {
  constructor(e, n, r, o) {
    let i,
      s = n.type.toDOM;
    if (
      (typeof s == "function" &&
        (s = s(r, () => {
          if (!i) return o;
          if (i.parent) return i.parent.posBeforeChild(i);
        })),
      !n.type.spec.raw)
    ) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), (s = a);
      }
      (s.contentEditable = "false"), s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), (this.widget = n), (this.widget = n), (i = this);
  }
  matchesWidget(e) {
    return this.dirty == An && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class a6 extends Ta {
  constructor(e, n, r, o) {
    super(e, [], n, null), (this.textDOM = r), (this.text = o);
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM
      ? this.posAtStart + (n ? this.size : 0)
      : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class li extends Ta {
  constructor(e, n, r, o, i) {
    super(e, [], r, o), (this.mark = n), (this.spec = i);
  }
  static create(e, n, r, o) {
    let i = o.nodeViews[n.type.name],
      s = i && i(n, o, r);
    return (
      (!s || !s.dom) &&
        (s = hi.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
      new li(e, n, s.dom, s.contentDOM || s.dom, s)
    );
  }
  parseRule() {
    return this.dirty & yr || this.mark.type.spec.reparseInView
      ? null
      : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM,
        };
  }
  matchesMark(e) {
    return this.dirty != yr && this.mark.eq(e);
  }
  markDirty(e, n) {
    if ((super.markDirty(e, n), this.dirty != An)) {
      let r = this.parent;
      for (; !r.node; ) r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = An);
    }
  }
  slice(e, n, r) {
    let o = li.create(this.parent, this.mark, !0, r),
      i = this.children,
      s = this.size;
    n < s && (i = bp(i, n, s, r)), e > 0 && (i = bp(i, 0, e, r));
    for (let a = 0; a < i.length; a++) i[a].parent = o;
    return (o.children = i), o;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class xo extends Ta {
  constructor(e, n, r, o, i, s, a, l, u) {
    super(e, [], i, s),
      (this.node = n),
      (this.outerDeco = r),
      (this.innerDeco = o),
      (this.nodeDOM = a);
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, o, i, s) {
    let a = i.nodeViews[n.type.name],
      l,
      u =
        a &&
        a(
          n,
          i,
          () => {
            if (!l) return s;
            if (l.parent) return l.parent.posBeforeChild(l);
          },
          r,
          o
        ),
      c = u && u.dom,
      d = u && u.contentDOM;
    if (n.isText) {
      if (!c) c = document.createTextNode(n.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      c ||
        ({ dom: c, contentDOM: d } = hi.renderSpec(
          document,
          n.type.spec.toDOM(n),
          null,
          n.attrs
        ));
    !d &&
      !n.isText &&
      c.nodeName != "BR" &&
      (c.hasAttribute("contenteditable") || (c.contentEditable = "false"),
      n.type.spec.draggable && (c.draggable = !0));
    let f = c;
    return (
      (c = yv(c, r, n)),
      u
        ? (l = new l6(e, n, r, o, c, d || null, f, u, i, s + 1))
        : n.isText
        ? new Yc(e, n, r, o, c, f, i)
        : new xo(e, n, r, o, c, d || null, f, i, s + 1)
    );
  }
  parseRule() {
    if (this.node.type.spec.reparseInView) return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (
      (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
      !this.contentDOM)
    )
      e.getContent = () => this.node.content;
    else if (!this.contentLost) e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => $.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return (
      this.dirty == An &&
      e.eq(this.node) &&
      gu(n, this.outerDeco) &&
      r.eq(this.innerDeco)
    );
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent,
      o = n,
      i = e.composing ? this.localCompositionInfo(e, n) : null,
      s = i && i.pos > -1 ? i : null,
      a = i && i.pos < 0,
      l = new c6(this, s && s.node, e);
    p6(
      this.node,
      this.innerDeco,
      (u, c, d) => {
        u.spec.marks
          ? l.syncToMarks(u.spec.marks, r, e)
          : u.type.side >= 0 &&
            !d &&
            l.syncToMarks(
              c == this.node.childCount ? Oe.none : this.node.child(c).marks,
              r,
              e
            ),
          l.placeWidget(u, e, o);
      },
      (u, c, d, f) => {
        l.syncToMarks(u.marks, r, e);
        let p;
        l.findNodeMatch(u, c, d, f) ||
          (a &&
            e.state.selection.from > o &&
            e.state.selection.to < o + u.nodeSize &&
            (p = l.findIndexWithChild(i.node)) > -1 &&
            l.updateNodeAt(u, c, d, p, e)) ||
          l.updateNextNode(u, c, d, e, f, o) ||
          l.addNode(u, c, d, e, o),
          (o += u.nodeSize);
      }
    ),
      l.syncToMarks([], r, e),
      this.node.isTextblock && l.addTextblockHacks(),
      l.destroyRest(),
      (l.changed || this.dirty == Wo) &&
        (s && this.protectLocalComposition(e, s),
        gv(this.contentDOM, this.children, e),
        qi && h6(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: o } = e.state.selection;
    if (
      !(e.state.selection instanceof q) ||
      r < n ||
      o > n + this.node.content.size
    )
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode)) return null;
    if (this.node.inlineContent) {
      let s = i.nodeValue,
        a = m6(this.node.content, s, r - n, o - n);
      return a < 0 ? null : { node: i, pos: a, text: s };
    } else return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: o }) {
    if (this.getDesc(n)) return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; ) i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let s = new a6(this, i, n, o);
    e.input.compositionNodes.push(s),
      (this.children = bp(this.children, r, r + o.length, e, s));
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, o) {
    return this.dirty == yr || !e.sameMarkup(this.node)
      ? !1
      : (this.updateInner(e, n, r, o), !0);
  }
  updateInner(e, n, r, o) {
    this.updateOuterDeco(n),
      (this.node = e),
      (this.innerDeco = r),
      this.contentDOM && this.updateChildren(o, this.posAtStart),
      (this.dirty = An);
  }
  updateOuterDeco(e) {
    if (gu(e, this.outerDeco)) return;
    let n = this.nodeDOM.nodeType != 1,
      r = this.dom;
    (this.dom = bv(
      this.dom,
      this.nodeDOM,
      gp(this.outerDeco, this.node, n),
      gp(e, this.node, n)
    )),
      this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
      (this.outerDeco = e);
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 &&
      this.nodeDOM.classList.add("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 &&
      (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function v1(t, e, n, r, o) {
  yv(r, e, t);
  let i = new xo(void 0, t, e, n, r, r, r, o, 0);
  return i.contentDOM && i.updateChildren(o, 0), i;
}
class Yc extends xo {
  constructor(e, n, r, o, i, s, a) {
    super(e, n, r, o, i, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, o) {
    return this.dirty == yr ||
      (this.dirty != An && !this.inParent()) ||
      !e.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(n),
        (this.dirty != An || e.text != this.node.text) &&
          e.text != this.nodeDOM.nodeValue &&
          ((this.nodeDOM.nodeValue = e.text),
          o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
        (this.node = e),
        (this.dirty = An),
        !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM
      ? this.posAtStart + Math.min(n, this.node.text.length)
      : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let o = this.node.cut(e, n),
      i = document.createTextNode(o.text);
    return new Yc(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n),
      this.dom != this.nodeDOM &&
        (e == 0 || n == this.nodeDOM.nodeValue.length) &&
        (this.dirty = yr);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class mv extends Ta {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == An && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class l6 extends xo {
  constructor(e, n, r, o, i, s, a, l, u, c) {
    super(e, n, r, o, i, s, a, u, c), (this.spec = l);
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, o) {
    if (this.dirty == yr) return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, r);
      return i && this.updateInner(e, n, r, o), i;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, o) {
    this.spec.setSelection
      ? this.spec.setSelection(e, n, r.root)
      : super.setSelection(e, n, r, o);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e);
  }
}
function gv(t, e, n) {
  let r = t.firstChild,
    o = !1;
  for (let i = 0; i < e.length; i++) {
    let s = e[i],
      a = s.dom;
    if (a.parentNode == t) {
      for (; a != r; ) (r = _1(r)), (o = !0);
      r = r.nextSibling;
    } else (o = !0), t.insertBefore(a, r);
    if (s instanceof li) {
      let l = r ? r.previousSibling : t.lastChild;
      gv(s.contentDOM, s.children, n), (r = l ? l.nextSibling : t.firstChild);
    }
  }
  for (; r; ) (r = _1(r)), (o = !0);
  o && n.trackWrites == t && (n.trackWrites = null);
}
const Ts = function (t) {
  t && (this.nodeName = t);
};
Ts.prototype = /* @__PURE__ */ Object.create(null);
const qo = [new Ts()];
function gp(t, e, n) {
  if (t.length == 0) return qo;
  let r = n ? qo[0] : new Ts(),
    o = [r];
  for (let i = 0; i < t.length; i++) {
    let s = t[i].type.attrs;
    if (s) {
      s.nodeName && o.push((r = new Ts(s.nodeName)));
      for (let a in s) {
        let l = s[a];
        l != null &&
          (n &&
            o.length == 1 &&
            o.push((r = new Ts(e.isInline ? "span" : "div"))),
          a == "class"
            ? (r.class = (r.class ? r.class + " " : "") + l)
            : a == "style"
            ? (r.style = (r.style ? r.style + ";" : "") + l)
            : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return o;
}
function bv(t, e, n, r) {
  if (n == qo && r == qo) return e;
  let o = e;
  for (let i = 0; i < r.length; i++) {
    let s = r[i],
      a = n[i];
    if (i) {
      let l;
      (a &&
        a.nodeName == s.nodeName &&
        o != t &&
        (l = o.parentNode) &&
        l.nodeName.toLowerCase() == s.nodeName) ||
        ((l = document.createElement(s.nodeName)),
        (l.pmIsDeco = !0),
        l.appendChild(o),
        (a = qo[0])),
        (o = l);
    }
    u6(o, a || qo[0], s);
  }
  return o;
}
function u6(t, e, n) {
  for (let r in e)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      !(r in n) &&
      t.removeAttribute(r);
  for (let r in n)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      n[r] != e[r] &&
      t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [],
      o = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r =
          /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        o;
      for (; (o = r.exec(e.style)); ) t.style.removeProperty(o[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function yv(t, e, n) {
  return bv(t, t, qo, gp(e, n, t.nodeType != 1));
}
function gu(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
  return !0;
}
function _1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class c6 {
  constructor(e, n, r) {
    (this.lock = n),
      (this.view = r),
      (this.index = 0),
      (this.stack = []),
      (this.changed = !1),
      (this.top = e),
      (this.preMatch = d6(e.node.content, e));
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++) this.top.children[r].destroy();
      this.top.children.splice(e, n - e), (this.changed = !0);
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let o = 0,
      i = this.stack.length >> 1,
      s = Math.min(i, e.length);
    for (
      ;
      o < s &&
      (o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(e[o]) &&
      e[o].type.spec.spanning !== !1;

    )
      o++;
    for (; o < i; )
      this.destroyRest(),
        (this.top.dirty = An),
        (this.index = this.stack.pop()),
        (this.top = this.stack.pop()),
        i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (
        let l = this.index;
        l < Math.min(this.index + 3, this.top.children.length);
        l++
      ) {
        let u = this.top.children[l];
        if (u.matchesMark(e[i]) && !this.isLocked(u.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index &&
          ((this.changed = !0), this.destroyBetween(this.index, a)),
          (this.top = this.top.children[this.index]);
      else {
        let l = li.create(this.top, e[i], n, r);
        this.top.children.splice(this.index, 0, l),
          (this.top = l),
          (this.changed = !0);
      }
      (this.index = 0), i++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, o) {
    let i = -1,
      s;
    if (
      o >= this.preMatch.index &&
      (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top &&
      s.matchesNode(e, n, r)
    )
      i = this.top.children.indexOf(s, this.index);
    else
      for (
        let a = this.index, l = Math.min(this.top.children.length, a + 5);
        a < l;
        a++
      ) {
        let u = this.top.children[a];
        if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
          i = a;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, r, o, i) {
    let s = this.top.children[o];
    return (
      s.dirty == yr && s.dom == s.contentDOM && (s.dirty = Wo),
      s.update(e, n, r, i)
        ? (this.destroyBetween(this.index, o), this.index++, !0)
        : !1
    );
  }
  findIndexWithChild(e) {
    for (;;) {
      let n = e.parentNode;
      if (!n) return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r) return o;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, o, i, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof xo) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != i) return !1;
        let c = l.dom,
          d,
          f =
            this.isLocked(c) &&
            !(
              e.isText &&
              l.node &&
              l.node.isText &&
              l.nodeDOM.nodeValue == e.text &&
              l.dirty != yr &&
              gu(n, l.outerDeco)
            );
        if (!f && l.update(e, n, r, o))
          return (
            this.destroyBetween(this.index, a),
            l.dom != c && (this.changed = !0),
            this.index++,
            !0
          );
        if (!f && (d = this.recreateWrapper(l, e, n, r, o, s)))
          return (
            this.destroyBetween(this.index, a),
            (this.top.children[this.index] = d),
            d.contentDOM &&
              ((d.dirty = Wo), d.updateChildren(o, s + 1), (d.dirty = An)),
            (this.changed = !0),
            this.index++,
            !0
          );
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, o, i, s) {
    if (
      e.dirty ||
      n.isAtom ||
      !e.children.length ||
      !e.node.content.eq(n.content) ||
      !gu(r, e.outerDeco) ||
      !o.eq(e.innerDeco)
    )
      return null;
    let a = xo.create(this.top, n, r, o, i, s);
    if (a.contentDOM) {
      (a.children = e.children), (e.children = []);
      for (let l of a.children) l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, o, i) {
    let s = xo.create(this.top, e, n, r, o, i);
    s.contentDOM && s.updateChildren(o, i + 1),
      this.top.children.splice(this.index++, 0, s),
      (this.changed = !0);
  }
  placeWidget(e, n, r) {
    let o =
      this.index < this.top.children.length
        ? this.top.children[this.index]
        : null;
    if (
      o &&
      o.matchesWidget(e) &&
      (e == o.widget || !o.widget.type.toDOM.parentNode)
    )
      this.index++;
    else {
      let i = new hv(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, i), (this.changed = !0);
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1],
      n = this.top;
    for (; e instanceof li; ) (n = e), (e = n.children[n.children.length - 1]);
    (!e || // Empty textblock
      !(e instanceof Yc) ||
      /\n$/.test(e.node.text) ||
      (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
      ((Bt || Mt) &&
        e &&
        e.dom.contentEditable == "false" &&
        this.addHackNode("IMG", n),
      this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (
      n == this.top &&
      this.index < n.children.length &&
      n.children[this.index].matchesHack(e)
    )
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && ((r.className = "ProseMirror-separator"), (r.alt = "")),
        e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let o = new mv(this.top, [], r, null);
      n != this.top
        ? n.children.push(o)
        : n.children.splice(this.index++, 0, o),
        (this.changed = !0);
    }
  }
  isLocked(e) {
    return (
      this.lock &&
      (e == this.lock || (e.nodeType == 1 && e.contains(this.lock.parentNode)))
    );
  }
}
function d6(t, e) {
  let n = e,
    r = n.children.length,
    o = t.childCount,
    i = /* @__PURE__ */ new Map(),
    s = [];
  e: for (; o > 0; ) {
    let a;
    for (;;)
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof li) (n = u), (r = u.children.length);
        else {
          (a = u), r--;
          break;
        }
      } else {
        if (n == e) break e;
        (r = n.parent.children.indexOf(n)), (n = n.parent);
      }
    let l = a.node;
    if (l) {
      if (l != t.child(o - 1)) break;
      --o, i.set(a, o), s.push(a);
    }
  }
  return { index: o, matched: i, matches: s.reverse() };
}
function f6(t, e) {
  return t.type.side - e.type.side;
}
function p6(t, e, n, r) {
  let o = e.locals(t),
    i = 0;
  if (o.length == 0) {
    for (let u = 0; u < t.childCount; u++) {
      let c = t.child(u);
      r(c, o, e.forChild(i, c), u), (i += c.nodeSize);
    }
    return;
  }
  let s = 0,
    a = [],
    l = null;
  for (let u = 0; ; ) {
    let c, d;
    for (; s < o.length && o[s].to == i; ) {
      let g = o[s++];
      g.widget && (c ? (d || (d = [c])).push(g) : (c = g));
    }
    if (c)
      if (d) {
        d.sort(f6);
        for (let g = 0; g < d.length; g++) n(d[g], u, !!l);
      } else n(c, u, !!l);
    let f, p;
    if (l) (p = -1), (f = l), (l = null);
    else if (u < t.childCount) (p = u), (f = t.child(u++));
    else break;
    for (let g = 0; g < a.length; g++) a[g].to <= i && a.splice(g--, 1);
    for (; s < o.length && o[s].from <= i && o[s].to > i; ) a.push(o[s++]);
    let h = i + f.nodeSize;
    if (f.isText) {
      let g = h;
      s < o.length && o[s].from < g && (g = o[s].from);
      for (let b = 0; b < a.length; b++) a[b].to < g && (g = a[b].to);
      g < h && ((l = f.cut(g - i)), (f = f.cut(0, g - i)), (h = g), (p = -1));
    } else for (; s < o.length && o[s].to < h; ) s++;
    let m = f.isInline && !f.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    r(f, m, e.forChild(i, f), p), (i = h);
  }
}
function h6(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    (t.style.cssText = e + "; list-style: square !important"),
      window.getComputedStyle(t).listStyle,
      (t.style.cssText = e);
  }
}
function m6(t, e, n, r) {
  for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
    let s = t.child(o++),
      a = i;
    if (((i += s.nodeSize), !s.isText)) continue;
    let l = s.text;
    for (; o < t.childCount; ) {
      let u = t.child(o++);
      if (((i += u.nodeSize), !u.isText)) break;
      l += u.text;
    }
    if (i >= n) {
      if (i >= r && l.slice(r - e.length - a, r - a) == e) return r - e.length;
      let u = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (u >= 0 && u + e.length + a >= n) return a + u;
      if (
        n == r &&
        l.length >= r + e.length - a &&
        l.slice(r - a, r - a + e.length) == e
      )
        return r;
    }
  }
  return -1;
}
function bp(t, e, n, r, o) {
  let i = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s],
      u = a,
      c = (a += l.size);
    u >= n || c <= e
      ? i.push(l)
      : (u < e && i.push(l.slice(0, e - u, r)),
        o && (i.push(o), (o = void 0)),
        c > n && i.push(l.slice(n - u, l.size, r)));
  }
  return i;
}
function Fh(t, e = null) {
  let n = t.domSelectionRange(),
    r = t.state.doc;
  if (!n.focusNode) return null;
  let o = t.docView.nearestDesc(n.focusNode),
    i = o && o.size == 0,
    s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0) return null;
  let a = r.resolve(s),
    l,
    u;
  if (Jc(n)) {
    for (l = s; o && !o.node; ) o = o.parent;
    let d = o.node;
    if (
      o &&
      d.isAtom &&
      Z.isSelectable(d) &&
      o.parent &&
      !(d.isInline && zC(n.focusNode, n.focusOffset, o.dom))
    ) {
      let f = o.posBefore;
      u = new Z(s == f ? a : r.resolve(f));
    }
  } else {
    if (
      n instanceof t.dom.ownerDocument.defaultView.Selection &&
      n.rangeCount > 1
    ) {
      let d = s,
        f = s;
      for (let p = 0; p < n.rangeCount; p++) {
        let h = n.getRangeAt(p);
        (d = Math.min(
          d,
          t.docView.posFromDOM(h.startContainer, h.startOffset, 1)
        )),
          (f = Math.max(
            f,
            t.docView.posFromDOM(h.endContainer, h.endOffset, -1)
          ));
      }
      if (d < 0) return null;
      ([l, s] = f == t.state.selection.anchor ? [f, d] : [d, f]),
        (a = r.resolve(s));
    } else l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0) return null;
  }
  let c = r.resolve(l);
  if (!u) {
    let d = e == "pointer" || (t.state.selection.head < a.pos && !i) ? 1 : -1;
    u = zh(t, c, a, d);
  }
  return u;
}
function vv(t) {
  return t.editable
    ? t.hasFocus()
    : xv(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Vr(t, e = !1) {
  let n = t.state.selection;
  if ((_v(t, n), !!vv(t))) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Mt) {
      let r = t.domSelectionRange(),
        o = t.domObserver.currentSelection;
      if (
        r.anchorNode &&
        o.anchorNode &&
        ai(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
      ) {
        (t.input.mouseDown.delayedSelectionSync = !0),
          t.domObserver.setCurSelection();
        return;
      }
    }
    if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) b6(t);
    else {
      let { anchor: r, head: o } = n,
        i,
        s;
      x1 &&
        !(n instanceof q) &&
        (n.$from.parent.inlineContent || (i = k1(t, n.from)),
        !n.empty && !n.$from.parent.inlineContent && (s = k1(t, n.to))),
        t.docView.setSelection(r, o, t, e),
        x1 && (i && w1(i), s && w1(s)),
        n.visible
          ? t.dom.classList.remove("ProseMirror-hideselection")
          : (t.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange" in document && g6(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const x1 = Bt || (Mt && av < 63);
function k1(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0),
    o = r < n.childNodes.length ? n.childNodes[r] : null,
    i = r ? n.childNodes[r - 1] : null;
  if (Bt && o && o.contentEditable == "false") return Wd(o);
  if (
    (!o || o.contentEditable == "false") &&
    (!i || i.contentEditable == "false")
  ) {
    if (o) return Wd(o);
    if (i) return Wd(i);
  }
}
function Wd(t) {
  return (
    (t.contentEditable = "true"),
    Bt && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
    t
  );
}
function w1(t) {
  (t.contentEditable = "false"),
    t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function g6(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(),
    r = n.anchorNode,
    o = n.anchorOffset;
  e.addEventListener(
    "selectionchange",
    (t.input.hideSelectionGuard = () => {
      (n.anchorNode != r || n.anchorOffset != o) &&
        (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
        setTimeout(() => {
          (!vv(t) || t.state.selection.visible) &&
            t.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
    })
  );
}
function b6(t) {
  let e = t.domSelection(),
    n = document.createRange();
  if (!e) return;
  let r = t.cursorWrapper.dom,
    o = r.nodeName == "IMG";
  o ? n.setStart(r.parentNode, xt(r) + 1) : n.setStart(r, 0),
    n.collapse(!0),
    e.removeAllRanges(),
    e.addRange(n),
    !o &&
      !t.state.selection.visible &&
      Gt &&
      _o <= 11 &&
      ((r.disabled = !0), (r.disabled = !1));
}
function _v(t, e) {
  if (e instanceof Z) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc &&
      (C1(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
  } else C1(t);
}
function C1(t) {
  t.lastSelectedViewDesc &&
    (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
    (t.lastSelectedViewDesc = void 0));
}
function zh(t, e, n, r) {
  return (
    t.someProp("createSelectionBetween", (o) => o(t, e, n)) ||
    q.between(e, n, r)
  );
}
function A1(t) {
  return t.editable && !t.hasFocus() ? !1 : xv(t);
}
function xv(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode) return !1;
  try {
    return (
      t.dom.contains(
        e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode
      ) &&
      (t.editable ||
        t.dom.contains(
          e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode
        ))
    );
  } catch {
    return !1;
  }
}
function y6(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0),
    n = t.domSelectionRange();
  return ai(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function yp(t, e) {
  let { $anchor: n, $head: r } = t.selection,
    o = e > 0 ? n.max(r) : n.min(r),
    i = o.parent.inlineContent
      ? o.depth
        ? t.doc.resolve(e > 0 ? o.after() : o.before())
        : null
      : o;
  return i && ee.findFrom(i, e);
}
function no(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function S1(t, e, n) {
  let r = t.state.selection;
  if (r instanceof q)
    if (n.indexOf("s") > -1) {
      let { $head: o } = r,
        i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!i || i.isText || !i.isLeaf) return !1;
      let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return no(t, new q(r.$anchor, s));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = yp(t.state, e);
        return o && o instanceof Z ? no(t, o) : !1;
      } else if (!(_n && n.indexOf("m") > -1)) {
        let o = r.$head,
          i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter,
          s;
        if (!i || i.isText) return !1;
        let a = e < 0 ? o.pos - i.nodeSize : o.pos;
        return i.isAtom || ((s = t.docView.descAt(a)) && !s.contentDOM)
          ? Z.isSelectable(i)
            ? no(t, new Z(e < 0 ? t.state.doc.resolve(o.pos - i.nodeSize) : o))
            : Ma
            ? no(t, new q(t.state.doc.resolve(e < 0 ? a : a + i.nodeSize)))
            : !1
          : !1;
      }
    } else return !1;
  else {
    if (r instanceof Z && r.node.isInline)
      return no(t, new q(e > 0 ? r.$to : r.$from));
    {
      let o = yp(t.state, e);
      return o ? no(t, o) : !1;
    }
  }
}
function bu(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Os(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function ki(t, e) {
  return e < 0 ? v6(t) : _6(t);
}
function v6(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset;
  if (!n) return;
  let o,
    i,
    s = !1;
  for (
    Jn && n.nodeType == 1 && r < bu(n) && Os(n.childNodes[r], -1) && (s = !0);
    ;

  )
    if (r > 0) {
      if (n.nodeType != 1) break;
      {
        let a = n.childNodes[r - 1];
        if (Os(a, -1)) (o = n), (i = --r);
        else if (a.nodeType == 3) (n = a), (r = n.nodeValue.length);
        else break;
      }
    } else {
      if (kv(n)) break;
      {
        let a = n.previousSibling;
        for (; a && Os(a, -1); )
          (o = n.parentNode), (i = xt(a)), (a = a.previousSibling);
        if (a) (n = a), (r = bu(n));
        else {
          if (((n = n.parentNode), n == t.dom)) break;
          r = 0;
        }
      }
    }
  s ? vp(t, n, r) : o && vp(t, o, i);
}
function _6(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset;
  if (!n) return;
  let o = bu(n),
    i,
    s;
  for (;;)
    if (r < o) {
      if (n.nodeType != 1) break;
      let a = n.childNodes[r];
      if (Os(a, 1)) (i = n), (s = ++r);
      else break;
    } else {
      if (kv(n)) break;
      {
        let a = n.nextSibling;
        for (; a && Os(a, 1); )
          (i = a.parentNode), (s = xt(a) + 1), (a = a.nextSibling);
        if (a) (n = a), (r = 0), (o = bu(n));
        else {
          if (((n = n.parentNode), n == t.dom)) break;
          r = o = 0;
        }
      }
    }
  i && vp(t, i, s);
}
function kv(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function x6(t, e) {
  for (; t && e == t.childNodes.length && !Ea(t); )
    (e = xt(t) + 1), (t = t.parentNode);
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3) return n;
    if (n.nodeType == 1 && n.contentEditable == "false") break;
    (t = n), (e = 0);
  }
}
function k6(t, e) {
  for (; t && !e && !Ea(t); ) (e = xt(t)), (t = t.parentNode);
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3) return n;
    if (n.nodeType == 1 && n.contentEditable == "false") break;
    (t = n), (e = t.childNodes.length);
  }
}
function vp(t, e, n) {
  if (e.nodeType != 3) {
    let i, s;
    (s = x6(e, n))
      ? ((e = s), (n = 0))
      : (i = k6(e, n)) && ((e = i), (n = i.nodeValue.length));
  }
  let r = t.domSelection();
  if (!r) return;
  if (Jc(r)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: o } = t;
  setTimeout(() => {
    t.state == o && Vr(t);
  }, 50);
}
function E1(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Mt || jC) && n.parent.inlineContent) {
    let o = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1),
        s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left < o.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1),
        s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function M1(t, e, n) {
  let r = t.state.selection;
  if (
    (r instanceof q && !r.empty) ||
    n.indexOf("s") > -1 ||
    (_n && n.indexOf("m") > -1)
  )
    return !1;
  let { $from: o, $to: i } = r;
  if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = yp(t.state, e);
    if (s && s instanceof Z) return no(t, s);
  }
  if (!o.parent.inlineContent) {
    let s = e < 0 ? o : i,
      a = r instanceof $t ? ee.near(s, e) : ee.findFrom(s, e);
    return a ? no(t, a) : !1;
  }
  return !1;
}
function T1(t, e) {
  if (!(t.state.selection instanceof q)) return !0;
  let { $head: n, $anchor: r, empty: o } = t.state.selection;
  if (!n.sameParent(r)) return !0;
  if (!o) return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let s = t.state.tr;
    return (
      e < 0
        ? s.delete(n.pos - i.nodeSize, n.pos)
        : s.delete(n.pos, n.pos + i.nodeSize),
      t.dispatch(s),
      !0
    );
  }
  return !1;
}
function O1(t, e, n) {
  t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function w6(t) {
  if (!Bt || t.state.selection.$head.parentOffset > 0) return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (
    e &&
    e.nodeType == 1 &&
    n == 0 &&
    e.firstChild &&
    e.firstChild.contentEditable == "false"
  ) {
    let r = e.firstChild;
    O1(t, r, "true"), setTimeout(() => O1(t, r, "false"), 20);
  }
  return !1;
}
function C6(t) {
  let e = "";
  return (
    t.ctrlKey && (e += "c"),
    t.metaKey && (e += "m"),
    t.altKey && (e += "a"),
    t.shiftKey && (e += "s"),
    e
  );
}
function A6(t, e) {
  let n = e.keyCode,
    r = C6(e);
  if (n == 8 || (_n && n == 72 && r == "c")) return T1(t, -1) || ki(t, -1);
  if ((n == 46 && !e.shiftKey) || (_n && n == 68 && r == "c"))
    return T1(t, 1) || ki(t, 1);
  if (n == 13 || n == 27) return !0;
  if (n == 37 || (_n && n == 66 && r == "c")) {
    let o = n == 37 ? (E1(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
    return S1(t, o, r) || ki(t, o);
  } else if (n == 39 || (_n && n == 70 && r == "c")) {
    let o = n == 39 ? (E1(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
    return S1(t, o, r) || ki(t, o);
  } else {
    if (n == 38 || (_n && n == 80 && r == "c"))
      return M1(t, -1, r) || ki(t, -1);
    if (n == 40 || (_n && n == 78 && r == "c"))
      return w6(t) || M1(t, 1, r) || ki(t, 1);
    if (r == (_n ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function Vh(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let n = [],
    { content: r, openStart: o, openEnd: i } = e;
  for (
    ;
    o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

  ) {
    o--, i--;
    let p = r.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null),
      (r = p.content);
  }
  let s = t.someProp("clipboardSerializer") || hi.fromSchema(t.state.schema),
    a = Ev(),
    l = a.createElement("div");
  l.appendChild(s.serializeFragment(r, { document: a }));
  let u = l.firstChild,
    c,
    d = 0;
  for (; u && u.nodeType == 1 && (c = Sv[u.nodeName.toLowerCase()]); ) {
    for (let p = c.length - 1; p >= 0; p--) {
      let h = a.createElement(c[p]);
      for (; l.firstChild; ) h.appendChild(l.firstChild);
      l.appendChild(h), d++;
    }
    u = l.firstChild;
  }
  u &&
    u.nodeType == 1 &&
    u.setAttribute(
      "data-pm-slice",
      `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`
    );
  let f =
    t.someProp("clipboardTextSerializer", (p) => p(e, t)) ||
    e.content.textBetween(
      0,
      e.content.size,
      `

`
    );
  return { dom: l, text: f, slice: e };
}
function Uh(t, e, n, r, o) {
  let i = o.parent.type.spec.code,
    s,
    a;
  if (!n && !e) return null;
  let l = e && (r || i || !n);
  if (l) {
    if (
      (t.someProp("transformPastedText", (f) => {
        e = f(e, i || r, t);
      }),
      i)
    )
      return e
        ? new W(
            $.from(
              t.state.schema.text(
                e.replace(
                  /\r\n?/g,
                  `
`
                )
              )
            ),
            0,
            0
          )
        : W.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, o, r, t));
    if (d) a = d;
    else {
      let f = o.marks(),
        { schema: p } = t.state,
        h = hi.fromSchema(p);
      (s = document.createElement("div")),
        e.split(/(?:\r\n?|\n)+/).forEach((m) => {
          let g = s.appendChild(document.createElement("p"));
          m && g.appendChild(h.serializeNode(p.text(m, f)));
        });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }),
      (s = T6(n)),
      Ma && O6(s);
  let u = s && s.querySelector("[data-pm-slice]"),
    c =
      u &&
      /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
        u.getAttribute("data-pm-slice") || ""
      );
  if (c && c[3])
    for (let d = +c[3]; d > 0; d--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; ) f = f.nextSibling;
      if (!f) break;
      s = f;
    }
  if (
    (a ||
      (a = (
        t.someProp("clipboardParser") ||
        t.someProp("domParser") ||
        zr.fromSchema(t.state.schema)
      ).parseSlice(s, {
        preserveWhitespace: !!(l || c),
        context: o,
        ruleFromNode(f) {
          return f.nodeName == "BR" &&
            !f.nextSibling &&
            f.parentNode &&
            !S6.test(f.parentNode.nodeName)
            ? { ignore: !0 }
            : null;
        },
      })),
    c)
  )
    a = D6(D1(a, +c[1], +c[2]), c[4]);
  else if (((a = W.maxOpen(E6(a.content, o), !0)), a.openStart || a.openEnd)) {
    let d = 0,
      f = 0;
    for (
      let p = a.content.firstChild;
      d < a.openStart && !p.type.spec.isolating;
      d++, p = p.firstChild
    );
    for (
      let p = a.content.lastChild;
      f < a.openEnd && !p.type.spec.isolating;
      f++, p = p.lastChild
    );
    a = D1(a, d, f);
  }
  return (
    t.someProp("transformPasted", (d) => {
      a = d(a, t);
    }),
    a
  );
}
const S6 =
  /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function E6(t, e) {
  if (t.childCount < 2) return t;
  for (let n = e.depth; n >= 0; n--) {
    let o = e.node(n).contentMatchAt(e.index(n)),
      i,
      s = [];
    if (
      (t.forEach((a) => {
        if (!s) return;
        let l = o.findWrapping(a.type),
          u;
        if (!l) return (s = null);
        if ((u = s.length && i.length && Cv(l, i, a, s[s.length - 1], 0)))
          s[s.length - 1] = u;
        else {
          s.length && (s[s.length - 1] = Av(s[s.length - 1], i.length));
          let c = wv(a, l);
          s.push(c), (o = o.matchType(c.type)), (i = l);
        }
      }),
      s)
    )
      return $.from(s);
  }
  return t;
}
function wv(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, $.from(t));
  return t;
}
function Cv(t, e, n, r, o) {
  if (o < t.length && o < e.length && t[o] == e[o]) {
    let i = Cv(t, e, n, r.lastChild, o + 1);
    if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i));
    if (
      r
        .contentMatchAt(r.childCount)
        .matchType(o == t.length - 1 ? n.type : t[o + 1])
    )
      return r.copy(r.content.append($.from(wv(n, t, o + 1))));
  }
}
function Av(t, e) {
  if (e == 0) return t;
  let n = t.content.replaceChild(t.childCount - 1, Av(t.lastChild, e - 1)),
    r = t.contentMatchAt(t.childCount).fillBefore($.empty, !0);
  return t.copy(n.append(r));
}
function _p(t, e, n, r, o, i) {
  let s = e < 0 ? t.firstChild : t.lastChild,
    a = s.content;
  return (
    t.childCount > 1 && (i = 0),
    o < r - 1 && (a = _p(a, e, n, r, o + 1, i)),
    o >= n &&
      (a =
        e < 0
          ? s
              .contentMatchAt(0)
              .fillBefore(a, i <= o)
              .append(a)
          : a.append(s.contentMatchAt(s.childCount).fillBefore($.empty, !0))),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a))
  );
}
function D1(t, e, n) {
  return (
    e < t.openStart &&
      (t = new W(
        _p(t.content, -1, e, t.openStart, 0, t.openEnd),
        e,
        t.openEnd
      )),
    n < t.openEnd &&
      (t = new W(_p(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
    t
  );
}
const Sv = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"],
};
let N1 = null;
function Ev() {
  return N1 || (N1 = document.implementation.createHTMLDocument("title"));
}
let qd = null;
function M6(t) {
  let e = window.trustedTypes;
  return e
    ? (qd ||
        (qd = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })),
      qd.createHTML(t))
    : t;
}
function T6(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = Ev().createElement("div"),
    r = /<([a-z][^>\s]+)/i.exec(t),
    o;
  if (
    ((o = r && Sv[r[1].toLowerCase()]) &&
      (t =
        o.map((i) => "<" + i + ">").join("") +
        t +
        o
          .map((i) => "</" + i + ">")
          .reverse()
          .join("")),
    (n.innerHTML = M6(t)),
    o)
  )
    for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n;
  return n;
}
function O6(t) {
  let e = t.querySelectorAll(
    Mt ? "span:not([class]):not([style])" : "span.Apple-converted-space"
  );
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 &&
      r.textContent == "" &&
      r.parentNode &&
      r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function D6(t, e) {
  if (!t.size) return t;
  let n = t.content.firstChild.type.schema,
    r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: o, openStart: i, openEnd: s } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs()) break;
    (o = $.from(l.create(r[a + 1], o))), i++, s++;
  }
  return new W(o, i, s);
}
const Ht = {},
  Ft = {},
  N6 = { touchstart: !0, touchmove: !0 };
class L6 {
  constructor() {
    (this.shiftKey = !1),
      (this.mouseDown = null),
      (this.lastKeyCode = null),
      (this.lastKeyCodeTime = 0),
      (this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastIOSEnter = 0),
      (this.lastIOSEnterFallbackTimeout = -1),
      (this.lastFocus = 0),
      (this.lastTouch = 0),
      (this.lastChromeDelete = 0),
      (this.composing = !1),
      (this.compositionNode = null),
      (this.composingTimeout = -1),
      (this.compositionNodes = []),
      (this.compositionEndedAt = -2e8),
      (this.compositionID = 1),
      (this.compositionPendingChanges = 0),
      (this.domChangeCount = 0),
      (this.eventHandlers = /* @__PURE__ */ Object.create(null)),
      (this.hideSelectionGuard = null);
  }
}
function R6(t) {
  for (let e in Ht) {
    let n = Ht[e];
    t.dom.addEventListener(
      e,
      (t.input.eventHandlers[e] = (r) => {
        P6(t, r) && !jh(t, r) && (t.editable || !(r.type in Ft)) && n(t, r);
      }),
      N6[e] ? { passive: !0 } : void 0
    );
  }
  Bt && t.dom.addEventListener("input", () => null), xp(t);
}
function mo(t, e) {
  (t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function I6(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout),
    clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function xp(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] ||
        t.dom.addEventListener(n, (t.input.eventHandlers[n] = (r) => jh(t, r)));
  });
}
function jh(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function P6(t, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e)))
      return !1;
  return !0;
}
function $6(t, e) {
  !jh(t, e) &&
    Ht[e.type] &&
    (t.editable || !(e.type in Ft)) &&
    Ht[e.type](t, e);
}
Ft.keydown = (t, e) => {
  let n = e;
  if (
    ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
    !Tv(t, n) &&
      ((t.input.lastKeyCode = n.keyCode),
      (t.input.lastKeyCodeTime = Date.now()),
      !(Br && Mt && n.keyCode == 13)))
  )
    if (
      (n.keyCode != 229 && t.domObserver.forceFlush(),
      qi && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
    ) {
      let r = Date.now();
      (t.input.lastIOSEnter = r),
        (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          t.input.lastIOSEnter == r &&
            (t.someProp("handleKeyDown", (o) => o(t, Uo(13, "Enter"))),
            (t.input.lastIOSEnter = 0));
        }, 200));
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || A6(t, n)
        ? n.preventDefault()
        : mo(t, "key");
};
Ft.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Ft.keypress = (t, e) => {
  let n = e;
  if (Tv(t, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (_n && n.metaKey))
    return;
  if (t.someProp("handleKeyPress", (o) => o(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof q) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(o) &&
      !t.someProp("handleTextInput", (i) => i(t, r.$from.pos, r.$to.pos, o)) &&
      t.dispatch(t.state.tr.insertText(o).scrollIntoView()),
      n.preventDefault();
  }
};
function Xc(t) {
  return { left: t.clientX, top: t.clientY };
}
function B6(t, e) {
  let n = e.x - t.clientX,
    r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function Wh(t, e, n, r, o) {
  if (r == -1) return !1;
  let i = t.state.doc.resolve(r);
  for (let s = i.depth + 1; s > 0; s--)
    if (
      t.someProp(e, (a) =>
        s > i.depth
          ? a(t, n, i.nodeAfter, i.before(s), o, !0)
          : a(t, n, i.node(s), i.before(s), o, !1)
      )
    )
      return !0;
  return !1;
}
function Bi(t, e, n) {
  if ((t.focused || t.focus(), t.state.selection.eq(e))) return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function H6(t, e) {
  if (e == -1) return !1;
  let n = t.state.doc.resolve(e),
    r = n.nodeAfter;
  return r && r.isAtom && Z.isSelectable(r) ? (Bi(t, new Z(n)), !0) : !1;
}
function F6(t, e) {
  if (e == -1) return !1;
  let n = t.state.selection,
    r,
    o;
  n instanceof Z && (r = n.node);
  let i = t.state.doc.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s);
    if (Z.isSelectable(a)) {
      r &&
      n.$from.depth > 0 &&
      s >= n.$from.depth &&
      i.before(n.$from.depth + 1) == n.$from.pos
        ? (o = i.before(n.$from.depth))
        : (o = i.before(s));
      break;
    }
  }
  return o != null ? (Bi(t, Z.create(t.state.doc, o)), !0) : !1;
}
function z6(t, e, n, r, o) {
  return (
    Wh(t, "handleClickOn", e, n, r) ||
    t.someProp("handleClick", (i) => i(t, e, r)) ||
    (o ? F6(t, n) : H6(t, n))
  );
}
function V6(t, e, n, r) {
  return (
    Wh(t, "handleDoubleClickOn", e, n, r) ||
    t.someProp("handleDoubleClick", (o) => o(t, e, r))
  );
}
function U6(t, e, n, r) {
  return (
    Wh(t, "handleTripleClickOn", e, n, r) ||
    t.someProp("handleTripleClick", (o) => o(t, e, r)) ||
    j6(t, n, r)
  );
}
function j6(t, e, n) {
  if (n.button != 0) return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Bi(t, q.create(r, 0, r.content.size)), !0) : !1;
  let o = r.resolve(e);
  for (let i = o.depth + 1; i > 0; i--) {
    let s = i > o.depth ? o.nodeAfter : o.node(i),
      a = o.before(i);
    if (s.inlineContent) Bi(t, q.create(r, a + 1, a + 1 + s.content.size));
    else if (Z.isSelectable(s)) Bi(t, Z.create(r, a));
    else continue;
    return !0;
  }
}
function qh(t) {
  return oa(t);
}
const Mv = _n ? "metaKey" : "ctrlKey";
Ht.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = qh(t),
    o = Date.now(),
    i = "singleClick";
  o - t.input.lastClick.time < 500 &&
    B6(n, t.input.lastClick) &&
    !n[Mv] &&
    (t.input.lastClick.type == "singleClick"
      ? (i = "doubleClick")
      : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
    (t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i });
  let s = t.posAtCoords(Xc(n));
  s &&
    (i == "singleClick"
      ? (t.input.mouseDown && t.input.mouseDown.done(),
        (t.input.mouseDown = new W6(t, s, n, !!r)))
      : (i == "doubleClick" ? V6 : U6)(t, s.pos, s.inside, n)
      ? n.preventDefault()
      : mo(t, "pointer"));
};
class W6 {
  constructor(e, n, r, o) {
    (this.view = e),
      (this.pos = n),
      (this.event = r),
      (this.flushed = o),
      (this.delayedSelectionSync = !1),
      (this.mightDrag = null),
      (this.startDoc = e.state.doc),
      (this.selectNode = !!r[Mv]),
      (this.allowDefault = r.shiftKey);
    let i, s;
    if (n.inside > -1) (i = e.state.doc.nodeAt(n.inside)), (s = n.inside);
    else {
      let c = e.state.doc.resolve(n.pos);
      (i = c.parent), (s = c.depth ? c.before() : 0);
    }
    const a = o ? null : r.target,
      l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: u } = e.state;
    ((r.button == 0 &&
      i.type.spec.draggable &&
      i.type.spec.selectable !== !1) ||
      (u instanceof Z && u.from <= s && u.to > s)) &&
      (this.mightDrag = {
        node: i,
        pos: s,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(
          this.target &&
          Jn &&
          !this.target.hasAttribute("contentEditable")
        ),
      }),
      this.target &&
        this.mightDrag &&
        (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable &&
          setTimeout(() => {
            this.view.input.mouseDown == this &&
              this.target.setAttribute("contentEditable", "false");
          }, 20),
        this.view.domObserver.start()),
      e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
      e.root.addEventListener("mousemove", (this.move = this.move.bind(this))),
      mo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up),
      this.view.root.removeEventListener("mousemove", this.move),
      this.mightDrag &&
        this.target &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable &&
          this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
      this.delayedSelectionSync && setTimeout(() => Vr(this.view)),
      (this.view.input.mouseDown = null);
  }
  up(e) {
    if ((this.done(), !this.view.dom.contains(e.target))) return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Xc(e))),
      this.updateAllowDefault(e),
      this.allowDefault || !n
        ? mo(this.view, "pointer")
        : z6(this.view, n.pos, n.inside, e, this.selectNode)
        ? e.preventDefault()
        : e.button == 0 &&
          (this.flushed || // Safari ignores clicks on draggable elements
            (Bt && this.mightDrag && !this.mightDrag.node.isAtom) || // Chrome will sometimes treat a node selection as a
            // cursor, but still report that the node is selected
            // when asked through getSelection. You'll then get a
            // situation where clicking at the point where that
            // (hidden) cursor is doesn't change the selection, and
            // thus doesn't get a reaction from ProseMirror. This
            // works around that.
            (Mt &&
              !this.view.state.selection.visible &&
              Math.min(
                Math.abs(n.pos - this.view.state.selection.from),
                Math.abs(n.pos - this.view.state.selection.to)
              ) <= 2))
        ? (Bi(this.view, ee.near(this.view.state.doc.resolve(n.pos))),
          e.preventDefault())
        : mo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e),
      mo(this.view, "pointer"),
      e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault &&
      (Math.abs(this.event.x - e.clientX) > 4 ||
        Math.abs(this.event.y - e.clientY) > 4) &&
      (this.allowDefault = !0);
  }
}
Ht.touchstart = (t) => {
  (t.input.lastTouch = Date.now()), qh(t), mo(t, "pointer");
};
Ht.touchmove = (t) => {
  (t.input.lastTouch = Date.now()), mo(t, "pointer");
};
Ht.contextmenu = (t) => qh(t);
function Tv(t, e) {
  return t.composing
    ? !0
    : Bt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
    ? ((t.input.compositionEndedAt = -2e8), !0)
    : !1;
}
const q6 = Br ? 5e3 : -1;
Ft.compositionstart = Ft.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t,
      n = e.selection.$to;
    if (
      e.selection instanceof q &&
      (e.storedMarks ||
        (!n.textOffset &&
          n.parentOffset &&
          n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
    )
      (t.markCursor = t.state.storedMarks || n.marks()),
        oa(t, !0),
        (t.markCursor = null);
    else if (
      (oa(t, !e.selection.empty),
      Jn &&
        e.selection.empty &&
        n.parentOffset &&
        !n.textOffset &&
        n.nodeBefore.marks.length)
    ) {
      let r = t.domSelectionRange();
      for (
        let o = r.focusNode, i = r.focusOffset;
        o && o.nodeType == 1 && i != 0;

      ) {
        let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
        if (!s) break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else (o = s), (i = -1);
      }
    }
    t.input.composing = !0;
  }
  Ov(t, q6);
};
Ft.compositionend = (t, e) => {
  t.composing &&
    ((t.input.composing = !1),
    (t.input.compositionEndedAt = e.timeStamp),
    (t.input.compositionPendingChanges = t.domObserver.pendingRecords().length
      ? t.input.compositionID
      : 0),
    (t.input.compositionNode = null),
    t.input.compositionPendingChanges &&
      Promise.resolve().then(() => t.domObserver.flush()),
    t.input.compositionID++,
    Ov(t, 20));
};
function Ov(t, e) {
  clearTimeout(t.input.composingTimeout),
    e > -1 && (t.input.composingTimeout = setTimeout(() => oa(t), e));
}
function Dv(t) {
  for (
    t.composing &&
    ((t.input.composing = !1), (t.input.compositionEndedAt = G6()));
    t.input.compositionNodes.length > 0;

  )
    t.input.compositionNodes.pop().markParentsDirty();
}
function K6(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode) return null;
  let n = HC(e.focusNode, e.focusOffset),
    r = FC(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let o = r.pmViewDesc,
      i = t.domObserver.lastChangedTextNode;
    if (n == i || r == i) return i;
    if (!o || !o.isText(r.nodeValue)) return r;
    if (t.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue))) return r;
    }
  }
  return n || r;
}
function G6() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function oa(t, e = !1) {
  if (!(Br && t.domObserver.flushingSoon >= 0)) {
    if (
      (t.domObserver.forceFlush(), Dv(t), e || (t.docView && t.docView.dirty))
    ) {
      let n = Fh(t);
      return (
        n && !n.eq(t.state.selection)
          ? t.dispatch(t.state.tr.setSelection(n))
          : (t.markCursor || e) && !t.state.selection.empty
          ? t.dispatch(t.state.tr.deleteSelection())
          : t.updateState(t.state),
        !0
      );
    }
    return !1;
  }
}
function J6(t, e) {
  if (!t.dom.parentNode) return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e),
    (n.style.cssText = "position: fixed; left: -10000px; top: 10px");
  let r = getSelection(),
    o = document.createRange();
  o.selectNodeContents(e),
    t.dom.blur(),
    r.removeAllRanges(),
    r.addRange(o),
    setTimeout(() => {
      n.parentNode && n.parentNode.removeChild(n), t.focus();
    }, 50);
}
const ia = (Gt && _o < 15) || (qi && WC < 604);
Ht.copy = Ft.cut = (t, e) => {
  let n = e,
    r = t.state.selection,
    o = n.type == "cut";
  if (r.empty) return;
  let i = ia ? null : n.clipboardData,
    s = r.content(),
    { dom: a, text: l } = Vh(t, s);
  i
    ? (n.preventDefault(),
      i.clearData(),
      i.setData("text/html", a.innerHTML),
      i.setData("text/plain", l))
    : J6(t, a),
    o &&
      t.dispatch(
        t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")
      );
};
function Y6(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
    ? t.content.firstChild
    : null;
}
function X6(t, e) {
  if (!t.dom.parentNode) return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
    r = t.dom.parentNode.appendChild(
      document.createElement(n ? "textarea" : "div")
    );
  n || (r.contentEditable = "true"),
    (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    r.focus();
  let o = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(),
      r.parentNode && r.parentNode.removeChild(r),
      n ? sa(t, r.value, null, o, e) : sa(t, r.textContent, r.innerHTML, o, e);
  }, 50);
}
function sa(t, e, n, r, o) {
  let i = Uh(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, o, i || W.empty))) return !0;
  if (!i) return !1;
  let s = Y6(i),
    a = s
      ? t.state.tr.replaceSelectionWith(s, r)
      : t.state.tr.replaceSelection(i);
  return (
    t.dispatch(
      a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
    ),
    !0
  );
}
function Nv(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e) return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Ft.paste = (t, e) => {
  let n = e;
  if (t.composing && !Br) return;
  let r = ia ? null : n.clipboardData,
    o = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && sa(t, Nv(r), r.getData("text/html"), o, n)
    ? n.preventDefault()
    : X6(t, n);
};
class Lv {
  constructor(e, n, r) {
    (this.slice = e), (this.move = n), (this.node = r);
  }
}
const Rv = _n ? "altKey" : "ctrlKey";
Ht.dragstart = (t, e) => {
  let n = e,
    r = t.input.mouseDown;
  if ((r && r.done(), !n.dataTransfer)) return;
  let o = t.state.selection,
    i = o.empty ? null : t.posAtCoords(Xc(n)),
    s;
  if (!(i && i.pos >= o.from && i.pos <= (o instanceof Z ? o.to - 1 : o.to))) {
    if (r && r.mightDrag) s = Z.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d &&
        d.node.type.spec.draggable &&
        d != t.docView &&
        (s = Z.create(t.state.doc, d.posBefore));
    }
  }
  let a = (s || t.state.selection).content(),
    { dom: l, text: u, slice: c } = Vh(t, a);
  (!n.dataTransfer.files.length || !Mt || av > 120) &&
    n.dataTransfer.clearData(),
    n.dataTransfer.setData(ia ? "Text" : "text/html", l.innerHTML),
    (n.dataTransfer.effectAllowed = "copyMove"),
    ia || n.dataTransfer.setData("text/plain", u),
    (t.dragging = new Lv(c, !n[Rv], s));
};
Ht.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Ft.dragover = Ft.dragenter = (t, e) => e.preventDefault();
Ft.drop = (t, e) => {
  let n = e,
    r = t.dragging;
  if (((t.dragging = null), !n.dataTransfer)) return;
  let o = t.posAtCoords(Xc(n));
  if (!o) return;
  let i = t.state.doc.resolve(o.pos),
    s = r && r.slice;
  s
    ? t.someProp("transformPasted", (h) => {
        s = h(s, t);
      })
    : (s = Uh(
        t,
        Nv(n.dataTransfer),
        ia ? null : n.dataTransfer.getData("text/html"),
        !1,
        i
      ));
  let a = !!(r && !n[Rv]);
  if (t.someProp("handleDrop", (h) => h(t, n, s || W.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s) return;
  n.preventDefault();
  let l = s ? Iy(t.state.doc, i.pos, s) : i.pos;
  l == null && (l = i.pos);
  let u = t.state.tr;
  if (a) {
    let { node: h } = r;
    h ? h.replace(u) : u.deleteSelection();
  }
  let c = u.mapping.map(l),
    d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
    f = u.doc;
  if (
    (d
      ? u.replaceRangeWith(c, c, s.content.firstChild)
      : u.replaceRange(c, c, s),
    u.doc.eq(f))
  )
    return;
  let p = u.doc.resolve(c);
  if (
    d &&
    Z.isSelectable(s.content.firstChild) &&
    p.nodeAfter &&
    p.nodeAfter.sameMarkup(s.content.firstChild)
  )
    u.setSelection(new Z(p));
  else {
    let h = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((m, g, b, _) => (h = _)),
      u.setSelection(zh(t, p, u.doc.resolve(h)));
  }
  t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
Ht.focus = (t) => {
  (t.input.lastFocus = Date.now()),
    t.focused ||
      (t.domObserver.stop(),
      t.dom.classList.add("ProseMirror-focused"),
      t.domObserver.start(),
      (t.focused = !0),
      setTimeout(() => {
        t.docView &&
          t.hasFocus() &&
          !t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
          Vr(t);
      }, 20));
};
Ht.blur = (t, e) => {
  let n = e;
  t.focused &&
    (t.domObserver.stop(),
    t.dom.classList.remove("ProseMirror-focused"),
    t.domObserver.start(),
    n.relatedTarget &&
      t.dom.contains(n.relatedTarget) &&
      t.domObserver.currentSelection.clear(),
    (t.focused = !1));
};
Ht.beforeinput = (t, e) => {
  if (Mt && Br && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (
        t.input.domChangeCount != r ||
        (t.dom.blur(),
        t.focus(),
        t.someProp("handleKeyDown", (i) => i(t, Uo(8, "Backspace"))))
      )
        return;
      let { $cursor: o } = t.state.selection;
      o &&
        o.pos > 0 &&
        t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Ft) Ht[t] = Ft[t];
function aa(t, e) {
  if (t == e) return !0;
  for (let n in t) if (t[n] !== e[n]) return !1;
  for (let n in e) if (!(n in t)) return !1;
  return !0;
}
class yu {
  constructor(e, n) {
    (this.toDOM = e), (this.spec = n || ti), (this.side = this.spec.side || 0);
  }
  map(e, n, r, o) {
    let { pos: i, deleted: s } = e.mapResult(
      n.from + o,
      this.side < 0 ? -1 : 1
    );
    return s ? null : new Ve(i - r, i - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof yu &&
        ((this.spec.key && this.spec.key == e.spec.key) ||
          (this.toDOM == e.toDOM && aa(this.spec, e.spec))))
    );
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class ko {
  constructor(e, n) {
    (this.attrs = e), (this.spec = n || ti);
  }
  map(e, n, r, o) {
    let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
      s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
    return i >= s ? null : new Ve(i, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof ko && aa(this.attrs, e.attrs) && aa(this.spec, e.spec))
    );
  }
  static is(e) {
    return e.type instanceof ko;
  }
  destroy() {}
}
class Kh {
  constructor(e, n) {
    (this.attrs = e), (this.spec = n || ti);
  }
  map(e, n, r, o) {
    let i = e.mapResult(n.from + o, 1);
    if (i.deleted) return null;
    let s = e.mapResult(n.to + o, -1);
    return s.deleted || s.pos <= i.pos
      ? null
      : new Ve(i.pos - r, s.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: o } = e.content.findIndex(n.from),
      i;
    return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof Kh && aa(this.attrs, e.attrs) && aa(this.spec, e.spec))
    );
  }
  destroy() {}
}
class Ve {
  /**
  @internal
  */
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.type = r);
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Ve(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return (
      this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
    );
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Ve(e, e, new yu(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, o) {
    return new Ve(e, n, new ko(r, o));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, o) {
    return new Ve(e, n, new Kh(r, o));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof ko;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof yu;
  }
}
const Mi = [],
  ti = {};
class ve {
  /**
  @internal
  */
  constructor(e, n) {
    (this.local = e.length ? e : Mi), (this.children = n.length ? n : Mi);
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? vu(n, e, 0, ti) : St;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let o = [];
    return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
  }
  findInner(e, n, r, o, i) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n &&
        a.to >= e &&
        (!i || i(a.spec)) &&
        r.push(a.copy(a.from + o, a.to + o));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, r, o + a, i);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == St || e.maps.length == 0
      ? this
      : this.mapInner(e, n, 0, 0, r || ti);
  }
  /**
  @internal
  */
  mapInner(e, n, r, o, i) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, o);
      l && l.type.valid(n, l)
        ? (s || (s = [])).push(l)
        : i.onRemove && i.onRemove(this.local[a].spec);
    }
    return this.children.length
      ? Z6(this.children, s || [], e, n, r, o, i)
      : s
      ? new ve(s.sort(ni), Mi)
      : St;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length
      ? this == St
        ? ve.create(e, n)
        : this.addInner(e, n, 0)
      : this;
  }
  addInner(e, n, r) {
    let o,
      i = 0;
    e.forEach((a, l) => {
      let u = l + r,
        c;
      if ((c = Pv(n, a, u))) {
        for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
          i += 3;
        o[i] == l
          ? (o[i + 2] = o[i + 2].addInner(a, c, u + 1))
          : o.splice(i, 0, l, l + a.nodeSize, vu(c, a, u + 1, ti)),
          (i += 3);
      }
    });
    let s = Iv(i ? $v(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new ve(
      s.length ? this.local.concat(s).sort(ni) : this.local,
      o || this.children
    );
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == St ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children,
      o = this.local;
    for (let i = 0; i < r.length; i += 3) {
      let s,
        a = r[i] + n,
        l = r[i + 1] + n;
      for (let c = 0, d; c < e.length; c++)
        (d = e[c]) &&
          d.from > a &&
          d.to < l &&
          ((e[c] = null), (s || (s = [])).push(d));
      if (!s) continue;
      r == this.children && (r = this.children.slice());
      let u = r[i + 2].removeInner(s, a + 1);
      u != St ? (r[i + 2] = u) : (r.splice(i, 3), (i -= 3));
    }
    if (o.length) {
      for (let i = 0, s; i < e.length; i++)
        if ((s = e[i]))
          for (let a = 0; a < o.length; a++)
            o[a].eq(s, n) &&
              (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
    }
    return r == this.children && o == this.local
      ? this
      : o.length || r.length
      ? new ve(o, r)
      : St;
  }
  forChild(e, n) {
    if (this == St) return this;
    if (n.isLeaf) return ve.empty;
    let r, o;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let i = e + 1,
      s = i + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > i && l.type instanceof ko) {
        let u = Math.max(i, l.from) - i,
          c = Math.min(s, l.to) - i;
        u < c && (o || (o = [])).push(l.copy(u, c));
      }
    }
    if (o) {
      let a = new ve(o.sort(ni), Mi);
      return r ? new lo([a, r]) : a;
    }
    return r || St;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e) return !0;
    if (
      !(e instanceof ve) ||
      this.local.length != e.local.length ||
      this.children.length != e.children.length
    )
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n])) return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (
        this.children[n] != e.children[n] ||
        this.children[n + 1] != e.children[n + 1] ||
        !this.children[n + 2].eq(e.children[n + 2])
      )
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Gh(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == St) return Mi;
    if (e.inlineContent || !this.local.some(ko.is)) return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof ko || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
ve.empty = new ve([], []);
ve.removeOverlap = Gh;
const St = ve.empty;
class lo {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((o) => o.map(e, n, ti));
    return lo.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf) return ve.empty;
    let r = [];
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].forChild(e, n);
      i != St && (i instanceof lo ? (r = r.concat(i.members)) : r.push(i));
    }
    return lo.from(r);
  }
  eq(e) {
    if (!(e instanceof lo) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n])) return !1;
    return !0;
  }
  locals(e) {
    let n,
      r = !0;
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].localsInner(e);
      if (i.length)
        if (!n) n = i;
        else {
          r && ((n = n.slice()), (r = !1));
          for (let s = 0; s < i.length; s++) n.push(i[s]);
        }
    }
    return n ? Gh(r ? n : n.sort(ni)) : Mi;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return St;
      case 1:
        return e[0];
      default:
        return new lo(
          e.every((n) => n instanceof ve)
            ? e
            : e.reduce((n, r) => n.concat(r instanceof ve ? r : r.members), [])
        );
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++) this.members[n].forEachSet(e);
  }
}
function Z6(t, e, n, r, o, i, s) {
  let a = t.slice();
  for (let u = 0, c = i; u < n.maps.length; u++) {
    let d = 0;
    n.maps[u].forEach((f, p, h, m) => {
      let g = m - h - (p - f);
      for (let b = 0; b < a.length; b += 3) {
        let _ = a[b + 1];
        if (_ < 0 || f > _ + c - d) continue;
        let v = a[b] + c - d;
        p >= v
          ? (a[b + 1] = f <= v ? -2 : -1)
          : f >= c && g && ((a[b] += g), (a[b + 1] += g));
      }
      d += g;
    }),
      (c = n.maps[u].map(c, -1));
  }
  let l = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        (l = !0), (a[u + 1] = -1);
        continue;
      }
      let c = n.map(t[u] + i),
        d = c - o;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[u + 1] + i, -1),
        p = f - o,
        { index: h, offset: m } = r.content.findIndex(d),
        g = r.maybeChild(h);
      if (g && m == d && m + g.nodeSize == p) {
        let b = a[u + 2].mapInner(n, g, c + 1, t[u] + i + 1, s);
        b != St
          ? ((a[u] = d), (a[u + 1] = p), (a[u + 2] = b))
          : ((a[u + 1] = -2), (l = !0));
      } else l = !0;
    }
  if (l) {
    let u = Q6(a, t, e, n, o, i, s),
      c = vu(u, r, 0, s);
    e = c.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), (d -= 3));
    for (let d = 0, f = 0; d < c.children.length; d += 3) {
      let p = c.children[d];
      for (; f < a.length && a[f] < p; ) f += 3;
      a.splice(f, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
    }
  }
  return new ve(e.sort(ni), a);
}
function Iv(t, e) {
  if (!e || !t.length) return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    n.push(new Ve(o.from + e, o.to + e, o.type));
  }
  return n;
}
function Q6(t, e, n, r, o, i, s) {
  function a(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let d = l.local[c].map(r, o, u);
      d ? n.push(d) : s.onRemove && s.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + i + 1);
  return n;
}
function Pv(t, e, n) {
  if (e.isLeaf) return null;
  let r = n + e.nodeSize,
    o = null;
  for (let i = 0, s; i < t.length; i++)
    (s = t[i]) &&
      s.from > n &&
      s.to < r &&
      ((o || (o = [])).push(s), (t[i] = null));
  return o;
}
function $v(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
  return e;
}
function vu(t, e, n, r) {
  let o = [],
    i = !1;
  e.forEach((a, l) => {
    let u = Pv(t, a, l + n);
    if (u) {
      i = !0;
      let c = vu(u, a, n + l + 1, r);
      c != St && o.push(l, l + a.nodeSize, c);
    }
  });
  let s = Iv(i ? $v(t) : t, -n).sort(ni);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) ||
      (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || o.length ? new ve(s, o) : St;
}
function ni(t, e) {
  return t.from - e.from || t.to - e.to;
}
function Gh(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let o = n + 1; o < e.length; o++) {
        let i = e[o];
        if (i.from == r.from) {
          i.to != r.to &&
            (e == t && (e = t.slice()),
            (e[o] = i.copy(i.from, r.to)),
            L1(e, o + 1, i.copy(r.to, i.to)));
          continue;
        } else {
          i.from < r.to &&
            (e == t && (e = t.slice()),
            (e[n] = r.copy(r.from, i.from)),
            L1(e, o, r.copy(i.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function L1(t, e, n) {
  for (; e < t.length && ni(n, t[e]) > 0; ) e++;
  t.splice(e, 0, n);
}
function Kd(t) {
  let e = [];
  return (
    t.someProp("decorations", (n) => {
      let r = n(t.state);
      r && r != St && e.push(r);
    }),
    t.cursorWrapper && e.push(ve.create(t.state.doc, [t.cursorWrapper.deco])),
    lo.from(e)
  );
}
const eA = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0,
  },
  tA = Gt && _o <= 11;
class nA {
  constructor() {
    (this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0);
  }
  set(e) {
    (this.anchorNode = e.anchorNode),
      (this.anchorOffset = e.anchorOffset),
      (this.focusNode = e.focusNode),
      (this.focusOffset = e.focusOffset);
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return (
      e.anchorNode == this.anchorNode &&
      e.anchorOffset == this.anchorOffset &&
      e.focusNode == this.focusNode &&
      e.focusOffset == this.focusOffset
    );
  }
}
class rA {
  constructor(e, n) {
    (this.view = e),
      (this.handleDOMChange = n),
      (this.queue = []),
      (this.flushingSoon = -1),
      (this.observer = null),
      (this.currentSelection = new nA()),
      (this.onCharData = null),
      (this.suppressingSelectionUpdates = !1),
      (this.lastChangedTextNode = null),
      (this.observer =
        window.MutationObserver &&
        new window.MutationObserver((r) => {
          for (let o = 0; o < r.length; o++) this.queue.push(r[o]);
          Gt &&
          _o <= 11 &&
          r.some(
            (o) =>
              (o.type == "childList" && o.removedNodes.length) ||
              (o.type == "characterData" &&
                o.oldValue.length > o.target.nodeValue.length)
          )
            ? this.flushSoon()
            : this.flush();
        })),
      tA &&
        (this.onCharData = (r) => {
          this.queue.push({
            target: r.target,
            type: "characterData",
            oldValue: r.prevValue,
          }),
            this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this));
  }
  flushSoon() {
    this.flushingSoon < 0 &&
      (this.flushingSoon = window.setTimeout(() => {
        (this.flushingSoon = -1), this.flush();
      }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 &&
      (window.clearTimeout(this.flushingSoon),
      (this.flushingSoon = -1),
      this.flush());
  }
  start() {
    this.observer &&
      (this.observer.takeRecords(), this.observer.observe(this.view.dom, eA)),
      this.onCharData &&
        this.view.dom.addEventListener(
          "DOMCharacterDataModified",
          this.onCharData
        ),
      this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData &&
      this.view.dom.removeEventListener(
        "DOMCharacterDataModified",
        this.onCharData
      ),
      this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener(
      "selectionchange",
      this.onSelectionChange
    );
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener(
      "selectionchange",
      this.onSelectionChange
    );
  }
  suppressSelectionUpdates() {
    (this.suppressingSelectionUpdates = !0),
      setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
  }
  onSelectionChange() {
    if (A1(this.view)) {
      if (this.suppressingSelectionUpdates) return Vr(this.view);
      if (Gt && _o <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (
          e.focusNode &&
          ai(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
        )
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode) return !0;
    let n = /* @__PURE__ */ new Set(),
      r;
    for (let i = e.focusNode; i; i = ra(i)) n.add(i);
    for (let i = e.anchorNode; i; i = ra(i))
      if (n.has(i)) {
        r = i;
        break;
      }
    let o = r && this.view.docView.nearestDesc(r);
    if (
      o &&
      o.ignoreMutation({
        type: "selection",
        target: r.nodeType == 3 ? r.parentNode : r,
      })
    )
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1) return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(),
      o =
        !this.suppressingSelectionUpdates &&
        !this.currentSelection.eq(r) &&
        A1(e) &&
        !this.ignoreSelectionChange(r),
      i = -1,
      s = -1,
      a = !1,
      l = [];
    if (e.editable)
      for (let c = 0; c < n.length; c++) {
        let d = this.registerMutation(n[c], l);
        d &&
          ((i = i < 0 ? d.from : Math.min(d.from, i)),
          (s = s < 0 ? d.to : Math.max(d.to, s)),
          d.typeOver && (a = !0));
      }
    if (Jn && l.length) {
      let c = l.filter((d) => d.nodeName == "BR");
      if (c.length == 2) {
        let [d, f] = c;
        d.parentNode && d.parentNode.parentNode == f.parentNode
          ? f.remove()
          : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of c) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!d || sA(e, d) != p) && f.remove();
        }
      }
    }
    let u = null;
    i < 0 &&
    o &&
    e.input.lastFocus > Date.now() - 200 &&
    Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
    Jc(r) &&
    (u = Fh(e)) &&
    u.eq(ee.near(e.state.doc.resolve(0), 1))
      ? ((e.input.lastFocus = 0),
        Vr(e),
        this.currentSelection.set(r),
        e.scrollToSelection())
      : (i > -1 || o) &&
        (i > -1 && (e.docView.markDirty(i, s), oA(e)),
        this.handleDOMChange(i, s, a, l),
        e.docView && e.docView.dirty
          ? e.updateState(e.state)
          : this.currentSelection.eq(r) || Vr(e),
        this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1) return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (
      (e.type == "attributes" &&
        (r == this.view.docView ||
          e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
          (e.attributeName == "style" &&
            !e.oldValue &&
            !e.target.getAttribute("style")))) ||
      !r ||
      r.ignoreMutation(e)
    )
      return null;
    if (e.type == "childList") {
      for (let c = 0; c < e.addedNodes.length; c++) {
        let d = e.addedNodes[c];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (
        r.contentDOM &&
        r.contentDOM != r.dom &&
        !r.contentDOM.contains(e.target)
      )
        return { from: r.posBefore, to: r.posAfter };
      let o = e.previousSibling,
        i = e.nextSibling;
      if (Gt && _o <= 11 && e.addedNodes.length)
        for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[c];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (o = d),
            (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) &&
              (i = f);
        }
      let s = o && o.parentNode == e.target ? xt(o) + 1 : 0,
        a = r.localPosFromDOM(e.target, s, -1),
        l = i && i.parentNode == e.target ? xt(i) : e.target.childNodes.length,
        u = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: u };
    } else
      return e.type == "attributes"
        ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
        : ((this.lastChangedTextNode = e.target),
          {
            from: r.posAtStart,
            to: r.posAtEnd,
            // An event was generated for a text change that didn't change
            // any text. Mark the dom change to fall back to assuming the
            // selection was typed over with an identical value if it can't
            // find another change.
            typeOver: e.target.nodeValue == e.oldValue,
          });
  }
}
let R1 = /* @__PURE__ */ new WeakMap(),
  I1 = !1;
function oA(t) {
  if (
    !R1.has(t) &&
    (R1.set(t, null),
    ["normal", "nowrap", "pre-line"].indexOf(
      getComputedStyle(t.dom).whiteSpace
    ) !== -1)
  ) {
    if (((t.requiresGeckoHackNode = Jn), I1)) return;
    console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
    ),
      (I1 = !0);
  }
}
function P1(t, e) {
  let n = e.startContainer,
    r = e.startOffset,
    o = e.endContainer,
    i = e.endOffset,
    s = t.domAtPos(t.state.selection.anchor);
  return (
    ai(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]),
    { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i }
  );
}
function iA(t, e) {
  if (e.getComposedRanges) {
    let o = e.getComposedRanges(t.root)[0];
    if (o) return P1(t, o);
  }
  let n;
  function r(o) {
    o.preventDefault(),
      o.stopImmediatePropagation(),
      (n = o.getTargetRanges()[0]);
  }
  return (
    t.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    t.dom.removeEventListener("beforeinput", r, !0),
    n ? P1(t, n) : null
  );
}
function sA(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock) return n;
  }
  return null;
}
function aA(t, e, n) {
  let {
      node: r,
      fromOffset: o,
      toOffset: i,
      from: s,
      to: a,
    } = t.docView.parseRange(e, n),
    l = t.domSelectionRange(),
    u,
    c = l.anchorNode;
  if (
    (c &&
      t.dom.contains(c.nodeType == 1 ? c : c.parentNode) &&
      ((u = [{ node: c, offset: l.anchorOffset }]),
      Jc(l) || u.push({ node: l.focusNode, offset: l.focusOffset })),
    Mt && t.input.lastKeyCode === 8)
  )
    for (let g = i; g > o; g--) {
      let b = r.childNodes[g - 1],
        _ = b.pmViewDesc;
      if (b.nodeName == "BR" && !_) {
        i = g;
        break;
      }
      if (!_ || _.size) break;
    }
  let d = t.state.doc,
    f = t.someProp("domParser") || zr.fromSchema(t.state.schema),
    p = d.resolve(s),
    h = null,
    m = f.parse(r, {
      topNode: p.parent,
      topMatch: p.parent.contentMatchAt(p.index()),
      topOpen: !0,
      from: o,
      to: i,
      preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: u,
      ruleFromNode: lA,
      context: p,
    });
  if (u && u[0].pos != null) {
    let g = u[0].pos,
      b = u[1] && u[1].pos;
    b == null && (b = g), (h = { anchor: g + s, head: b + s });
  }
  return { doc: m, sel: h, from: s, to: a };
}
function lA(t) {
  let e = t.pmViewDesc;
  if (e) return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Bt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (
      t.parentNode.lastChild == t ||
      (Bt && /^(tr|table)$/i.test(t.parentNode.nodeName))
    )
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const uA =
  /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function cA(t, e, n, r, o) {
  let i =
    t.input.compositionPendingChanges ||
    (t.composing ? t.input.compositionID : 0);
  if (((t.input.compositionPendingChanges = 0), e < 0)) {
    let T =
        t.input.lastSelectionTime > Date.now() - 50
          ? t.input.lastSelectionOrigin
          : null,
      P = Fh(t, T);
    if (P && !t.state.selection.eq(P)) {
      if (
        Mt &&
        Br &&
        t.input.lastKeyCode === 13 &&
        Date.now() - 100 < t.input.lastKeyCodeTime &&
        t.someProp("handleKeyDown", (H) => H(t, Uo(13, "Enter")))
      )
        return;
      let z = t.state.tr.setSelection(P);
      T == "pointer"
        ? z.setMeta("pointer", !0)
        : T == "key" && z.scrollIntoView(),
        i && z.setMeta("composition", i),
        t.dispatch(z);
    }
    return;
  }
  let s = t.state.doc.resolve(e),
    a = s.sharedDepth(n);
  (e = s.before(a + 1)), (n = t.state.doc.resolve(n).after(a + 1));
  let l = t.state.selection,
    u = aA(t, e, n),
    c = t.state.doc,
    d = c.slice(u.from, u.to),
    f,
    p;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
    ? ((f = t.state.selection.to), (p = "end"))
    : ((f = t.state.selection.from), (p = "start")),
    (t.input.lastKeyCode = null);
  let h = pA(d.content, u.doc.content, u.from, f, p);
  if (
    (h && t.input.domChangeCount++,
    ((qi && t.input.lastIOSEnter > Date.now() - 225) || Br) &&
      o.some((T) => T.nodeType == 1 && !uA.test(T.nodeName)) &&
      (!h || h.endA >= h.endB) &&
      t.someProp("handleKeyDown", (T) => T(t, Uo(13, "Enter"))))
  ) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!h)
    if (
      r &&
      l instanceof q &&
      !l.empty &&
      l.$head.sameParent(l.$anchor) &&
      !t.composing &&
      !(u.sel && u.sel.anchor != u.sel.head)
    )
      h = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let T = $1(t, t.state.doc, u.sel);
        if (T && !T.eq(t.state.selection)) {
          let P = t.state.tr.setSelection(T);
          i && P.setMeta("composition", i), t.dispatch(P);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to &&
    h.start == h.endB &&
    t.state.selection instanceof q &&
    (h.start > t.state.selection.from &&
    h.start <= t.state.selection.from + 2 &&
    t.state.selection.from >= u.from
      ? (h.start = t.state.selection.from)
      : h.endA < t.state.selection.to &&
        h.endA >= t.state.selection.to - 2 &&
        t.state.selection.to <= u.to &&
        ((h.endB += t.state.selection.to - h.endA),
        (h.endA = t.state.selection.to))),
    Gt &&
      _o <= 11 &&
      h.endB == h.start + 1 &&
      h.endA == h.start &&
      h.start > u.from &&
      u.doc.textBetween(h.start - u.from - 1, h.start - u.from + 1) == " " &&
      (h.start--, h.endA--, h.endB--);
  let m = u.doc.resolveNoCache(h.start - u.from),
    g = u.doc.resolveNoCache(h.endB - u.from),
    b = c.resolve(h.start),
    _ = m.sameParent(g) && m.parent.inlineContent && b.end() >= h.endA,
    v;
  if (
    ((qi &&
      t.input.lastIOSEnter > Date.now() - 225 &&
      (!_ || o.some((T) => T.nodeName == "DIV" || T.nodeName == "P"))) ||
      (!_ &&
        m.pos < u.doc.content.size &&
        !m.sameParent(g) &&
        (v = ee.findFrom(u.doc.resolve(m.pos + 1), 1, !0)) &&
        v.head == g.pos)) &&
    t.someProp("handleKeyDown", (T) => T(t, Uo(13, "Enter")))
  ) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (
    t.state.selection.anchor > h.start &&
    fA(c, h.start, h.endA, m, g) &&
    t.someProp("handleKeyDown", (T) => T(t, Uo(8, "Backspace")))
  ) {
    Br && Mt && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Mt && h.endB == h.start && (t.input.lastChromeDelete = Date.now()),
    Br &&
      !_ &&
      m.start() != g.start() &&
      g.parentOffset == 0 &&
      m.depth == g.depth &&
      u.sel &&
      u.sel.anchor == u.sel.head &&
      u.sel.head == h.endA &&
      ((h.endB -= 2),
      (g = u.doc.resolveNoCache(h.endB - u.from)),
      setTimeout(() => {
        t.someProp("handleKeyDown", function (T) {
          return T(t, Uo(13, "Enter"));
        });
      }, 20));
  let y = h.start,
    w = h.endA,
    x,
    M,
    N;
  if (_) {
    if (m.pos == g.pos)
      Gt &&
        _o <= 11 &&
        m.parentOffset == 0 &&
        (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Vr(t), 20)),
        (x = t.state.tr.delete(y, w)),
        (M = c.resolve(h.start).marksAcross(c.resolve(h.endA)));
    else if (
      // Adding or removing a mark
      h.endA == h.endB &&
      (N = dA(
        m.parent.content.cut(m.parentOffset, g.parentOffset),
        b.parent.content.cut(b.parentOffset, h.endA - b.start())
      ))
    )
      (x = t.state.tr),
        N.type == "add" ? x.addMark(y, w, N.mark) : x.removeMark(y, w, N.mark);
    else if (
      m.parent.child(m.index()).isText &&
      m.index() == g.index() - (g.textOffset ? 0 : 1)
    ) {
      let T = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (t.someProp("handleTextInput", (P) => P(t, y, w, T))) return;
      x = t.state.tr.insertText(T, y, w);
    }
  }
  if (
    (x ||
      (x = t.state.tr.replace(
        y,
        w,
        u.doc.slice(h.start - u.from, h.endB - u.from)
      )),
    u.sel)
  ) {
    let T = $1(t, x.doc, u.sel);
    T &&
      !(
        (Mt &&
          t.composing &&
          T.empty &&
          (h.start != h.endB || t.input.lastChromeDelete < Date.now() - 100) &&
          (T.head == y || T.head == x.mapping.map(w) - 1)) ||
        (Gt && T.empty && T.head == y)
      ) &&
      x.setSelection(T);
  }
  M && x.ensureMarks(M),
    i && x.setMeta("composition", i),
    t.dispatch(x.scrollIntoView());
}
function $1(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size
    ? null
    : zh(t, e.resolve(n.anchor), e.resolve(n.head));
}
function dA(t, e) {
  let n = t.firstChild.marks,
    r = e.firstChild.marks,
    o = n,
    i = r,
    s,
    a,
    l;
  for (let c = 0; c < r.length; c++) o = r[c].removeFromSet(o);
  for (let c = 0; c < n.length; c++) i = n[c].removeFromSet(i);
  if (o.length == 1 && i.length == 0)
    (a = o[0]), (s = "add"), (l = (c) => c.mark(a.addToSet(c.marks)));
  else if (o.length == 0 && i.length == 1)
    (a = i[0]), (s = "remove"), (l = (c) => c.mark(a.removeFromSet(c.marks)));
  else return null;
  let u = [];
  for (let c = 0; c < e.childCount; c++) u.push(l(e.child(c)));
  if ($.from(u).eq(t)) return { mark: a, type: s };
}
function fA(t, e, n, r, o) {
  if (
    // The content must have shrunk
    n - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Gd(r, !0, !1) < o.pos
  )
    return !1;
  let i = t.resolve(e);
  if (!r.parent.isTextblock) {
    let a = i.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let s = t.resolve(Gd(i, !0, !0));
  return !s.parent.isTextblock || s.pos > n || Gd(s, !0, !1) < n
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Gd(t, e, n) {
  let r = t.depth,
    o = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, o++, (e = !1);
  if (n) {
    let i = t.node(r).maybeChild(t.indexAfter(r));
    for (; i && !i.isLeaf; ) (i = i.firstChild), o++;
  }
  return o;
}
function pA(t, e, n, r, o) {
  let i = t.findDiffStart(e, n);
  if (i == null) return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (o == "end") {
    let l = Math.max(0, i - Math.min(s, a));
    r -= s + l - i;
  }
  if (s < i && t.size < e.size) {
    let l = r <= i && r >= s ? i - r : 0;
    (i -= l),
      i && i < e.size && B1(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
      (a = i + (a - s)),
      (s = i);
  } else if (a < i) {
    let l = r <= i && r >= a ? i - r : 0;
    (i -= l),
      i && i < t.size && B1(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1),
      (s = i + (s - a)),
      (a = i);
  }
  return { start: i, endA: s, endB: a };
}
function B1(t) {
  if (t.length != 2) return !1;
  let e = t.charCodeAt(0),
    n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
const hA = Vh,
  aV = Uh,
  lV = oa;
class mA {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    (this._root = null),
      (this.focused = !1),
      (this.trackWrites = null),
      (this.mounted = !1),
      (this.markCursor = null),
      (this.cursorWrapper = null),
      (this.lastSelectedViewDesc = void 0),
      (this.input = new L6()),
      (this.prevDirectPlugins = []),
      (this.pluginViews = []),
      (this.requiresGeckoHackNode = !1),
      (this.dragging = null),
      (this._props = n),
      (this.state = n.state),
      (this.directPlugins = n.plugins || []),
      this.directPlugins.forEach(U1),
      (this.dispatch = this.dispatch.bind(this)),
      (this.dom = (e && e.mount) || document.createElement("div")),
      e &&
        (e.appendChild
          ? e.appendChild(this.dom)
          : typeof e == "function"
          ? e(this.dom)
          : e.mount && (this.mounted = !0)),
      (this.editable = z1(this)),
      F1(this),
      (this.nodeViews = V1(this)),
      (this.docView = v1(this.state.doc, H1(this), Kd(this), this.dom, this)),
      (this.domObserver = new rA(this, (r, o, i, s) => cA(this, r, o, i, s))),
      this.domObserver.start(),
      R6(this),
      this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e) this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && xp(this);
    let n = this._props;
    (this._props = e),
      e.plugins && (e.plugins.forEach(U1), (this.directPlugins = e.plugins)),
      this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props) n[r] = this._props[r];
    n.state = this.state;
    for (let r in e) n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let o = this.state,
      i = !1,
      s = !1;
    e.storedMarks && this.composing && (Dv(this), (s = !0)), (this.state = e);
    let a = o.plugins != e.plugins || this._props.plugins != n.plugins;
    if (
      a ||
      this._props.plugins != n.plugins ||
      this._props.nodeViews != n.nodeViews
    ) {
      let p = V1(this);
      bA(p, this.nodeViews) && ((this.nodeViews = p), (i = !0));
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && xp(this),
      (this.editable = z1(this)),
      F1(this);
    let l = Kd(this),
      u = H1(this),
      c =
        o.plugins != e.plugins && !o.doc.eq(e.doc)
          ? "reset"
          : e.scrollToSelection > o.scrollToSelection
          ? "to selection"
          : "preserve",
      d = i || !this.docView.matchesNode(e.doc, u, l);
    (d || !e.selection.eq(o.selection)) && (s = !0);
    let f =
      c == "preserve" && s && this.dom.style.overflowAnchor == null && GC(this);
    if (s) {
      this.domObserver.stop();
      let p =
        d &&
        (Gt || Mt) &&
        !this.composing &&
        !o.selection.empty &&
        !e.selection.empty &&
        gA(o.selection, e.selection);
      if (d) {
        let h = Mt
          ? (this.trackWrites = this.domSelectionRange().focusNode)
          : null;
        this.composing && (this.input.compositionNode = K6(this)),
          (i || !this.docView.update(e.doc, u, l, this)) &&
            (this.docView.updateOuterDeco(u),
            this.docView.destroy(),
            (this.docView = v1(e.doc, u, l, this.dom, this))),
          h && !this.trackWrites && (p = !0);
      }
      p ||
      !(
        this.input.mouseDown &&
        this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
        y6(this)
      )
        ? Vr(this, p)
        : (_v(this, e.selection), this.domObserver.setCurSelection()),
        this.domObserver.start();
    }
    this.updatePluginViews(o),
      !((r = this.dragging) === null || r === void 0) &&
        r.node &&
        !o.doc.eq(e.doc) &&
        this.updateDraggedNode(this.dragging, o),
      c == "reset"
        ? (this.dom.scrollTop = 0)
        : c == "to selection"
        ? this.scrollToSelection()
        : f && JC(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this)))
      if (this.state.selection instanceof Z) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && p1(this, n.getBoundingClientRect(), e);
      } else p1(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (
      !e ||
      e.plugins != this.state.plugins ||
      this.directPlugins != this.prevDirectPlugins
    ) {
      (this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node,
      o = -1;
    if (this.state.doc.nodeAt(r.from) == r.node) o = r.from;
    else {
      let i = r.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
    }
    this.dragging = new Lv(
      e.slice,
      e.move,
      o < 0 ? void 0 : Z.create(this.state.doc, o)
    );
  }
  someProp(e, n) {
    let r = this._props && this._props[e],
      o;
    if (r != null && (o = n ? n(r) : r)) return o;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (o = n ? n(a) : a)) return o;
    }
    let i = this.state.plugins;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s].props[e];
        if (a != null && (o = n ? n(a) : a)) return o;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Gt) {
      let e = this.root.activeElement;
      if (e == this.dom) return !0;
      if (!e || !this.dom.contains(e)) return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false") return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(),
      this.editable && YC(this.dom),
      Vr(this),
      this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
          return (
            n.getSelection ||
              (Object.getPrototypeOf(n).getSelection = () =>
                n.ownerDocument.getSelection()),
            (this._root = n)
          );
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return t6(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return fv(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let o = this.docView.posFromDOM(e, n, r);
    if (o == null) throw new RangeError("DOM position not inside the editor");
    return o;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return s6(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return sa(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return sa(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView &&
      (I6(this),
      this.destroyPluginViews(),
      this.mounted
        ? (this.docView.update(this.state.doc, [], Kd(this), this),
          (this.dom.textContent = ""))
        : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
      this.docView.destroy(),
      (this.docView = null),
      $C());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return $6(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e
      ? (Bt &&
          this.root.nodeType === 11 &&
          VC(this.dom.ownerDocument) == this.dom &&
          iA(this, e)) ||
          e
      : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function H1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return (
    (e.class = "ProseMirror"),
    (e.contenteditable = String(t.editable)),
    t.someProp("attributes", (n) => {
      if ((typeof n == "function" && (n = n(t.state)), n))
        for (let r in n)
          r == "class"
            ? (e.class += " " + n[r])
            : r == "style"
            ? (e.style = (e.style ? e.style + ";" : "") + n[r])
            : !e[r] &&
              r != "contenteditable" &&
              r != "nodeName" &&
              (e[r] = String(n[r]));
    }),
    e.translate || (e.translate = "no"),
    [Ve.node(0, t.state.doc.content.size, e)]
  );
}
function F1(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    (e.className = "ProseMirror-separator"),
      e.setAttribute("mark-placeholder", "true"),
      e.setAttribute("alt", ""),
      (t.cursorWrapper = {
        dom: e,
        deco: Ve.widget(t.state.selection.from, e, {
          raw: !0,
          marks: t.markCursor,
        }),
      });
  } else t.cursorWrapper = null;
}
function z1(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function gA(t, e) {
  let n = Math.min(
    t.$anchor.sharedDepth(t.head),
    e.$anchor.sharedDepth(e.head)
  );
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function V1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let o in r)
      Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function bA(t, e) {
  let n = 0,
    r = 0;
  for (let o in t) {
    if (t[o] != e[o]) return !0;
    n++;
  }
  for (let o in e) r++;
  return n != r;
}
function U1(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError(
      "Plugins passed directly to the view must not have a state component"
    );
}
let Qt = class to extends ee {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return to.valid(r) ? new to(r) : ee.near(r);
  }
  content() {
    return W.empty;
  }
  eq(e) {
    return e instanceof to && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new to(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new yA(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !vA(e) || !_A(e)) return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null) return r;
    let o = n.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (;;) {
      if (!r && to.valid(e)) return e;
      let o = e.pos,
        i = null;
      for (let s = e.depth; ; s--) {
        let a = e.node(s);
        if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
          i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
          break;
        } else if (s == 0) return null;
        o += n;
        let l = e.doc.resolve(o);
        if (to.valid(l)) return l;
      }
      for (;;) {
        let s = n > 0 ? i.firstChild : i.lastChild;
        if (!s) {
          if (i.isAtom && !i.isText && !Z.isSelectable(i)) {
            (e = e.doc.resolve(o + i.nodeSize * n)), (r = !1);
            continue e;
          }
          break;
        }
        (i = s), (o += n);
        let a = e.doc.resolve(o);
        if (to.valid(a)) return a;
      }
      return null;
    }
  }
};
Qt.prototype.visible = !1;
Qt.findFrom = Qt.findGapCursorFrom;
ee.jsonID("gapcursor", Qt);
let yA = class Bv {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Bv(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Qt.valid(n) ? new Qt(n) : ee.near(n);
  }
};
function vA(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e),
      r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    for (let o = r.child(n - 1); ; o = o.lastChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0;
      if (o.inlineContent) return !1;
    }
  }
  return !0;
}
function _A(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e),
      r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    for (let o = r.child(n); ; o = o.firstChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0;
      if (o.inlineContent) return !1;
    }
  }
  return !0;
}
function uV() {
  return new be({
    props: {
      decorations: CA,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Qt.valid(n) ? new Qt(n) : null;
      },
      handleClick: kA,
      handleKeyDown: xA,
      handleDOMEvents: { beforeinput: wA },
    },
  });
}
const xA = Gc({
  ArrowLeft: sl("horiz", -1),
  ArrowRight: sl("horiz", 1),
  ArrowUp: sl("vert", -1),
  ArrowDown: sl("vert", 1),
});
function sl(t, e) {
  const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
  return function (r, o, i) {
    let s = r.selection,
      a = e > 0 ? s.$to : s.$from,
      l = s.empty;
    if (s instanceof q) {
      if (!i.endOfTextblock(n) || a.depth == 0) return !1;
      (l = !1), (a = r.doc.resolve(e > 0 ? a.after() : a.before()));
    }
    let u = Qt.findGapCursorFrom(a, e, l);
    return u ? (o && o(r.tr.setSelection(new Qt(u))), !0) : !1;
  };
}
function kA(t, e, n) {
  if (!t || !t.editable) return !1;
  let r = t.state.doc.resolve(e);
  if (!Qt.valid(r)) return !1;
  let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return o && o.inside > -1 && Z.isSelectable(t.state.doc.nodeAt(o.inside))
    ? !1
    : (t.dispatch(t.state.tr.setSelection(new Qt(r))), !0);
}
function wA(t, e) {
  if (
    e.inputType != "insertCompositionText" ||
    !(t.state.selection instanceof Qt)
  )
    return !1;
  let { $from: n } = t.state.selection,
    r = n.parent
      .contentMatchAt(n.index())
      .findWrapping(t.state.schema.nodes.text);
  if (!r) return !1;
  let o = $.empty;
  for (let s = r.length - 1; s >= 0; s--)
    o = $.from(r[s].createAndFill(null, o));
  let i = t.state.tr.replace(n.pos, n.pos, new W(o, 0, 0));
  return i.setSelection(q.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function CA(t) {
  if (!(t.selection instanceof Qt)) return null;
  let e = document.createElement("div");
  return (
    (e.className = "ProseMirror-gapcursor"),
    ve.create(t.doc, [Ve.widget(t.selection.head, e, { key: "gapcursor" })])
  );
}
var _u = 200,
  kt = function () {};
kt.prototype.append = function (e) {
  return e.length
    ? ((e = kt.from(e)),
      (!this.length && e) ||
        (e.length < _u && this.leafAppend(e)) ||
        (this.length < _u && e.leafPrepend(this)) ||
        this.appendInner(e))
    : this;
};
kt.prototype.prepend = function (e) {
  return e.length ? kt.from(e).append(this) : this;
};
kt.prototype.appendInner = function (e) {
  return new AA(this, e);
};
kt.prototype.slice = function (e, n) {
  return (
    e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n
      ? kt.empty
      : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
  );
};
kt.prototype.get = function (e) {
  if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
kt.prototype.forEach = function (e, n, r) {
  n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r
      ? this.forEachInner(e, n, r, 0)
      : this.forEachInvertedInner(e, n, r, 0);
};
kt.prototype.map = function (e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var o = [];
  return (
    this.forEach(
      function (i, s) {
        return o.push(e(i, s));
      },
      n,
      r
    ),
    o
  );
};
kt.from = function (e) {
  return e instanceof kt ? e : e && e.length ? new Hv(e) : kt.empty;
};
var Hv = /* @__PURE__ */ (function (t) {
  function e(r) {
    t.call(this), (this.values = r);
  }
  t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e);
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return (
    (e.prototype.flatten = function () {
      return this.values;
    }),
    (e.prototype.sliceInner = function (o, i) {
      return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
    }),
    (e.prototype.getInner = function (o) {
      return this.values[o];
    }),
    (e.prototype.forEachInner = function (o, i, s, a) {
      for (var l = i; l < s; l++)
        if (o(this.values[l], a + l) === !1) return !1;
    }),
    (e.prototype.forEachInvertedInner = function (o, i, s, a) {
      for (var l = i - 1; l >= s; l--)
        if (o(this.values[l], a + l) === !1) return !1;
    }),
    (e.prototype.leafAppend = function (o) {
      if (this.length + o.length <= _u)
        return new e(this.values.concat(o.flatten()));
    }),
    (e.prototype.leafPrepend = function (o) {
      if (this.length + o.length <= _u)
        return new e(o.flatten().concat(this.values));
    }),
    (n.length.get = function () {
      return this.values.length;
    }),
    (n.depth.get = function () {
      return 0;
    }),
    Object.defineProperties(e.prototype, n),
    e
  );
})(kt);
kt.empty = new Hv([]);
var AA = /* @__PURE__ */ (function (t) {
    function e(n, r) {
      t.call(this),
        (this.left = n),
        (this.right = r),
        (this.length = n.length + r.length),
        (this.depth = Math.max(n.depth, r.depth) + 1);
    }
    return (
      t && (e.__proto__ = t),
      (e.prototype = Object.create(t && t.prototype)),
      (e.prototype.constructor = e),
      (e.prototype.flatten = function () {
        return this.left.flatten().concat(this.right.flatten());
      }),
      (e.prototype.getInner = function (r) {
        return r < this.left.length
          ? this.left.get(r)
          : this.right.get(r - this.left.length);
      }),
      (e.prototype.forEachInner = function (r, o, i, s) {
        var a = this.left.length;
        if (
          (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === !1) ||
          (i > a &&
            this.right.forEachInner(
              r,
              Math.max(o - a, 0),
              Math.min(this.length, i) - a,
              s + a
            ) === !1)
        )
          return !1;
      }),
      (e.prototype.forEachInvertedInner = function (r, o, i, s) {
        var a = this.left.length;
        if (
          (o > a &&
            this.right.forEachInvertedInner(
              r,
              o - a,
              Math.max(i, a) - a,
              s + a
            ) === !1) ||
          (i < a &&
            this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === !1)
        )
          return !1;
      }),
      (e.prototype.sliceInner = function (r, o) {
        if (r == 0 && o == this.length) return this;
        var i = this.left.length;
        return o <= i
          ? this.left.slice(r, o)
          : r >= i
          ? this.right.slice(r - i, o - i)
          : this.left.slice(r, i).append(this.right.slice(0, o - i));
      }),
      (e.prototype.leafAppend = function (r) {
        var o = this.right.leafAppend(r);
        if (o) return new e(this.left, o);
      }),
      (e.prototype.leafPrepend = function (r) {
        var o = this.left.leafPrepend(r);
        if (o) return new e(o, this.right);
      }),
      (e.prototype.appendInner = function (r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
          ? new e(this.left, new e(this.right, r))
          : new e(this, r);
      }),
      e
    );
  })(kt),
  Fv = kt;
const SA = 500;
class Hn {
  constructor(e, n) {
    (this.items = e), (this.eventCount = n);
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0) return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let o, i;
    n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length));
    let s = e.tr,
      a,
      l,
      u = [],
      c = [];
    return (
      this.items.forEach(
        (d, f) => {
          if (!d.step) {
            o || ((o = this.remapping(r, f + 1)), (i = o.maps.length)),
              i--,
              c.push(d);
            return;
          }
          if (o) {
            c.push(new nr(d.map));
            let p = d.step.map(o.slice(i)),
              h;
            p &&
              s.maybeStep(p).doc &&
              ((h = s.mapping.maps[s.mapping.maps.length - 1]),
              u.push(new nr(h, void 0, void 0, u.length + c.length))),
              i--,
              h && o.appendMap(h, i);
          } else s.maybeStep(d.step);
          if (d.selection)
            return (
              (a = o ? d.selection.map(o.slice(i)) : d.selection),
              (l = new Hn(
                this.items.slice(0, r).append(c.reverse().concat(u)),
                this.eventCount - 1
              )),
              !1
            );
        },
        this.items.length,
        0
      ),
      { remaining: l, transform: s, selection: a }
    );
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, o) {
    let i = [],
      s = this.eventCount,
      a = this.items,
      l = !o && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let d = e.steps[c].invert(e.docs[c]),
        f = new nr(e.mapping.maps[c], d, n),
        p;
      (p = l && l.merge(f)) &&
        ((f = p), c ? i.pop() : (a = a.slice(0, a.length - 1))),
        i.push(f),
        n && (s++, (n = void 0)),
        o || (l = f);
    }
    let u = s - r.depth;
    return u > MA && ((a = EA(a, u)), (s -= u)), new Hn(a.append(i), s);
  }
  remapping(e, n) {
    let r = new $i();
    return (
      this.items.forEach(
        (o, i) => {
          let s =
            o.mirrorOffset != null && i - o.mirrorOffset >= e
              ? r.maps.length - o.mirrorOffset
              : void 0;
          r.appendMap(o.map, s);
        },
        e,
        n
      ),
      r
    );
  }
  addMaps(e) {
    return this.eventCount == 0
      ? this
      : new Hn(this.items.append(e.map((n) => new nr(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount) return this;
    let r = [],
      o = Math.max(0, this.items.length - n),
      i = e.mapping,
      s = e.steps.length,
      a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, o);
    let l = n;
    this.items.forEach((f) => {
      let p = i.getMirror(--l);
      if (p == null) return;
      s = Math.min(s, p);
      let h = i.maps[p];
      if (f.step) {
        let m = e.steps[p].invert(e.docs[p]),
          g = f.selection && f.selection.map(i.slice(l + 1, p));
        g && a++, r.push(new nr(h, m, g));
      } else r.push(new nr(h));
    }, o);
    let u = [];
    for (let f = n; f < s; f++) u.push(new nr(i.maps[f]));
    let c = this.items.slice(0, o).append(u).append(r),
      d = new Hn(c, a);
    return (
      d.emptyItemCount() > SA && (d = d.compress(this.items.length - r.length)),
      d
    );
  }
  emptyItemCount() {
    let e = 0;
    return (
      this.items.forEach((n) => {
        n.step || e++;
      }),
      e
    );
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e),
      r = n.maps.length,
      o = [],
      i = 0;
    return (
      this.items.forEach(
        (s, a) => {
          if (a >= e) o.push(s), s.selection && i++;
          else if (s.step) {
            let l = s.step.map(n.slice(r)),
              u = l && l.getMap();
            if ((r--, u && n.appendMap(u, r), l)) {
              let c = s.selection && s.selection.map(n.slice(r));
              c && i++;
              let d = new nr(u.invert(), l, c),
                f,
                p = o.length - 1;
              (f = o.length && o[p].merge(d)) ? (o[p] = f) : o.push(d);
            }
          } else s.map && r--;
        },
        this.items.length,
        0
      ),
      new Hn(Fv.from(o.reverse()), i)
    );
  }
}
Hn.empty = new Hn(Fv.empty, 0);
function EA(t, e) {
  let n;
  return (
    t.forEach((r, o) => {
      if (r.selection && e-- == 0) return (n = o), !1;
    }),
    t.slice(n)
  );
}
class nr {
  constructor(e, n, r, o) {
    (this.map = e),
      (this.step = n),
      (this.selection = r),
      (this.mirrorOffset = o);
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n) return new nr(n.getMap().invert(), n, this.selection);
    }
  }
}
class ro {
  constructor(e, n, r, o, i) {
    (this.done = e),
      (this.undone = n),
      (this.prevRanges = r),
      (this.prevTime = o),
      (this.prevComposition = i);
  }
}
const MA = 20;
function TA(t, e, n, r) {
  let o = n.getMeta(Ur),
    i;
  if (o) return o.historyState;
  n.getMeta(zv) && (t = new ro(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0) return t;
  if (s && s.getMeta(Ur))
    return s.getMeta(Ur).redo
      ? new ro(
          t.done.addTransform(n, void 0, r, Ul(e)),
          t.undone,
          j1(n.mapping.maps),
          t.prevTime,
          t.prevComposition
        )
      : new ro(
          t.done,
          t.undone.addTransform(n, void 0, r, Ul(e)),
          null,
          t.prevTime,
          t.prevComposition
        );
  if (
    n.getMeta("addToHistory") !== !1 &&
    !(s && s.getMeta("addToHistory") === !1)
  ) {
    let a = n.getMeta("composition"),
      l =
        t.prevTime == 0 ||
        (!s &&
          t.prevComposition != a &&
          (t.prevTime < (n.time || 0) - r.newGroupDelay ||
            !OA(n, t.prevRanges))),
      u = s ? Jd(t.prevRanges, n.mapping) : j1(n.mapping.maps);
    return new ro(
      t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, Ul(e)),
      Hn.empty,
      u,
      n.time,
      a ?? t.prevComposition
    );
  } else
    return (i = n.getMeta("rebased"))
      ? new ro(
          t.done.rebased(n, i),
          t.undone.rebased(n, i),
          Jd(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        )
      : new ro(
          t.done.addMaps(n.mapping.maps),
          t.undone.addMaps(n.mapping.maps),
          Jd(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        );
}
function OA(t, e) {
  if (!e) return !1;
  if (!t.docChanged) return !0;
  let n = !1;
  return (
    t.mapping.maps[0].forEach((r, o) => {
      for (let i = 0; i < e.length; i += 2)
        r <= e[i + 1] && o >= e[i] && (n = !0);
    }),
    n
  );
}
function j1(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, o, i, s) => e.push(i, s));
  return e;
}
function Jd(t, e) {
  if (!t) return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let o = e.map(t[r], 1),
      i = e.map(t[r + 1], -1);
    o <= i && n.push(o, i);
  }
  return n;
}
function DA(t, e, n) {
  let r = Ul(e),
    o = Ur.get(e).spec.config,
    i = (n ? t.undone : t.done).popEvent(e, r);
  if (!i) return null;
  let s = i.selection.resolve(i.transform.doc),
    a = (n ? t.done : t.undone).addTransform(
      i.transform,
      e.selection.getBookmark(),
      o,
      r
    ),
    l = new ro(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
  return i.transform.setSelection(s).setMeta(Ur, { redo: n, historyState: l });
}
let Yd = !1,
  W1 = null;
function Ul(t) {
  let e = t.plugins;
  if (W1 != e) {
    (Yd = !1), (W1 = e);
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Yd = !0;
        break;
      }
  }
  return Yd;
}
function cV(t) {
  return t.setMeta(zv, !0);
}
const Ur = new ke("history"),
  zv = new ke("closeHistory");
function NA(t = {}) {
  return (
    (t = {
      depth: t.depth || 100,
      newGroupDelay: t.newGroupDelay || 500,
    }),
    new be({
      key: Ur,
      state: {
        init() {
          return new ro(Hn.empty, Hn.empty, null, 0, -1);
        },
        apply(e, n, r) {
          return TA(n, r, e, t);
        },
      },
      config: t,
      props: {
        handleDOMEvents: {
          beforeinput(e, n) {
            let r = n.inputType,
              o = r == "historyUndo" ? xu : r == "historyRedo" ? ku : null;
            return o ? (n.preventDefault(), o(e.state, e.dispatch)) : !1;
          },
        },
      },
    })
  );
}
function Zc(t, e) {
  return (n, r) => {
    let o = Ur.getState(n);
    if (!o || (t ? o.undone : o.done).eventCount == 0) return !1;
    if (r) {
      let i = DA(o, n, t);
      i && r(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const xu = Zc(!1, !0),
  ku = Zc(!0, !0),
  dV = Zc(!1, !1),
  fV = Zc(!0, !1);
function pV(t) {
  let e = Ur.getState(t);
  return e ? e.done.eventCount : 0;
}
function hV(t) {
  let e = Ur.getState(t);
  return e ? e.undone.eventCount : 0;
}
let Do = class {
  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number)  ?Transaction>)
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, n, r = {}) {
    (this.match = e),
      (this.match = e),
      (this.handler = typeof n == "string" ? LA(n) : n),
      (this.undoable = r.undoable !== !1),
      (this.inCode = r.inCode || !1);
  }
};
function LA(t) {
  return function (e, n, r, o) {
    let i = t;
    if (n[1]) {
      let s = n[0].lastIndexOf(n[1]);
      (i += n[0].slice(s + n[1].length)), (r += s);
      let a = r - o;
      a > 0 && ((i = n[0].slice(s - a, s) + i), (r = o));
    }
    return e.tr.insertText(i, r, o);
  };
}
const RA = 500;
function gV({ rules: t }) {
  let e = new be({
    state: {
      init() {
        return null;
      },
      apply(n, r) {
        let o = n.getMeta(this);
        return o || (n.selectionSet || n.docChanged ? null : r);
      },
    },
    props: {
      handleTextInput(n, r, o, i) {
        return q1(n, r, o, i, t, e);
      },
      handleDOMEvents: {
        compositionend: (n) => {
          setTimeout(() => {
            let { $cursor: r } = n.state.selection;
            r && q1(n, r.pos, r.pos, "", t, e);
          });
        },
      },
    },
    isInputRules: !0,
  });
  return e;
}
function q1(t, e, n, r, o, i) {
  if (t.composing) return !1;
  let s = t.state,
    a = s.doc.resolve(e),
    l =
      a.parent.textBetween(
        Math.max(0, a.parentOffset - RA),
        a.parentOffset,
        null,
        ""
      ) + r;
  for (let u = 0; u < o.length; u++) {
    let c = o[u];
    if (a.parent.type.spec.code) {
      if (!c.inCode) continue;
    } else if (c.inCode === "only") continue;
    let d = c.match.exec(l),
      f = d && c.handler(s, d, e - (d[0].length - r.length), n);
    if (f)
      return (
        c.undoable && f.setMeta(i, { transform: f, from: e, to: n, text: r }),
        t.dispatch(f),
        !0
      );
  }
  return !1;
}
const bV = (t, e) => {
    let n = t.plugins;
    for (let r = 0; r < n.length; r++) {
      let o = n[r],
        i;
      if (o.spec.isInputRules && (i = o.getState(t))) {
        if (e) {
          let s = t.tr,
            a = i.transform;
          for (let l = a.steps.length - 1; l >= 0; l--)
            s.step(a.steps[l].invert(a.docs[l]));
          if (i.text) {
            let l = s.doc.resolve(i.from).marks();
            s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
          } else s.delete(i.from, i.to);
          e(s);
        }
        return !0;
      }
    }
    return !1;
  },
  yV = new Do(/--$/, ""),
  vV = new Do(/\.\.\.$/, ""),
  IA = new Do(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, ""),
  PA = new Do(/"$/, ""),
  $A = new Do(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, ""),
  BA = new Do(/'$/, ""),
  _V = [IA, PA, $A, BA];
function xV(t, e, n = null, r) {
  return new Do(t, (o, i, s, a) => {
    let l = n instanceof Function ? n(i) : n,
      u = o.tr.delete(s, a),
      c = u.doc.resolve(s),
      d = c.blockRange(),
      f = d && jc(d, e, l);
    if (!f) return null;
    u.wrap(d, f);
    let p = u.doc.resolve(s - 1).nodeBefore;
    return (
      p && p.type == e && _r(u.doc, s - 1) && (!r || r(i, p)) && u.join(s - 1),
      u
    );
  });
}
function kV(t, e, n = null) {
  return new Do(t, (r, o, i, s) => {
    let a = r.doc.resolve(i),
      l = n instanceof Function ? n(o) : n;
    return a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), e)
      ? r.tr.delete(i, s).setBlockType(i, i, e, l)
      : null;
  });
}
const K1 = {};
function HA(t) {
  let e = K1[t];
  if (e) return e;
  e = K1[t] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    e.push(r);
  }
  for (let n = 0; n < t.length; n++) {
    const r = t.charCodeAt(n);
    e[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Ki(t, e) {
  typeof e != "string" && (e = Ki.defaultChars);
  const n = HA(e);
  return t.replace(/(%[a-f0-9]{2})+/gi, function (r) {
    let o = "";
    for (let i = 0, s = r.length; i < s; i += 3) {
      const a = parseInt(r.slice(i + 1, i + 3), 16);
      if (a < 128) {
        o += n[a];
        continue;
      }
      if ((a & 224) === 192 && i + 3 < s) {
        const l = parseInt(r.slice(i + 4, i + 6), 16);
        if ((l & 192) === 128) {
          const u = ((a << 6) & 1984) | (l & 63);
          u < 128 ? (o += "") : (o += String.fromCharCode(u)), (i += 3);
          continue;
        }
      }
      if ((a & 240) === 224 && i + 6 < s) {
        const l = parseInt(r.slice(i + 4, i + 6), 16),
          u = parseInt(r.slice(i + 7, i + 9), 16);
        if ((l & 192) === 128 && (u & 192) === 128) {
          const c = ((a << 12) & 61440) | ((l << 6) & 4032) | (u & 63);
          c < 2048 || (c >= 55296 && c <= 57343)
            ? (o += "")
            : (o += String.fromCharCode(c)),
            (i += 6);
          continue;
        }
      }
      if ((a & 248) === 240 && i + 9 < s) {
        const l = parseInt(r.slice(i + 4, i + 6), 16),
          u = parseInt(r.slice(i + 7, i + 9), 16),
          c = parseInt(r.slice(i + 10, i + 12), 16);
        if ((l & 192) === 128 && (u & 192) === 128 && (c & 192) === 128) {
          let d =
            ((a << 18) & 1835008) |
            ((l << 12) & 258048) |
            ((u << 6) & 4032) |
            (c & 63);
          d < 65536 || d > 1114111
            ? (o += "")
            : ((d -= 65536),
              (o += String.fromCharCode(
                55296 + (d >> 10),
                56320 + (d & 1023)
              ))),
            (i += 9);
          continue;
        }
      }
      o += "";
    }
    return o;
  });
}
Ki.defaultChars = ";/?:@&=+$,#";
Ki.componentChars = "";
const G1 = {};
function FA(t) {
  let e = G1[t];
  if (e) return e;
  e = G1[t] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(r)
      ? e.push(r)
      : e.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < t.length; n++) e[t.charCodeAt(n)] = t[n];
  return e;
}
function Oa(t, e, n) {
  typeof e != "string" && ((n = e), (e = Oa.defaultChars)),
    typeof n > "u" && (n = !0);
  const r = FA(e);
  let o = "";
  for (let i = 0, s = t.length; i < s; i++) {
    const a = t.charCodeAt(i);
    if (
      n &&
      a === 37 &&
      i + 2 < s &&
      /^[0-9a-f]{2}$/i.test(t.slice(i + 1, i + 3))
    ) {
      (o += t.slice(i, i + 3)), (i += 2);
      continue;
    }
    if (a < 128) {
      o += r[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && i + 1 < s) {
        const l = t.charCodeAt(i + 1);
        if (l >= 56320 && l <= 57343) {
          (o += encodeURIComponent(t[i] + t[i + 1])), i++;
          continue;
        }
      }
      o += "%EF%BF%BD";
      continue;
    }
    o += encodeURIComponent(t[i]);
  }
  return o;
}
Oa.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Oa.componentChars = "-_.!~*'()";
function Jh(t) {
  let e = "";
  return (
    (e += t.protocol || ""),
    (e += t.slashes ? "//" : ""),
    (e += t.auth ? t.auth + "@" : ""),
    t.hostname && t.hostname.indexOf(":") !== -1
      ? (e += "[" + t.hostname + "]")
      : (e += t.hostname || ""),
    (e += t.port ? ":" + t.port : ""),
    (e += t.pathname || ""),
    (e += t.search || ""),
    (e += t.hash || ""),
    e
  );
}
function wu() {
  (this.protocol = null),
    (this.slashes = null),
    (this.auth = null),
    (this.port = null),
    (this.hostname = null),
    (this.hash = null),
    (this.search = null),
    (this.pathname = null);
}
const zA = /^([a-z0-9.+-]+:)/i,
  VA = /:[0-9]*$/,
  UA = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
  jA = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	",
  ],
  WA = ["{", "}", "|", "\\", "^", "`"].concat(jA),
  qA = ["'"].concat(WA),
  J1 = ["%", "/", "?", ";", "#"].concat(qA),
  Y1 = ["/", "?", "#"],
  KA = 255,
  X1 = /^[+a-z0-9A-Z_-]{0,63}$/,
  GA = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  Z1 = {
    javascript: !0,
    "javascript:": !0,
  },
  Q1 = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0,
  };
function Yh(t, e) {
  if (t && t instanceof wu) return t;
  const n = new wu();
  return n.parse(t, e), n;
}
wu.prototype.parse = function (t, e) {
  let n,
    r,
    o,
    i = t;
  if (((i = i.trim()), !e && t.split("#").length === 1)) {
    const u = UA.exec(i);
    if (u) return (this.pathname = u[1]), u[2] && (this.search = u[2]), this;
  }
  let s = zA.exec(i);
  if (
    (s &&
      ((s = s[0]),
      (n = s.toLowerCase()),
      (this.protocol = s),
      (i = i.substr(s.length))),
    (e || s || i.match(/^\/\/[^@\/]+@[^@\/]+/)) &&
      ((o = i.substr(0, 2) === "//"),
      o && !(s && Z1[s]) && ((i = i.substr(2)), (this.slashes = !0))),
    !Z1[s] && (o || (s && !Q1[s])))
  ) {
    let u = -1;
    for (let h = 0; h < Y1.length; h++)
      (r = i.indexOf(Y1[h])), r !== -1 && (u === -1 || r < u) && (u = r);
    let c, d;
    u === -1 ? (d = i.lastIndexOf("@")) : (d = i.lastIndexOf("@", u)),
      d !== -1 && ((c = i.slice(0, d)), (i = i.slice(d + 1)), (this.auth = c)),
      (u = -1);
    for (let h = 0; h < J1.length; h++)
      (r = i.indexOf(J1[h])), r !== -1 && (u === -1 || r < u) && (u = r);
    u === -1 && (u = i.length), i[u - 1] === ":" && u--;
    const f = i.slice(0, u);
    (i = i.slice(u)), this.parseHost(f), (this.hostname = this.hostname || "");
    const p =
      this.hostname[0] === "[" &&
      this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const h = this.hostname.split(/\./);
      for (let m = 0, g = h.length; m < g; m++) {
        const b = h[m];
        if (b && !b.match(X1)) {
          let _ = "";
          for (let v = 0, y = b.length; v < y; v++)
            b.charCodeAt(v) > 127 ? (_ += "x") : (_ += b[v]);
          if (!_.match(X1)) {
            const v = h.slice(0, m),
              y = h.slice(m + 1),
              w = b.match(GA);
            w && (v.push(w[1]), y.unshift(w[2])),
              y.length && (i = y.join(".") + i),
              (this.hostname = v.join("."));
            break;
          }
        }
      }
    }
    this.hostname.length > KA && (this.hostname = ""),
      p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = i.indexOf("#");
  a !== -1 && ((this.hash = i.substr(a)), (i = i.slice(0, a)));
  const l = i.indexOf("?");
  return (
    l !== -1 && ((this.search = i.substr(l)), (i = i.slice(0, l))),
    i && (this.pathname = i),
    Q1[n] && this.hostname && !this.pathname && (this.pathname = ""),
    this
  );
};
wu.prototype.parseHost = function (t) {
  let e = VA.exec(t);
  e &&
    ((e = e[0]),
    e !== ":" && (this.port = e.substr(1)),
    (t = t.substr(0, t.length - e.length))),
    t && (this.hostname = t);
};
const JA = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        decode: Ki,
        encode: Oa,
        format: Jh,
        parse: Yh,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Vv =
    /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  Uv = /[\0-\x1F\x7F-\x9F]/,
  YA =
    /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/,
  Xh =
    /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  jv = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,
  XA = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Any: Vv,
        Cc: Uv,
        Cf: YA,
        P: Xh,
        Z: jv,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  ZA = new Uint16Array(
    // prettier-ignore
    '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((t) => t.charCodeAt(0))
  ),
  QA = new Uint16Array(
    // prettier-ignore
    "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((t) => t.charCodeAt(0))
  );
var Xd;
const eS = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
  ]),
  tS =
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (Xd = String.fromCodePoint) !== null && Xd !== void 0
      ? Xd
      : function (t) {
          let e = "";
          return (
            t > 65535 &&
              ((t -= 65536),
              (e += String.fromCharCode(((t >>> 10) & 1023) | 55296)),
              (t = 56320 | (t & 1023))),
            (e += String.fromCharCode(t)),
            e
          );
        };
function nS(t) {
  var e;
  return (t >= 55296 && t <= 57343) || t > 1114111
    ? 65533
    : (e = eS.get(t)) !== null && e !== void 0
    ? e
    : t;
}
var ht;
(function (t) {
  (t[(t.NUM = 35)] = "NUM"),
    (t[(t.SEMI = 59)] = "SEMI"),
    (t[(t.EQUALS = 61)] = "EQUALS"),
    (t[(t.ZERO = 48)] = "ZERO"),
    (t[(t.NINE = 57)] = "NINE"),
    (t[(t.LOWER_A = 97)] = "LOWER_A"),
    (t[(t.LOWER_F = 102)] = "LOWER_F"),
    (t[(t.LOWER_X = 120)] = "LOWER_X"),
    (t[(t.LOWER_Z = 122)] = "LOWER_Z"),
    (t[(t.UPPER_A = 65)] = "UPPER_A"),
    (t[(t.UPPER_F = 70)] = "UPPER_F"),
    (t[(t.UPPER_Z = 90)] = "UPPER_Z");
})(ht || (ht = {}));
const rS = 32;
var go;
(function (t) {
  (t[(t.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
    (t[(t.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
    (t[(t.JUMP_TABLE = 127)] = "JUMP_TABLE");
})(go || (go = {}));
function kp(t) {
  return t >= ht.ZERO && t <= ht.NINE;
}
function oS(t) {
  return (
    (t >= ht.UPPER_A && t <= ht.UPPER_F) || (t >= ht.LOWER_A && t <= ht.LOWER_F)
  );
}
function iS(t) {
  return (
    (t >= ht.UPPER_A && t <= ht.UPPER_Z) ||
    (t >= ht.LOWER_A && t <= ht.LOWER_Z) ||
    kp(t)
  );
}
function sS(t) {
  return t === ht.EQUALS || iS(t);
}
var dt;
(function (t) {
  (t[(t.EntityStart = 0)] = "EntityStart"),
    (t[(t.NumericStart = 1)] = "NumericStart"),
    (t[(t.NumericDecimal = 2)] = "NumericDecimal"),
    (t[(t.NumericHex = 3)] = "NumericHex"),
    (t[(t.NamedEntity = 4)] = "NamedEntity");
})(dt || (dt = {}));
var uo;
(function (t) {
  (t[(t.Legacy = 0)] = "Legacy"),
    (t[(t.Strict = 1)] = "Strict"),
    (t[(t.Attribute = 2)] = "Attribute");
})(uo || (uo = {}));
class aS {
  constructor(e, n, r) {
    (this.decodeTree = e),
      (this.emitCodePoint = n),
      (this.errors = r),
      (this.state = dt.EntityStart),
      (this.consumed = 1),
      (this.result = 0),
      (this.treeIndex = 0),
      (this.excess = 1),
      (this.decodeMode = uo.Strict);
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    (this.decodeMode = e),
      (this.state = dt.EntityStart),
      (this.result = 0),
      (this.treeIndex = 0),
      (this.excess = 1),
      (this.consumed = 1);
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case dt.EntityStart:
        return e.charCodeAt(n) === ht.NUM
          ? ((this.state = dt.NumericStart),
            (this.consumed += 1),
            this.stateNumericStart(e, n + 1))
          : ((this.state = dt.NamedEntity), this.stateNamedEntity(e, n));
      case dt.NumericStart:
        return this.stateNumericStart(e, n);
      case dt.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case dt.NumericHex:
        return this.stateNumericHex(e, n);
      case dt.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length
      ? -1
      : (e.charCodeAt(n) | rS) === ht.LOWER_X
      ? ((this.state = dt.NumericHex),
        (this.consumed += 1),
        this.stateNumericHex(e, n + 1))
      : ((this.state = dt.NumericDecimal), this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, o) {
    if (n !== r) {
      const i = r - n;
      (this.result =
        this.result * Math.pow(o, i) + parseInt(e.substr(n, i), o)),
        (this.consumed += i);
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const o = e.charCodeAt(n);
      if (kp(o) || oS(o)) n += 1;
      else
        return (
          this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(o, 3)
        );
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const o = e.charCodeAt(n);
      if (kp(o)) n += 1;
      else
        return (
          this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(o, 2)
        );
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (
        (r = this.errors) === null ||
          r === void 0 ||
          r.absenceOfDigitsInNumericCharacterReference(this.consumed),
        0
      );
    if (e === ht.SEMI) this.consumed += 1;
    else if (this.decodeMode === uo.Strict) return 0;
    return (
      this.emitCodePoint(nS(this.result), this.consumed),
      this.errors &&
        (e !== ht.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
        this.errors.validateNumericCharacterReference(this.result)),
      this.consumed
    );
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let o = r[this.treeIndex],
      i = (o & go.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const s = e.charCodeAt(n);
      if (
        ((this.treeIndex = lS(r, o, this.treeIndex + Math.max(1, i), s)),
        this.treeIndex < 0)
      )
        return this.result === 0 || // If we are parsing an attribute
          (this.decodeMode === uo.Attribute && // We shouldn't have consumed any characters after the entity,
            (i === 0 || // And there should be no invalid characters.
              sS(s)))
          ? 0
          : this.emitNotTerminatedNamedEntity();
      if (
        ((o = r[this.treeIndex]), (i = (o & go.VALUE_LENGTH) >> 14), i !== 0)
      ) {
        if (s === ht.SEMI)
          return this.emitNamedEntityData(
            this.treeIndex,
            i,
            this.consumed + this.excess
          );
        this.decodeMode !== uo.Strict &&
          ((this.result = this.treeIndex),
          (this.consumed += this.excess),
          (this.excess = 0));
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this,
      o = (r[n] & go.VALUE_LENGTH) >> 14;
    return (
      this.emitNamedEntityData(n, o, this.consumed),
      (e = this.errors) === null ||
        e === void 0 ||
        e.missingSemicolonAfterCharacterReference(),
      this.consumed
    );
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: o } = this;
    return (
      this.emitCodePoint(n === 1 ? o[e] & ~go.VALUE_LENGTH : o[e + 1], r),
      n === 3 && this.emitCodePoint(o[e + 2], r),
      r
    );
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case dt.NamedEntity:
        return this.result !== 0 &&
          (this.decodeMode !== uo.Attribute || this.result === this.treeIndex)
          ? this.emitNotTerminatedNamedEntity()
          : 0;
      // Otherwise, emit a numeric entity if we have one.
      case dt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case dt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case dt.NumericStart:
        return (
          (e = this.errors) === null ||
            e === void 0 ||
            e.absenceOfDigitsInNumericCharacterReference(this.consumed),
          0
        );
      case dt.EntityStart:
        return 0;
    }
  }
}
function Wv(t) {
  let e = "";
  const n = new aS(t, (r) => (e += tS(r)));
  return function (o, i) {
    let s = 0,
      a = 0;
    for (; (a = o.indexOf("&", a)) >= 0; ) {
      (e += o.slice(s, a)), n.startEntity(i);
      const u = n.write(
        o,
        // Skip the "&"
        a + 1
      );
      if (u < 0) {
        s = a + n.end();
        break;
      }
      (s = a + u), (a = u === 0 ? s + 1 : s);
    }
    const l = e + o.slice(s);
    return (e = ""), l;
  };
}
function lS(t, e, n, r) {
  const o = (e & go.BRANCH_LENGTH) >> 7,
    i = e & go.JUMP_TABLE;
  if (o === 0) return i !== 0 && r === i ? n : -1;
  if (i) {
    const l = r - i;
    return l < 0 || l >= o ? -1 : t[n + l] - 1;
  }
  let s = n,
    a = s + o - 1;
  for (; s <= a; ) {
    const l = (s + a) >>> 1,
      u = t[l];
    if (u < r) s = l + 1;
    else if (u > r) a = l - 1;
    else return t[l + o];
  }
  return -1;
}
const uS = Wv(ZA);
Wv(QA);
function qv(t, e = uo.Legacy) {
  return uS(t, e);
}
function cS(t) {
  return Object.prototype.toString.call(t);
}
function Zh(t) {
  return cS(t) === "[object String]";
}
const dS = Object.prototype.hasOwnProperty;
function fS(t, e) {
  return dS.call(t, e);
}
function Qc(t) {
  return (
    Array.prototype.slice.call(arguments, 1).forEach(function (n) {
      if (n) {
        if (typeof n != "object") throw new TypeError(n + "must be object");
        Object.keys(n).forEach(function (r) {
          t[r] = n[r];
        });
      }
    }),
    t
  );
}
function Kv(t, e, n) {
  return [].concat(t.slice(0, e), n, t.slice(e + 1));
}
function Qh(t) {
  return !(
    (t >= 55296 && t <= 57343) ||
    (t >= 64976 && t <= 65007) ||
    (t & 65535) === 65535 ||
    (t & 65535) === 65534 ||
    (t >= 0 && t <= 8) ||
    t === 11 ||
    (t >= 14 && t <= 31) ||
    (t >= 127 && t <= 159) ||
    t > 1114111
  );
}
function Cu(t) {
  if (t > 65535) {
    t -= 65536;
    const e = 55296 + (t >> 10),
      n = 56320 + (t & 1023);
    return String.fromCharCode(e, n);
  }
  return String.fromCharCode(t);
}
const Gv = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g,
  pS = /&([a-z#][a-z0-9]{1,31});/gi,
  hS = new RegExp(Gv.source + "|" + pS.source, "gi"),
  mS = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function gS(t, e) {
  if (e.charCodeAt(0) === 35 && mS.test(e)) {
    const r =
      e[1].toLowerCase() === "x"
        ? parseInt(e.slice(2), 16)
        : parseInt(e.slice(1), 10);
    return Qh(r) ? Cu(r) : t;
  }
  const n = qv(t);
  return n !== t ? n : t;
}
function bS(t) {
  return t.indexOf("\\") < 0 ? t : t.replace(Gv, "$1");
}
function la(t) {
  return t.indexOf("\\") < 0 && t.indexOf("&") < 0
    ? t
    : t.replace(hS, function (e, n, r) {
        return n || gS(e, r);
      });
}
const yS = /[&<>"]/,
  vS = /[&<>"]/g,
  _S = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
  };
function xS(t) {
  return _S[t];
}
function Ao(t) {
  return yS.test(t) ? t.replace(vS, xS) : t;
}
const kS = /[.?*+^$[\]\\(){}|-]/g;
function wS(t) {
  return t.replace(kS, "\\$&");
}
function Ue(t) {
  switch (t) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function ua(t) {
  if (t >= 8192 && t <= 8202) return !0;
  switch (t) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function ca(t) {
  return Xh.test(t);
}
function da(t) {
  switch (t) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function ed(t) {
  return (
    (t = t.trim().replace(/\s+/g, " ")),
    "".toLowerCase() === "" && (t = t.replace(//g, "")),
    t.toLowerCase().toUpperCase()
  );
}
const CS = { mdurl: JA, ucmicro: XA },
  AS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        arrayReplaceAt: Kv,
        assign: Qc,
        escapeHtml: Ao,
        escapeRE: wS,
        fromCodePoint: Cu,
        has: fS,
        isMdAsciiPunct: da,
        isPunctChar: ca,
        isSpace: Ue,
        isString: Zh,
        isValidEntityCode: Qh,
        isWhiteSpace: ua,
        lib: CS,
        normalizeReference: ed,
        unescapeAll: la,
        unescapeMd: bS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function SS(t, e, n) {
  let r, o, i, s;
  const a = t.posMax,
    l = t.pos;
  for (t.pos = e + 1, r = 1; t.pos < a; ) {
    if (((i = t.src.charCodeAt(t.pos)), i === 93 && (r--, r === 0))) {
      o = !0;
      break;
    }
    if (((s = t.pos), t.md.inline.skipToken(t), i === 91)) {
      if (s === t.pos - 1) r++;
      else if (n) return (t.pos = l), -1;
    }
  }
  let u = -1;
  return o && (u = t.pos), (t.pos = l), u;
}
function ES(t, e, n) {
  let r,
    o = e;
  const i = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: "",
  };
  if (t.charCodeAt(o) === 60) {
    for (o++; o < n; ) {
      if (((r = t.charCodeAt(o)), r === 10 || r === 60)) return i;
      if (r === 62)
        return (i.pos = o + 1), (i.str = la(t.slice(e + 1, o))), (i.ok = !0), i;
      if (r === 92 && o + 1 < n) {
        o += 2;
        continue;
      }
      o++;
    }
    return i;
  }
  let s = 0;
  for (
    ;
    o < n && ((r = t.charCodeAt(o)), !(r === 32 || r < 32 || r === 127));

  ) {
    if (r === 92 && o + 1 < n) {
      if (t.charCodeAt(o + 1) === 32) break;
      o += 2;
      continue;
    }
    if (r === 40 && (s++, s > 32)) return i;
    if (r === 41) {
      if (s === 0) break;
      s--;
    }
    o++;
  }
  return (
    e === o ||
      s !== 0 ||
      ((i.str = la(t.slice(e, o))), (i.pos = o), (i.ok = !0)),
    i
  );
}
function MS(t, e, n) {
  let r,
    o,
    i = 0,
    s = e;
  const a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: "",
  };
  if (s >= n || ((o = t.charCodeAt(s)), o !== 34 && o !== 39 && o !== 40))
    return a;
  for (s++, o === 40 && (o = 41); s < n; ) {
    if (((r = t.charCodeAt(s)), r === o))
      return (
        (a.pos = s + 1),
        (a.lines = i),
        (a.str = la(t.slice(e + 1, s))),
        (a.ok = !0),
        a
      );
    if (r === 40 && o === 41) return a;
    r === 10
      ? i++
      : r === 92 && s + 1 < n && (s++, t.charCodeAt(s) === 10 && i++),
      s++;
  }
  return a;
}
const TS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        parseLinkDestination: ES,
        parseLinkLabel: SS,
        parseLinkTitle: MS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  xr = {};
xr.code_inline = function (t, e, n, r, o) {
  const i = t[e];
  return "<code" + o.renderAttrs(i) + ">" + Ao(i.content) + "</code>";
};
xr.code_block = function (t, e, n, r, o) {
  const i = t[e];
  return (
    "<pre" +
    o.renderAttrs(i) +
    "><code>" +
    Ao(t[e].content) +
    `</code></pre>
`
  );
};
xr.fence = function (t, e, n, r, o) {
  const i = t[e],
    s = i.info ? la(i.info).trim() : "";
  let a = "",
    l = "";
  if (s) {
    const c = s.split(/(\s+)/g);
    (a = c[0]), (l = c.slice(2).join(""));
  }
  let u;
  if (
    (n.highlight
      ? (u = n.highlight(i.content, a, l) || Ao(i.content))
      : (u = Ao(i.content)),
    u.indexOf("<pre") === 0)
  )
    return (
      u +
      `
`
    );
  if (s) {
    const c = i.attrIndex("class"),
      d = i.attrs ? i.attrs.slice() : [];
    c < 0
      ? d.push(["class", n.langPrefix + a])
      : ((d[c] = d[c].slice()), (d[c][1] += " " + n.langPrefix + a));
    const f = {
      attrs: d,
    };
    return `<pre><code${o.renderAttrs(f)}>${u}</code></pre>
`;
  }
  return `<pre><code${o.renderAttrs(i)}>${u}</code></pre>
`;
};
xr.image = function (t, e, n, r, o) {
  const i = t[e];
  return (
    (i.attrs[i.attrIndex("alt")][1] = o.renderInlineAsText(i.children, n, r)),
    o.renderToken(t, e, n)
  );
};
xr.hardbreak = function (t, e, n) {
  return n.xhtmlOut
    ? `<br />
`
    : `<br>
`;
};
xr.softbreak = function (t, e, n) {
  return n.breaks
    ? n.xhtmlOut
      ? `<br />
`
      : `<br>
`
    : `
`;
};
xr.text = function (t, e) {
  return Ao(t[e].content);
};
xr.html_block = function (t, e) {
  return t[e].content;
};
xr.html_inline = function (t, e) {
  return t[e].content;
};
function rs() {
  this.rules = Qc({}, xr);
}
rs.prototype.renderAttrs = function (e) {
  let n, r, o;
  if (!e.attrs) return "";
  for (o = "", n = 0, r = e.attrs.length; n < r; n++)
    o += " " + Ao(e.attrs[n][0]) + '="' + Ao(e.attrs[n][1]) + '"';
  return o;
};
rs.prototype.renderToken = function (e, n, r) {
  const o = e[n];
  let i = "";
  if (o.hidden) return "";
  o.block &&
    o.nesting !== -1 &&
    n &&
    e[n - 1].hidden &&
    (i += `
`),
    (i += (o.nesting === -1 ? "</" : "<") + o.tag),
    (i += this.renderAttrs(o)),
    o.nesting === 0 && r.xhtmlOut && (i += " /");
  let s = !1;
  if (o.block && ((s = !0), o.nesting === 1 && n + 1 < e.length)) {
    const a = e[n + 1];
    (a.type === "inline" ||
      a.hidden ||
      (a.nesting === -1 && a.tag === o.tag)) &&
      (s = !1);
  }
  return (
    (i += s
      ? `>
`
      : ">"),
    i
  );
};
rs.prototype.renderInline = function (t, e, n) {
  let r = "";
  const o = this.rules;
  for (let i = 0, s = t.length; i < s; i++) {
    const a = t[i].type;
    typeof o[a] < "u"
      ? (r += o[a](t, i, e, n, this))
      : (r += this.renderToken(t, i, e));
  }
  return r;
};
rs.prototype.renderInlineAsText = function (t, e, n) {
  let r = "";
  for (let o = 0, i = t.length; o < i; o++)
    switch (t[o].type) {
      case "text":
        r += t[o].content;
        break;
      case "image":
        r += this.renderInlineAsText(t[o].children, e, n);
        break;
      case "html_inline":
      case "html_block":
        r += t[o].content;
        break;
      case "softbreak":
      case "hardbreak":
        r += `
`;
        break;
    }
  return r;
};
rs.prototype.render = function (t, e, n) {
  let r = "";
  const o = this.rules;
  for (let i = 0, s = t.length; i < s; i++) {
    const a = t[i].type;
    a === "inline"
      ? (r += this.renderInline(t[i].children, e, n))
      : typeof o[a] < "u"
      ? (r += o[a](t, i, e, n, this))
      : (r += this.renderToken(t, i, e, n));
  }
  return r;
};
function en() {
  (this.__rules__ = []), (this.__cache__ = null);
}
en.prototype.__find__ = function (t) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t) return e;
  return -1;
};
en.prototype.__compile__ = function () {
  const t = this,
    e = [""];
  t.__rules__.forEach(function (n) {
    n.enabled &&
      n.alt.forEach(function (r) {
        e.indexOf(r) < 0 && e.push(r);
      });
  }),
    (t.__cache__ = {}),
    e.forEach(function (n) {
      (t.__cache__[n] = []),
        t.__rules__.forEach(function (r) {
          r.enabled &&
            ((n && r.alt.indexOf(n) < 0) || t.__cache__[n].push(r.fn));
        });
    });
};
en.prototype.at = function (t, e, n) {
  const r = this.__find__(t),
    o = n || {};
  if (r === -1) throw new Error("Parser rule not found: " + t);
  (this.__rules__[r].fn = e),
    (this.__rules__[r].alt = o.alt || []),
    (this.__cache__ = null);
};
en.prototype.before = function (t, e, n, r) {
  const o = this.__find__(t),
    i = r || {};
  if (o === -1) throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(o, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: i.alt || [],
  }),
    (this.__cache__ = null);
};
en.prototype.after = function (t, e, n, r) {
  const o = this.__find__(t),
    i = r || {};
  if (o === -1) throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(o + 1, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: i.alt || [],
  }),
    (this.__cache__ = null);
};
en.prototype.push = function (t, e, n) {
  const r = n || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: r.alt || [],
  }),
    (this.__cache__ = null);
};
en.prototype.enable = function (t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return (
    t.forEach(function (r) {
      const o = this.__find__(r);
      if (o < 0) {
        if (e) return;
        throw new Error("Rules manager: invalid rule name " + r);
      }
      (this.__rules__[o].enabled = !0), n.push(r);
    }, this),
    (this.__cache__ = null),
    n
  );
};
en.prototype.enableOnly = function (t, e) {
  Array.isArray(t) || (t = [t]),
    this.__rules__.forEach(function (n) {
      n.enabled = !1;
    }),
    this.enable(t, e);
};
en.prototype.disable = function (t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return (
    t.forEach(function (r) {
      const o = this.__find__(r);
      if (o < 0) {
        if (e) return;
        throw new Error("Rules manager: invalid rule name " + r);
      }
      (this.__rules__[o].enabled = !1), n.push(r);
    }, this),
    (this.__cache__ = null),
    n
  );
};
en.prototype.getRules = function (t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
function Yn(t, e, n) {
  (this.type = t),
    (this.tag = e),
    (this.attrs = null),
    (this.map = null),
    (this.nesting = n),
    (this.level = 0),
    (this.children = null),
    (this.content = ""),
    (this.markup = ""),
    (this.info = ""),
    (this.meta = null),
    (this.block = !1),
    (this.hidden = !1);
}
Yn.prototype.attrIndex = function (e) {
  if (!this.attrs) return -1;
  const n = this.attrs;
  for (let r = 0, o = n.length; r < o; r++) if (n[r][0] === e) return r;
  return -1;
};
Yn.prototype.attrPush = function (e) {
  this.attrs ? this.attrs.push(e) : (this.attrs = [e]);
};
Yn.prototype.attrSet = function (e, n) {
  const r = this.attrIndex(e),
    o = [e, n];
  r < 0 ? this.attrPush(o) : (this.attrs[r] = o);
};
Yn.prototype.attrGet = function (e) {
  const n = this.attrIndex(e);
  let r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
Yn.prototype.attrJoin = function (e, n) {
  const r = this.attrIndex(e);
  r < 0
    ? this.attrPush([e, n])
    : (this.attrs[r][1] = this.attrs[r][1] + " " + n);
};
function Jv(t, e, n) {
  (this.src = t),
    (this.env = n),
    (this.tokens = []),
    (this.inlineMode = !1),
    (this.md = e);
}
Jv.prototype.Token = Yn;
const OS = /\r\n?|\n/g,
  DS = /\0/g;
function NS(t) {
  let e;
  (e = t.src.replace(
    OS,
    `
`
  )),
    (e = e.replace(DS, "")),
    (t.src = e);
}
function LS(t) {
  let e;
  t.inlineMode
    ? ((e = new t.Token("inline", "", 0)),
      (e.content = t.src),
      (e.map = [0, 1]),
      (e.children = []),
      t.tokens.push(e))
    : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}
function RS(t) {
  const e = t.tokens;
  for (let n = 0, r = e.length; n < r; n++) {
    const o = e[n];
    o.type === "inline" &&
      t.md.inline.parse(o.content, t.md, t.env, o.children);
  }
}
function IS(t) {
  return /^<a[>\s]/i.test(t);
}
function PS(t) {
  return /^<\/a\s*>/i.test(t);
}
function $S(t) {
  const e = t.tokens;
  if (t.md.options.linkify)
    for (let n = 0, r = e.length; n < r; n++) {
      if (e[n].type !== "inline" || !t.md.linkify.pretest(e[n].content))
        continue;
      let o = e[n].children,
        i = 0;
      for (let s = o.length - 1; s >= 0; s--) {
        const a = o[s];
        if (a.type === "link_close") {
          for (s--; o[s].level !== a.level && o[s].type !== "link_open"; ) s--;
          continue;
        }
        if (
          (a.type === "html_inline" &&
            (IS(a.content) && i > 0 && i--, PS(a.content) && i++),
          !(i > 0) && a.type === "text" && t.md.linkify.test(a.content))
        ) {
          const l = a.content;
          let u = t.md.linkify.match(l);
          const c = [];
          let d = a.level,
            f = 0;
          u.length > 0 &&
            u[0].index === 0 &&
            s > 0 &&
            o[s - 1].type === "text_special" &&
            (u = u.slice(1));
          for (let p = 0; p < u.length; p++) {
            const h = u[p].url,
              m = t.md.normalizeLink(h);
            if (!t.md.validateLink(m)) continue;
            let g = u[p].text;
            u[p].schema
              ? u[p].schema === "mailto:" && !/^mailto:/i.test(g)
                ? (g = t.md
                    .normalizeLinkText("mailto:" + g)
                    .replace(/^mailto:/, ""))
                : (g = t.md.normalizeLinkText(g))
              : (g = t.md
                  .normalizeLinkText("http://" + g)
                  .replace(/^http:\/\//, ""));
            const b = u[p].index;
            if (b > f) {
              const w = new t.Token("text", "", 0);
              (w.content = l.slice(f, b)), (w.level = d), c.push(w);
            }
            const _ = new t.Token("link_open", "a", 1);
            (_.attrs = [["href", m]]),
              (_.level = d++),
              (_.markup = "linkify"),
              (_.info = "auto"),
              c.push(_);
            const v = new t.Token("text", "", 0);
            (v.content = g), (v.level = d), c.push(v);
            const y = new t.Token("link_close", "a", -1);
            (y.level = --d),
              (y.markup = "linkify"),
              (y.info = "auto"),
              c.push(y),
              (f = u[p].lastIndex);
          }
          if (f < l.length) {
            const p = new t.Token("text", "", 0);
            (p.content = l.slice(f)), (p.level = d), c.push(p);
          }
          e[n].children = o = Kv(o, s, c);
        }
      }
    }
}
const Yv = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
  BS = /\((c|tm|r)\)/i,
  HS = /\((c|tm|r)\)/gi,
  FS = {
    c: "",
    r: "",
    tm: "",
  };
function zS(t, e) {
  return FS[e.toLowerCase()];
}
function VS(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const r = t[n];
    r.type === "text" && !e && (r.content = r.content.replace(HS, zS)),
      r.type === "link_open" && r.info === "auto" && e--,
      r.type === "link_close" && r.info === "auto" && e++;
  }
}
function US(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const r = t[n];
    r.type === "text" &&
      !e &&
      Yv.test(r.content) &&
      (r.content = r.content
        .replace(/\+-/g, "")
        .replace(/\.{2,}/g, "")
        .replace(/([?!])/g, "$1..")
        .replace(/([?!]){4,}/g, "$1$1$1")
        .replace(/,{2,}/g, ",")
        .replace(/(^|[^-])---(?=[^-]|$)/gm, "$1")
        .replace(/(^|\s)--(?=\s|$)/gm, "$1")
        .replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, "$1")),
      r.type === "link_open" && r.info === "auto" && e--,
      r.type === "link_close" && r.info === "auto" && e++;
  }
}
function jS(t) {
  let e;
  if (t.md.options.typographer)
    for (e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type === "inline" &&
        (BS.test(t.tokens[e].content) && VS(t.tokens[e].children),
        Yv.test(t.tokens[e].content) && US(t.tokens[e].children));
}
const WS = /['"]/,
  eg = /['"]/g,
  tg = "";
function al(t, e, n) {
  return t.slice(0, e) + n + t.slice(e + 1);
}
function qS(t, e) {
  let n;
  const r = [];
  for (let o = 0; o < t.length; o++) {
    const i = t[o],
      s = t[o].level;
    for (n = r.length - 1; n >= 0 && !(r[n].level <= s); n--);
    if (((r.length = n + 1), i.type !== "text")) continue;
    let a = i.content,
      l = 0,
      u = a.length;
    e: for (; l < u; ) {
      eg.lastIndex = l;
      const c = eg.exec(a);
      if (!c) break;
      let d = !0,
        f = !0;
      l = c.index + 1;
      const p = c[0] === "'";
      let h = 32;
      if (c.index - 1 >= 0) h = a.charCodeAt(c.index - 1);
      else
        for (
          n = o - 1;
          n >= 0 && !(t[n].type === "softbreak" || t[n].type === "hardbreak");
          n--
        )
          if (t[n].content) {
            h = t[n].content.charCodeAt(t[n].content.length - 1);
            break;
          }
      let m = 32;
      if (l < u) m = a.charCodeAt(l);
      else
        for (
          n = o + 1;
          n < t.length &&
          !(t[n].type === "softbreak" || t[n].type === "hardbreak");
          n++
        )
          if (t[n].content) {
            m = t[n].content.charCodeAt(0);
            break;
          }
      const g = da(h) || ca(String.fromCharCode(h)),
        b = da(m) || ca(String.fromCharCode(m)),
        _ = ua(h),
        v = ua(m);
      if (
        (v ? (d = !1) : b && (_ || g || (d = !1)),
        _ ? (f = !1) : g && (v || b || (f = !1)),
        m === 34 && c[0] === '"' && h >= 48 && h <= 57 && (f = d = !1),
        d && f && ((d = g), (f = b)),
        !d && !f)
      ) {
        p && (i.content = al(i.content, c.index, tg));
        continue;
      }
      if (f)
        for (n = r.length - 1; n >= 0; n--) {
          let y = r[n];
          if (r[n].level < s) break;
          if (y.single === p && r[n].level === s) {
            y = r[n];
            let w, x;
            p
              ? ((w = e.md.options.quotes[2]), (x = e.md.options.quotes[3]))
              : ((w = e.md.options.quotes[0]), (x = e.md.options.quotes[1])),
              (i.content = al(i.content, c.index, x)),
              (t[y.token].content = al(t[y.token].content, y.pos, w)),
              (l += x.length - 1),
              y.token === o && (l += w.length - 1),
              (a = i.content),
              (u = a.length),
              (r.length = n);
            continue e;
          }
        }
      d
        ? r.push({
            token: o,
            pos: c.index,
            single: p,
            level: s,
          })
        : f && p && (i.content = al(i.content, c.index, tg));
    }
  }
}
function KS(t) {
  if (t.md.options.typographer)
    for (let e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type !== "inline" ||
        !WS.test(t.tokens[e].content) ||
        qS(t.tokens[e].children, t);
}
function GS(t) {
  let e, n;
  const r = t.tokens,
    o = r.length;
  for (let i = 0; i < o; i++) {
    if (r[i].type !== "inline") continue;
    const s = r[i].children,
      a = s.length;
    for (e = 0; e < a; e++)
      s[e].type === "text_special" && (s[e].type = "text");
    for (e = n = 0; e < a; e++)
      s[e].type === "text" && e + 1 < a && s[e + 1].type === "text"
        ? (s[e + 1].content = s[e].content + s[e + 1].content)
        : (e !== n && (s[n] = s[e]), n++);
    e !== n && (s.length = n);
  }
}
const Zd = [
  ["normalize", NS],
  ["block", LS],
  ["inline", RS],
  ["linkify", $S],
  ["replacements", jS],
  ["smartquotes", KS],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", GS],
];
function e0() {
  this.ruler = new en();
  for (let t = 0; t < Zd.length; t++) this.ruler.push(Zd[t][0], Zd[t][1]);
}
e0.prototype.process = function (t) {
  const e = this.ruler.getRules("");
  for (let n = 0, r = e.length; n < r; n++) e[n](t);
};
e0.prototype.State = Jv;
function kr(t, e, n, r) {
  (this.src = t),
    (this.md = e),
    (this.env = n),
    (this.tokens = r),
    (this.bMarks = []),
    (this.eMarks = []),
    (this.tShift = []),
    (this.sCount = []),
    (this.bsCount = []),
    (this.blkIndent = 0),
    (this.line = 0),
    (this.lineMax = 0),
    (this.tight = !1),
    (this.ddIndent = -1),
    (this.listIndent = -1),
    (this.parentType = "root"),
    (this.level = 0);
  const o = this.src;
  for (let i = 0, s = 0, a = 0, l = 0, u = o.length, c = !1; s < u; s++) {
    const d = o.charCodeAt(s);
    if (!c)
      if (Ue(d)) {
        a++, d === 9 ? (l += 4 - (l % 4)) : l++;
        continue;
      } else c = !0;
    (d === 10 || s === u - 1) &&
      (d !== 10 && s++,
      this.bMarks.push(i),
      this.eMarks.push(s),
      this.tShift.push(a),
      this.sCount.push(l),
      this.bsCount.push(0),
      (c = !1),
      (a = 0),
      (l = 0),
      (i = s + 1));
  }
  this.bMarks.push(o.length),
    this.eMarks.push(o.length),
    this.tShift.push(0),
    this.sCount.push(0),
    this.bsCount.push(0),
    (this.lineMax = this.bMarks.length - 1);
}
kr.prototype.push = function (t, e, n) {
  const r = new Yn(t, e, n);
  return (
    (r.block = !0),
    n < 0 && this.level--,
    (r.level = this.level),
    n > 0 && this.level++,
    this.tokens.push(r),
    r
  );
};
kr.prototype.isEmpty = function (e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
kr.prototype.skipEmptyLines = function (e) {
  for (
    let n = this.lineMax;
    e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]);
    e++
  );
  return e;
};
kr.prototype.skipSpaces = function (e) {
  for (let n = this.src.length; e < n; e++) {
    const r = this.src.charCodeAt(e);
    if (!Ue(r)) break;
  }
  return e;
};
kr.prototype.skipSpacesBack = function (e, n) {
  if (e <= n) return e;
  for (; e > n; ) if (!Ue(this.src.charCodeAt(--e))) return e + 1;
  return e;
};
kr.prototype.skipChars = function (e, n) {
  for (let r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++);
  return e;
};
kr.prototype.skipCharsBack = function (e, n, r) {
  if (e <= r) return e;
  for (; e > r; ) if (n !== this.src.charCodeAt(--e)) return e + 1;
  return e;
};
kr.prototype.getLines = function (e, n, r, o) {
  if (e >= n) return "";
  const i = new Array(n - e);
  for (let s = 0, a = e; a < n; a++, s++) {
    let l = 0;
    const u = this.bMarks[a];
    let c = u,
      d;
    for (
      a + 1 < n || o ? (d = this.eMarks[a] + 1) : (d = this.eMarks[a]);
      c < d && l < r;

    ) {
      const f = this.src.charCodeAt(c);
      if (Ue(f)) f === 9 ? (l += 4 - ((l + this.bsCount[a]) % 4)) : l++;
      else if (c - u < this.tShift[a]) l++;
      else break;
      c++;
    }
    l > r
      ? (i[s] = new Array(l - r + 1).join(" ") + this.src.slice(c, d))
      : (i[s] = this.src.slice(c, d));
  }
  return i.join("");
};
kr.prototype.Token = Yn;
function Qd(t, e) {
  const n = t.bMarks[e] + t.tShift[e],
    r = t.eMarks[e];
  return t.src.slice(n, r);
}
function ng(t) {
  const e = [],
    n = t.length;
  let r = 0,
    o = t.charCodeAt(r),
    i = !1,
    s = 0,
    a = "";
  for (; r < n; )
    o === 124 &&
      (i
        ? ((a += t.substring(s, r - 1)), (s = r))
        : (e.push(a + t.substring(s, r)), (a = ""), (s = r + 1))),
      (i = o === 92),
      r++,
      (o = t.charCodeAt(r));
  return e.push(a + t.substring(s)), e;
}
function JS(t, e, n, r) {
  if (e + 2 > n) return !1;
  let o = e + 1;
  if (t.sCount[o] < t.blkIndent || t.sCount[o] - t.blkIndent >= 4) return !1;
  let i = t.bMarks[o] + t.tShift[o];
  if (i >= t.eMarks[o]) return !1;
  const s = t.src.charCodeAt(i++);
  if ((s !== 124 && s !== 45 && s !== 58) || i >= t.eMarks[o]) return !1;
  const a = t.src.charCodeAt(i++);
  if ((a !== 124 && a !== 45 && a !== 58 && !Ue(a)) || (s === 45 && Ue(a)))
    return !1;
  for (; i < t.eMarks[o]; ) {
    const v = t.src.charCodeAt(i);
    if (v !== 124 && v !== 45 && v !== 58 && !Ue(v)) return !1;
    i++;
  }
  let l = Qd(t, e + 1),
    u = l.split("|");
  const c = [];
  for (let v = 0; v < u.length; v++) {
    const y = u[v].trim();
    if (!y) {
      if (v === 0 || v === u.length - 1) continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(y)) return !1;
    y.charCodeAt(y.length - 1) === 58
      ? c.push(y.charCodeAt(0) === 58 ? "center" : "right")
      : y.charCodeAt(0) === 58
      ? c.push("left")
      : c.push("");
  }
  if (
    ((l = Qd(t, e).trim()),
    l.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
  )
    return !1;
  (u = ng(l)),
    u.length && u[0] === "" && u.shift(),
    u.length && u[u.length - 1] === "" && u.pop();
  const d = u.length;
  if (d === 0 || d !== c.length) return !1;
  if (r) return !0;
  const f = t.parentType;
  t.parentType = "table";
  const p = t.md.block.ruler.getRules("blockquote"),
    h = t.push("table_open", "table", 1),
    m = [e, 0];
  h.map = m;
  const g = t.push("thead_open", "thead", 1);
  g.map = [e, e + 1];
  const b = t.push("tr_open", "tr", 1);
  b.map = [e, e + 1];
  for (let v = 0; v < u.length; v++) {
    const y = t.push("th_open", "th", 1);
    c[v] && (y.attrs = [["style", "text-align:" + c[v]]]);
    const w = t.push("inline", "", 0);
    (w.content = u[v].trim()), (w.children = []), t.push("th_close", "th", -1);
  }
  t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
  let _;
  for (o = e + 2; o < n && !(t.sCount[o] < t.blkIndent); o++) {
    let v = !1;
    for (let w = 0, x = p.length; w < x; w++)
      if (p[w](t, o, n, !0)) {
        v = !0;
        break;
      }
    if (v || ((l = Qd(t, o).trim()), !l) || t.sCount[o] - t.blkIndent >= 4)
      break;
    if (
      ((u = ng(l)),
      u.length && u[0] === "" && u.shift(),
      u.length && u[u.length - 1] === "" && u.pop(),
      o === e + 2)
    ) {
      const w = t.push("tbody_open", "tbody", 1);
      w.map = _ = [e + 2, 0];
    }
    const y = t.push("tr_open", "tr", 1);
    y.map = [o, o + 1];
    for (let w = 0; w < d; w++) {
      const x = t.push("td_open", "td", 1);
      c[w] && (x.attrs = [["style", "text-align:" + c[w]]]);
      const M = t.push("inline", "", 0);
      (M.content = u[w] ? u[w].trim() : ""),
        (M.children = []),
        t.push("td_close", "td", -1);
    }
    t.push("tr_close", "tr", -1);
  }
  return (
    _ && (t.push("tbody_close", "tbody", -1), (_[1] = o)),
    t.push("table_close", "table", -1),
    (m[1] = o),
    (t.parentType = f),
    (t.line = o),
    !0
  );
}
function YS(t, e, n) {
  if (t.sCount[e] - t.blkIndent < 4) return !1;
  let r = e + 1,
    o = r;
  for (; r < n; ) {
    if (t.isEmpty(r)) {
      r++;
      continue;
    }
    if (t.sCount[r] - t.blkIndent >= 4) {
      r++, (o = r);
      continue;
    }
    break;
  }
  t.line = o;
  const i = t.push("code_block", "code", 0);
  return (
    (i.content =
      t.getLines(e, o, 4 + t.blkIndent, !1) +
      `
`),
    (i.map = [e, t.line]),
    !0
  );
}
function XS(t, e, n, r) {
  let o = t.bMarks[e] + t.tShift[e],
    i = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || o + 3 > i) return !1;
  const s = t.src.charCodeAt(o);
  if (s !== 126 && s !== 96) return !1;
  let a = o;
  o = t.skipChars(o, s);
  let l = o - a;
  if (l < 3) return !1;
  const u = t.src.slice(a, o),
    c = t.src.slice(o, i);
  if (s === 96 && c.indexOf(String.fromCharCode(s)) >= 0) return !1;
  if (r) return !0;
  let d = e,
    f = !1;
  for (
    ;
    d++,
      !(
        d >= n ||
        ((o = a = t.bMarks[d] + t.tShift[d]),
        (i = t.eMarks[d]),
        o < i && t.sCount[d] < t.blkIndent)
      );

  )
    if (
      t.src.charCodeAt(o) === s &&
      !(t.sCount[d] - t.blkIndent >= 4) &&
      ((o = t.skipChars(o, s)),
      !(o - a < l) && ((o = t.skipSpaces(o)), !(o < i)))
    ) {
      f = !0;
      break;
    }
  (l = t.sCount[e]), (t.line = d + (f ? 1 : 0));
  const p = t.push("fence", "code", 0);
  return (
    (p.info = c),
    (p.content = t.getLines(e + 1, d, l, !0)),
    (p.markup = u),
    (p.map = [e, t.line]),
    !0
  );
}
function ZS(t, e, n, r) {
  let o = t.bMarks[e] + t.tShift[e],
    i = t.eMarks[e];
  const s = t.lineMax;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(o) !== 62) return !1;
  if (r) return !0;
  const a = [],
    l = [],
    u = [],
    c = [],
    d = t.md.block.ruler.getRules("blockquote"),
    f = t.parentType;
  t.parentType = "blockquote";
  let p = !1,
    h;
  for (h = e; h < n; h++) {
    const v = t.sCount[h] < t.blkIndent;
    if (((o = t.bMarks[h] + t.tShift[h]), (i = t.eMarks[h]), o >= i)) break;
    if (t.src.charCodeAt(o++) === 62 && !v) {
      let w = t.sCount[h] + 1,
        x,
        M;
      t.src.charCodeAt(o) === 32
        ? (o++, w++, (M = !1), (x = !0))
        : t.src.charCodeAt(o) === 9
        ? ((x = !0),
          (t.bsCount[h] + w) % 4 === 3 ? (o++, w++, (M = !1)) : (M = !0))
        : (x = !1);
      let N = w;
      for (a.push(t.bMarks[h]), t.bMarks[h] = o; o < i; ) {
        const T = t.src.charCodeAt(o);
        if (Ue(T))
          T === 9 ? (N += 4 - ((N + t.bsCount[h] + (M ? 1 : 0)) % 4)) : N++;
        else break;
        o++;
      }
      (p = o >= i),
        l.push(t.bsCount[h]),
        (t.bsCount[h] = t.sCount[h] + 1 + (x ? 1 : 0)),
        u.push(t.sCount[h]),
        (t.sCount[h] = N - w),
        c.push(t.tShift[h]),
        (t.tShift[h] = o - t.bMarks[h]);
      continue;
    }
    if (p) break;
    let y = !1;
    for (let w = 0, x = d.length; w < x; w++)
      if (d[w](t, h, n, !0)) {
        y = !0;
        break;
      }
    if (y) {
      (t.lineMax = h),
        t.blkIndent !== 0 &&
          (a.push(t.bMarks[h]),
          l.push(t.bsCount[h]),
          c.push(t.tShift[h]),
          u.push(t.sCount[h]),
          (t.sCount[h] -= t.blkIndent));
      break;
    }
    a.push(t.bMarks[h]),
      l.push(t.bsCount[h]),
      c.push(t.tShift[h]),
      u.push(t.sCount[h]),
      (t.sCount[h] = -1);
  }
  const m = t.blkIndent;
  t.blkIndent = 0;
  const g = t.push("blockquote_open", "blockquote", 1);
  g.markup = ">";
  const b = [e, 0];
  (g.map = b), t.md.block.tokenize(t, e, h);
  const _ = t.push("blockquote_close", "blockquote", -1);
  (_.markup = ">"), (t.lineMax = s), (t.parentType = f), (b[1] = t.line);
  for (let v = 0; v < c.length; v++)
    (t.bMarks[v + e] = a[v]),
      (t.tShift[v + e] = c[v]),
      (t.sCount[v + e] = u[v]),
      (t.bsCount[v + e] = l[v]);
  return (t.blkIndent = m), !0;
}
function QS(t, e, n, r) {
  const o = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4) return !1;
  let i = t.bMarks[e] + t.tShift[e];
  const s = t.src.charCodeAt(i++);
  if (s !== 42 && s !== 45 && s !== 95) return !1;
  let a = 1;
  for (; i < o; ) {
    const u = t.src.charCodeAt(i++);
    if (u !== s && !Ue(u)) return !1;
    u === s && a++;
  }
  if (a < 3) return !1;
  if (r) return !0;
  t.line = e + 1;
  const l = t.push("hr", "hr", 0);
  return (
    (l.map = [e, t.line]),
    (l.markup = Array(a + 1).join(String.fromCharCode(s))),
    !0
  );
}
function rg(t, e) {
  const n = t.eMarks[e];
  let r = t.bMarks[e] + t.tShift[e];
  const o = t.src.charCodeAt(r++);
  if (o !== 42 && o !== 45 && o !== 43) return -1;
  if (r < n) {
    const i = t.src.charCodeAt(r);
    if (!Ue(i)) return -1;
  }
  return r;
}
function og(t, e) {
  const n = t.bMarks[e] + t.tShift[e],
    r = t.eMarks[e];
  let o = n;
  if (o + 1 >= r) return -1;
  let i = t.src.charCodeAt(o++);
  if (i < 48 || i > 57) return -1;
  for (;;) {
    if (o >= r) return -1;
    if (((i = t.src.charCodeAt(o++)), i >= 48 && i <= 57)) {
      if (o - n >= 10) return -1;
      continue;
    }
    if (i === 41 || i === 46) break;
    return -1;
  }
  return o < r && ((i = t.src.charCodeAt(o)), !Ue(i)) ? -1 : o;
}
function eE(t, e) {
  const n = t.level + 2;
  for (let r = e + 2, o = t.tokens.length - 2; r < o; r++)
    t.tokens[r].level === n &&
      t.tokens[r].type === "paragraph_open" &&
      ((t.tokens[r + 2].hidden = !0), (t.tokens[r].hidden = !0), (r += 2));
}
function tE(t, e, n, r) {
  let o,
    i,
    s,
    a,
    l = e,
    u = !0;
  if (
    t.sCount[l] - t.blkIndent >= 4 ||
    (t.listIndent >= 0 &&
      t.sCount[l] - t.listIndent >= 4 &&
      t.sCount[l] < t.blkIndent)
  )
    return !1;
  let c = !1;
  r && t.parentType === "paragraph" && t.sCount[l] >= t.blkIndent && (c = !0);
  let d, f, p;
  if ((p = og(t, l)) >= 0) {
    if (
      ((d = !0),
      (s = t.bMarks[l] + t.tShift[l]),
      (f = Number(t.src.slice(s, p - 1))),
      c && f !== 1)
    )
      return !1;
  } else if ((p = rg(t, l)) >= 0) d = !1;
  else return !1;
  if (c && t.skipSpaces(p) >= t.eMarks[l]) return !1;
  if (r) return !0;
  const h = t.src.charCodeAt(p - 1),
    m = t.tokens.length;
  d
    ? ((a = t.push("ordered_list_open", "ol", 1)),
      f !== 1 && (a.attrs = [["start", f]]))
    : (a = t.push("bullet_list_open", "ul", 1));
  const g = [l, 0];
  (a.map = g), (a.markup = String.fromCharCode(h));
  let b = !1;
  const _ = t.md.block.ruler.getRules("list"),
    v = t.parentType;
  for (t.parentType = "list"; l < n; ) {
    (i = p), (o = t.eMarks[l]);
    const y = t.sCount[l] + p - (t.bMarks[l] + t.tShift[l]);
    let w = y;
    for (; i < o; ) {
      const te = t.src.charCodeAt(i);
      if (te === 9) w += 4 - ((w + t.bsCount[l]) % 4);
      else if (te === 32) w++;
      else break;
      i++;
    }
    const x = i;
    let M;
    x >= o ? (M = 1) : (M = w - y), M > 4 && (M = 1);
    const N = y + M;
    (a = t.push("list_item_open", "li", 1)),
      (a.markup = String.fromCharCode(h));
    const T = [l, 0];
    (a.map = T), d && (a.info = t.src.slice(s, p - 1));
    const P = t.tight,
      z = t.tShift[l],
      H = t.sCount[l],
      U = t.listIndent;
    if (
      ((t.listIndent = t.blkIndent),
      (t.blkIndent = N),
      (t.tight = !0),
      (t.tShift[l] = x - t.bMarks[l]),
      (t.sCount[l] = w),
      x >= o && t.isEmpty(l + 1)
        ? (t.line = Math.min(t.line + 2, n))
        : t.md.block.tokenize(t, l, n, !0),
      (!t.tight || b) && (u = !1),
      (b = t.line - l > 1 && t.isEmpty(t.line - 1)),
      (t.blkIndent = t.listIndent),
      (t.listIndent = U),
      (t.tShift[l] = z),
      (t.sCount[l] = H),
      (t.tight = P),
      (a = t.push("list_item_close", "li", -1)),
      (a.markup = String.fromCharCode(h)),
      (l = t.line),
      (T[1] = l),
      l >= n || t.sCount[l] < t.blkIndent || t.sCount[l] - t.blkIndent >= 4)
    )
      break;
    let re = !1;
    for (let te = 0, Q = _.length; te < Q; te++)
      if (_[te](t, l, n, !0)) {
        re = !0;
        break;
      }
    if (re) break;
    if (d) {
      if (((p = og(t, l)), p < 0)) break;
      s = t.bMarks[l] + t.tShift[l];
    } else if (((p = rg(t, l)), p < 0)) break;
    if (h !== t.src.charCodeAt(p - 1)) break;
  }
  return (
    d
      ? (a = t.push("ordered_list_close", "ol", -1))
      : (a = t.push("bullet_list_close", "ul", -1)),
    (a.markup = String.fromCharCode(h)),
    (g[1] = l),
    (t.line = l),
    (t.parentType = v),
    u && eE(t, m),
    !0
  );
}
function nE(t, e, n, r) {
  let o = 0,
    i = t.bMarks[e] + t.tShift[e],
    s = t.eMarks[e],
    a = e + 1;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(i) !== 91) return !1;
  for (; ++i < s; )
    if (t.src.charCodeAt(i) === 93 && t.src.charCodeAt(i - 1) !== 92) {
      if (i + 1 === s || t.src.charCodeAt(i + 1) !== 58) return !1;
      break;
    }
  const l = t.lineMax,
    u = t.md.block.ruler.getRules("reference"),
    c = t.parentType;
  for (t.parentType = "reference"; a < l && !t.isEmpty(a); a++) {
    if (t.sCount[a] - t.blkIndent > 3 || t.sCount[a] < 0) continue;
    let w = !1;
    for (let x = 0, M = u.length; x < M; x++)
      if (u[x](t, a, l, !0)) {
        w = !0;
        break;
      }
    if (w) break;
  }
  const d = t.getLines(e, a, t.blkIndent, !1).trim();
  s = d.length;
  let f = -1;
  for (i = 1; i < s; i++) {
    const w = d.charCodeAt(i);
    if (w === 91) return !1;
    if (w === 93) {
      f = i;
      break;
    } else
      w === 10
        ? o++
        : w === 92 && (i++, i < s && d.charCodeAt(i) === 10 && o++);
  }
  if (f < 0 || d.charCodeAt(f + 1) !== 58) return !1;
  for (i = f + 2; i < s; i++) {
    const w = d.charCodeAt(i);
    if (w === 10) o++;
    else if (!Ue(w)) break;
  }
  const p = t.md.helpers.parseLinkDestination(d, i, s);
  if (!p.ok) return !1;
  const h = t.md.normalizeLink(p.str);
  if (!t.md.validateLink(h)) return !1;
  (i = p.pos), (o += p.lines);
  const m = i,
    g = o,
    b = i;
  for (; i < s; i++) {
    const w = d.charCodeAt(i);
    if (w === 10) o++;
    else if (!Ue(w)) break;
  }
  const _ = t.md.helpers.parseLinkTitle(d, i, s);
  let v;
  for (
    i < s && b !== i && _.ok
      ? ((v = _.str), (i = _.pos), (o += _.lines))
      : ((v = ""), (i = m), (o = g));
    i < s;

  ) {
    const w = d.charCodeAt(i);
    if (!Ue(w)) break;
    i++;
  }
  if (i < s && d.charCodeAt(i) !== 10 && v)
    for (v = "", i = m, o = g; i < s; ) {
      const w = d.charCodeAt(i);
      if (!Ue(w)) break;
      i++;
    }
  if (i < s && d.charCodeAt(i) !== 10) return !1;
  const y = ed(d.slice(1, f));
  return y
    ? (r ||
        (typeof t.env.references > "u" && (t.env.references = {}),
        typeof t.env.references[y] > "u" &&
          (t.env.references[y] = { title: v, href: h }),
        (t.parentType = c),
        (t.line = e + o + 1)),
      !0)
    : !1;
}
const rE = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "section",
    "source",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul",
  ],
  oE = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
  iE = "[^\"'=<>`\\x00-\\x20]+",
  sE = "'[^']*'",
  aE = '"[^"]*"',
  lE = "(?:" + iE + "|" + sE + "|" + aE + ")",
  uE = "(?:\\s+" + oE + "(?:\\s*=\\s*" + lE + ")?)",
  Xv = "<[A-Za-z][A-Za-z0-9\\-]*" + uE + "*\\s*\\/?>",
  Zv = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
  cE = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->",
  dE = "<[?][\\s\\S]*?[?]>",
  fE = "<![A-Z]+\\s+[^>]*>",
  pE = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  hE = new RegExp(
    "^(?:" + Xv + "|" + Zv + "|" + cE + "|" + dE + "|" + fE + "|" + pE + ")"
  ),
  mE = new RegExp("^(?:" + Xv + "|" + Zv + ")"),
  wi = [
    [
      /^<(script|pre|style|textarea)(?=(\s|>|$))/i,
      /<\/(script|pre|style|textarea)>/i,
      !0,
    ],
    [/^<!--/, /-->/, !0],
    [/^<\?/, /\?>/, !0],
    [/^<![A-Z]/, />/, !0],
    [/^<!\[CDATA\[/, /\]\]>/, !0],
    [new RegExp("^</?(" + rE.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
    [new RegExp(mE.source + "\\s*$"), /^$/, !1],
  ];
function gE(t, e, n, r) {
  let o = t.bMarks[e] + t.tShift[e],
    i = t.eMarks[e];
  if (
    t.sCount[e] - t.blkIndent >= 4 ||
    !t.md.options.html ||
    t.src.charCodeAt(o) !== 60
  )
    return !1;
  let s = t.src.slice(o, i),
    a = 0;
  for (; a < wi.length && !wi[a][0].test(s); a++);
  if (a === wi.length) return !1;
  if (r) return wi[a][2];
  let l = e + 1;
  if (!wi[a][1].test(s)) {
    for (; l < n && !(t.sCount[l] < t.blkIndent); l++)
      if (
        ((o = t.bMarks[l] + t.tShift[l]),
        (i = t.eMarks[l]),
        (s = t.src.slice(o, i)),
        wi[a][1].test(s))
      ) {
        s.length !== 0 && l++;
        break;
      }
  }
  t.line = l;
  const u = t.push("html_block", "", 0);
  return (u.map = [e, l]), (u.content = t.getLines(e, l, t.blkIndent, !0)), !0;
}
function bE(t, e, n, r) {
  let o = t.bMarks[e] + t.tShift[e],
    i = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4) return !1;
  let s = t.src.charCodeAt(o);
  if (s !== 35 || o >= i) return !1;
  let a = 1;
  for (s = t.src.charCodeAt(++o); s === 35 && o < i && a <= 6; )
    a++, (s = t.src.charCodeAt(++o));
  if (a > 6 || (o < i && !Ue(s))) return !1;
  if (r) return !0;
  i = t.skipSpacesBack(i, o);
  const l = t.skipCharsBack(i, 35, o);
  l > o && Ue(t.src.charCodeAt(l - 1)) && (i = l), (t.line = e + 1);
  const u = t.push("heading_open", "h" + String(a), 1);
  (u.markup = "########".slice(0, a)), (u.map = [e, t.line]);
  const c = t.push("inline", "", 0);
  (c.content = t.src.slice(o, i).trim()),
    (c.map = [e, t.line]),
    (c.children = []);
  const d = t.push("heading_close", "h" + String(a), -1);
  return (d.markup = "########".slice(0, a)), !0;
}
function yE(t, e, n) {
  const r = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[e] - t.blkIndent >= 4) return !1;
  const o = t.parentType;
  t.parentType = "paragraph";
  let i = 0,
    s,
    a = e + 1;
  for (; a < n && !t.isEmpty(a); a++) {
    if (t.sCount[a] - t.blkIndent > 3) continue;
    if (t.sCount[a] >= t.blkIndent) {
      let p = t.bMarks[a] + t.tShift[a];
      const h = t.eMarks[a];
      if (
        p < h &&
        ((s = t.src.charCodeAt(p)),
        (s === 45 || s === 61) &&
          ((p = t.skipChars(p, s)), (p = t.skipSpaces(p)), p >= h))
      ) {
        i = s === 61 ? 1 : 2;
        break;
      }
    }
    if (t.sCount[a] < 0) continue;
    let f = !1;
    for (let p = 0, h = r.length; p < h; p++)
      if (r[p](t, a, n, !0)) {
        f = !0;
        break;
      }
    if (f) break;
  }
  if (!i) return !1;
  const l = t.getLines(e, a, t.blkIndent, !1).trim();
  t.line = a + 1;
  const u = t.push("heading_open", "h" + String(i), 1);
  (u.markup = String.fromCharCode(s)), (u.map = [e, t.line]);
  const c = t.push("inline", "", 0);
  (c.content = l), (c.map = [e, t.line - 1]), (c.children = []);
  const d = t.push("heading_close", "h" + String(i), -1);
  return (d.markup = String.fromCharCode(s)), (t.parentType = o), !0;
}
function vE(t, e, n) {
  const r = t.md.block.ruler.getRules("paragraph"),
    o = t.parentType;
  let i = e + 1;
  for (t.parentType = "paragraph"; i < n && !t.isEmpty(i); i++) {
    if (t.sCount[i] - t.blkIndent > 3 || t.sCount[i] < 0) continue;
    let u = !1;
    for (let c = 0, d = r.length; c < d; c++)
      if (r[c](t, i, n, !0)) {
        u = !0;
        break;
      }
    if (u) break;
  }
  const s = t.getLines(e, i, t.blkIndent, !1).trim();
  t.line = i;
  const a = t.push("paragraph_open", "p", 1);
  a.map = [e, t.line];
  const l = t.push("inline", "", 0);
  return (
    (l.content = s),
    (l.map = [e, t.line]),
    (l.children = []),
    t.push("paragraph_close", "p", -1),
    (t.parentType = o),
    !0
  );
}
const ll = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", JS, ["paragraph", "reference"]],
  ["code", YS],
  ["fence", XS, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", ZS, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", QS, ["paragraph", "reference", "blockquote", "list"]],
  ["list", tE, ["paragraph", "reference", "blockquote"]],
  ["reference", nE],
  ["html_block", gE, ["paragraph", "reference", "blockquote"]],
  ["heading", bE, ["paragraph", "reference", "blockquote"]],
  ["lheading", yE],
  ["paragraph", vE],
];
function td() {
  this.ruler = new en();
  for (let t = 0; t < ll.length; t++)
    this.ruler.push(ll[t][0], ll[t][1], { alt: (ll[t][2] || []).slice() });
}
td.prototype.tokenize = function (t, e, n) {
  const r = this.ruler.getRules(""),
    o = r.length,
    i = t.md.options.maxNesting;
  let s = e,
    a = !1;
  for (
    ;
    s < n &&
    ((t.line = s = t.skipEmptyLines(s)),
    !(s >= n || t.sCount[s] < t.blkIndent));

  ) {
    if (t.level >= i) {
      t.line = n;
      break;
    }
    const l = t.line;
    let u = !1;
    for (let c = 0; c < o; c++)
      if (((u = r[c](t, s, n, !1)), u)) {
        if (l >= t.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!u) throw new Error("none of the block rules matched");
    (t.tight = !a),
      t.isEmpty(t.line - 1) && (a = !0),
      (s = t.line),
      s < n && t.isEmpty(s) && ((a = !0), s++, (t.line = s));
  }
};
td.prototype.parse = function (t, e, n, r) {
  if (!t) return;
  const o = new this.State(t, e, n, r);
  this.tokenize(o, o.line, o.lineMax);
};
td.prototype.State = kr;
function Da(t, e, n, r) {
  (this.src = t),
    (this.env = n),
    (this.md = e),
    (this.tokens = r),
    (this.tokens_meta = Array(r.length)),
    (this.pos = 0),
    (this.posMax = this.src.length),
    (this.level = 0),
    (this.pending = ""),
    (this.pendingLevel = 0),
    (this.cache = {}),
    (this.delimiters = []),
    (this._prev_delimiters = []),
    (this.backticks = {}),
    (this.backticksScanned = !1),
    (this.linkLevel = 0);
}
Da.prototype.pushPending = function () {
  const t = new Yn("text", "", 0);
  return (
    (t.content = this.pending),
    (t.level = this.pendingLevel),
    this.tokens.push(t),
    (this.pending = ""),
    t
  );
};
Da.prototype.push = function (t, e, n) {
  this.pending && this.pushPending();
  const r = new Yn(t, e, n);
  let o = null;
  return (
    n < 0 && (this.level--, (this.delimiters = this._prev_delimiters.pop())),
    (r.level = this.level),
    n > 0 &&
      (this.level++,
      this._prev_delimiters.push(this.delimiters),
      (this.delimiters = []),
      (o = { delimiters: this.delimiters })),
    (this.pendingLevel = this.level),
    this.tokens.push(r),
    this.tokens_meta.push(o),
    r
  );
};
Da.prototype.scanDelims = function (t, e) {
  let n,
    r,
    o = !0,
    i = !0;
  const s = this.posMax,
    a = this.src.charCodeAt(t),
    l = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let u = t;
  for (; u < s && this.src.charCodeAt(u) === a; ) u++;
  const c = u - t,
    d = u < s ? this.src.charCodeAt(u) : 32,
    f = da(l) || ca(String.fromCharCode(l)),
    p = da(d) || ca(String.fromCharCode(d)),
    h = ua(l),
    m = ua(d);
  return (
    m ? (o = !1) : p && (h || f || (o = !1)),
    h ? (i = !1) : f && (m || p || (i = !1)),
    e ? ((n = o), (r = i)) : ((n = o && (!i || f)), (r = i && (!o || p))),
    { can_open: n, can_close: r, length: c }
  );
};
Da.prototype.Token = Yn;
function _E(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function xE(t, e) {
  let n = t.pos;
  for (; n < t.posMax && !_E(t.src.charCodeAt(n)); ) n++;
  return n === t.pos
    ? !1
    : (e || (t.pending += t.src.slice(t.pos, n)), (t.pos = n), !0);
}
const kE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function wE(t, e) {
  if (!t.md.options.linkify || t.linkLevel > 0) return !1;
  const n = t.pos,
    r = t.posMax;
  if (
    n + 3 > r ||
    t.src.charCodeAt(n) !== 58 ||
    t.src.charCodeAt(n + 1) !== 47 ||
    t.src.charCodeAt(n + 2) !== 47
  )
    return !1;
  const o = t.pending.match(kE);
  if (!o) return !1;
  const i = o[1],
    s = t.md.linkify.matchAtStart(t.src.slice(n - i.length));
  if (!s) return !1;
  let a = s.url;
  if (a.length <= i.length) return !1;
  a = a.replace(/\*+$/, "");
  const l = t.md.normalizeLink(a);
  if (!t.md.validateLink(l)) return !1;
  if (!e) {
    t.pending = t.pending.slice(0, -i.length);
    const u = t.push("link_open", "a", 1);
    (u.attrs = [["href", l]]), (u.markup = "linkify"), (u.info = "auto");
    const c = t.push("text", "", 0);
    c.content = t.md.normalizeLinkText(a);
    const d = t.push("link_close", "a", -1);
    (d.markup = "linkify"), (d.info = "auto");
  }
  return (t.pos += a.length - i.length), !0;
}
function CE(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 10) return !1;
  const r = t.pending.length - 1,
    o = t.posMax;
  if (!e)
    if (r >= 0 && t.pending.charCodeAt(r) === 32)
      if (r >= 1 && t.pending.charCodeAt(r - 1) === 32) {
        let i = r - 1;
        for (; i >= 1 && t.pending.charCodeAt(i - 1) === 32; ) i--;
        (t.pending = t.pending.slice(0, i)), t.push("hardbreak", "br", 0);
      } else (t.pending = t.pending.slice(0, -1)), t.push("softbreak", "br", 0);
    else t.push("softbreak", "br", 0);
  for (n++; n < o && Ue(t.src.charCodeAt(n)); ) n++;
  return (t.pos = n), !0;
}
const t0 = [];
for (let t = 0; t < 256; t++) t0.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function (t) {
  t0[t.charCodeAt(0)] = 1;
});
function AE(t, e) {
  let n = t.pos;
  const r = t.posMax;
  if (t.src.charCodeAt(n) !== 92 || (n++, n >= r)) return !1;
  let o = t.src.charCodeAt(n);
  if (o === 10) {
    for (
      e || t.push("hardbreak", "br", 0), n++;
      n < r && ((o = t.src.charCodeAt(n)), !!Ue(o));

    )
      n++;
    return (t.pos = n), !0;
  }
  let i = t.src[n];
  if (o >= 55296 && o <= 56319 && n + 1 < r) {
    const a = t.src.charCodeAt(n + 1);
    a >= 56320 && a <= 57343 && ((i += t.src[n + 1]), n++);
  }
  const s = "\\" + i;
  if (!e) {
    const a = t.push("text_special", "", 0);
    o < 256 && t0[o] !== 0 ? (a.content = i) : (a.content = s),
      (a.markup = s),
      (a.info = "escape");
  }
  return (t.pos = n + 1), !0;
}
function SE(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 96) return !1;
  const o = n;
  n++;
  const i = t.posMax;
  for (; n < i && t.src.charCodeAt(n) === 96; ) n++;
  const s = t.src.slice(o, n),
    a = s.length;
  if (t.backticksScanned && (t.backticks[a] || 0) <= o)
    return e || (t.pending += s), (t.pos += a), !0;
  let l = n,
    u;
  for (; (u = t.src.indexOf("`", l)) !== -1; ) {
    for (l = u + 1; l < i && t.src.charCodeAt(l) === 96; ) l++;
    const c = l - u;
    if (c === a) {
      if (!e) {
        const d = t.push("code_inline", "code", 0);
        (d.markup = s),
          (d.content = t.src
            .slice(n, u)
            .replace(/\n/g, " ")
            .replace(/^ (.+) $/, "$1"));
      }
      return (t.pos = l), !0;
    }
    t.backticks[c] = u;
  }
  return (t.backticksScanned = !0), e || (t.pending += s), (t.pos += a), !0;
}
function EE(t, e) {
  const n = t.pos,
    r = t.src.charCodeAt(n);
  if (e || r !== 126) return !1;
  const o = t.scanDelims(t.pos, !0);
  let i = o.length;
  const s = String.fromCharCode(r);
  if (i < 2) return !1;
  let a;
  i % 2 && ((a = t.push("text", "", 0)), (a.content = s), i--);
  for (let l = 0; l < i; l += 2)
    (a = t.push("text", "", 0)),
      (a.content = s + s),
      t.delimiters.push({
        marker: r,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: t.tokens.length - 1,
        end: -1,
        open: o.can_open,
        close: o.can_close,
      });
  return (t.pos += o.length), !0;
}
function ig(t, e) {
  let n;
  const r = [],
    o = e.length;
  for (let i = 0; i < o; i++) {
    const s = e[i];
    if (s.marker !== 126 || s.end === -1) continue;
    const a = e[s.end];
    (n = t.tokens[s.token]),
      (n.type = "s_open"),
      (n.tag = "s"),
      (n.nesting = 1),
      (n.markup = "~~"),
      (n.content = ""),
      (n = t.tokens[a.token]),
      (n.type = "s_close"),
      (n.tag = "s"),
      (n.nesting = -1),
      (n.markup = "~~"),
      (n.content = ""),
      t.tokens[a.token - 1].type === "text" &&
        t.tokens[a.token - 1].content === "~" &&
        r.push(a.token - 1);
  }
  for (; r.length; ) {
    const i = r.pop();
    let s = i + 1;
    for (; s < t.tokens.length && t.tokens[s].type === "s_close"; ) s++;
    s--,
      i !== s &&
        ((n = t.tokens[s]), (t.tokens[s] = t.tokens[i]), (t.tokens[i] = n));
  }
}
function ME(t) {
  const e = t.tokens_meta,
    n = t.tokens_meta.length;
  ig(t, t.delimiters);
  for (let r = 0; r < n; r++) e[r] && e[r].delimiters && ig(t, e[r].delimiters);
}
const Qv = {
  tokenize: EE,
  postProcess: ME,
};
function TE(t, e) {
  const n = t.pos,
    r = t.src.charCodeAt(n);
  if (e || (r !== 95 && r !== 42)) return !1;
  const o = t.scanDelims(t.pos, r === 42);
  for (let i = 0; i < o.length; i++) {
    const s = t.push("text", "", 0);
    (s.content = String.fromCharCode(r)),
      t.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker: r,
        // Total length of these series of delimiters.
        //
        length: o.length,
        // A position of the token this delimiter corresponds to.
        //
        token: t.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: o.can_open,
        close: o.can_close,
      });
  }
  return (t.pos += o.length), !0;
}
function sg(t, e) {
  const n = e.length;
  for (let r = n - 1; r >= 0; r--) {
    const o = e[r];
    if ((o.marker !== 95 && o.marker !== 42) || o.end === -1) continue;
    const i = e[o.end],
      s =
        r > 0 &&
        e[r - 1].end === o.end + 1 && // check that first two markers match and adjacent
        e[r - 1].marker === o.marker &&
        e[r - 1].token === o.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        e[o.end + 1].token === i.token + 1,
      a = String.fromCharCode(o.marker),
      l = t.tokens[o.token];
    (l.type = s ? "strong_open" : "em_open"),
      (l.tag = s ? "strong" : "em"),
      (l.nesting = 1),
      (l.markup = s ? a + a : a),
      (l.content = "");
    const u = t.tokens[i.token];
    (u.type = s ? "strong_close" : "em_close"),
      (u.tag = s ? "strong" : "em"),
      (u.nesting = -1),
      (u.markup = s ? a + a : a),
      (u.content = ""),
      s &&
        ((t.tokens[e[r - 1].token].content = ""),
        (t.tokens[e[o.end + 1].token].content = ""),
        r--);
  }
}
function OE(t) {
  const e = t.tokens_meta,
    n = t.tokens_meta.length;
  sg(t, t.delimiters);
  for (let r = 0; r < n; r++) e[r] && e[r].delimiters && sg(t, e[r].delimiters);
}
const e_ = {
  tokenize: TE,
  postProcess: OE,
};
function DE(t, e) {
  let n,
    r,
    o,
    i,
    s = "",
    a = "",
    l = t.pos,
    u = !0;
  if (t.src.charCodeAt(t.pos) !== 91) return !1;
  const c = t.pos,
    d = t.posMax,
    f = t.pos + 1,
    p = t.md.helpers.parseLinkLabel(t, t.pos, !0);
  if (p < 0) return !1;
  let h = p + 1;
  if (h < d && t.src.charCodeAt(h) === 40) {
    for (
      u = !1, h++;
      h < d && ((n = t.src.charCodeAt(h)), !(!Ue(n) && n !== 10));
      h++
    );
    if (h >= d) return !1;
    if (
      ((l = h),
      (o = t.md.helpers.parseLinkDestination(t.src, h, t.posMax)),
      o.ok)
    ) {
      for (
        s = t.md.normalizeLink(o.str),
          t.md.validateLink(s) ? (h = o.pos) : (s = ""),
          l = h;
        h < d && ((n = t.src.charCodeAt(h)), !(!Ue(n) && n !== 10));
        h++
      );
      if (
        ((o = t.md.helpers.parseLinkTitle(t.src, h, t.posMax)),
        h < d && l !== h && o.ok)
      )
        for (
          a = o.str, h = o.pos;
          h < d && ((n = t.src.charCodeAt(h)), !(!Ue(n) && n !== 10));
          h++
        );
    }
    (h >= d || t.src.charCodeAt(h) !== 41) && (u = !0), h++;
  }
  if (u) {
    if (typeof t.env.references > "u") return !1;
    if (
      (h < d && t.src.charCodeAt(h) === 91
        ? ((l = h + 1),
          (h = t.md.helpers.parseLinkLabel(t, h)),
          h >= 0 ? (r = t.src.slice(l, h++)) : (h = p + 1))
        : (h = p + 1),
      r || (r = t.src.slice(f, p)),
      (i = t.env.references[ed(r)]),
      !i)
    )
      return (t.pos = c), !1;
    (s = i.href), (a = i.title);
  }
  if (!e) {
    (t.pos = f), (t.posMax = p);
    const m = t.push("link_open", "a", 1),
      g = [["href", s]];
    (m.attrs = g),
      a && g.push(["title", a]),
      t.linkLevel++,
      t.md.inline.tokenize(t),
      t.linkLevel--,
      t.push("link_close", "a", -1);
  }
  return (t.pos = h), (t.posMax = d), !0;
}
function NE(t, e) {
  let n,
    r,
    o,
    i,
    s,
    a,
    l,
    u,
    c = "";
  const d = t.pos,
    f = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
    return !1;
  const p = t.pos + 2,
    h = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
  if (h < 0) return !1;
  if (((i = h + 1), i < f && t.src.charCodeAt(i) === 40)) {
    for (i++; i < f && ((n = t.src.charCodeAt(i)), !(!Ue(n) && n !== 10)); i++);
    if (i >= f) return !1;
    for (
      u = i,
        a = t.md.helpers.parseLinkDestination(t.src, i, t.posMax),
        a.ok &&
          ((c = t.md.normalizeLink(a.str)),
          t.md.validateLink(c) ? (i = a.pos) : (c = "")),
        u = i;
      i < f && ((n = t.src.charCodeAt(i)), !(!Ue(n) && n !== 10));
      i++
    );
    if (
      ((a = t.md.helpers.parseLinkTitle(t.src, i, t.posMax)),
      i < f && u !== i && a.ok)
    )
      for (
        l = a.str, i = a.pos;
        i < f && ((n = t.src.charCodeAt(i)), !(!Ue(n) && n !== 10));
        i++
      );
    else l = "";
    if (i >= f || t.src.charCodeAt(i) !== 41) return (t.pos = d), !1;
    i++;
  } else {
    if (typeof t.env.references > "u") return !1;
    if (
      (i < f && t.src.charCodeAt(i) === 91
        ? ((u = i + 1),
          (i = t.md.helpers.parseLinkLabel(t, i)),
          i >= 0 ? (o = t.src.slice(u, i++)) : (i = h + 1))
        : (i = h + 1),
      o || (o = t.src.slice(p, h)),
      (s = t.env.references[ed(o)]),
      !s)
    )
      return (t.pos = d), !1;
    (c = s.href), (l = s.title);
  }
  if (!e) {
    r = t.src.slice(p, h);
    const m = [];
    t.md.inline.parse(r, t.md, t.env, m);
    const g = t.push("image", "img", 0),
      b = [
        ["src", c],
        ["alt", ""],
      ];
    (g.attrs = b), (g.children = m), (g.content = r), l && b.push(["title", l]);
  }
  return (t.pos = i), (t.posMax = f), !0;
}
const LE =
    /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,
  RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function IE(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 60) return !1;
  const r = t.pos,
    o = t.posMax;
  for (;;) {
    if (++n >= o) return !1;
    const s = t.src.charCodeAt(n);
    if (s === 60) return !1;
    if (s === 62) break;
  }
  const i = t.src.slice(r + 1, n);
  if (RE.test(i)) {
    const s = t.md.normalizeLink(i);
    if (!t.md.validateLink(s)) return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      (a.attrs = [["href", s]]), (a.markup = "autolink"), (a.info = "auto");
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(i);
      const u = t.push("link_close", "a", -1);
      (u.markup = "autolink"), (u.info = "auto");
    }
    return (t.pos += i.length + 2), !0;
  }
  if (LE.test(i)) {
    const s = t.md.normalizeLink("mailto:" + i);
    if (!t.md.validateLink(s)) return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      (a.attrs = [["href", s]]), (a.markup = "autolink"), (a.info = "auto");
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(i);
      const u = t.push("link_close", "a", -1);
      (u.markup = "autolink"), (u.info = "auto");
    }
    return (t.pos += i.length + 2), !0;
  }
  return !1;
}
function PE(t) {
  return /^<a[>\s]/i.test(t);
}
function $E(t) {
  return /^<\/a\s*>/i.test(t);
}
function BE(t) {
  const e = t | 32;
  return e >= 97 && e <= 122;
}
function HE(t, e) {
  if (!t.md.options.html) return !1;
  const n = t.posMax,
    r = t.pos;
  if (t.src.charCodeAt(r) !== 60 || r + 2 >= n) return !1;
  const o = t.src.charCodeAt(r + 1);
  if (o !== 33 && o !== 63 && o !== 47 && !BE(o)) return !1;
  const i = t.src.slice(r).match(hE);
  if (!i) return !1;
  if (!e) {
    const s = t.push("html_inline", "", 0);
    (s.content = i[0]),
      PE(s.content) && t.linkLevel++,
      $E(s.content) && t.linkLevel--;
  }
  return (t.pos += i[0].length), !0;
}
const FE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,
  zE = /^&([a-z][a-z0-9]{1,31});/i;
function VE(t, e) {
  const n = t.pos,
    r = t.posMax;
  if (t.src.charCodeAt(n) !== 38 || n + 1 >= r) return !1;
  if (t.src.charCodeAt(n + 1) === 35) {
    const i = t.src.slice(n).match(FE);
    if (i) {
      if (!e) {
        const s =
            i[1][0].toLowerCase() === "x"
              ? parseInt(i[1].slice(1), 16)
              : parseInt(i[1], 10),
          a = t.push("text_special", "", 0);
        (a.content = Qh(s) ? Cu(s) : Cu(65533)),
          (a.markup = i[0]),
          (a.info = "entity");
      }
      return (t.pos += i[0].length), !0;
    }
  } else {
    const i = t.src.slice(n).match(zE);
    if (i) {
      const s = qv(i[0]);
      if (s !== i[0]) {
        if (!e) {
          const a = t.push("text_special", "", 0);
          (a.content = s), (a.markup = i[0]), (a.info = "entity");
        }
        return (t.pos += i[0].length), !0;
      }
    }
  }
  return !1;
}
function ag(t) {
  const e = {},
    n = t.length;
  if (!n) return;
  let r = 0,
    o = -2;
  const i = [];
  for (let s = 0; s < n; s++) {
    const a = t[s];
    if (
      (i.push(0),
      (t[r].marker !== a.marker || o !== a.token - 1) && (r = s),
      (o = a.token),
      (a.length = a.length || 0),
      !a.close)
    )
      continue;
    e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[a.marker][(a.open ? 3 : 0) + (a.length % 3)];
    let u = r - i[r] - 1,
      c = u;
    for (; u > l; u -= i[u] + 1) {
      const d = t[u];
      if (d.marker === a.marker && d.open && d.end < 0) {
        let f = !1;
        if (
          ((d.close || a.open) &&
            (d.length + a.length) % 3 === 0 &&
            (d.length % 3 !== 0 || a.length % 3 !== 0) &&
            (f = !0),
          !f)
        ) {
          const p = u > 0 && !t[u - 1].open ? i[u - 1] + 1 : 0;
          (i[s] = s - u + p),
            (i[u] = p),
            (a.open = !1),
            (d.end = s),
            (d.close = !1),
            (c = -1),
            (o = -2);
          break;
        }
      }
    }
    c !== -1 && (e[a.marker][(a.open ? 3 : 0) + ((a.length || 0) % 3)] = c);
  }
}
function UE(t) {
  const e = t.tokens_meta,
    n = t.tokens_meta.length;
  ag(t.delimiters);
  for (let r = 0; r < n; r++) e[r] && e[r].delimiters && ag(e[r].delimiters);
}
function jE(t) {
  let e,
    n,
    r = 0;
  const o = t.tokens,
    i = t.tokens.length;
  for (e = n = 0; e < i; e++)
    o[e].nesting < 0 && r--,
      (o[e].level = r),
      o[e].nesting > 0 && r++,
      o[e].type === "text" && e + 1 < i && o[e + 1].type === "text"
        ? (o[e + 1].content = o[e].content + o[e + 1].content)
        : (e !== n && (o[n] = o[e]), n++);
  e !== n && (o.length = n);
}
const ef = [
    ["text", xE],
    ["linkify", wE],
    ["newline", CE],
    ["escape", AE],
    ["backticks", SE],
    ["strikethrough", Qv.tokenize],
    ["emphasis", e_.tokenize],
    ["link", DE],
    ["image", NE],
    ["autolink", IE],
    ["html_inline", HE],
    ["entity", VE],
  ],
  tf = [
    ["balance_pairs", UE],
    ["strikethrough", Qv.postProcess],
    ["emphasis", e_.postProcess],
    // rules for pairs separate '**' into its own text tokens, which may be left unused,
    // rule below merges unused segments back with the rest of the text
    ["fragments_join", jE],
  ];
function Na() {
  this.ruler = new en();
  for (let t = 0; t < ef.length; t++) this.ruler.push(ef[t][0], ef[t][1]);
  this.ruler2 = new en();
  for (let t = 0; t < tf.length; t++) this.ruler2.push(tf[t][0], tf[t][1]);
}
Na.prototype.skipToken = function (t) {
  const e = t.pos,
    n = this.ruler.getRules(""),
    r = n.length,
    o = t.md.options.maxNesting,
    i = t.cache;
  if (typeof i[e] < "u") {
    t.pos = i[e];
    return;
  }
  let s = !1;
  if (t.level < o) {
    for (let a = 0; a < r; a++)
      if ((t.level++, (s = n[a](t, !0)), t.level--, s)) {
        if (e >= t.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else t.pos = t.posMax;
  s || t.pos++, (i[e] = t.pos);
};
Na.prototype.tokenize = function (t) {
  const e = this.ruler.getRules(""),
    n = e.length,
    r = t.posMax,
    o = t.md.options.maxNesting;
  for (; t.pos < r; ) {
    const i = t.pos;
    let s = !1;
    if (t.level < o) {
      for (let a = 0; a < n; a++)
        if (((s = e[a](t, !1)), s)) {
          if (i >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (s) {
      if (t.pos >= r) break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
Na.prototype.parse = function (t, e, n, r) {
  const o = new this.State(t, e, n, r);
  this.tokenize(o);
  const i = this.ruler2.getRules(""),
    s = i.length;
  for (let a = 0; a < s; a++) i[a](o);
};
Na.prototype.State = Da;
function WE(t) {
  const e = {};
  (t = t || {}),
    (e.src_Any = Vv.source),
    (e.src_Cc = Uv.source),
    (e.src_Z = jv.source),
    (e.src_P = Xh.source),
    (e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|")),
    (e.src_ZCc = [e.src_Z, e.src_Cc].join("|"));
  const n = "[><]";
  return (
    (e.src_pseudo_letter =
      "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")"),
    (e.src_ip4 =
      "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"),
    (e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?"),
    (e.src_port =
      "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?"),
    (e.src_host_terminator =
      "(?=$|" +
      n +
      "|" +
      e.src_ZPCc +
      ")(?!" +
      (t["---"] ? "-(?!--)|" : "-|") +
      "_|:\\d|\\.-|\\.(?!$|" +
      e.src_ZPCc +
      "))"),
    (e.src_path =
      "(?:[/?#](?:(?!" +
      e.src_ZCc +
      "|" +
      n +
      `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` +
      e.src_ZCc +
      "|\\]).)*\\]|\\((?:(?!" +
      e.src_ZCc +
      "|[)]).)*\\)|\\{(?:(?!" +
      e.src_ZCc +
      '|[}]).)*\\}|\\"(?:(?!' +
      e.src_ZCc +
      `|["]).)+\\"|\\'(?:(?!` +
      e.src_ZCc +
      "|[']).)+\\'|\\'(?=" +
      e.src_pseudo_letter +
      "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" +
      e.src_ZCc +
      "|[.]|$)|" +
      (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
      ",(?!" +
      e.src_ZCc +
      "|$)|;(?!" +
      e.src_ZCc +
      "|$)|\\!+(?!" +
      e.src_ZCc +
      "|[!]|$)|\\?(?!" +
      e.src_ZCc +
      "|[?]|$))+|\\/)?"),
    (e.src_email_name =
      '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*'),
    (e.src_xn = "xn--[a-z0-9\\-]{1,59}"),
    (e.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})"),
    (e.src_domain =
      "(?:" +
      e.src_xn +
      "|(?:" +
      e.src_pseudo_letter +
      ")|(?:" +
      e.src_pseudo_letter +
      "(?:-|" +
      e.src_pseudo_letter +
      "){0,61}" +
      e.src_pseudo_letter +
      "))"),
    (e.src_host =
      "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))"),
    (e.tpl_host_fuzzy =
      "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))"),
    (e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))"),
    (e.src_host_strict = e.src_host + e.src_host_terminator),
    (e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator),
    (e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator),
    (e.tpl_host_port_fuzzy_strict =
      e.tpl_host_fuzzy + e.src_port + e.src_host_terminator),
    (e.tpl_host_port_no_ip_fuzzy_strict =
      e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator),
    (e.tpl_host_fuzzy_test =
      "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" +
      e.src_ZPCc +
      "|>|$))"),
    (e.tpl_email_fuzzy =
      "(^|" +
      n +
      '|"|\\(|' +
      e.src_ZCc +
      ")(" +
      e.src_email_name +
      "@" +
      e.tpl_host_fuzzy_strict +
      ")"),
    (e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" +
      e.src_ZPCc +
      "))((?![$+<=>^`|])" +
      e.tpl_host_port_fuzzy_strict +
      e.src_path +
      ")"),
    (e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" +
      e.src_ZPCc +
      "))((?![$+<=>^`|])" +
      e.tpl_host_port_no_ip_fuzzy_strict +
      e.src_path +
      ")"),
    e
  );
}
function wp(t) {
  return (
    Array.prototype.slice.call(arguments, 1).forEach(function (n) {
      n &&
        Object.keys(n).forEach(function (r) {
          t[r] = n[r];
        });
    }),
    t
  );
}
function nd(t) {
  return Object.prototype.toString.call(t);
}
function qE(t) {
  return nd(t) === "[object String]";
}
function KE(t) {
  return nd(t) === "[object Object]";
}
function GE(t) {
  return nd(t) === "[object RegExp]";
}
function lg(t) {
  return nd(t) === "[object Function]";
}
function JE(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const t_ = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1,
};
function YE(t) {
  return Object.keys(t || {}).reduce(function (e, n) {
    return e || t_.hasOwnProperty(n);
  }, !1);
}
const XE = {
    "http:": {
      validate: function (t, e, n) {
        const r = t.slice(e);
        return (
          n.re.http ||
            (n.re.http = new RegExp(
              "^\\/\\/" +
                n.re.src_auth +
                n.re.src_host_port_strict +
                n.re.src_path,
              "i"
            )),
          n.re.http.test(r) ? r.match(n.re.http)[0].length : 0
        );
      },
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function (t, e, n) {
        const r = t.slice(e);
        return (
          n.re.no_http ||
            (n.re.no_http = new RegExp(
              "^" +
                n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
                // with code comments
                "(?:localhost|(?:(?:" +
                n.re.src_domain +
                ")\\.)+" +
                n.re.src_domain_root +
                ")" +
                n.re.src_port +
                n.re.src_host_terminator +
                n.re.src_path,
              "i"
            )),
          n.re.no_http.test(r)
            ? (e >= 3 && t[e - 3] === ":") || (e >= 3 && t[e - 3] === "/")
              ? 0
              : r.match(n.re.no_http)[0].length
            : 0
        );
      },
    },
    "mailto:": {
      validate: function (t, e, n) {
        const r = t.slice(e);
        return (
          n.re.mailto ||
            (n.re.mailto = new RegExp(
              "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
              "i"
            )),
          n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0
        );
      },
    },
  },
  ZE =
    "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
  QE =
    "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split(
      "|"
    );
function e8(t) {
  (t.__index__ = -1), (t.__text_cache__ = "");
}
function t8(t) {
  return function (e, n) {
    const r = e.slice(n);
    return t.test(r) ? r.match(t)[0].length : 0;
  };
}
function ug() {
  return function (t, e) {
    e.normalize(t);
  };
}
function Au(t) {
  const e = (t.re = WE(t.__opts__)),
    n = t.__tlds__.slice();
  t.onCompile(),
    t.__tlds_replaced__ || n.push(ZE),
    n.push(e.src_xn),
    (e.src_tlds = n.join("|"));
  function r(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  (e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i")),
    (e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i")),
    (e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i")),
    (e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i"));
  const o = [];
  t.__compiled__ = {};
  function i(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(t.__schemas__).forEach(function (a) {
    const l = t.__schemas__[a];
    if (l === null) return;
    const u = { validate: null, link: null };
    if (((t.__compiled__[a] = u), KE(l))) {
      GE(l.validate)
        ? (u.validate = t8(l.validate))
        : lg(l.validate)
        ? (u.validate = l.validate)
        : i(a, l),
        lg(l.normalize)
          ? (u.normalize = l.normalize)
          : l.normalize
          ? i(a, l)
          : (u.normalize = ug());
      return;
    }
    if (qE(l)) {
      o.push(a);
      return;
    }
    i(a, l);
  }),
    o.forEach(function (a) {
      t.__compiled__[t.__schemas__[a]] &&
        ((t.__compiled__[a].validate =
          t.__compiled__[t.__schemas__[a]].validate),
        (t.__compiled__[a].normalize =
          t.__compiled__[t.__schemas__[a]].normalize));
    }),
    (t.__compiled__[""] = { validate: null, normalize: ug() });
  const s = Object.keys(t.__compiled__)
    .filter(function (a) {
      return a.length > 0 && t.__compiled__[a];
    })
    .map(JE)
    .join("|");
  (t.re.schema_test = RegExp(
    "(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + s + ")",
    "i"
  )),
    (t.re.schema_search = RegExp(
      "(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + s + ")",
      "ig"
    )),
    (t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i")),
    (t.re.pretest = RegExp(
      "(" +
        t.re.schema_test.source +
        ")|(" +
        t.re.host_fuzzy_test.source +
        ")|@",
      "i"
    )),
    e8(t);
}
function n8(t, e) {
  const n = t.__index__,
    r = t.__last_index__,
    o = t.__text_cache__.slice(n, r);
  (this.schema = t.__schema__.toLowerCase()),
    (this.index = n + e),
    (this.lastIndex = r + e),
    (this.raw = o),
    (this.text = o),
    (this.url = o);
}
function Cp(t, e) {
  const n = new n8(t, e);
  return t.__compiled__[n.schema].normalize(n, t), n;
}
function dn(t, e) {
  if (!(this instanceof dn)) return new dn(t, e);
  e || (YE(t) && ((e = t), (t = {}))),
    (this.__opts__ = wp({}, t_, e)),
    (this.__index__ = -1),
    (this.__last_index__ = -1),
    (this.__schema__ = ""),
    (this.__text_cache__ = ""),
    (this.__schemas__ = wp({}, XE, t)),
    (this.__compiled__ = {}),
    (this.__tlds__ = QE),
    (this.__tlds_replaced__ = !1),
    (this.re = {}),
    Au(this);
}
dn.prototype.add = function (e, n) {
  return (this.__schemas__[e] = n), Au(this), this;
};
dn.prototype.set = function (e) {
  return (this.__opts__ = wp(this.__opts__, e)), this;
};
dn.prototype.test = function (e) {
  if (((this.__text_cache__ = e), (this.__index__ = -1), !e.length)) return !1;
  let n, r, o, i, s, a, l, u, c;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (n = l.exec(e)) !== null; )
      if (((i = this.testSchemaAt(e, n[2], l.lastIndex)), i)) {
        (this.__schema__ = n[2]),
          (this.__index__ = n.index + n[1].length),
          (this.__last_index__ = n.index + n[0].length + i);
        break;
      }
  }
  return (
    this.__opts__.fuzzyLink &&
      this.__compiled__["http:"] &&
      ((u = e.search(this.re.host_fuzzy_test)),
      u >= 0 &&
        (this.__index__ < 0 || u < this.__index__) &&
        (r = e.match(
          this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy
        )) !== null &&
        ((s = r.index + r[1].length),
        (this.__index__ < 0 || s < this.__index__) &&
          ((this.__schema__ = ""),
          (this.__index__ = s),
          (this.__last_index__ = r.index + r[0].length)))),
    this.__opts__.fuzzyEmail &&
      this.__compiled__["mailto:"] &&
      ((c = e.indexOf("@")),
      c >= 0 &&
        (o = e.match(this.re.email_fuzzy)) !== null &&
        ((s = o.index + o[1].length),
        (a = o.index + o[0].length),
        (this.__index__ < 0 ||
          s < this.__index__ ||
          (s === this.__index__ && a > this.__last_index__)) &&
          ((this.__schema__ = "mailto:"),
          (this.__index__ = s),
          (this.__last_index__ = a)))),
    this.__index__ >= 0
  );
};
dn.prototype.pretest = function (e) {
  return this.re.pretest.test(e);
};
dn.prototype.testSchemaAt = function (e, n, r) {
  return this.__compiled__[n.toLowerCase()]
    ? this.__compiled__[n.toLowerCase()].validate(e, r, this)
    : 0;
};
dn.prototype.match = function (e) {
  const n = [];
  let r = 0;
  this.__index__ >= 0 &&
    this.__text_cache__ === e &&
    (n.push(Cp(this, r)), (r = this.__last_index__));
  let o = r ? e.slice(r) : e;
  for (; this.test(o); )
    n.push(Cp(this, r)),
      (o = o.slice(this.__last_index__)),
      (r += this.__last_index__);
  return n.length ? n : null;
};
dn.prototype.matchAtStart = function (e) {
  if (((this.__text_cache__ = e), (this.__index__ = -1), !e.length))
    return null;
  const n = this.re.schema_at_start.exec(e);
  if (!n) return null;
  const r = this.testSchemaAt(e, n[2], n[0].length);
  return r
    ? ((this.__schema__ = n[2]),
      (this.__index__ = n.index + n[1].length),
      (this.__last_index__ = n.index + n[0].length + r),
      Cp(this, 0))
    : null;
};
dn.prototype.tlds = function (e, n) {
  return (
    (e = Array.isArray(e) ? e : [e]),
    n
      ? ((this.__tlds__ = this.__tlds__
          .concat(e)
          .sort()
          .filter(function (r, o, i) {
            return r !== i[o - 1];
          })
          .reverse()),
        Au(this),
        this)
      : ((this.__tlds__ = e.slice()),
        (this.__tlds_replaced__ = !0),
        Au(this),
        this)
  );
};
dn.prototype.normalize = function (e) {
  e.schema || (e.url = "http://" + e.url),
    e.schema === "mailto:" &&
      !/^mailto:/i.test(e.url) &&
      (e.url = "mailto:" + e.url);
};
dn.prototype.onCompile = function () {};
const Hi = 2147483647,
  cr = 36,
  n0 = 1,
  fa = 26,
  r8 = 38,
  o8 = 700,
  n_ = 72,
  r_ = 128,
  o_ = "-",
  i8 = /^xn--/,
  s8 = /[^\0-\x7F]/,
  a8 = /[\x2E\u3002\uFF0E\uFF61]/g,
  l8 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input",
  },
  nf = cr - n0,
  dr = Math.floor,
  rf = String.fromCharCode;
function oo(t) {
  throw new RangeError(l8[t]);
}
function u8(t, e) {
  const n = [];
  let r = t.length;
  for (; r--; ) n[r] = e(t[r]);
  return n;
}
function i_(t, e) {
  const n = t.split("@");
  let r = "";
  n.length > 1 && ((r = n[0] + "@"), (t = n[1])), (t = t.replace(a8, "."));
  const o = t.split("."),
    i = u8(o, e).join(".");
  return r + i;
}
function s_(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const o = t.charCodeAt(n++);
    if (o >= 55296 && o <= 56319 && n < r) {
      const i = t.charCodeAt(n++);
      (i & 64512) == 56320
        ? e.push(((o & 1023) << 10) + (i & 1023) + 65536)
        : (e.push(o), n--);
    } else e.push(o);
  }
  return e;
}
const c8 = (t) => String.fromCodePoint(...t),
  d8 = function (t) {
    return t >= 48 && t < 58
      ? 26 + (t - 48)
      : t >= 65 && t < 91
      ? t - 65
      : t >= 97 && t < 123
      ? t - 97
      : cr;
  },
  cg = function (t, e) {
    return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
  },
  a_ = function (t, e, n) {
    let r = 0;
    for (
      t = n ? dr(t / o8) : t >> 1, t += dr(t / e);
      t > (nf * fa) >> 1;
      r += cr
    )
      t = dr(t / nf);
    return dr(r + ((nf + 1) * t) / (t + r8));
  },
  l_ = function (t) {
    const e = [],
      n = t.length;
    let r = 0,
      o = r_,
      i = n_,
      s = t.lastIndexOf(o_);
    s < 0 && (s = 0);
    for (let a = 0; a < s; ++a)
      t.charCodeAt(a) >= 128 && oo("not-basic"), e.push(t.charCodeAt(a));
    for (let a = s > 0 ? s + 1 : 0; a < n; ) {
      const l = r;
      for (let c = 1, d = cr; ; d += cr) {
        a >= n && oo("invalid-input");
        const f = d8(t.charCodeAt(a++));
        f >= cr && oo("invalid-input"),
          f > dr((Hi - r) / c) && oo("overflow"),
          (r += f * c);
        const p = d <= i ? n0 : d >= i + fa ? fa : d - i;
        if (f < p) break;
        const h = cr - p;
        c > dr(Hi / h) && oo("overflow"), (c *= h);
      }
      const u = e.length + 1;
      (i = a_(r - l, u, l == 0)),
        dr(r / u) > Hi - o && oo("overflow"),
        (o += dr(r / u)),
        (r %= u),
        e.splice(r++, 0, o);
    }
    return String.fromCodePoint(...e);
  },
  u_ = function (t) {
    const e = [];
    t = s_(t);
    const n = t.length;
    let r = r_,
      o = 0,
      i = n_;
    for (const l of t) l < 128 && e.push(rf(l));
    const s = e.length;
    let a = s;
    for (s && e.push(o_); a < n; ) {
      let l = Hi;
      for (const c of t) c >= r && c < l && (l = c);
      const u = a + 1;
      l - r > dr((Hi - o) / u) && oo("overflow"), (o += (l - r) * u), (r = l);
      for (const c of t)
        if ((c < r && ++o > Hi && oo("overflow"), c === r)) {
          let d = o;
          for (let f = cr; ; f += cr) {
            const p = f <= i ? n0 : f >= i + fa ? fa : f - i;
            if (d < p) break;
            const h = d - p,
              m = cr - p;
            e.push(rf(cg(p + (h % m), 0))), (d = dr(h / m));
          }
          e.push(rf(cg(d, 0))), (i = a_(o, u, a === s)), (o = 0), ++a;
        }
      ++o, ++r;
    }
    return e.join("");
  },
  f8 = function (t) {
    return i_(t, function (e) {
      return i8.test(e) ? l_(e.slice(4).toLowerCase()) : e;
    });
  },
  p8 = function (t) {
    return i_(t, function (e) {
      return s8.test(e) ? "xn--" + u_(e) : e;
    });
  },
  c_ = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    version: "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    ucs2: {
      decode: s_,
      encode: c8,
    },
    decode: l_,
    encode: u_,
    toASCII: p8,
    toUnicode: f8,
  },
  h8 = {
    options: {
      // Enable HTML tags in source
      html: !1,
      // Use '/' to close single tags (<br />)
      xhtmlOut: !1,
      // Convert '\n' in paragraphs into <br>
      breaks: !1,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: !1,
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 100,
    },
    components: {
      core: {},
      block: {},
      inline: {},
    },
  },
  m8 = {
    options: {
      // Enable HTML tags in source
      html: !1,
      // Use '/' to close single tags (<br />)
      xhtmlOut: !1,
      // Convert '\n' in paragraphs into <br>
      breaks: !1,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: !1,
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20,
    },
    components: {
      core: {
        rules: ["normalize", "block", "inline", "text_join"],
      },
      block: {
        rules: ["paragraph"],
      },
      inline: {
        rules: ["text"],
        rules2: ["balance_pairs", "fragments_join"],
      },
    },
  },
  g8 = {
    options: {
      // Enable HTML tags in source
      html: !0,
      // Use '/' to close single tags (<br />)
      xhtmlOut: !0,
      // Convert '\n' in paragraphs into <br>
      breaks: !1,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: !1,
      // Enable some language-neutral replacements + quotes beautification
      typographer: !1,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20,
    },
    components: {
      core: {
        rules: ["normalize", "block", "inline", "text_join"],
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph",
        ],
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text",
        ],
        rules2: ["balance_pairs", "emphasis", "fragments_join"],
      },
    },
  },
  b8 = {
    default: h8,
    zero: m8,
    commonmark: g8,
  },
  y8 = /^(vbscript|javascript|file|data):/,
  v8 = /^data:image\/(gif|png|jpeg|webp);/;
function _8(t) {
  const e = t.trim().toLowerCase();
  return y8.test(e) ? v8.test(e) : !0;
}
const d_ = ["http:", "https:", "mailto:"];
function x8(t) {
  const e = Yh(t, !0);
  if (e.hostname && (!e.protocol || d_.indexOf(e.protocol) >= 0))
    try {
      e.hostname = c_.toASCII(e.hostname);
    } catch {}
  return Oa(Jh(e));
}
function k8(t) {
  const e = Yh(t, !0);
  if (e.hostname && (!e.protocol || d_.indexOf(e.protocol) >= 0))
    try {
      e.hostname = c_.toUnicode(e.hostname);
    } catch {}
  return Ki(Jh(e), Ki.defaultChars + "%");
}
function Tn(t, e) {
  if (!(this instanceof Tn)) return new Tn(t, e);
  e || Zh(t) || ((e = t || {}), (t = "default")),
    (this.inline = new Na()),
    (this.block = new td()),
    (this.core = new e0()),
    (this.renderer = new rs()),
    (this.linkify = new dn()),
    (this.validateLink = _8),
    (this.normalizeLink = x8),
    (this.normalizeLinkText = k8),
    (this.utils = AS),
    (this.helpers = Qc({}, TS)),
    (this.options = {}),
    this.configure(t),
    e && this.set(e);
}
Tn.prototype.set = function (t) {
  return Qc(this.options, t), this;
};
Tn.prototype.configure = function (t) {
  const e = this;
  if (Zh(t)) {
    const n = t;
    if (((t = b8[n]), !t))
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!t) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return (
    t.options && e.set(t.options),
    t.components &&
      Object.keys(t.components).forEach(function (n) {
        t.components[n].rules && e[n].ruler.enableOnly(t.components[n].rules),
          t.components[n].rules2 &&
            e[n].ruler2.enableOnly(t.components[n].rules2);
      }),
    this
  );
};
Tn.prototype.enable = function (t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]),
    ["core", "block", "inline"].forEach(function (o) {
      n = n.concat(this[o].ruler.enable(t, !0));
    }, this),
    (n = n.concat(this.inline.ruler2.enable(t, !0)));
  const r = t.filter(function (o) {
    return n.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
Tn.prototype.disable = function (t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]),
    ["core", "block", "inline"].forEach(function (o) {
      n = n.concat(this[o].ruler.disable(t, !0));
    }, this),
    (n = n.concat(this.inline.ruler2.disable(t, !0)));
  const r = t.filter(function (o) {
    return n.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
Tn.prototype.use = function (t) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
Tn.prototype.parse = function (t, e) {
  if (typeof t != "string") throw new Error("Input data should be a String");
  const n = new this.core.State(t, this, e);
  return this.core.process(n), n.tokens;
};
Tn.prototype.render = function (t, e) {
  return (e = e || {}), this.renderer.render(this.parse(t, e), this.options, e);
};
Tn.prototype.parseInline = function (t, e) {
  const n = new this.core.State(t, this, e);
  return (n.inlineMode = !0), this.core.process(n), n.tokens;
};
Tn.prototype.renderInline = function (t, e) {
  return (
    (e = e || {}), this.renderer.render(this.parseInline(t, e), this.options, e)
  );
};
const w8 = new Uc({
  nodes: {
    doc: {
      content: "block+",
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      },
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      },
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      },
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: !0,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } },
      ],
      toDOM(t) {
        return ["h" + t.attrs.level, 0];
      },
    },
    code_block: {
      content: "text*",
      group: "block",
      code: !0,
      defining: !0,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [
        {
          tag: "pre",
          preserveWhitespace: "full",
          getAttrs: (t) => ({ params: t.getAttribute("data-params") || "" }),
        },
      ],
      toDOM(t) {
        return [
          "pre",
          t.attrs.params ? { "data-params": t.attrs.params } : {},
          ["code", 0],
        ];
      },
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: !1 } },
      parseDOM: [
        {
          tag: "ol",
          getAttrs(t) {
            return {
              order: t.hasAttribute("start") ? +t.getAttribute("start") : 1,
              tight: t.hasAttribute("data-tight"),
            };
          },
        },
      ],
      toDOM(t) {
        return [
          "ol",
          {
            start: t.attrs.order == 1 ? null : t.attrs.order,
            "data-tight": t.attrs.tight ? "true" : null,
          },
          0,
        ];
      },
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: !1 } },
      parseDOM: [
        {
          tag: "ul",
          getAttrs: (t) => ({ tight: t.hasAttribute("data-tight") }),
        },
      ],
      toDOM(t) {
        return ["ul", { "data-tight": t.attrs.tight ? "true" : null }, 0];
      },
    },
    list_item: {
      content: "block+",
      defining: !0,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      },
    },
    text: {
      group: "inline",
    },
    image: {
      inline: !0,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null },
      },
      group: "inline",
      draggable: !0,
      parseDOM: [
        {
          tag: "img[src]",
          getAttrs(t) {
            return {
              src: t.getAttribute("src"),
              title: t.getAttribute("title"),
              alt: t.getAttribute("alt"),
            };
          },
        },
      ],
      toDOM(t) {
        return ["img", t.attrs];
      },
    },
    hard_break: {
      inline: !0,
      group: "inline",
      selectable: !1,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      },
    },
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (t) => t.type.name == "em" },
      ],
      toDOM() {
        return ["em"];
      },
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (t) => t.type.name == "strong" },
        {
          style: "font-weight",
          getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
        },
      ],
      toDOM() {
        return ["strong"];
      },
    },
    link: {
      attrs: {
        href: {},
        title: { default: null },
      },
      inclusive: !1,
      parseDOM: [
        {
          tag: "a[href]",
          getAttrs(t) {
            return {
              href: t.getAttribute("href"),
              title: t.getAttribute("title"),
            };
          },
        },
      ],
      toDOM(t) {
        return ["a", t.attrs];
      },
    },
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      },
    },
  },
});
function C8(t, e) {
  if (t.isText && e.isText && Oe.sameSet(t.marks, e.marks))
    return t.withText(t.text + e.text);
}
class A8 {
  constructor(e, n) {
    (this.schema = e),
      (this.tokenHandlers = n),
      (this.stack = [
        { type: e.topNodeType, attrs: null, content: [], marks: Oe.none },
      ]);
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(e) {
    this.stack.length && this.top().content.push(e);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(e) {
    if (!e) return;
    let n = this.top(),
      r = n.content,
      o = r[r.length - 1],
      i = this.schema.text(e, n.marks),
      s;
    o && (s = C8(o, i)) ? (r[r.length - 1] = s) : r.push(i);
  }
  // Adds the given mark to the set of active marks.
  openMark(e) {
    let n = this.top();
    n.marks = e.addToSet(n.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(e) {
    let n = this.top();
    n.marks = e.removeFromSet(n.marks);
  }
  parseTokens(e) {
    for (let n = 0; n < e.length; n++) {
      let r = e[n],
        o = this.tokenHandlers[r.type];
      if (!o)
        throw new Error(
          "Token type `" + r.type + "` not supported by Markdown parser"
        );
      o(this, r, e, n);
    }
  }
  // Add a node at the current position.
  addNode(e, n, r) {
    let o = this.top(),
      i = e.createAndFill(n, r, o ? o.marks : []);
    return i ? (this.push(i), i) : null;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(e, n) {
    this.stack.push({ type: e, attrs: n, content: [], marks: Oe.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let e = this.stack.pop();
    return this.addNode(e.type, e.attrs, e.content);
  }
}
function fs(t, e, n, r) {
  return t.getAttrs
    ? t.getAttrs(e, n, r)
    : t.attrs instanceof Function
    ? t.attrs(e)
    : t.attrs;
}
function of(t, e) {
  return (
    t.noCloseToken || e == "code_inline" || e == "code_block" || e == "fence"
  );
}
function dg(t) {
  return t[t.length - 1] ==
    `
`
    ? t.slice(0, t.length - 1)
    : t;
}
function sf() {}
function S8(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let o = e[r];
    if (o.block) {
      let i = t.nodeType(o.block);
      of(o, r)
        ? (n[r] = (s, a, l, u) => {
            s.openNode(i, fs(o, a, l, u)),
              s.addText(dg(a.content)),
              s.closeNode();
          })
        : ((n[r + "_open"] = (s, a, l, u) => s.openNode(i, fs(o, a, l, u))),
          (n[r + "_close"] = (s) => s.closeNode()));
    } else if (o.node) {
      let i = t.nodeType(o.node);
      n[r] = (s, a, l, u) => s.addNode(i, fs(o, a, l, u));
    } else if (o.mark) {
      let i = t.marks[o.mark];
      of(o, r)
        ? (n[r] = (s, a, l, u) => {
            s.openMark(i.create(fs(o, a, l, u))),
              s.addText(dg(a.content)),
              s.closeMark(i);
          })
        : ((n[r + "_open"] = (s, a, l, u) =>
            s.openMark(i.create(fs(o, a, l, u)))),
          (n[r + "_close"] = (s) => s.closeMark(i)));
    } else if (o.ignore)
      of(o, r) ? (n[r] = sf) : ((n[r + "_open"] = sf), (n[r + "_close"] = sf));
    else throw new RangeError("Unrecognized parsing spec " + JSON.stringify(o));
  }
  return (
    (n.text = (r, o) => r.addText(o.content)),
    (n.inline = (r, o) => r.parseTokens(o.children)),
    (n.softbreak = n.softbreak || ((r) => r.addText(" "))),
    n
  );
}
class E8 {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(e, n, r) {
    (this.schema = e),
      (this.tokenizer = n),
      (this.tokens = r),
      (this.tokenHandlers = S8(e, r));
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(e, n = {}) {
    let r = new A8(this.schema, this.tokenHandlers),
      o;
    r.parseTokens(this.tokenizer.parse(e, n));
    do o = r.closeNode();
    while (r.stack.length);
    return o || this.schema.topNodeType.createAndFill();
  }
}
function fg(t, e) {
  for (; ++e < t.length; )
    if (t[e].type != "list_item_open") return t[e].hidden;
  return !1;
}
const wV = new E8(w8, Tn("commonmark", { html: !1 }), {
    blockquote: { block: "blockquote" },
    paragraph: { block: "paragraph" },
    list_item: { block: "list_item" },
    bullet_list: {
      block: "bullet_list",
      getAttrs: (t, e, n) => ({ tight: fg(e, n) }),
    },
    ordered_list: {
      block: "ordered_list",
      getAttrs: (t, e, n) => ({
        order: +t.attrGet("start") || 1,
        tight: fg(e, n),
      }),
    },
    heading: {
      block: "heading",
      getAttrs: (t) => ({ level: +t.tag.slice(1) }),
    },
    code_block: { block: "code_block", noCloseToken: !0 },
    fence: {
      block: "code_block",
      getAttrs: (t) => ({ params: t.info || "" }),
      noCloseToken: !0,
    },
    hr: { node: "horizontal_rule" },
    image: {
      node: "image",
      getAttrs: (t) => ({
        src: t.attrGet("src"),
        title: t.attrGet("title") || null,
        alt: (t.children[0] && t.children[0].content) || null,
      }),
    },
    hardbreak: { node: "hard_break" },
    em: { mark: "em" },
    strong: { mark: "strong" },
    link: {
      mark: "link",
      getAttrs: (t) => ({
        href: t.attrGet("href"),
        title: t.attrGet("title") || null,
      }),
    },
    code_inline: { mark: "code", noCloseToken: !0 },
  }),
  M8 = { open: "", close: "", mixable: !0 };
class T8 {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(e, n, r = {}) {
    (this.nodes = e), (this.marks = n), (this.options = r);
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(e, n = {}) {
    n = Object.assign({}, this.options, n);
    let r = new D8(this.nodes, this.marks, n);
    return r.renderContent(e), r.out;
  }
}
const CV = new T8(
  {
    blockquote(t, e) {
      t.wrapBlock("> ", null, e, () => t.renderContent(e));
    },
    code_block(t, e) {
      const n = e.textContent.match(/`{3,}/gm),
        r = n ? n.sort().slice(-1)[0] + "`" : "```";
      t.write(
        r +
          (e.attrs.params || "") +
          `
`
      ),
        t.text(e.textContent, !1),
        t.write(`
`),
        t.write(r),
        t.closeBlock(e);
    },
    heading(t, e) {
      t.write(t.repeat("#", e.attrs.level) + " "),
        t.renderInline(e, !1),
        t.closeBlock(e);
    },
    horizontal_rule(t, e) {
      t.write(e.attrs.markup || "---"), t.closeBlock(e);
    },
    bullet_list(t, e) {
      t.renderList(e, "  ", () => (e.attrs.bullet || "*") + " ");
    },
    ordered_list(t, e) {
      let n = e.attrs.order || 1,
        r = String(n + e.childCount - 1).length,
        o = t.repeat(" ", r + 2);
      t.renderList(e, o, (i) => {
        let s = String(n + i);
        return t.repeat(" ", r - s.length) + s + ". ";
      });
    },
    list_item(t, e) {
      t.renderContent(e);
    },
    paragraph(t, e) {
      t.renderInline(e), t.closeBlock(e);
    },
    image(t, e) {
      t.write(
        "![" +
          t.esc(e.attrs.alt || "") +
          "](" +
          e.attrs.src.replace(/[\(\)]/g, "\\$&") +
          (e.attrs.title
            ? ' "' + e.attrs.title.replace(/"/g, '\\"') + '"'
            : "") +
          ")"
      );
    },
    hard_break(t, e, n, r) {
      for (let o = r + 1; o < n.childCount; o++)
        if (n.child(o).type != e.type) {
          t.write(`\\
`);
          return;
        }
    },
    text(t, e) {
      t.text(e.text, !t.inAutolink);
    },
  },
  {
    em: { open: "*", close: "*", mixable: !0, expelEnclosingWhitespace: !0 },
    strong: {
      open: "**",
      close: "**",
      mixable: !0,
      expelEnclosingWhitespace: !0,
    },
    link: {
      open(t, e, n, r) {
        return (t.inAutolink = O8(e, n, r)), t.inAutolink ? "<" : "[";
      },
      close(t, e, n, r) {
        let { inAutolink: o } = t;
        return (
          (t.inAutolink = void 0),
          o
            ? ">"
            : "](" +
              e.attrs.href.replace(/[\(\)"]/g, "\\$&") +
              (e.attrs.title
                ? ` "${e.attrs.title.replace(/"/g, '\\"')}"`
                : "") +
              ")"
        );
      },
      mixable: !0,
    },
    code: {
      open(t, e, n, r) {
        return pg(n.child(r), -1);
      },
      close(t, e, n, r) {
        return pg(n.child(r - 1), 1);
      },
      escape: !1,
    },
  }
);
function pg(t, e) {
  let n = /`+/g,
    r,
    o = 0;
  if (t.isText) for (; (r = n.exec(t.text)); ) o = Math.max(o, r[0].length);
  let i = o > 0 && e > 0 ? " `" : "`";
  for (let s = 0; s < o; s++) i += "`";
  return o > 0 && e < 0 && (i += " "), i;
}
function O8(t, e, n) {
  if (t.attrs.title || !/^\w+:/.test(t.attrs.href)) return !1;
  let r = e.child(n);
  return !r.isText || r.text != t.attrs.href || r.marks[r.marks.length - 1] != t
    ? !1
    : n == e.childCount - 1 || !t.isInSet(e.child(n + 1).marks);
}
class D8 {
  /**
  @internal
  */
  constructor(e, n, r) {
    (this.nodes = e),
      (this.marks = n),
      (this.options = r),
      (this.delim = ""),
      (this.out = ""),
      (this.closed = null),
      (this.inAutolink = void 0),
      (this.atBlockStart = !1),
      (this.inTightList = !1),
      typeof this.options.tightLists > "u" && (this.options.tightLists = !1),
      typeof this.options.hardBreakNodeName > "u" &&
        (this.options.hardBreakNodeName = "hard_break");
  }
  /**
  @internal
  */
  flushClose(e = 2) {
    if (this.closed) {
      if (
        (this.atBlank() ||
          (this.out += `
`),
        e > 1)
      ) {
        let n = this.delim,
          r = /\s+$/.exec(n);
        r && (n = n.slice(0, n.length - r[0].length));
        for (let o = 1; o < e; o++)
          this.out +=
            n +
            `
`;
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(e) {
    let n = this.marks[e];
    if (!n) {
      if (this.options.strict !== !1)
        throw new Error(
          `Mark type \`${e}\` not supported by Markdown renderer`
        );
      n = M8;
    }
    return n;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(e, n, r, o) {
    let i = this.delim;
    this.write(n ?? e),
      (this.delim += e),
      o(),
      (this.delim = i),
      this.closeBlock(r);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    this.atBlank() ||
      (this.out += `
`);
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(e) {
    this.flushClose(),
      this.delim && this.atBlank() && (this.out += this.delim),
      e && (this.out += e);
  }
  /**
  Close the block for the given node.
  */
  closeBlock(e) {
    this.closed = e;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(e, n = !0) {
    let r = e.split(`
`);
    for (let o = 0; o < r.length; o++)
      this.write(),
        !n &&
          r[o][0] == "[" &&
          /(^|[^\\])\!$/.test(this.out) &&
          (this.out = this.out.slice(0, this.out.length - 1) + "\\!"),
        (this.out += n ? this.esc(r[o], this.atBlockStart) : r[o]),
        o != r.length - 1 &&
          (this.out += `
`);
  }
  /**
  Render the given node as a block.
  */
  render(e, n, r) {
    if (this.nodes[e.type.name]) this.nodes[e.type.name](this, e, n, r);
    else {
      if (this.options.strict !== !1)
        throw new Error(
          "Token type `" + e.type.name + "` not supported by Markdown renderer"
        );
      e.type.isLeaf ||
        (e.type.inlineContent ? this.renderInline(e) : this.renderContent(e),
        e.isBlock && this.closeBlock(e));
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(e) {
    e.forEach((n, r, o) => this.render(n, e, o));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(e, n = !0) {
    this.atBlockStart = n;
    let r = [],
      o = "",
      i = (s, a, l) => {
        let u = s ? s.marks : [];
        s &&
          s.type.name === this.options.hardBreakNodeName &&
          (u = u.filter((m) => {
            if (l + 1 == e.childCount) return !1;
            let g = e.child(l + 1);
            return m.isInSet(g.marks) && (!g.isText || /\S/.test(g.text));
          }));
        let c = o;
        if (
          ((o = ""),
          s &&
            s.isText &&
            u.some((m) => {
              let g = this.getMark(m.type.name);
              return g && g.expelEnclosingWhitespace && !m.isInSet(r);
            }))
        ) {
          let [m, g, b] = /^(\s*)(.*)$/m.exec(s.text);
          g && ((c += g), (s = b ? s.withText(b) : null), s || (u = r));
        }
        if (
          s &&
          s.isText &&
          u.some((m) => {
            let g = this.getMark(m.type.name);
            return (
              g &&
              g.expelEnclosingWhitespace &&
              (l == e.childCount - 1 || !m.isInSet(e.child(l + 1).marks))
            );
          })
        ) {
          let [m, g, b] = /^(.*?)(\s*)$/m.exec(s.text);
          b && ((o = b), (s = g ? s.withText(g) : null), s || (u = r));
        }
        let d = u.length ? u[u.length - 1] : null,
          f = d && this.getMark(d.type.name).escape === !1,
          p = u.length - (f ? 1 : 0);
        e: for (let m = 0; m < p; m++) {
          let g = u[m];
          if (!this.getMark(g.type.name).mixable) break;
          for (let b = 0; b < r.length; b++) {
            let _ = r[b];
            if (!this.getMark(_.type.name).mixable) break;
            if (g.eq(_)) {
              m > b
                ? (u = u
                    .slice(0, b)
                    .concat(g)
                    .concat(u.slice(b, m))
                    .concat(u.slice(m + 1, p)))
                : b > m &&
                  (u = u
                    .slice(0, m)
                    .concat(u.slice(m + 1, b))
                    .concat(g)
                    .concat(u.slice(b, p)));
              continue e;
            }
          }
        }
        let h = 0;
        for (; h < Math.min(r.length, p) && u[h].eq(r[h]); ) ++h;
        for (; h < r.length; )
          this.text(this.markString(r.pop(), !1, e, l), !1);
        if ((c && this.text(c), s)) {
          for (; r.length < p; ) {
            let m = u[r.length];
            r.push(m),
              this.text(this.markString(m, !0, e, l), !1),
              (this.atBlockStart = !1);
          }
          f && s.isText
            ? this.text(
                this.markString(d, !0, e, l) +
                  s.text +
                  this.markString(d, !1, e, l + 1),
                !1
              )
            : this.render(s, e, l),
            (this.atBlockStart = !1);
        }
        s != null && s.isText && s.nodeSize > 0 && (this.atBlockStart = !1);
      };
    e.forEach(i), i(null, 0, e.childCount), (this.atBlockStart = !1);
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(e, n, r) {
    this.closed && this.closed.type == e.type
      ? this.flushClose(3)
      : this.inTightList && this.flushClose(1);
    let o =
        typeof e.attrs.tight < "u" ? e.attrs.tight : this.options.tightLists,
      i = this.inTightList;
    (this.inTightList = o),
      e.forEach((s, a, l) => {
        l && o && this.flushClose(1),
          this.wrapBlock(n, r(l), e, () => this.render(s, e, l));
      }),
      (this.inTightList = i);
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(e, n = !1) {
    return (
      (e = e.replace(/[`*\\~\[\]_]/g, (r, o) =>
        r == "_" &&
        o > 0 &&
        o + 1 < e.length &&
        e[o - 1].match(/\w/) &&
        e[o + 1].match(/\w/)
          ? r
          : "\\" + r
      )),
      n &&
        (e = e
          .replace(/^(\+[ ]|[\-*>])/, "\\$&")
          .replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3")
          .replace(/^(\s*\d+)\.\s/, "$1\\. ")),
      this.options.escapeExtraCharacters &&
        (e = e.replace(this.options.escapeExtraCharacters, "\\$&")),
      e
    );
  }
  /**
  @internal
  */
  quote(e) {
    let n = e.indexOf('"') == -1 ? '""' : e.indexOf("'") == -1 ? "''" : "()";
    return n[0] + e + n[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(e, n) {
    let r = "";
    for (let o = 0; o < n; o++) r += e;
    return r;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(e, n, r, o) {
    let i = this.getMark(e.type.name),
      s = n ? i.open : i.close;
    return typeof s == "string" ? s : s(this, e, r, o);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(e) {
    return {
      leading: (e.match(/^(\s+)/) || [void 0])[0],
      trailing: (e.match(/(\s+)$/) || [void 0])[0],
    };
  }
}
function cn() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1,
    n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var o = n[r];
        typeof o == "string" ? t.setAttribute(r, o) : o != null && (t[r] = o);
      }
    e++;
  }
  for (; e < arguments.length; e++) f_(t, arguments[e]);
  return t;
}
function f_(t, e) {
  if (typeof e == "string") t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null) t.appendChild(e);
    else if (Array.isArray(e)) for (var n = 0; n < e.length; n++) f_(t, e[n]);
    else throw new RangeError("Unsupported child node: " + e);
}
const Ds = "http://www.w3.org/2000/svg",
  N8 = "http://www.w3.org/1999/xlink",
  Ap = "ProseMirror-icon";
function L8(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) e = ((e << 5) - e + t.charCodeAt(n)) | 0;
  return e;
}
function R8(t, e) {
  let n = (t.nodeType == 9 ? t : t.ownerDocument) || document,
    r = n.createElement("div");
  if (((r.className = Ap), e.path)) {
    let { path: o, width: i, height: s } = e,
      a = "pm-icon-" + L8(o).toString(16);
    n.getElementById(a) || I8(t, a, e);
    let l = r.appendChild(n.createElementNS(Ds, "svg"));
    (l.style.width = i / s + "em"),
      l
        .appendChild(n.createElementNS(Ds, "use"))
        .setAttributeNS(
          N8,
          "href",
          /([^#]*)/.exec(n.location.toString())[1] + "#" + a
        );
  } else if (e.dom) r.appendChild(e.dom.cloneNode(!0));
  else {
    let { text: o, css: i } = e;
    (r.appendChild(n.createElement("span")).textContent = o || ""),
      i && (r.firstChild.style.cssText = i);
  }
  return r;
}
function I8(t, e, n) {
  let [r, o] = t.nodeType == 9 ? [t, t.body] : [t.ownerDocument || document, t],
    i = r.getElementById(Ap + "-collection");
  i ||
    ((i = r.createElementNS(Ds, "svg")),
    (i.id = Ap + "-collection"),
    (i.style.display = "none"),
    o.insertBefore(i, o.firstChild));
  let s = r.createElementNS(Ds, "symbol");
  (s.id = e),
    s.setAttribute("viewBox", "0 0 " + n.width + " " + n.height),
    s.appendChild(r.createElementNS(Ds, "path")).setAttribute("d", n.path),
    i.appendChild(s);
}
const qt = "ProseMirror-menu";
class mi {
  /**
  Create a menu item.
  */
  constructor(e) {
    this.spec = e;
  }
  /**
  Renders the icon according to its [display
  spec](https://prosemirror.net/docs/ref/#menu.MenuItemSpec.display), and adds an event handler which
  executes the command when the representation is clicked.
  */
  render(e) {
    let n = this.spec,
      r = n.render
        ? n.render(e)
        : n.icon
        ? R8(e.root, n.icon)
        : n.label
        ? cn("div", null, pa(e, n.label))
        : null;
    if (!r) throw new RangeError("MenuItem without icon or label property");
    if (n.title) {
      const i = typeof n.title == "function" ? n.title(e.state) : n.title;
      r.setAttribute("title", pa(e, i));
    }
    n.class && r.classList.add(n.class),
      n.css && (r.style.cssText += n.css),
      r.addEventListener("mousedown", (i) => {
        i.preventDefault(),
          r.classList.contains(qt + "-disabled") ||
            n.run(e.state, e.dispatch, e, i);
      });
    function o(i) {
      if (n.select) {
        let a = n.select(i);
        if (((r.style.display = a ? "" : "none"), !a)) return !1;
      }
      let s = !0;
      if (
        (n.enable && ((s = n.enable(i) || !1), Sp(r, qt + "-disabled", !s)),
        n.active)
      ) {
        let a = (s && n.active(i)) || !1;
        Sp(r, qt + "-active", a);
      }
      return !0;
    }
    return { dom: r, update: o };
  }
}
function pa(t, e) {
  return t._props.translate ? t._props.translate(e) : e;
}
let Ns = { time: 0, node: null };
function p_(t) {
  (Ns.time = Date.now()), (Ns.node = t.target);
}
function h_(t) {
  return Date.now() - 100 < Ns.time && Ns.node && t.contains(Ns.node);
}
class AV {
  /**
  Create a dropdown wrapping the elements.
  */
  constructor(e, n = {}) {
    (this.options = n),
      (this.options = n || {}),
      (this.content = Array.isArray(e) ? e : [e]);
  }
  /**
  Render the dropdown menu and sub-items.
  */
  render(e) {
    let n = m_(this.content, e),
      r = e.dom.ownerDocument.defaultView || window,
      o = cn(
        "div",
        {
          class: qt + "-dropdown " + (this.options.class || ""),
          style: this.options.css,
        },
        pa(e, this.options.label || "")
      );
    this.options.title && o.setAttribute("title", pa(e, this.options.title));
    let i = cn("div", { class: qt + "-dropdown-wrap" }, o),
      s = null,
      a = null,
      l = () => {
        s && s.close() && ((s = null), r.removeEventListener("mousedown", a));
      };
    o.addEventListener("mousedown", (c) => {
      c.preventDefault(),
        p_(c),
        s
          ? l()
          : ((s = this.expand(i, n.dom)),
            r.addEventListener(
              "mousedown",
              (a = () => {
                h_(i) || l();
              })
            ));
    });
    function u(c) {
      let d = n.update(c);
      return (i.style.display = d ? "" : "none"), d;
    }
    return { dom: i, update: u };
  }
  /**
  @internal
  */
  expand(e, n) {
    let r = cn(
        "div",
        { class: qt + "-dropdown-menu " + (this.options.class || "") },
        n
      ),
      o = !1;
    function i() {
      return o ? !1 : ((o = !0), e.removeChild(r), !0);
    }
    return e.appendChild(r), { close: i, node: r };
  }
}
function m_(t, e) {
  let n = [],
    r = [];
  for (let o = 0; o < t.length; o++) {
    let { dom: i, update: s } = t[o].render(e);
    n.push(cn("div", { class: qt + "-dropdown-item" }, i)), r.push(s);
  }
  return { dom: n, update: g_(r, n) };
}
function g_(t, e) {
  return (n) => {
    let r = !1;
    for (let o = 0; o < t.length; o++) {
      let i = t[o](n);
      (e[o].style.display = i ? "" : "none"), i && (r = !0);
    }
    return r;
  };
}
class SV {
  /**
  Creates a submenu for the given group of menu elements. The
  following options are recognized:
  */
  constructor(e, n = {}) {
    (this.options = n), (this.content = Array.isArray(e) ? e : [e]);
  }
  /**
  Renders the submenu.
  */
  render(e) {
    let n = m_(this.content, e),
      r = e.dom.ownerDocument.defaultView || window,
      o = cn(
        "div",
        { class: qt + "-submenu-label" },
        pa(e, this.options.label || "")
      ),
      i = cn(
        "div",
        { class: qt + "-submenu-wrap" },
        o,
        cn("div", { class: qt + "-submenu" }, n.dom)
      ),
      s = null;
    o.addEventListener("mousedown", (l) => {
      l.preventDefault(),
        p_(l),
        Sp(i, qt + "-submenu-wrap-active", !1),
        s ||
          r.addEventListener(
            "mousedown",
            (s = () => {
              h_(i) ||
                (i.classList.remove(qt + "-submenu-wrap-active"),
                r.removeEventListener("mousedown", s),
                (s = null));
            })
          );
    });
    function a(l) {
      let u = n.update(l);
      return (i.style.display = u ? "" : "none"), u;
    }
    return { dom: i, update: a };
  }
}
function P8(t, e) {
  let n = document.createDocumentFragment(),
    r = [],
    o = [];
  for (let s = 0; s < e.length; s++) {
    let a = e[s],
      l = [],
      u = [];
    for (let c = 0; c < a.length; c++) {
      let { dom: d, update: f } = a[c].render(t),
        p = cn("span", { class: qt + "item" }, d);
      n.appendChild(p), u.push(p), l.push(f);
    }
    l.length &&
      (r.push(g_(l, u)), s < e.length - 1 && o.push(n.appendChild($8())));
  }
  function i(s) {
    let a = !1,
      l = !1;
    for (let u = 0; u < r.length; u++) {
      let c = r[u](s);
      u && (o[u - 1].style.display = l && c ? "" : "none"),
        (l = c),
        c && (a = !0);
    }
    return a;
  }
  return { dom: n, update: i };
}
function $8() {
  return cn("span", { class: qt + "separator" });
}
const La = {
    join: {
      width: 800,
      height: 900,
      path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z",
    },
    lift: {
      width: 1024,
      height: 1024,
      path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z",
    },
    selectParentNode: { text: "", css: "font-weight: bold" },
    undo: {
      width: 1024,
      height: 1024,
      path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z",
    },
    redo: {
      width: 1024,
      height: 1024,
      path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z",
    },
    strong: {
      width: 805,
      height: 1024,
      path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z",
    },
    em: {
      width: 585,
      height: 1024,
      path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z",
    },
    code: {
      width: 896,
      height: 1024,
      path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z",
    },
    link: {
      width: 951,
      height: 1024,
      path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z",
    },
    bulletList: {
      width: 768,
      height: 896,
      path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z",
    },
    orderedList: {
      width: 768,
      height: 896,
      path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z",
    },
    blockquote: {
      width: 640,
      height: 896,
      path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z",
    },
  },
  EV = new mi({
    title: "Join with above block",
    run: ap,
    select: (t) => ap(t),
    icon: La.join,
  }),
  MV = new mi({
    title: "Lift out of enclosing block",
    run: lp,
    select: (t) => lp(t),
    icon: La.lift,
  }),
  TV = new mi({
    title: "Select parent node",
    run: up,
    select: (t) => up(t),
    icon: La.selectParentNode,
  });
let OV = new mi({
    title: "Undo last change",
    run: xu,
    enable: (t) => xu(t),
    icon: La.undo,
  }),
  DV = new mi({
    title: "Redo last undone change",
    run: ku,
    enable: (t) => ku(t),
    icon: La.redo,
  });
function NV(t, e) {
  let n = {
    run(r, o) {
      return cp(t, e.attrs)(r, o);
    },
    select(r) {
      return cp(t, e.attrs)(r);
    },
  };
  for (let r in e) n[r] = e[r];
  return new mi(n);
}
function LV(t, e) {
  let n = dp(t, e.attrs),
    r = {
      run: n,
      enable(o) {
        return n(o);
      },
      active(o) {
        let { $from: i, to: s, node: a } = o.selection;
        return a
          ? a.hasMarkup(t, e.attrs)
          : s <= i.end() && i.parent.hasMarkup(t, e.attrs);
      },
    };
  for (let o in e) r[o] = e[o];
  return new mi(r);
}
function Sp(t, e, n) {
  n ? t.classList.add(e) : t.classList.remove(e);
}
const ul = "ProseMirror-menubar";
function B8() {
  if (typeof navigator > "u") return !1;
  let t = navigator.userAgent;
  return !/Edge\/\d/.test(t) && /AppleWebKit/.test(t) && /Mobile\/\w+/.test(t);
}
function RV(t) {
  return new be({
    view(e) {
      return new H8(e, t);
    },
  });
}
class H8 {
  constructor(e, n) {
    (this.editorView = e),
      (this.options = n),
      (this.spacer = null),
      (this.maxHeight = 0),
      (this.widthForMaxHeight = 0),
      (this.floating = !1),
      (this.scrollHandler = null),
      (this.wrapper = cn("div", { class: ul + "-wrapper" })),
      (this.menu = this.wrapper.appendChild(cn("div", { class: ul }))),
      (this.menu.className = ul),
      e.dom.parentNode && e.dom.parentNode.replaceChild(this.wrapper, e.dom),
      this.wrapper.appendChild(e.dom);
    let { dom: r, update: o } = P8(this.editorView, this.options.content);
    if (
      ((this.contentUpdate = o),
      this.menu.appendChild(r),
      this.update(),
      n.floating && !B8())
    ) {
      this.updateFloat();
      let i = V8(this.wrapper);
      (this.scrollHandler = (s) => {
        let a = this.editorView.root;
        (a.body || a).contains(this.wrapper)
          ? this.updateFloat(s.target.getBoundingClientRect ? s.target : void 0)
          : i.forEach((l) =>
              l.removeEventListener("scroll", this.scrollHandler)
            );
      }),
        i.forEach((s) => s.addEventListener("scroll", this.scrollHandler));
    }
  }
  update() {
    this.contentUpdate(this.editorView.state),
      this.floating
        ? this.updateScrollCursor()
        : (this.menu.offsetWidth != this.widthForMaxHeight &&
            ((this.widthForMaxHeight = this.menu.offsetWidth),
            (this.maxHeight = 0)),
          this.menu.offsetHeight > this.maxHeight &&
            ((this.maxHeight = this.menu.offsetHeight),
            (this.menu.style.minHeight = this.maxHeight + "px")));
  }
  updateScrollCursor() {
    let e = this.editorView.root.getSelection();
    if (!e.focusNode) return;
    let n = e.getRangeAt(0).getClientRects(),
      r = n[F8(e) ? 0 : n.length - 1];
    if (!r) return;
    let o = this.menu.getBoundingClientRect();
    if (r.top < o.bottom && r.bottom > o.top) {
      let i = z8(this.wrapper);
      i && (i.scrollTop -= o.bottom - r.top);
    }
  }
  updateFloat(e) {
    let n = this.wrapper,
      r = n.getBoundingClientRect(),
      o = e ? Math.max(0, e.getBoundingClientRect().top) : 0;
    if (this.floating)
      if (r.top >= o || r.bottom < this.menu.offsetHeight + 10)
        (this.floating = !1),
          (this.menu.style.position =
            this.menu.style.left =
            this.menu.style.top =
            this.menu.style.width =
              ""),
          (this.menu.style.display = ""),
          this.spacer.parentNode.removeChild(this.spacer),
          (this.spacer = null);
      else {
        let i = (n.offsetWidth - n.clientWidth) / 2;
        (this.menu.style.left = r.left + i + "px"),
          (this.menu.style.display =
            r.top >
            (this.editorView.dom.ownerDocument.defaultView || window)
              .innerHeight
              ? "none"
              : ""),
          e && (this.menu.style.top = o + "px");
      }
    else if (r.top < o && r.bottom >= this.menu.offsetHeight + 10) {
      this.floating = !0;
      let i = this.menu.getBoundingClientRect();
      (this.menu.style.left = i.left + "px"),
        (this.menu.style.width = i.width + "px"),
        e && (this.menu.style.top = o + "px"),
        (this.menu.style.position = "fixed"),
        (this.spacer = cn("div", {
          class: ul + "-spacer",
          style: `height: ${i.height}px`,
        })),
        n.insertBefore(this.spacer, this.menu);
    }
  }
  destroy() {
    this.wrapper.parentNode &&
      this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
  }
}
function F8(t) {
  return t.anchorNode == t.focusNode
    ? t.anchorOffset > t.focusOffset
    : t.anchorNode.compareDocumentPosition(t.focusNode) ==
        Node.DOCUMENT_POSITION_FOLLOWING;
}
function z8(t) {
  for (let e = t.parentNode; e; e = e.parentNode)
    if (e.scrollHeight > e.clientHeight) return e;
}
function V8(t) {
  let e = [t.ownerDocument.defaultView || window];
  for (let n = t.parentNode; n; n = n.parentNode) e.push(n);
  return e;
}
const U8 = ["p", 0],
  j8 = ["blockquote", 0],
  W8 = ["hr"],
  q8 = ["pre", ["code", 0]],
  K8 = ["br"],
  G8 = {
    /**
  NodeSpec The top level document node.
  */
    doc: {
      content: "block+",
    },
    /**
  A plain paragraph textblock. Represented in the DOM
  as a `<p>` element.
  */
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return U8;
      },
    },
    /**
  A blockquote (`<blockquote>`) wrapping one or more blocks.
  */
    blockquote: {
      content: "block+",
      group: "block",
      defining: !0,
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return j8;
      },
    },
    /**
  A horizontal rule (`<hr>`).
  */
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return W8;
      },
    },
    /**
  A heading textblock, with a `level` attribute that
  should hold the number 1 to 6. Parsed and serialized as `<h1>` to
  `<h6>` elements.
  */
    heading: {
      attrs: { level: { default: 1, validate: "number" } },
      content: "inline*",
      group: "block",
      defining: !0,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } },
      ],
      toDOM(t) {
        return ["h" + t.attrs.level, 0];
      },
    },
    /**
  A code listing. Disallows marks or non-text inline
  nodes by default. Represented as a `<pre>` element with a
  `<code>` element inside of it.
  */
    code_block: {
      content: "text*",
      marks: "",
      group: "block",
      code: !0,
      defining: !0,
      parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
      toDOM() {
        return q8;
      },
    },
    /**
  The text node.
  */
    text: {
      group: "inline",
    },
    /**
  An inline image (`<img>`) node. Supports `src`,
  `alt`, and `href` attributes. The latter two default to the empty
  string.
  */
    image: {
      inline: !0,
      attrs: {
        src: { validate: "string" },
        alt: { default: null, validate: "string|null" },
        title: { default: null, validate: "string|null" },
      },
      group: "inline",
      draggable: !0,
      parseDOM: [
        {
          tag: "img[src]",
          getAttrs(t) {
            return {
              src: t.getAttribute("src"),
              title: t.getAttribute("title"),
              alt: t.getAttribute("alt"),
            };
          },
        },
      ],
      toDOM(t) {
        let { src: e, alt: n, title: r } = t.attrs;
        return ["img", { src: e, alt: n, title: r }];
      },
    },
    /**
  A hard line break, represented in the DOM as `<br>`.
  */
    hard_break: {
      inline: !0,
      group: "inline",
      selectable: !1,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return K8;
      },
    },
  },
  J8 = ["em", 0],
  Y8 = ["strong", 0],
  X8 = ["code", 0],
  Z8 = {
    /**
  A link. Has `href` and `title` attributes. `title`
  defaults to the empty string. Rendered and parsed as an `<a>`
  element.
  */
    link: {
      attrs: {
        href: { validate: "string" },
        title: { default: null, validate: "string|null" },
      },
      inclusive: !1,
      parseDOM: [
        {
          tag: "a[href]",
          getAttrs(t) {
            return {
              href: t.getAttribute("href"),
              title: t.getAttribute("title"),
            };
          },
        },
      ],
      toDOM(t) {
        let { href: e, title: n } = t.attrs;
        return ["a", { href: e, title: n }, 0];
      },
    },
    /**
  An emphasis mark. Rendered as an `<em>` element. Has parse rules
  that also match `<i>` and `font-style: italic`.
  */
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (t) => t.type.name == "em" },
      ],
      toDOM() {
        return J8;
      },
    },
    /**
  A strong mark. Rendered as `<strong>`, parse rules also match
  `<b>` and `font-weight: bold`.
  */
    strong: {
      parseDOM: [
        { tag: "strong" },
        // This works around a Google Docs misbehavior where
        // pasted content will be inexplicably wrapped in `<b>`
        // tags with a font-weight normal.
        { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (t) => t.type.name == "strong" },
        {
          style: "font-weight",
          getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
        },
      ],
      toDOM() {
        return Y8;
      },
    },
    /**
  Code font mark. Represented as a `<code>` element.
  */
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return X8;
      },
    },
  },
  IV = new Uc({ nodes: G8, marks: Z8 }),
  Q8 = ["ol", 0],
  eM = ["ul", 0],
  tM = ["li", 0],
  nM = {
    attrs: { order: { default: 1, validate: "number" } },
    parseDOM: [
      {
        tag: "ol",
        getAttrs(t) {
          return {
            order: t.hasAttribute("start") ? +t.getAttribute("start") : 1,
          };
        },
      },
    ],
    toDOM(t) {
      return t.attrs.order == 1 ? Q8 : ["ol", { start: t.attrs.order }, 0];
    },
  },
  rM = {
    parseDOM: [{ tag: "ul" }],
    toDOM() {
      return eM;
    },
  },
  oM = {
    parseDOM: [{ tag: "li" }],
    toDOM() {
      return tM;
    },
    defining: !0,
  };
function af(t, e) {
  let n = {};
  for (let r in t) n[r] = t[r];
  for (let r in e) n[r] = e[r];
  return n;
}
function PV(t, e, n) {
  return t.append({
    ordered_list: af(nM, { content: "list_item+", group: n }),
    bullet_list: af(rM, { content: "list_item+", group: n }),
    list_item: af(oM, { content: e }),
  });
}
function iM(t, e = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      s = o.blockRange(i),
      a = !1,
      l = s;
    if (!s) return !1;
    if (
      s.depth >= 2 &&
      o.node(s.depth - 1).type.compatibleContent(t) &&
      s.startIndex == 0
    ) {
      if (o.index(s.depth - 1) == 0) return !1;
      let c = n.doc.resolve(s.start - 2);
      (l = new uu(c, c, s.depth)),
        s.endIndex < s.parent.childCount &&
          (s = new uu(o, n.doc.resolve(i.end(s.depth)), s.depth)),
        (a = !0);
    }
    let u = jc(l, t, e, s);
    return u ? (r && r(sM(n.tr, s, u, a, t).scrollIntoView()), !0) : !1;
  };
}
function sM(t, e, n, r, o) {
  let i = $.empty;
  for (let c = n.length - 1; c >= 0; c--)
    i = $.from(n[c].type.create(n[c].attrs, i));
  t.step(
    new bt(
      e.start - (r ? 2 : 0),
      e.end,
      e.start,
      e.end,
      new W(i, 0, 0),
      n.length,
      !0
    )
  );
  let s = 0;
  for (let c = 0; c < n.length; c++) n[c].type == o && (s = c + 1);
  let a = n.length - s,
    l = e.start + n.length - (r ? 2 : 0),
    u = e.parent;
  for (let c = e.startIndex, d = e.endIndex, f = !0; c < d; c++, f = !1)
    !f && hr(t.doc, l, a) && (t.split(l, a), (l += 2 * a)),
      (l += u.child(c).nodeSize);
  return t;
}
function aM(t, e) {
  return function (n, r) {
    let { $from: o, $to: i, node: s } = n.selection;
    if ((s && s.isBlock) || o.depth < 2 || !o.sameParent(i)) return !1;
    let a = o.node(-1);
    if (a.type != t) return !1;
    if (
      o.parent.content.size == 0 &&
      o.node(-1).childCount == o.indexAfter(-1)
    ) {
      if (
        o.depth == 3 ||
        o.node(-3).type != t ||
        o.index(-2) != o.node(-2).childCount - 1
      )
        return !1;
      if (r) {
        let d = $.empty,
          f = o.index(-1) ? 1 : o.index(-2) ? 2 : 3;
        for (let b = o.depth - f; b >= o.depth - 3; b--)
          d = $.from(o.node(b).copy(d));
        let p =
          o.indexAfter(-1) < o.node(-2).childCount
            ? 1
            : o.indexAfter(-2) < o.node(-3).childCount
            ? 2
            : 3;
        d = d.append($.from(t.createAndFill()));
        let h = o.before(o.depth - (f - 1)),
          m = n.tr.replace(h, o.after(-p), new W(d, 4 - f, 0)),
          g = -1;
        m.doc.nodesBetween(h, m.doc.content.size, (b, _) => {
          if (g > -1) return !1;
          b.isTextblock && b.content.size == 0 && (g = _ + 1);
        }),
          g > -1 && m.setSelection(ee.near(m.doc.resolve(g))),
          r(m.scrollIntoView());
      }
      return !0;
    }
    let l = i.pos == o.end() ? a.contentMatchAt(0).defaultType : null,
      u = n.tr.delete(o.pos, i.pos),
      c = l ? [e ? { type: t, attrs: e } : null, { type: l }] : void 0;
    return hr(u.doc, o.pos, 2, c)
      ? (r && r(u.split(o.pos, 2, c).scrollIntoView()), !0)
      : !1;
  };
}
function $V(t, e) {
  let n = aM(t, e);
  return (r, o) =>
    n(
      r,
      o &&
        ((i) => {
          let s =
            r.storedMarks ||
            (r.selection.$to.parentOffset && r.selection.$from.marks());
          s && i.ensureMarks(s), o(i);
        })
    );
}
function lM(t) {
  return function (e, n) {
    let { $from: r, $to: o } = e.selection,
      i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t);
    return i
      ? n
        ? r.node(i.depth - 1).type == t
          ? uM(e, n, t, i)
          : cM(e, n, i)
        : !0
      : !1;
  };
}
function uM(t, e, n, r) {
  let o = t.tr,
    i = r.end,
    s = r.$to.end(r.depth);
  i < s &&
    (o.step(
      new bt(
        i - 1,
        s,
        i,
        s,
        new W($.from(n.create(null, r.parent.copy())), 1, 0),
        1,
        !0
      )
    ),
    (r = new uu(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth)));
  const a = ns(r);
  if (a == null) return !1;
  o.lift(r, a);
  let l = o.mapping.map(i, -1) - 1;
  return _r(o.doc, l) && o.join(l), e(o.scrollIntoView()), !0;
}
function cM(t, e, n) {
  let r = t.tr,
    o = n.parent;
  for (let p = n.end, h = n.endIndex - 1, m = n.startIndex; h > m; h--)
    (p -= o.child(h).nodeSize), r.delete(p - 1, p + 1);
  let i = r.doc.resolve(n.start),
    s = i.nodeAfter;
  if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1;
  let a = n.startIndex == 0,
    l = n.endIndex == o.childCount,
    u = i.node(-1),
    c = i.index(-1);
  if (
    !u.canReplace(
      c + (a ? 0 : 1),
      c + 1,
      s.content.append(l ? $.empty : $.from(o))
    )
  )
    return !1;
  let d = i.pos,
    f = d + s.nodeSize;
  return (
    r.step(
      new bt(
        d - (a ? 1 : 0),
        f + (l ? 1 : 0),
        d + 1,
        f - 1,
        new W(
          (a ? $.empty : $.from(o.copy($.empty))).append(
            l ? $.empty : $.from(o.copy($.empty))
          ),
          a ? 0 : 1,
          l ? 0 : 1
        ),
        a ? 0 : 1
      )
    ),
    e(r.scrollIntoView()),
    !0
  );
}
function dM(t) {
  return function (e, n) {
    let { $from: r, $to: o } = e.selection,
      i = r.blockRange(o, (u) => u.childCount > 0 && u.firstChild.type == t);
    if (!i) return !1;
    let s = i.startIndex;
    if (s == 0) return !1;
    let a = i.parent,
      l = a.child(s - 1);
    if (l.type != t) return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == a.type,
        c = $.from(u ? t.create() : null),
        d = new W(
          $.from(t.create(null, $.from(a.type.create(null, c)))),
          u ? 3 : 1,
          0
        ),
        f = i.start,
        p = i.end;
      n(e.tr.step(new bt(f - (u ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
var Ep, Mp;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  (Ep = (e) => t.get(e)), (Mp = (e, n) => (t.set(e, n), n));
} else {
  const t = [];
  let n = 0;
  (Ep = (r) => {
    for (let o = 0; o < t.length; o += 2) if (t[o] == r) return t[o + 1];
  }),
    (Mp = (r, o) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = o)));
}
var Ae = class {
  constructor(t, e, n, r) {
    (this.width = t), (this.height = e), (this.map = n), (this.problems = r);
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t) continue;
      const r = e % this.width,
        o = (e / this.width) | 0;
      let i = r + 1,
        s = o + 1;
      for (let a = 1; i < this.width && this.map[e + a] == n; a++) i++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
        s++;
      return { left: r, top: o, right: i, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t) return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
    return e == "horiz"
      ? (n < 0 ? r == 0 : o == this.width)
        ? null
        : this.map[i * this.width + (n < 0 ? r - 1 : o)]
      : (n < 0 ? i == 0 : s == this.height)
      ? null
      : this.map[r + this.width * (n < 0 ? i - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const { left: n, right: r, top: o, bottom: i } = this.findCell(t),
      { left: s, right: a, top: l, bottom: u } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(o, l),
      right: Math.max(r, a),
      bottom: Math.max(i, u),
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [],
      n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let o = t.left; o < t.right; o++) {
        const i = r * this.width + o,
          s = this.map[i];
        n[s] ||
          ((n[s] = !0),
          !(
            (o == t.left && o && this.map[i - 1] == s) ||
            (r == t.top && r && this.map[i - this.width] == s)
          ) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, o = 0; ; r++) {
      const i = o + n.child(r).nodeSize;
      if (r == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < o; ) s++;
        return s == a ? i - 1 : this.map[s];
      }
      o = i;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return Ep(t) || Mp(t, fM(t));
  }
};
function fM(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = pM(t),
    n = t.childCount,
    r = [];
  let o = 0,
    i = null;
  const s = [];
  for (let u = 0, c = e * n; u < c; u++) r[u] = 0;
  for (let u = 0, c = 0; u < n; u++) {
    const d = t.child(u);
    c++;
    for (let h = 0; ; h++) {
      for (; o < r.length && r[o] != 0; ) o++;
      if (h == d.childCount) break;
      const m = d.child(h),
        { colspan: g, rowspan: b, colwidth: _ } = m.attrs;
      for (let v = 0; v < b; v++) {
        if (v + u >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: c,
            n: b - v,
          });
          break;
        }
        const y = o + v * e;
        for (let w = 0; w < g; w++) {
          r[y + w] == 0
            ? (r[y + w] = c)
            : (i || (i = [])).push({
                type: "collision",
                row: u,
                pos: c,
                n: g - w,
              });
          const x = _ && _[w];
          if (x) {
            const M = ((y + w) % e) * 2,
              N = s[M];
            N == null || (N != x && s[M + 1] == 1)
              ? ((s[M] = x), (s[M + 1] = 1))
              : N == x && s[M + 1]++;
          }
        }
      }
      (o += g), (c += m.nodeSize);
    }
    const f = (u + 1) * e;
    let p = 0;
    for (; o < f; ) r[o++] == 0 && p++;
    p && (i || (i = [])).push({ type: "missing", row: u, n: p }), c++;
  }
  const a = new Ae(e, n, r, i);
  let l = !1;
  for (let u = 0; !l && u < s.length; u += 2)
    s[u] != null && s[u + 1] < n && (l = !0);
  return l && hM(a, s, t), a;
}
function pM(t) {
  let e = -1,
    n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const o = t.child(r);
    let i = 0;
    if (n)
      for (let s = 0; s < r; s++) {
        const a = t.child(s);
        for (let l = 0; l < a.childCount; l++) {
          const u = a.child(l);
          s + u.attrs.rowspan > r && (i += u.attrs.colspan);
        }
      }
    for (let s = 0; s < o.childCount; s++) {
      const a = o.child(s);
      (i += a.attrs.colspan), a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? (e = i) : e != i && (e = Math.max(e, i));
  }
  return e;
}
function hM(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let o = 0; o < t.map.length; o++) {
    const i = t.map[o];
    if (r[i]) continue;
    r[i] = !0;
    const s = n.nodeAt(i);
    if (!s) throw new RangeError(`No cell with offset ${i} found`);
    let a = null;
    const l = s.attrs;
    for (let u = 0; u < l.colspan; u++) {
      const c = (o + u) % t.width,
        d = e[c * 2];
      d != null &&
        (!l.colwidth || l.colwidth[u] != d) &&
        ((a || (a = mM(l)))[u] = d);
    }
    a &&
      t.problems.unshift({
        type: "colwidth mismatch",
        pos: i,
        colwidth: a,
      });
  }
}
function mM(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++) e.push(0);
  return e;
}
function hg(t, e) {
  if (typeof t == "string") return {};
  const n = t.getAttribute("data-colwidth"),
    r = n && /^\d+(,\d+)*$/.test(n) ? n.split(",").map((s) => Number(s)) : null,
    o = Number(t.getAttribute("colspan") || 1),
    i = {
      colspan: o,
      rowspan: Number(t.getAttribute("rowspan") || 1),
      colwidth: r && r.length == o ? r : null,
    };
  for (const s in e) {
    const a = e[s].getFromDOM,
      l = a && a(t);
    l != null && (i[s] = l);
  }
  return i;
}
function mg(t, e) {
  const n = {};
  t.attrs.colspan != 1 && (n.colspan = t.attrs.colspan),
    t.attrs.rowspan != 1 && (n.rowspan = t.attrs.rowspan),
    t.attrs.colwidth && (n["data-colwidth"] = t.attrs.colwidth.join(","));
  for (const r in e) {
    const o = e[r].setDOMAttr;
    o && o(t.attrs[r], n);
  }
  return n;
}
function BV(t) {
  const e = t.cellAttributes || {},
    n = {
      colspan: { default: 1 },
      rowspan: { default: 1 },
      colwidth: { default: null },
    };
  for (const r in e) n[r] = { default: e[r].default };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: t.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      },
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      },
    },
    table_cell: {
      content: t.cellContent,
      attrs: n,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [{ tag: "td", getAttrs: (r) => hg(r, e) }],
      toDOM(r) {
        return ["td", mg(r, e), 0];
      },
    },
    table_header: {
      content: t.cellContent,
      attrs: n,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [{ tag: "th", getAttrs: (r) => hg(r, e) }],
      toDOM(r) {
        return ["th", mg(r, e), 0];
      },
    },
  };
}
function Dt(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n],
        o = r.spec.tableRole;
      o && (e[o] = r);
    }
  }
  return e;
}
var co = new ke("selectingCells");
function is(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function gM(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return t.node(e);
  }
  return null;
}
function Xn(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function rd(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = is(e.$head) || bM(e.$head);
  if (n) return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function bM(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n - e.nodeSize);
  }
}
function Tp(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function yM(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function r0(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function HV(t) {
  return Ae.get(t.node(-1)).findCell(t.pos - t.start(-1));
}
function FV(t) {
  return Ae.get(t.node(-1)).colCount(t.pos - t.start(-1));
}
function b_(t, e, n) {
  const r = t.node(-1),
    o = Ae.get(r),
    i = t.start(-1),
    s = o.nextCell(t.pos - i, e, n);
  return s == null ? null : t.node(0).resolve(i + s);
}
function ui(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return (
    r.colwidth &&
      ((r.colwidth = r.colwidth.slice()),
      r.colwidth.splice(e, n),
      r.colwidth.some((o) => o > 0) || (r.colwidth = null)),
    r
  );
}
function y_(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function vM(t, e, n) {
  const r = Dt(e.type.schema).header_cell;
  for (let o = 0; o < t.height; o++)
    if (e.nodeAt(t.map[n + o * t.width]).type != r) return !1;
  return !0;
}
var De = class Or extends ee {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1),
      o = Ae.get(r),
      i = e.start(-1),
      s = o.rectBetween(e.pos - i, n.pos - i),
      a = e.node(0),
      l = o.cellsInRect(s).filter((c) => c != n.pos - i);
    l.unshift(n.pos - i);
    const u = l.map((c) => {
      const d = r.nodeAt(c);
      if (!d) throw RangeError(`No cell with offset ${c} found`);
      const f = i + c + 1;
      return new pu(a.resolve(f), a.resolve(f + d.content.size));
    });
    super(u[0].$from, u[0].$to, u),
      (this.$anchorCell = e),
      (this.$headCell = n);
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)),
      o = e.resolve(n.map(this.$headCell.pos));
    if (Tp(r) && Tp(o) && r0(r, o)) {
      const i = this.$anchorCell.node(-1) != r.node(-1);
      return i && this.isRowSelection()
        ? Or.rowSelection(r, o)
        : i && this.isColSelection()
        ? Or.colSelection(r, o)
        : new Or(r, o);
    }
    return q.between(r, o);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1),
      n = Ae.get(e),
      r = this.$anchorCell.start(-1),
      o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
      i = {},
      s = [];
    for (let l = o.top; l < o.bottom; l++) {
      const u = [];
      for (let c = l * n.width + o.left, d = o.left; d < o.right; d++, c++) {
        const f = n.map[c];
        if (i[f]) continue;
        i[f] = !0;
        const p = n.findCell(f);
        let h = e.nodeAt(f);
        if (!h) throw RangeError(`No cell with offset ${f} found`);
        const m = o.left - p.left,
          g = p.right - o.right;
        if (m > 0 || g > 0) {
          let b = h.attrs;
          if (
            (m > 0 && (b = ui(b, 0, m)),
            g > 0 && (b = ui(b, b.colspan - g, g)),
            p.left < o.left)
          ) {
            if (((h = h.type.createAndFill(b)), !h))
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else h = h.type.create(b, h.content);
        }
        if (p.top < o.top || p.bottom > o.bottom) {
          const b = {
            ...h.attrs,
            rowspan: Math.min(p.bottom, o.bottom) - Math.max(p.top, o.top),
          };
          p.top < o.top
            ? (h = h.type.createAndFill(b))
            : (h = h.type.create(b, h.content));
        }
        u.push(h);
      }
      s.push(e.child(l).copy($.from(u)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new W($.from(a), 1, 1);
  }
  replace(e, n = W.empty) {
    const r = e.steps.length,
      o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      const { $from: a, $to: l } = o[s],
        u = e.mapping.slice(r);
      e.replace(u.map(a.pos), u.map(l.pos), s ? W.empty : n);
    }
    const i = ee.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
    i && e.setSelection(i);
  }
  replaceWith(e, n) {
    this.replace(e, new W($.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1),
      r = Ae.get(n),
      o = this.$anchorCell.start(-1),
      i = r.cellsInRect(
        r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o)
      );
    for (let s = 0; s < i.length; s++) e(n.nodeAt(i[s]), o + i[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1),
      n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
      o = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, o) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1),
      o = Ae.get(r),
      i = e.start(-1),
      s = o.findCell(e.pos - i),
      a = o.findCell(n.pos - i),
      l = e.node(0);
    return (
      s.top <= a.top
        ? (s.top > 0 && (e = l.resolve(i + o.map[s.left])),
          a.bottom < o.height &&
            (n = l.resolve(i + o.map[o.width * (o.height - 1) + a.right - 1])))
        : (a.top > 0 && (n = l.resolve(i + o.map[a.left])),
          s.bottom < o.height &&
            (e = l.resolve(i + o.map[o.width * (o.height - 1) + s.right - 1]))),
      new Or(e, n)
    );
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1),
      n = Ae.get(e),
      r = this.$anchorCell.start(-1),
      o = n.colCount(this.$anchorCell.pos - r),
      i = n.colCount(this.$headCell.pos - r);
    if (Math.min(o, i) > 0) return !1;
    const s = o + this.$anchorCell.nodeAfter.attrs.colspan,
      a = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return (
      e instanceof Or &&
      e.$anchorCell.pos == this.$anchorCell.pos &&
      e.$headCell.pos == this.$headCell.pos
    );
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1),
      o = Ae.get(r),
      i = e.start(-1),
      s = o.findCell(e.pos - i),
      a = o.findCell(n.pos - i),
      l = e.node(0);
    return (
      s.left <= a.left
        ? (s.left > 0 && (e = l.resolve(i + o.map[s.top * o.width])),
          a.right < o.width &&
            (n = l.resolve(i + o.map[o.width * (a.top + 1) - 1])))
        : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])),
          s.right < o.width &&
            (e = l.resolve(i + o.map[o.width * (s.top + 1) - 1]))),
      new Or(e, n)
    );
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos,
    };
  }
  static fromJSON(e, n) {
    return new Or(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Or(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new _M(this.$anchorCell.pos, this.$headCell.pos);
  }
};
De.prototype.visible = !1;
ee.jsonID("cell", De);
var _M = class v_ {
  constructor(e, n) {
    (this.anchor = e), (this.head = n);
  }
  map(e) {
    return new v_(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor),
      r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" &&
      r.parent.type.spec.tableRole == "row" &&
      n.index() < n.parent.childCount &&
      r.index() < r.parent.childCount &&
      r0(n, r)
      ? new De(n, r)
      : ee.near(r, 1);
  }
};
function xM(t) {
  if (!(t.selection instanceof De)) return null;
  const e = [];
  return (
    t.selection.forEachCell((n, r) => {
      e.push(Ve.node(r, r + n.nodeSize, { class: "selectedCell" }));
    }),
    ve.create(t.doc, e)
  );
}
function kM({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let n = t.pos,
    r = e.pos,
    o = t.depth;
  for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++);
  for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--);
  return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
}
function wM({ $from: t, $to: e }) {
  let n, r;
  for (let o = t.depth; o > 0; o--) {
    const i = t.node(o);
    if (
      i.type.spec.tableRole === "cell" ||
      i.type.spec.tableRole === "header_cell"
    ) {
      n = i;
      break;
    }
  }
  for (let o = e.depth; o > 0; o--) {
    const i = e.node(o);
    if (
      i.type.spec.tableRole === "cell" ||
      i.type.spec.tableRole === "header_cell"
    ) {
      r = i;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function CM(t, e, n) {
  const r = (e || t).selection,
    o = (e || t).doc;
  let i, s;
  if (r instanceof Z && (s = r.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell") i = De.create(o, r.from);
    else if (s == "row") {
      const a = o.resolve(r.from + 1);
      i = De.rowSelection(a, a);
    } else if (!n) {
      const a = Ae.get(r.node),
        l = r.from + 1,
        u = l + a.map[a.width * a.height - 1];
      i = De.create(o, l + 1, u);
    }
  } else
    r instanceof q && kM(r)
      ? (i = q.create(o, r.from))
      : r instanceof q &&
        wM(r) &&
        (i = q.create(o, r.$from.start(), r.$from.end()));
  return i && (e || (e = t.tr)).setSelection(i), e;
}
var AM = new ke("fix-tables");
function __(t, e, n, r) {
  const o = t.childCount,
    i = e.childCount;
  e: for (let s = 0, a = 0; s < i; s++) {
    const l = e.child(s);
    for (let u = a, c = Math.min(o, s + 3); u < c; u++)
      if (t.child(u) == l) {
        (a = u + 1), (n += l.nodeSize);
        continue e;
      }
    r(l, n),
      a < o && t.child(a).sameMarkup(l)
        ? __(t.child(a), l, n + 1, r)
        : l.nodesBetween(0, l.content.size, r, n + 1),
      (n += l.nodeSize);
  }
}
function x_(t, e) {
  let n;
  const r = (o, i) => {
    o.type.spec.tableRole == "table" && (n = SM(t, o, i, n));
  };
  return e ? e.doc != t.doc && __(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function SM(t, e, n, r) {
  const o = Ae.get(e);
  if (!o.problems) return r;
  r || (r = t.tr);
  const i = [];
  for (let l = 0; l < o.height; l++) i.push(0);
  for (let l = 0; l < o.problems.length; l++) {
    const u = o.problems[l];
    if (u.type == "collision") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      const d = c.attrs;
      for (let f = 0; f < d.rowspan; f++) i[u.row + f] += u.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + u.pos),
        null,
        ui(d, d.colspan - u.n, u.n)
      );
    } else if (u.type == "missing") i[u.row] += u.n;
    else if (u.type == "overlong_rowspan") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
        ...c.attrs,
        rowspan: c.attrs.rowspan - u.n,
      });
    } else if (u.type == "colwidth mismatch") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
        ...c.attrs,
        colwidth: u.colwidth,
      });
    }
  }
  let s, a;
  for (let l = 0; l < i.length; l++) i[l] && (s == null && (s = l), (a = l));
  for (let l = 0, u = n + 1; l < o.height; l++) {
    const c = e.child(l),
      d = u + c.nodeSize,
      f = i[l];
    if (f > 0) {
      let p = "cell";
      c.firstChild && (p = c.firstChild.type.spec.tableRole);
      const h = [];
      for (let g = 0; g < f; g++) {
        const b = Dt(t.schema)[p].createAndFill();
        b && h.push(b);
      }
      const m = (l == 0 || s == l - 1) && a == l ? u + 1 : d - 1;
      r.insert(r.mapping.map(m), h);
    }
    u = d;
  }
  return r.setMeta(AM, { fixTables: !0 });
}
function Zn(t) {
  const e = t.selection,
    n = rd(t),
    r = n.node(-1),
    o = n.start(-1),
    i = Ae.get(r);
  return {
    ...(e instanceof De
      ? i.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o)
      : i.findCell(n.pos - o)),
    tableStart: o,
    map: i,
    table: r,
  };
}
function k_(t, { map: e, tableStart: n, table: r }, o) {
  let i = o > 0 ? -1 : 0;
  vM(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + o;
    if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a],
        u = r.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        y_(u.attrs, o - e.colCount(l))
      ),
        (s += u.attrs.rowspan - 1);
    } else {
      const l =
          i == null ? Dt(r.type.schema).cell : r.nodeAt(e.map[a + i]).type,
        u = e.positionAt(s, o, r);
      t.insert(t.mapping.map(n + u), l.createAndFill());
    }
  }
  return t;
}
function EM(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t);
    e(k_(t.tr, n, n.left));
  }
  return !0;
}
function w_(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t);
    e(k_(t.tr, n, n.right));
  }
  return !0;
}
function MM(t, { map: e, table: n, tableStart: r }, o) {
  const i = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + o,
      l = e.map[a],
      u = n.nodeAt(l),
      c = u.attrs;
    if ((o > 0 && e.map[a - 1] == l) || (o < e.width - 1 && e.map[a + 1] == l))
      t.setNodeMarkup(
        t.mapping.slice(i).map(r + l),
        null,
        ui(c, o - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(i).map(r + l);
      t.delete(d, d + u.nodeSize);
    }
    s += c.rowspan;
  }
}
function TM(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t),
      r = t.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let o = n.right - 1; MM(r, n, o), o != n.left; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw RangeError("No table found");
      (n.table = i), (n.map = Ae.get(i));
    }
    e(r);
  }
  return !0;
}
function OM(t, e, n) {
  var r;
  const o = Dt(e.type.schema).header_cell;
  for (let i = 0; i < t.width; i++)
    if (((r = e.nodeAt(t.map[i + n * t.width])) == null ? void 0 : r.type) != o)
      return !1;
  return !0;
}
function C_(t, { map: e, tableStart: n, table: r }, o) {
  var i;
  let s = n;
  for (let u = 0; u < o; u++) s += r.child(u).nodeSize;
  const a = [];
  let l = o > 0 ? -1 : 0;
  OM(e, r, o + l) && (l = o == 0 || o == e.height ? null : 0);
  for (let u = 0, c = e.width * o; u < e.width; u++, c++)
    if (o > 0 && o < e.height && e.map[c] == e.map[c - e.width]) {
      const d = e.map[c],
        f = r.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...f,
        rowspan: f.rowspan + 1,
      }),
        (u += f.colspan - 1);
    } else {
      const d =
          l == null
            ? Dt(r.type.schema).cell
            : (i = r.nodeAt(e.map[c + l * e.width])) == null
            ? void 0
            : i.type,
        f = d == null ? void 0 : d.createAndFill();
      f && a.push(f);
    }
  return t.insert(s, Dt(r.type.schema).row.create(null, a)), t;
}
function DM(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t);
    e(C_(t.tr, n, n.top));
  }
  return !0;
}
function A_(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t);
    e(C_(t.tr, n, n.bottom));
  }
  return !0;
}
function NM(t, { map: e, table: n, tableStart: r }, o) {
  let i = 0;
  for (let u = 0; u < o; u++) i += n.child(u).nodeSize;
  const s = i + n.child(o).nodeSize,
    a = t.mapping.maps.length;
  t.delete(i + r, s + r);
  const l = /* @__PURE__ */ new Set();
  for (let u = 0, c = o * e.width; u < e.width; u++, c++) {
    const d = e.map[c];
    if (!l.has(d)) {
      if ((l.add(d), o > 0 && d == e.map[c - e.width])) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1,
        }),
          (u += f.colspan - 1);
      } else if (o < e.height && d == e.map[c + e.width]) {
        const f = n.nodeAt(d),
          p = f.attrs,
          h = f.type.create({ ...p, rowspan: f.attrs.rowspan - 1 }, f.content),
          m = e.positionAt(o + 1, u, n);
        t.insert(t.mapping.slice(a).map(r + m), h), (u += p.colspan - 1);
      }
    }
  }
}
function LM(t, e) {
  if (!Xn(t)) return !1;
  if (e) {
    const n = Zn(t),
      r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let o = n.bottom - 1; NM(r, n, o), o != n.top; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw RangeError("No table found");
      (n.table = i), (n.map = Ae.get(n.table));
    }
    e(r);
  }
  return !0;
}
function gg(t) {
  const e = t.content;
  return (
    e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0
  );
}
function RM({ width: t, height: e, map: n }, r) {
  let o = r.top * t + r.left,
    i = o,
    s = (r.bottom - 1) * t + r.left,
    a = o + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if ((r.left > 0 && n[i] == n[i - 1]) || (r.right < t && n[a] == n[a + 1]))
      return !0;
    (i += t), (a += t);
  }
  for (let l = r.left; l < r.right; l++) {
    if ((r.top > 0 && n[o] == n[o - t]) || (r.bottom < e && n[s] == n[s + t]))
      return !0;
    o++, s++;
  }
  return !1;
}
function bg(t, e) {
  const n = t.selection;
  if (!(n instanceof De) || n.$anchorCell.pos == n.$headCell.pos) return !1;
  const r = Zn(t),
    { map: o } = r;
  if (RM(o, r)) return !1;
  if (e) {
    const i = t.tr,
      s = {};
    let a = $.empty,
      l,
      u;
    for (let c = r.top; c < r.bottom; c++)
      for (let d = r.left; d < r.right; d++) {
        const f = o.map[c * o.width + d],
          p = r.table.nodeAt(f);
        if (!(s[f] || !p))
          if (((s[f] = !0), l == null)) (l = f), (u = p);
          else {
            gg(p) || (a = a.append(p.content));
            const h = i.mapping.map(f + r.tableStart);
            i.delete(h, h + p.nodeSize);
          }
      }
    if (l == null || u == null) return !0;
    if (
      (i.setNodeMarkup(l + r.tableStart, null, {
        ...y_(u.attrs, u.attrs.colspan, r.right - r.left - u.attrs.colspan),
        rowspan: r.bottom - r.top,
      }),
      a.size)
    ) {
      const c = l + 1 + u.content.size,
        d = gg(u) ? l + 1 : c;
      i.replaceWith(d + r.tableStart, c + r.tableStart, a);
    }
    i.setSelection(new De(i.doc.resolve(l + r.tableStart))), e(i);
  }
  return !0;
}
function yg(t, e) {
  const n = Dt(t.schema);
  return IM(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function IM(t) {
  return (e, n) => {
    var r;
    const o = e.selection;
    let i, s;
    if (o instanceof De) {
      if (o.$anchorCell.pos != o.$headCell.pos) return !1;
      (i = o.$anchorCell.nodeAfter), (s = o.$anchorCell.pos);
    } else {
      if (((i = gM(o.$from)), !i)) return !1;
      s = (r = is(o.$from)) == null ? void 0 : r.pos;
    }
    if (
      i == null ||
      s == null ||
      (i.attrs.colspan == 1 && i.attrs.rowspan == 1)
    )
      return !1;
    if (n) {
      let a = i.attrs;
      const l = [],
        u = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }),
        a.colspan > 1 && (a = { ...a, colspan: 1 });
      const c = Zn(e),
        d = e.tr;
      for (let p = 0; p < c.right - c.left; p++)
        l.push(
          u
            ? {
                ...a,
                colwidth: u && u[p] ? [u[p]] : null,
              }
            : a
        );
      let f;
      for (let p = c.top; p < c.bottom; p++) {
        let h = c.map.positionAt(p, c.left, c.table);
        p == c.top && (h += i.nodeSize);
        for (let m = c.left, g = 0; m < c.right; m++, g++)
          (m == c.left && p == c.top) ||
            d.insert(
              (f = d.mapping.map(h + c.tableStart, 1)),
              t({ node: i, row: p, col: m }).createAndFill(l[g])
            );
      }
      d.setNodeMarkup(s, t({ node: i, row: c.top, col: c.left }), l[0]),
        o instanceof De &&
          d.setSelection(
            new De(
              d.doc.resolve(o.$anchorCell.pos),
              f ? d.doc.resolve(f) : void 0
            )
          ),
        n(d);
    }
    return !0;
  };
}
function PM(t, e) {
  return function (n, r) {
    if (!Xn(n)) return !1;
    const o = rd(n);
    if (o.nodeAfter.attrs[t] === e) return !1;
    if (r) {
      const i = n.tr;
      n.selection instanceof De
        ? n.selection.forEachCell((s, a) => {
            s.attrs[t] !== e &&
              i.setNodeMarkup(a, null, {
                ...s.attrs,
                [t]: e,
              });
          })
        : i.setNodeMarkup(o.pos, null, {
            ...o.nodeAfter.attrs,
            [t]: e,
          }),
        r(i);
    }
    return !0;
  };
}
function $M(t) {
  return function (e, n) {
    if (!Xn(e)) return !1;
    if (n) {
      const r = Dt(e.schema),
        o = Zn(e),
        i = e.tr,
        s = o.map.cellsInRect(
          t == "column"
            ? {
                left: o.left,
                top: 0,
                right: o.right,
                bottom: o.map.height,
              }
            : t == "row"
            ? {
                left: 0,
                top: o.top,
                right: o.map.width,
                bottom: o.bottom,
              }
            : o
        ),
        a = s.map((l) => o.table.nodeAt(l));
      for (let l = 0; l < s.length; l++)
        a[l].type == r.header_cell &&
          i.setNodeMarkup(o.tableStart + s[l], r.cell, a[l].attrs);
      if (i.steps.length == 0)
        for (let l = 0; l < s.length; l++)
          i.setNodeMarkup(o.tableStart + s[l], r.header_cell, a[l].attrs);
      n(i);
    }
    return !0;
  };
}
function vg(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1,
  });
  for (let o = 0; o < r.length; o++) {
    const i = e.table.nodeAt(r[o]);
    if (i && i.type !== n.header_cell) return !1;
  }
  return !0;
}
function ha(t, e) {
  return (
    (e = e || { useDeprecatedLogic: !1 }),
    e.useDeprecatedLogic
      ? $M(t)
      : function (n, r) {
          if (!Xn(n)) return !1;
          if (r) {
            const o = Dt(n.schema),
              i = Zn(n),
              s = n.tr,
              a = vg("row", i, o),
              l = vg("column", i, o),
              c = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0,
              d =
                t == "column"
                  ? {
                      left: 0,
                      top: c,
                      right: 1,
                      bottom: i.map.height,
                    }
                  : t == "row"
                  ? {
                      left: c,
                      top: 0,
                      right: i.map.width,
                      bottom: 1,
                    }
                  : i,
              f =
                t == "column"
                  ? l
                    ? o.cell
                    : o.header_cell
                  : t == "row"
                  ? a
                    ? o.cell
                    : o.header_cell
                  : o.cell;
            i.map.cellsInRect(d).forEach((p) => {
              const h = p + i.tableStart,
                m = s.doc.nodeAt(h);
              m && s.setNodeMarkup(h, f, m.attrs);
            }),
              r(s);
          }
          return !0;
        }
  );
}
var zV = ha("row", {
    useDeprecatedLogic: !0,
  }),
  VV = ha("column", {
    useDeprecatedLogic: !0,
  }),
  BM = ha("cell", {
    useDeprecatedLogic: !0,
  });
function HM(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n) return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
      const i = t.node(-1).child(r),
        s = i.lastChild;
      if (s) return o - 1 - s.nodeSize;
      o -= i.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
      const i = n.child(r);
      if (i.childCount) return o + 1;
      o += i.nodeSize;
    }
  }
  return null;
}
function _g(t) {
  return function (e, n) {
    if (!Xn(e)) return !1;
    const r = HM(rd(e), t);
    if (r == null) return !1;
    if (n) {
      const o = e.doc.resolve(r);
      n(e.tr.setSelection(q.between(o, yM(o))).scrollIntoView());
    }
    return !0;
  };
}
function FM(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0;
  return !1;
}
function cl(t, e) {
  const n = t.selection;
  if (!(n instanceof De)) return !1;
  if (e) {
    const r = t.tr,
      o = Dt(t.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(o) ||
        r.replace(
          r.mapping.map(s + 1),
          r.mapping.map(s + i.nodeSize - 1),
          new W(o, 0, 0)
        );
    }),
      r.docChanged && e(r);
  }
  return !0;
}
function zM(t) {
  if (!t.size) return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (
    ;
    e.childCount == 1 &&
    ((n > 0 && r > 0) || e.child(0).type.spec.tableRole == "table");

  )
    n--, r--, (e = e.child(0).content);
  const o = e.child(0),
    i = o.type.spec.tableRole,
    s = o.type.schema,
    a = [];
  if (i == "row")
    for (let l = 0; l < e.childCount; l++) {
      let u = e.child(l).content;
      const c = l ? 0 : Math.max(0, n - 1),
        d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (c || d) && (u = Op(Dt(s).row, new W(u, c, d)).content), a.push(u);
    }
  else if (i == "cell" || i == "header_cell")
    a.push(n || r ? Op(Dt(s).row, new W(e, n, r)).content : e);
  else return null;
  return VM(s, a);
}
function VM(t, e) {
  const n = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = i.child(s).attrs;
      for (let u = o; u < o + a; u++) n[u] = (n[u] || 0) + l;
    }
  }
  let r = 0;
  for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
  for (let o = 0; o < n.length; o++)
    if ((o >= e.length && e.push($.empty), n[o] < r)) {
      const i = Dt(t).cell.createAndFill(),
        s = [];
      for (let a = n[o]; a < r; a++) s.push(i);
      e[o] = e[o].append($.from(s));
    }
  return { height: e.length, width: r, rows: e };
}
function Op(t, e) {
  const n = t.createAndFill();
  return new Nh(n).replace(0, n.content.size, e).doc;
}
function UM({ width: t, height: e, rows: n }, r, o) {
  if (t != r) {
    const i = [],
      s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a],
        u = [];
      for (let c = i[a] || 0, d = 0; c < r; d++) {
        let f = l.child(d % l.childCount);
        c + f.attrs.colspan > r &&
          (f = f.type.createChecked(
            ui(f.attrs, f.attrs.colspan, c + f.attrs.colspan - r),
            f.content
          )),
          u.push(f),
          (c += f.attrs.colspan);
        for (let p = 1; p < f.attrs.rowspan; p++)
          i[a + p] = (i[a + p] || 0) + f.attrs.colspan;
      }
      s.push($.from(u));
    }
    (n = s), (t = r);
  }
  if (e != o) {
    const i = [];
    for (let s = 0, a = 0; s < o; s++, a++) {
      const l = [],
        u = n[a % e];
      for (let c = 0; c < u.childCount; c++) {
        let d = u.child(c);
        s + d.attrs.rowspan > o &&
          (d = d.type.create(
            {
              ...d.attrs,
              rowspan: Math.max(1, o - d.attrs.rowspan),
            },
            d.content
          )),
          l.push(d);
      }
      i.push($.from(l));
    }
    (n = i), (e = o);
  }
  return { width: t, height: e, rows: n };
}
function jM(t, e, n, r, o, i, s) {
  const a = t.doc.type.schema,
    l = Dt(a);
  let u, c;
  if (o > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const p = n.child(d);
      f += p.nodeSize;
      const h = [];
      let m;
      p.lastChild == null || p.lastChild.type == l.cell
        ? (m = u || (u = l.cell.createAndFill()))
        : (m = c || (c = l.header_cell.createAndFill()));
      for (let g = e.width; g < o; g++) h.push(m);
      t.insert(t.mapping.slice(s).map(f - 1 + r), h);
    }
  if (i > e.height) {
    const d = [];
    for (
      let h = 0, m = (e.height - 1) * e.width;
      h < Math.max(e.width, o);
      h++
    ) {
      const g =
        h >= e.width ? !1 : n.nodeAt(e.map[m + h]).type == l.header_cell;
      d.push(
        g
          ? c || (c = l.header_cell.createAndFill())
          : u || (u = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, $.from(d)),
      p = [];
    for (let h = e.height; h < i; h++) p.push(f);
    t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), p);
  }
  return !!(u || c);
}
function xg(t, e, n, r, o, i, s, a) {
  if (s == 0 || s == e.height) return !1;
  let l = !1;
  for (let u = o; u < i; u++) {
    const c = s * e.width + u,
      d = e.map[c];
    if (e.map[c - e.width] == d) {
      l = !0;
      const f = n.nodeAt(d),
        { top: p, left: h } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
        ...f.attrs,
        rowspan: s - p,
      }),
        t.insert(
          t.mapping.slice(a).map(e.positionAt(s, h, n)),
          f.type.createAndFill({
            ...f.attrs,
            rowspan: p + f.attrs.rowspan - s,
          })
        ),
        (u += f.attrs.colspan - 1);
    }
  }
  return l;
}
function kg(t, e, n, r, o, i, s, a) {
  if (s == 0 || s == e.width) return !1;
  let l = !1;
  for (let u = o; u < i; u++) {
    const c = u * e.width + s,
      d = e.map[c];
    if (e.map[c - 1] == d) {
      l = !0;
      const f = n.nodeAt(d),
        p = e.colCount(d),
        h = t.mapping.slice(a).map(d + r);
      t.setNodeMarkup(h, null, ui(f.attrs, s - p, f.attrs.colspan - (s - p))),
        t.insert(h + f.nodeSize, f.type.createAndFill(ui(f.attrs, 0, s - p))),
        (u += f.attrs.rowspan - 1);
    }
  }
  return l;
}
function wg(t, e, n, r, o) {
  let i = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!i) throw new Error("No table found");
  let s = Ae.get(i);
  const { top: a, left: l } = r,
    u = l + o.width,
    c = a + o.height,
    d = t.tr;
  let f = 0;
  function p() {
    if (((i = n ? d.doc.nodeAt(n - 1) : d.doc), !i))
      throw new Error("No table found");
    (s = Ae.get(i)), (f = d.mapping.maps.length);
  }
  jM(d, s, i, n, u, c, f) && p(),
    xg(d, s, i, n, l, u, a, f) && p(),
    xg(d, s, i, n, l, u, c, f) && p(),
    kg(d, s, i, n, a, c, l, f) && p(),
    kg(d, s, i, n, a, c, u, f) && p();
  for (let h = a; h < c; h++) {
    const m = s.positionAt(h, l, i),
      g = s.positionAt(h, u, i);
    d.replace(
      d.mapping.slice(f).map(m + n),
      d.mapping.slice(f).map(g + n),
      new W(o.rows[h - a], 0, 0)
    );
  }
  p(),
    d.setSelection(
      new De(
        d.doc.resolve(n + s.positionAt(a, l, i)),
        d.doc.resolve(n + s.positionAt(c - 1, u - 1, i))
      )
    ),
    e(d);
}
var WM = Gc({
  ArrowLeft: dl("horiz", -1),
  ArrowRight: dl("horiz", 1),
  ArrowUp: dl("vert", -1),
  ArrowDown: dl("vert", 1),
  "Shift-ArrowLeft": fl("horiz", -1),
  "Shift-ArrowRight": fl("horiz", 1),
  "Shift-ArrowUp": fl("vert", -1),
  "Shift-ArrowDown": fl("vert", 1),
  Backspace: cl,
  "Mod-Backspace": cl,
  Delete: cl,
  "Mod-Delete": cl,
});
function jl(t, e, n) {
  return n.eq(t.selection)
    ? !1
    : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function dl(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    if (i instanceof De) return jl(n, r, ee.near(i.$headCell, e));
    if (t != "horiz" && !i.empty) return !1;
    const s = S_(o, t, e);
    if (s == null) return !1;
    if (t == "horiz") return jl(n, r, ee.near(n.doc.resolve(i.head + e), e));
    {
      const a = n.doc.resolve(s),
        l = b_(a, t, e);
      let u;
      return (
        l
          ? (u = ee.near(l, 1))
          : e < 0
          ? (u = ee.near(n.doc.resolve(a.before(-1)), -1))
          : (u = ee.near(n.doc.resolve(a.after(-1)), 1)),
        jl(n, r, u)
      );
    }
  };
}
function fl(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    let s;
    if (i instanceof De) s = i;
    else {
      const l = S_(o, t, e);
      if (l == null) return !1;
      s = new De(n.doc.resolve(l));
    }
    const a = b_(s.$headCell, t, e);
    return a ? jl(n, r, new De(s.$anchorCell, a)) : !1;
  };
}
function qM(t, e) {
  const n = t.state.doc,
    r = is(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new De(r))), !0) : !1;
}
function KM(t, e, n) {
  if (!Xn(t.state)) return !1;
  let r = zM(n);
  const o = t.state.selection;
  if (o instanceof De) {
    r ||
      (r = {
        width: 1,
        height: 1,
        rows: [$.from(Op(Dt(t.state.schema).cell, n))],
      });
    const i = o.$anchorCell.node(-1),
      s = o.$anchorCell.start(-1),
      a = Ae.get(i).rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
    return (
      (r = UM(r, a.right - a.left, a.bottom - a.top)),
      wg(t.state, t.dispatch, s, a, r),
      !0
    );
  } else if (r) {
    const i = rd(t.state),
      s = i.start(-1);
    return (
      wg(t.state, t.dispatch, s, Ae.get(i.node(-1)).findCell(i.pos - s), r), !0
    );
  } else return !1;
}
function GM(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey) return;
  const r = Cg(t, e.target);
  let o;
  if (e.shiftKey && t.state.selection instanceof De)
    i(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (
    e.shiftKey &&
    r &&
    (o = is(t.state.selection.$anchor)) != null &&
    ((n = lf(t, e)) == null ? void 0 : n.pos) != o.pos
  )
    i(o, e), e.preventDefault();
  else if (!r) return;
  function i(l, u) {
    let c = lf(t, u);
    const d = co.getState(t.state) == null;
    if (!c || !r0(l, c))
      if (d) c = l;
      else return;
    const f = new De(l, c);
    if (d || !t.state.selection.eq(f)) {
      const p = t.state.tr.setSelection(f);
      d && p.setMeta(co, l.pos), t.dispatch(p);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s),
      t.root.removeEventListener("dragstart", s),
      t.root.removeEventListener("mousemove", a),
      co.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(co, -1));
  }
  function a(l) {
    const u = l,
      c = co.getState(t.state);
    let d;
    if (c != null) d = t.state.doc.resolve(c);
    else if (Cg(t, u.target) != r && ((d = lf(t, e)), !d)) return s();
    d && i(d, u);
  }
  t.root.addEventListener("mouseup", s),
    t.root.addEventListener("dragstart", s),
    t.root.addEventListener("mousemove", a);
}
function S_(t, e, n) {
  if (!(t.state.selection instanceof q)) return null;
  const { $head: r } = t.state.selection;
  for (let o = r.depth - 1; o >= 0; o--) {
    const i = r.node(o);
    if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount))
      return null;
    if (
      i.type.spec.tableRole == "cell" ||
      i.type.spec.tableRole == "header_cell"
    ) {
      const a = r.before(o),
        l = e == "vert" ? (n > 0 ? "down" : "up") : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function Cg(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH") return e;
  return null;
}
function lf(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY,
  });
  return n && n ? is(t.state.doc.resolve(n.pos)) : null;
}
var JM = class {
  constructor(e, n) {
    (this.node = e),
      (this.defaultCellMinWidth = n),
      (this.dom = document.createElement("div")),
      (this.dom.className = "tableWrapper"),
      (this.table = this.dom.appendChild(document.createElement("table"))),
      this.table.style.setProperty("--default-cell-min-width", `${n}px`),
      (this.colgroup = this.table.appendChild(
        document.createElement("colgroup")
      )),
      Dp(e, this.colgroup, this.table, n),
      (this.contentDOM = this.table.appendChild(
        document.createElement("tbody")
      ));
  }
  update(e) {
    return e.type != this.node.type
      ? !1
      : ((this.node = e),
        Dp(e, this.colgroup, this.table, this.defaultCellMinWidth),
        !0);
  }
  ignoreMutation(e) {
    return (
      e.type == "attributes" &&
      (e.target == this.table || this.colgroup.contains(e.target))
    );
  }
};
function Dp(t, e, n, r, o, i) {
  var s;
  let a = 0,
    l = !0,
    u = e.firstChild;
  const c = t.firstChild;
  if (c) {
    for (let d = 0, f = 0; d < c.childCount; d++) {
      const { colspan: p, colwidth: h } = c.child(d).attrs;
      for (let m = 0; m < p; m++, f++) {
        const g = o == f ? i : h && h[m],
          b = g ? g + "px" : "";
        if (((a += g || r), g || (l = !1), u))
          u.style.width != b && (u.style.width = b), (u = u.nextSibling);
        else {
          const _ = document.createElement("col");
          (_.style.width = b), e.appendChild(_);
        }
      }
    }
    for (; u; ) {
      const d = u.nextSibling;
      (s = u.parentNode) == null || s.removeChild(u), (u = d);
    }
    l
      ? ((n.style.width = a + "px"), (n.style.minWidth = ""))
      : ((n.style.width = ""), (n.style.minWidth = a + "px"));
  }
}
var ln = new ke("tableColumnResizing");
function YM({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = JM,
  lastColumnResizable: o = !0,
} = {}) {
  const i = new be({
    key: ln,
    state: {
      init(s, a) {
        var l, u;
        const c =
            (u = (l = i.spec) == null ? void 0 : l.props) == null
              ? void 0
              : u.nodeViews,
          d = Dt(a.schema).table.name;
        return r && c && (c[d] = (f, p) => new r(f, n, p)), new XM(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      },
    },
    props: {
      attributes: (s) => {
        const a = ln.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          ZM(s, a, t, o);
        },
        mouseleave: (s) => {
          QM(s);
        },
        mousedown: (s, a) => {
          eT(s, a, e, n);
        },
      },
      decorations: (s) => {
        const a = ln.getState(s);
        if (a && a.activeHandle > -1) return iT(s, a.activeHandle);
      },
      nodeViews: {},
    },
  });
  return i;
}
var XM = class Wl {
  constructor(e, n) {
    (this.activeHandle = e), (this.dragging = n);
  }
  apply(e) {
    const n = this,
      r = e.getMeta(ln);
    if (r && r.setHandle != null) return new Wl(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Wl(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let o = e.mapping.map(n.activeHandle, -1);
      return Tp(e.doc.resolve(o)) || (o = -1), new Wl(o, n.dragging);
    }
    return n;
  }
};
function ZM(t, e, n, r) {
  const o = ln.getState(t.state);
  if (o && !o.dragging) {
    const i = nT(e.target);
    let s = -1;
    if (i) {
      const { left: a, right: l } = i.getBoundingClientRect();
      e.clientX - a <= n
        ? (s = Ag(t, e, "left", n))
        : l - e.clientX <= n && (s = Ag(t, e, "right", n));
    }
    if (s != o.activeHandle) {
      if (!r && s !== -1) {
        const a = t.state.doc.resolve(s),
          l = a.node(-1),
          u = Ae.get(l),
          c = a.start(-1);
        if (
          u.colCount(a.pos - c) + a.nodeAfter.attrs.colspan - 1 ==
          u.width - 1
        )
          return;
      }
      E_(t, s);
    }
  }
}
function QM(t) {
  const e = ln.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && E_(t, -1);
}
function eT(t, e, n, r) {
  var o;
  const i = (o = t.dom.ownerDocument.defaultView) != null ? o : window,
    s = ln.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging) return !1;
  const a = t.state.doc.nodeAt(s.activeHandle),
    l = tT(t, s.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(ln, {
      setDragging: { startX: e.clientX, startWidth: l },
    })
  );
  function u(d) {
    i.removeEventListener("mouseup", u), i.removeEventListener("mousemove", c);
    const f = ln.getState(t.state);
    f != null &&
      f.dragging &&
      (rT(t, f.activeHandle, Sg(f.dragging, d, n)),
      t.dispatch(t.state.tr.setMeta(ln, { setDragging: null })));
  }
  function c(d) {
    if (!d.which) return u(d);
    const f = ln.getState(t.state);
    if (f && f.dragging) {
      const p = Sg(f.dragging, d, n);
      Eg(t, f.activeHandle, p, r);
    }
  }
  return (
    Eg(t, s.activeHandle, l, r),
    i.addEventListener("mouseup", u),
    i.addEventListener("mousemove", c),
    e.preventDefault(),
    !0
  );
}
function tT(t, e, { colspan: n, colwidth: r }) {
  const o = r && r[r.length - 1];
  if (o) return o;
  const i = t.domAtPos(e);
  let a = i.node.childNodes[i.offset].offsetWidth,
    l = n;
  if (r) for (let u = 0; u < n; u++) r[u] && ((a -= r[u]), l--);
  return a / l;
}
function nT(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t =
      t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function Ag(t, e, n, r) {
  const o = n == "right" ? -r : r,
    i = t.posAtCoords({
      left: e.clientX + o,
      top: e.clientY,
    });
  if (!i) return -1;
  const { pos: s } = i,
    a = is(t.state.doc.resolve(s));
  if (!a) return -1;
  if (n == "right") return a.pos;
  const l = Ae.get(a.node(-1)),
    u = a.start(-1),
    c = l.map.indexOf(a.pos - u);
  return c % l.width == 0 ? -1 : u + l.map[c - 1];
}
function Sg(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function E_(t, e) {
  t.dispatch(t.state.tr.setMeta(ln, { setHandle: e }));
}
function rT(t, e, n) {
  const r = t.state.doc.resolve(e),
    o = r.node(-1),
    i = Ae.get(o),
    s = r.start(-1),
    a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1,
    l = t.state.tr;
  for (let u = 0; u < i.height; u++) {
    const c = u * i.width + a;
    if (u && i.map[c] == i.map[c - i.width]) continue;
    const d = i.map[c],
      f = o.nodeAt(d).attrs,
      p = f.colspan == 1 ? 0 : a - i.colCount(d);
    if (f.colwidth && f.colwidth[p] == n) continue;
    const h = f.colwidth ? f.colwidth.slice() : oT(f.colspan);
    (h[p] = n), l.setNodeMarkup(s + d, null, { ...f, colwidth: h });
  }
  l.docChanged && t.dispatch(l);
}
function Eg(t, e, n, r) {
  const o = t.state.doc.resolve(e),
    i = o.node(-1),
    s = o.start(-1),
    a = Ae.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(o.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; ) l = l.parentNode;
  l && Dp(i, l.firstChild, l, r, a, n);
}
function oT(t) {
  return Array(t).fill(0);
}
function iT(t, e) {
  var n;
  const r = [],
    o = t.doc.resolve(e),
    i = o.node(-1);
  if (!i) return ve.empty;
  const s = Ae.get(i),
    a = o.start(-1),
    l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
  for (let u = 0; u < s.height; u++) {
    const c = l + u * s.width;
    if (
      (l == s.width - 1 || s.map[c] != s.map[c + 1]) &&
      (u == 0 || s.map[c] != s.map[c - s.width])
    ) {
      const d = s.map[c],
        f = a + d + i.nodeAt(d).nodeSize - 1,
        p = document.createElement("div");
      (p.className = "column-resize-handle"),
        (n = ln.getState(t)) != null &&
          n.dragging &&
          r.push(
            Ve.node(a + d, a + d + i.nodeAt(d).nodeSize, {
              class: "column-resize-dragging",
            })
          ),
        r.push(Ve.widget(f, p));
    }
  }
  return ve.create(t.doc, r);
}
function sT({ allowTableNodeSelection: t = !1 } = {}) {
  return new be({
    key: co,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(co);
        if (r != null) return r == -1 ? null : r;
        if (n == null || !e.docChanged) return n;
        const { deleted: o, pos: i } = e.mapping.mapResult(n);
        return o ? null : i;
      },
    },
    props: {
      decorations: xM,
      handleDOMEvents: {
        mousedown: GM,
      },
      createSelectionBetween(e) {
        return co.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: qM,
      handleKeyDown: WM,
      handlePaste: KM,
    },
    appendTransaction(e, n, r) {
      return CM(r, x_(r, n), t);
    },
  });
}
var Mg = new ke("trailingNode");
function jV(t) {
  const { ignoredNodes: e = [], nodeName: n = "paragraph" } = t ?? {},
    r = /* @__PURE__ */ new Set([...e, n]);
  let o, i;
  return new be({
    key: Mg,
    appendTransaction(s, a, l) {
      const { doc: u, tr: c } = l,
        d = Mg.getState(l),
        f = u.content.size;
      if (d) return c.insert(f, o.create());
    },
    state: {
      init: (s, { doc: a, schema: l }) => {
        var u;
        const c = l.nodes[n];
        if (!c)
          throw new Error(
            "Invalid node being used for trailing node extension: '".concat(
              n,
              "'"
            )
          );
        return (
          (o = c),
          (i = Object.values(l.nodes)
            .map((d) => d)
            .filter((d) => !r.has(d.name))),
          i.includes((u = a.lastChild) == null ? void 0 : u.type)
        );
      },
      apply: (s, a) => {
        var l;
        return s.docChanged
          ? i.includes((l = s.doc.lastChild) == null ? void 0 : l.type)
          : a;
      },
    },
  });
}
function od(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n,
    { doc: o } = n,
    { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return (r = n.selection), (o = n.doc), (i = n.storedMarks), n;
    },
  };
}
class id {
  constructor(e) {
    (this.editor = e.editor),
      (this.rawCommands = this.editor.extensionManager.commands),
      (this.customState = e.state);
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this,
      { view: o } = n,
      { tr: i } = r,
      s = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(e).map(([a, l]) => [
        a,
        (...c) => {
          const d = l(...c)(s);
          return (
            !i.getMeta("preventDispatch") &&
              !this.hasCustomState &&
              o.dispatch(i),
            d
          );
        },
      ])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: s } = o,
      a = [],
      l = !!e,
      u = e || i.tr,
      c = () => (
        !l &&
          n &&
          !u.getMeta("preventDispatch") &&
          !this.hasCustomState &&
          s.dispatch(u),
        a.every((f) => f === !0)
      ),
      d = {
        ...Object.fromEntries(
          Object.entries(r).map(([f, p]) => [
            f,
            (...m) => {
              const g = this.buildProps(u, n),
                b = p(...m)(g);
              return a.push(b), d;
            },
          ])
        ),
        run: c,
      };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this,
      o = !1,
      i = e || r.tr,
      s = this.buildProps(i, o);
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([l, u]) => [
          l,
          (...c) => u(...c)({ ...s, dispatch: void 0 }),
        ])
      ),
      chain: () => this.createChain(i, o),
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: s } = o,
      a = {
        tr: e,
        editor: o,
        view: s,
        state: od({
          state: i,
          transaction: e,
        }),
        dispatch: n ? () => {} : void 0,
        chain: () => this.createChain(e, n),
        can: () => this.createCan(e),
        get commands() {
          return Object.fromEntries(
            Object.entries(r).map(([l, u]) => [l, (...c) => u(...c)(a)])
          );
        },
      };
    return a;
  }
}
class aT {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return (
      this.callbacks[e] || (this.callbacks[e] = []),
      this.callbacks[e].push(n),
      this
    );
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((o) => o.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return (
      r &&
        (n
          ? (this.callbacks[e] = r.filter((o) => o !== n))
          : delete this.callbacks[e]),
      this
    );
  }
  once(e, n) {
    const r = (...o) => {
      this.off(e, r), n.apply(this, o);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function K(t, e, n) {
  return t.config[e] === void 0 && t.parent
    ? K(t.parent, e, n)
    : typeof t.config[e] == "function"
    ? t.config[e].bind({
        ...n,
        parent: t.parent ? K(t.parent, e, n) : null,
      })
    : t.config[e];
}
function sd(t) {
  const e = t.filter((o) => o.type === "extension"),
    n = t.filter((o) => o.type === "node"),
    r = t.filter((o) => o.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r,
  };
}
function M_(t) {
  const e = [],
    { nodeExtensions: n, markExtensions: r } = sd(t),
    o = [...n, ...r],
    i = {
      default: null,
      rendered: !0,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: !0,
      isRequired: !1,
    };
  return (
    t.forEach((s) => {
      const a = {
          name: s.name,
          options: s.options,
          storage: s.storage,
          extensions: o,
        },
        l = K(s, "addGlobalAttributes", a);
      if (!l) return;
      l().forEach((c) => {
        c.types.forEach((d) => {
          Object.entries(c.attributes).forEach(([f, p]) => {
            e.push({
              type: d,
              name: f,
              attribute: {
                ...i,
                ...p,
              },
            });
          });
        });
      });
    }),
    o.forEach((s) => {
      const a = {
          name: s.name,
          options: s.options,
          storage: s.storage,
        },
        l = K(s, "addAttributes", a);
      if (!l) return;
      const u = l();
      Object.entries(u).forEach(([c, d]) => {
        const f = {
          ...i,
          ...d,
        };
        typeof (f == null ? void 0 : f.default) == "function" &&
          (f.default = f.default()),
          f != null &&
            f.isRequired &&
            (f == null ? void 0 : f.default) === void 0 &&
            delete f.default,
          e.push({
            type: s.name,
            name: c,
            attribute: f,
          });
      });
    }),
    e
  );
}
function lt(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(
        `There is no node type named '${t}'. Maybe you forgot to add the extension?`
      );
    return e.nodes[t];
  }
  return t;
}
function ge(...t) {
  return t
    .filter((e) => !!e)
    .reduce((e, n) => {
      const r = { ...e };
      return (
        Object.entries(n).forEach(([o, i]) => {
          if (!r[o]) {
            r[o] = i;
            return;
          }
          if (o === "class") {
            const a = i ? String(i).split(" ") : [],
              l = r[o] ? r[o].split(" ") : [],
              u = a.filter((c) => !l.includes(c));
            r[o] = [...l, ...u].join(" ");
          } else if (o === "style") {
            const a = i
                ? i
                    .split(";")
                    .map((c) => c.trim())
                    .filter(Boolean)
                : [],
              l = r[o]
                ? r[o]
                    .split(";")
                    .map((c) => c.trim())
                    .filter(Boolean)
                : [],
              u = /* @__PURE__ */ new Map();
            l.forEach((c) => {
              const [d, f] = c.split(":").map((p) => p.trim());
              u.set(d, f);
            }),
              a.forEach((c) => {
                const [d, f] = c.split(":").map((p) => p.trim());
                u.set(d, f);
              }),
              (r[o] = Array.from(u.entries())
                .map(([c, d]) => `${c}: ${d}`)
                .join("; "));
          } else r[o] = i;
        }),
        r
      );
    }, {});
}
function Np(t, e) {
  return e
    .filter((n) => n.type === t.type.name)
    .filter((n) => n.attribute.rendered)
    .map((n) =>
      n.attribute.renderHTML
        ? n.attribute.renderHTML(t.attrs) || {}
        : {
            [n.name]: t.attrs[n.name],
          }
    )
    .reduce((n, r) => ge(n, r), {});
}
function T_(t) {
  return typeof t == "function";
}
function le(t, e = void 0, ...n) {
  return T_(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function lT(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function uT(t) {
  return typeof t != "string"
    ? t
    : t.match(/^[+-]?(?:\d*\.)?\d+$/)
    ? Number(t)
    : t === "true"
    ? !0
    : t === "false"
    ? !1
    : t;
}
function Tg(t, e) {
  return "style" in t
    ? t
    : {
        ...t,
        getAttrs: (n) => {
          const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
          if (r === !1) return !1;
          const o = e.reduce((i, s) => {
            const a = s.attribute.parseHTML
              ? s.attribute.parseHTML(n)
              : uT(n.getAttribute(s.name));
            return a == null
              ? i
              : {
                  ...i,
                  [s.name]: a,
                };
          }, {});
          return { ...r, ...o };
        },
      };
}
function Og(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) =>
      e === "attrs" && lT(n) ? !1 : n != null
    )
  );
}
function O_(t, e) {
  var n;
  const r = M_(t),
    { nodeExtensions: o, markExtensions: i } = sd(t),
    s =
      (n = o.find((u) => K(u, "topNode"))) === null || n === void 0
        ? void 0
        : n.name,
    a = Object.fromEntries(
      o.map((u) => {
        const c = r.filter((b) => b.type === u.name),
          d = {
            name: u.name,
            options: u.options,
            storage: u.storage,
            editor: e,
          },
          f = t.reduce((b, _) => {
            const v = K(_, "extendNodeSchema", d);
            return {
              ...b,
              ...(v ? v(u) : {}),
            };
          }, {}),
          p = Og({
            ...f,
            content: le(K(u, "content", d)),
            marks: le(K(u, "marks", d)),
            group: le(K(u, "group", d)),
            inline: le(K(u, "inline", d)),
            atom: le(K(u, "atom", d)),
            selectable: le(K(u, "selectable", d)),
            draggable: le(K(u, "draggable", d)),
            code: le(K(u, "code", d)),
            whitespace: le(K(u, "whitespace", d)),
            linebreakReplacement: le(K(u, "linebreakReplacement", d)),
            defining: le(K(u, "defining", d)),
            isolating: le(K(u, "isolating", d)),
            attrs: Object.fromEntries(
              c.map((b) => {
                var _;
                return [
                  b.name,
                  {
                    default:
                      (_ = b == null ? void 0 : b.attribute) === null ||
                      _ === void 0
                        ? void 0
                        : _.default,
                  },
                ];
              })
            ),
          }),
          h = le(K(u, "parseHTML", d));
        h && (p.parseDOM = h.map((b) => Tg(b, c)));
        const m = K(u, "renderHTML", d);
        m &&
          (p.toDOM = (b) =>
            m({
              node: b,
              HTMLAttributes: Np(b, c),
            }));
        const g = K(u, "renderText", d);
        return g && (p.toText = g), [u.name, p];
      })
    ),
    l = Object.fromEntries(
      i.map((u) => {
        const c = r.filter((g) => g.type === u.name),
          d = {
            name: u.name,
            options: u.options,
            storage: u.storage,
            editor: e,
          },
          f = t.reduce((g, b) => {
            const _ = K(b, "extendMarkSchema", d);
            return {
              ...g,
              ...(_ ? _(u) : {}),
            };
          }, {}),
          p = Og({
            ...f,
            inclusive: le(K(u, "inclusive", d)),
            excludes: le(K(u, "excludes", d)),
            group: le(K(u, "group", d)),
            spanning: le(K(u, "spanning", d)),
            code: le(K(u, "code", d)),
            attrs: Object.fromEntries(
              c.map((g) => {
                var b;
                return [
                  g.name,
                  {
                    default:
                      (b = g == null ? void 0 : g.attribute) === null ||
                      b === void 0
                        ? void 0
                        : b.default,
                  },
                ];
              })
            ),
          }),
          h = le(K(u, "parseHTML", d));
        h && (p.parseDOM = h.map((g) => Tg(g, c)));
        const m = K(u, "renderHTML", d);
        return (
          m &&
            (p.toDOM = (g) =>
              m({
                mark: g,
                HTMLAttributes: Np(g, c),
              })),
          [u.name, p]
        );
      })
    );
  return new Uc({
    topNode: s,
    nodes: a,
    marks: l,
  });
}
function uf(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function Dg(t, e) {
  return Array.isArray(e)
    ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name)
    : e;
}
function ad(t, e) {
  const n = hi.fromSchema(e).serializeFragment(t),
    o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(n), o.innerHTML;
}
const cT = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return (
    t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, a) => {
      var l, u;
      const c =
        ((u = (l = o.type.spec).toText) === null || u === void 0
          ? void 0
          : u.call(l, {
              node: o,
              pos: i,
              parent: s,
              index: a,
            })) ||
        o.textContent ||
        "%leaf%";
      n += o.isAtom && !o.isText ? c : c.slice(0, Math.max(0, r - i));
    }),
    n
  );
};
function o0(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Ra {
  constructor(e) {
    (this.find = e.find), (this.handler = e.handler);
  }
}
const dT = (t, e) => {
  if (o0(e)) return e.exec(t);
  const n = e(t);
  if (!n) return null;
  const r = [n.text];
  return (
    (r.index = n.index),
    (r.input = t),
    (r.data = n.data),
    n.replaceWith &&
      (n.text.includes(n.replaceWith) ||
        console.warn(
          '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
        ),
      r.push(n.replaceWith)),
    r
  );
};
function pl(t) {
  var e;
  const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = t,
    { view: l } = n;
  if (l.composing) return !1;
  const u = l.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code ||
    (!((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) &&
      e.marks.find((f) => f.type.spec.code))
  )
    return !1;
  let c = !1;
  const d = cT(u) + i;
  return (
    s.forEach((f) => {
      if (c) return;
      const p = dT(d, f.find);
      if (!p) return;
      const h = l.state.tr,
        m = od({
          state: l.state,
          transaction: h,
        }),
        g = {
          from: r - (p[0].length - i.length),
          to: o,
        },
        {
          commands: b,
          chain: _,
          can: v,
        } = new id({
          editor: n,
          state: m,
        });
      f.handler({
        state: m,
        range: g,
        match: p,
        commands: b,
        chain: _,
        can: v,
      }) === null ||
        !h.steps.length ||
        (h.setMeta(a, {
          transform: h,
          from: r,
          to: o,
          text: i,
        }),
        l.dispatch(h),
        (c = !0));
    }),
    c
  );
}
function fT(t) {
  const { editor: e, rules: n } = t,
    r = new be({
      state: {
        init() {
          return null;
        },
        apply(o, i, s) {
          const a = o.getMeta(r);
          if (a) return a;
          const l = o.getMeta("applyInputRules");
          return (
            !!l &&
              setTimeout(() => {
                let { text: c } = l;
                typeof c == "string" ? (c = c) : (c = ad($.from(c), s.schema));
                const { from: d } = l,
                  f = d + c.length;
                pl({
                  editor: e,
                  from: d,
                  to: f,
                  text: c,
                  rules: n,
                  plugin: r,
                });
              }),
            o.selectionSet || o.docChanged ? null : i
          );
        },
      },
      props: {
        handleTextInput(o, i, s, a) {
          return pl({
            editor: e,
            from: i,
            to: s,
            text: a,
            rules: n,
            plugin: r,
          });
        },
        handleDOMEvents: {
          compositionend: (o) => (
            setTimeout(() => {
              const { $cursor: i } = o.state.selection;
              i &&
                pl({
                  editor: e,
                  from: i.pos,
                  to: i.pos,
                  text: "",
                  rules: n,
                  plugin: r,
                });
            }),
            !1
          ),
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(o, i) {
          if (i.key !== "Enter") return !1;
          const { $cursor: s } = o.state.selection;
          return s
            ? pl({
                editor: e,
                from: s.pos,
                to: s.pos,
                text: `
`,
                rules: n,
                plugin: r,
              })
            : !1;
        },
      },
      // @ts-ignore
      isInputRules: !0,
    });
  return r;
}
function pT(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function hl(t) {
  return pT(t) !== "Object"
    ? !1
    : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function ld(t, e) {
  const n = { ...t };
  return (
    hl(t) &&
      hl(e) &&
      Object.keys(e).forEach((r) => {
        hl(e[r]) && hl(t[r]) ? (n[r] = ld(t[r], e[r])) : (n[r] = e[r]);
      }),
    n
  );
}
class tn {
  constructor(e = {}) {
    (this.type = "mark"),
      (this.name = "mark"),
      (this.parent = null),
      (this.child = null),
      (this.config = {
        name: this.name,
        defaultOptions: {},
      }),
      (this.config = {
        ...this.config,
        ...e,
      }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = le(
          K(this, "addOptions", {
            name: this.name,
          })
        )),
      (this.storage =
        le(
          K(this, "addStorage", {
            name: this.name,
            options: this.options,
          })
        ) || {});
  }
  static create(e = {}) {
    return new tn(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => ld(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new tn(e);
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = le(
        K(n, "addOptions", {
          name: n.name,
        })
      )),
      (n.storage = le(
        K(n, "addStorage", {
          name: n.name,
          options: n.options,
        })
      )),
      n
    );
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state,
      o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const s = o.marks();
      if (!!!s.find((u) => (u == null ? void 0 : u.type.name) === n.name))
        return !1;
      const l = s.find((u) => (u == null ? void 0 : u.type.name) === n.name);
      return (
        l && r.removeStoredMark(l),
        r.insertText(" ", o.pos),
        e.view.dispatch(r),
        !0
      );
    }
    return !1;
  }
}
function hT(t) {
  return typeof t == "number";
}
class i0 {
  constructor(e) {
    (this.find = e.find), (this.handler = e.handler);
  }
}
const mT = (t, e, n) => {
  if (o0(e)) return [...t.matchAll(e)];
  const r = e(t, n);
  return r
    ? r.map((o) => {
        const i = [o.text];
        return (
          (i.index = o.index),
          (i.input = t),
          (i.data = o.data),
          o.replaceWith &&
            (o.text.includes(o.replaceWith) ||
              console.warn(
                '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
              ),
            i.push(o.replaceWith)),
          i
        );
      })
    : [];
};
function gT(t) {
  const {
      editor: e,
      state: n,
      from: r,
      to: o,
      rule: i,
      pasteEvent: s,
      dropEvent: a,
    } = t,
    {
      commands: l,
      chain: u,
      can: c,
    } = new id({
      editor: e,
      state: n,
    }),
    d = [];
  return (
    n.doc.nodesBetween(r, o, (p, h) => {
      if (!p.isTextblock || p.type.spec.code) return;
      const m = Math.max(r, h),
        g = Math.min(o, h + p.content.size),
        b = p.textBetween(m - h, g - h, void 0, "");
      mT(b, i.find, s).forEach((v) => {
        if (v.index === void 0) return;
        const y = m + v.index + 1,
          w = y + v[0].length,
          x = {
            from: n.tr.mapping.map(y),
            to: n.tr.mapping.map(w),
          },
          M = i.handler({
            state: n,
            range: x,
            match: v,
            commands: l,
            chain: u,
            can: c,
            pasteEvent: s,
            dropEvent: a,
          });
        d.push(M);
      });
    }),
    d.every((p) => p !== null)
  );
}
let ml = null;
const bT = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer(),
  });
  return (
    (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t),
    n
  );
};
function yT(t) {
  const { editor: e, rules: n } = t;
  let r = null,
    o = !1,
    i = !1,
    s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
    a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: c, from: d, to: f, rule: p, pasteEvt: h }) => {
    const m = c.tr,
      g = od({
        state: c,
        transaction: m,
      });
    if (
      !(
        !gT({
          editor: e,
          state: g,
          from: Math.max(d - 1, 0),
          to: f.b - 1,
          rule: p,
          pasteEvent: h,
          dropEvent: a,
        }) || !m.steps.length
      )
    ) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return (
        (s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null),
        m
      );
    }
  };
  return n.map(
    (c) =>
      new be({
        // we register a global drag handler to track the current drag source element
        view(d) {
          const f = (h) => {
              var m;
              (r =
                !((m = d.dom.parentElement) === null || m === void 0) &&
                m.contains(h.target)
                  ? d.dom.parentElement
                  : null),
                r && (ml = e);
            },
            p = () => {
              ml && (ml = null);
            };
          return (
            window.addEventListener("dragstart", f),
            window.addEventListener("dragend", p),
            {
              destroy() {
                window.removeEventListener("dragstart", f),
                  window.removeEventListener("dragend", p);
              },
            }
          );
        },
        props: {
          handleDOMEvents: {
            drop: (d, f) => {
              if (((i = r === d.dom.parentElement), (a = f), !i)) {
                const p = ml;
                p &&
                  setTimeout(() => {
                    const h = p.state.selection;
                    h && p.commands.deleteRange({ from: h.from, to: h.to });
                  }, 10);
              }
              return !1;
            },
            paste: (d, f) => {
              var p;
              const h =
                (p = f.clipboardData) === null || p === void 0
                  ? void 0
                  : p.getData("text/html");
              return (
                (s = f), (o = !!(h != null && h.includes("data-pm-slice"))), !1
              );
            },
          },
        },
        appendTransaction: (d, f, p) => {
          const h = d[0],
            m = h.getMeta("uiEvent") === "paste" && !o,
            g = h.getMeta("uiEvent") === "drop" && !i,
            b = h.getMeta("applyPasteRules"),
            _ = !!b;
          if (!m && !g && !_) return;
          if (_) {
            let { text: w } = b;
            typeof w == "string" ? (w = w) : (w = ad($.from(w), p.schema));
            const { from: x } = b,
              M = x + w.length,
              N = bT(w);
            return l({
              rule: c,
              state: p,
              from: x,
              to: { b: M },
              pasteEvt: N,
            });
          }
          const v = f.doc.content.findDiffStart(p.doc.content),
            y = f.doc.content.findDiffEnd(p.doc.content);
          if (!(!hT(v) || !y || v === y.b))
            return l({
              rule: c,
              state: p,
              from: v,
              to: y,
              pasteEvt: s,
            });
        },
      })
  );
}
function vT(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class Ko {
  constructor(e, n) {
    (this.splittableMarks = []),
      (this.editor = n),
      (this.extensions = Ko.resolve(e)),
      (this.schema = O_(this.extensions, n)),
      this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = Ko.sort(Ko.flatten(e)),
      r = vT(n.map((o) => o.name));
    return (
      r.length &&
        console.warn(
          `[tiptap warn]: Duplicate extension names found: [${r
            .map((o) => `'${o}'`)
            .join(", ")}]. This can lead to issues.`
        ),
      n
    );
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e
      .map((n) => {
        const r = {
            name: n.name,
            options: n.options,
            storage: n.storage,
          },
          o = K(n, "addExtensions", r);
        return o ? [n, ...this.flatten(o())] : n;
      })
      .flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, o) => {
      const i = K(r, "priority") || 100,
        s = K(o, "priority") || 100;
      return i > s ? -1 : i < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
          name: n.name,
          options: n.options,
          storage: n.storage,
          editor: this.editor,
          type: uf(n.name, this.schema),
        },
        o = K(n, "addCommands", r);
      return o
        ? {
            ...e,
            ...o(),
          }
        : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this,
      n = Ko.sort([...this.extensions].reverse()),
      r = [],
      o = [],
      i = n
        .map((s) => {
          const a = {
              name: s.name,
              options: s.options,
              storage: s.storage,
              editor: e,
              type: uf(s.name, this.schema),
            },
            l = [],
            u = K(s, "addKeyboardShortcuts", a);
          let c = {};
          if (
            (s.type === "mark" &&
              K(s, "exitable", a) &&
              (c.ArrowRight = () => tn.handleExit({ editor: e, mark: s })),
            u)
          ) {
            const m = Object.fromEntries(
              Object.entries(u()).map(([g, b]) => [g, () => b({ editor: e })])
            );
            c = { ...c, ...m };
          }
          const d = PC(c);
          l.push(d);
          const f = K(s, "addInputRules", a);
          Dg(s, e.options.enableInputRules) && f && r.push(...f());
          const p = K(s, "addPasteRules", a);
          Dg(s, e.options.enablePasteRules) && p && o.push(...p());
          const h = K(s, "addProseMirrorPlugins", a);
          if (h) {
            const m = h();
            l.push(...m);
          }
          return l;
        })
        .flat();
    return [
      fT({
        editor: e,
        rules: r,
      }),
      ...yT({
        editor: e,
        rules: o,
      }),
      ...i,
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return M_(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this,
      { nodeExtensions: n } = sd(this.extensions);
    return Object.fromEntries(
      n
        .filter((r) => !!K(r, "addNodeView"))
        .map((r) => {
          const o = this.attributes.filter((l) => l.type === r.name),
            i = {
              name: r.name,
              options: r.options,
              storage: r.storage,
              editor: e,
              type: lt(r.name, this.schema),
            },
            s = K(r, "addNodeView", i);
          if (!s) return [];
          const a = (l, u, c, d, f) => {
            const p = Np(l, o);
            return s()({
              // pass-through
              node: l,
              view: u,
              getPos: c,
              decorations: d,
              innerDecorations: f,
              // tiptap-specific
              editor: e,
              extension: r,
              HTMLAttributes: p,
            });
          };
          return [r.name, a];
        })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: uf(e.name, this.schema),
      };
      e.type === "mark" &&
        (!((n = le(K(e, "keepOnSplit", r))) !== null && n !== void 0) || n) &&
        this.splittableMarks.push(e.name);
      const o = K(e, "onBeforeCreate", r),
        i = K(e, "onCreate", r),
        s = K(e, "onUpdate", r),
        a = K(e, "onSelectionUpdate", r),
        l = K(e, "onTransaction", r),
        u = K(e, "onFocus", r),
        c = K(e, "onBlur", r),
        d = K(e, "onDestroy", r);
      o && this.editor.on("beforeCreate", o),
        i && this.editor.on("create", i),
        s && this.editor.on("update", s),
        a && this.editor.on("selectionUpdate", a),
        l && this.editor.on("transaction", l),
        u && this.editor.on("focus", u),
        c && this.editor.on("blur", c),
        d && this.editor.on("destroy", d);
    });
  }
}
class Ne {
  constructor(e = {}) {
    (this.type = "extension"),
      (this.name = "extension"),
      (this.parent = null),
      (this.child = null),
      (this.config = {
        name: this.name,
        defaultOptions: {},
      }),
      (this.config = {
        ...this.config,
        ...e,
      }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = le(
          K(this, "addOptions", {
            name: this.name,
          })
        )),
      (this.storage =
        le(
          K(this, "addStorage", {
            name: this.name,
            options: this.options,
          })
        ) || {});
  }
  static create(e = {}) {
    return new Ne(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => ld(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new Ne({ ...this.config, ...e });
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = le(
        K(n, "addOptions", {
          name: n.name,
        })
      )),
      (n.storage = le(
        K(n, "addStorage", {
          name: n.name,
          options: n.options,
        })
      )),
      n
    );
  }
}
function D_(t, e, n) {
  const { from: r, to: o } = e,
    {
      blockSeparator: i = `

`,
      textSerializers: s = {},
    } = n || {};
  let a = "";
  return (
    t.nodesBetween(r, o, (l, u, c, d) => {
      var f;
      l.isBlock && u > r && (a += i);
      const p = s == null ? void 0 : s[l.type.name];
      if (p)
        return (
          c &&
            (a += p({
              node: l,
              pos: u,
              parent: c,
              index: d,
              range: e,
            })),
          !1
        );
      l.isText &&
        (a +=
          (f = l == null ? void 0 : l.text) === null || f === void 0
            ? void 0
            : f.slice(Math.max(r, u) - u, o - u));
    }),
    a
  );
}
function ud(t) {
  return Object.fromEntries(
    Object.entries(t.nodes)
      .filter(([, e]) => e.spec.toText)
      .map(([e, n]) => [e, n.spec.toText])
  );
}
const N_ = Ne.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return {
        blockSeparator: void 0,
      };
    },
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor: t } = this,
                { state: e, schema: n } = t,
                { doc: r, selection: o } = e,
                { ranges: i } = o,
                s = Math.min(...i.map((c) => c.$from.pos)),
                a = Math.max(...i.map((c) => c.$to.pos)),
                l = ud(n);
              return D_(
                r,
                { from: s, to: a },
                {
                  ...(this.options.blockSeparator !== void 0
                    ? { blockSeparator: this.options.blockSeparator }
                    : {}),
                  textSerializers: l,
                }
              );
            },
          },
        }),
      ];
    },
  }),
  _T =
    () =>
    ({ editor: t, view: e }) => (
      requestAnimationFrame(() => {
        var n;
        t.isDestroyed ||
          (e.dom.blur(),
          (n = window == null ? void 0 : window.getSelection()) === null ||
            n === void 0 ||
            n.removeAllRanges());
      }),
      !0
    ),
  xT =
    (t = !1) =>
    ({ commands: e }) =>
      e.setContent("", t),
  kT =
    () =>
    ({ state: t, tr: e, dispatch: n }) => {
      const { selection: r } = e,
        { ranges: o } = r;
      return (
        n &&
          o.forEach(({ $from: i, $to: s }) => {
            t.doc.nodesBetween(i.pos, s.pos, (a, l) => {
              if (a.type.isText) return;
              const { doc: u, mapping: c } = e,
                d = u.resolve(c.map(l)),
                f = u.resolve(c.map(l + a.nodeSize)),
                p = d.blockRange(f);
              if (!p) return;
              const h = ns(p);
              if (a.type.isTextblock) {
                const { defaultType: m } = d.parent.contentMatchAt(d.index());
                e.setNodeMarkup(p.start, m);
              }
              (h || h === 0) && e.lift(p, h);
            });
          }),
        !0
      );
    },
  wT = (t) => (e) => t(e),
  CT =
    () =>
    ({ state: t, dispatch: e }) =>
      Zy(t, e),
  AT =
    (t, e) =>
    ({ editor: n, tr: r }) => {
      const { state: o } = n,
        i = o.doc.slice(t.from, t.to);
      r.deleteRange(t.from, t.to);
      const s = r.mapping.map(e);
      return (
        r.insert(s, i.content), r.setSelection(new q(r.doc.resolve(s - 1))), !0
      );
    },
  ST =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        r = n.$anchor.node();
      if (r.content.size > 0) return !1;
      const o = t.selection.$anchor;
      for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
          if (e) {
            const a = o.before(i),
              l = o.after(i);
            t.delete(a, l).scrollIntoView();
          }
          return !0;
        }
      return !1;
    },
  ET =
    (t) =>
    ({ tr: e, state: n, dispatch: r }) => {
      const o = lt(t, n.schema),
        i = e.selection.$anchor;
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o) {
          if (r) {
            const l = i.before(s),
              u = i.after(s);
            e.delete(l, u).scrollIntoView();
          }
          return !0;
        }
      return !1;
    },
  MT =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      const { from: r, to: o } = t;
      return n && e.delete(r, o), !0;
    },
  TT =
    () =>
    ({ state: t, dispatch: e }) =>
      Rh(t, e),
  OT =
    () =>
    ({ commands: t }) =>
      t.keyboardShortcut("Enter"),
  DT =
    () =>
    ({ state: t, dispatch: e }) =>
      Xy(t, e);
function Su(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length
    ? r.every((o) =>
        n.strict ? e[o] === t[o] : o0(e[o]) ? e[o].test(t[o]) : e[o] === t[o]
      )
    : !0;
}
function L_(t, e, n = {}) {
  return t.find(
    (r) =>
      r.type === e &&
      Su(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
        n
      )
  );
}
function Ng(t, e, n = {}) {
  return !!L_(t, e, n);
}
function s0(t, e, n) {
  var r;
  if (!t || !e) return;
  let o = t.parent.childAfter(t.parentOffset);
  if (
    ((!o.node || !o.node.marks.some((c) => c.type === e)) &&
      (o = t.parent.childBefore(t.parentOffset)),
    !o.node ||
      !o.node.marks.some((c) => c.type === e) ||
      ((n =
        n ||
        ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs)),
      !L_([...o.node.marks], e, n)))
  )
    return;
  let s = o.index,
    a = t.start() + o.offset,
    l = s + 1,
    u = a + o.node.nodeSize;
  for (; s > 0 && Ng([...t.parent.child(s - 1).marks], e, n); )
    (s -= 1), (a -= t.parent.child(s).nodeSize);
  for (; l < t.parent.childCount && Ng([...t.parent.child(l).marks], e, n); )
    (u += t.parent.child(l).nodeSize), (l += 1);
  return {
    from: a,
    to: u,
  };
}
function No(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(
        `There is no mark type named '${t}'. Maybe you forgot to add the extension?`
      );
    return e.marks[t];
  }
  return t;
}
const NT =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const i = No(t, r.schema),
        { doc: s, selection: a } = n,
        { $from: l, from: u, to: c } = a;
      if (o) {
        const d = s0(l, i, e);
        if (d && d.from <= u && d.to >= c) {
          const f = q.create(s, d.from, d.to);
          n.setSelection(f);
        }
      }
      return !0;
    },
  LT = (t) => (e) => {
    const n = typeof t == "function" ? t(e) : t;
    for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
    return !1;
  };
function Ia(t) {
  return t instanceof q;
}
function Hr(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function R_(t, e = null) {
  if (!e) return null;
  const n = ee.atStart(t),
    r = ee.atEnd(t);
  if (e === "start" || e === !0) return n;
  if (e === "end") return r;
  const o = n.from,
    i = r.to;
  return e === "all"
    ? q.create(t, Hr(0, o, i), Hr(t.content.size, o, i))
    : q.create(t, Hr(e, o, i), Hr(e, o, i));
}
const RT =
    (t = null, e = {}) =>
    ({ editor: n, view: r, tr: o, dispatch: i }) => {
      e = {
        scrollIntoView: !0,
        ...e,
      };
      const s = () => {
        r.dom.focus(),
          requestAnimationFrame(() => {
            n.isDestroyed ||
              (r.focus(),
              e != null && e.scrollIntoView && n.commands.scrollIntoView());
          });
      };
      if ((r.hasFocus() && t === null) || t === !1) return !0;
      if (i && t === null && !Ia(n.state.selection)) return s(), !0;
      const a = R_(o.doc, t) || n.state.selection,
        l = n.state.selection.eq(a);
      return (
        i &&
          (l || o.setSelection(a),
          l && o.storedMarks && o.setStoredMarks(o.storedMarks),
          s()),
        !0
      );
    },
  IT = (t, e) => (n) => t.every((r, o) => e(r, { ...n, index: o })),
  PT =
    (t, e) =>
    ({ tr: n, commands: r }) =>
      r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
  I_ = (t) => {
    const e = t.childNodes;
    for (let n = e.length - 1; n >= 0; n -= 1) {
      const r = e[n];
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
        ? t.removeChild(r)
        : r.nodeType === 1 && I_(r);
    }
    return t;
  };
function ys(t) {
  const e = `<body>${t}</body>`,
    n = new window.DOMParser().parseFromString(e, "text/html").body;
  return I_(n);
}
function Eu(t, e, n) {
  if (t instanceof qn || t instanceof $) return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n,
  };
  const r = typeof t == "object" && t !== null,
    o = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return $.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return (
        console.warn(
          "[tiptap warn]: Invalid content.",
          "Passed value:",
          t,
          "Error:",
          i
        ),
        Eu("", e, n)
      );
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1,
        a = "";
      const l = new Uc({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (
                  (s = !0), (a = typeof u == "string" ? u : u.outerHTML), null
                ),
              },
            ],
          },
        }),
      });
      if (
        (n.slice
          ? zr.fromSchema(l).parseSlice(ys(t), n.parseOptions)
          : zr.fromSchema(l).parse(ys(t), n.parseOptions),
        n.errorOnInvalidContent && s)
      )
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`),
        });
    }
    const i = zr.fromSchema(e);
    return n.slice
      ? i.parseSlice(ys(t), n.parseOptions).content
      : i.parse(ys(t), n.parseOptions);
  }
  return Eu("", e, n);
}
function $T(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e) return;
  const o = t.steps[r];
  if (!(o instanceof pt || o instanceof bt)) return;
  const i = t.mapping.maps[r];
  let s = 0;
  i.forEach((a, l, u, c) => {
    s === 0 && (s = c);
  }),
    t.setSelection(ee.near(t.doc.resolve(s), n));
}
const BT = (t) => !("type" in t),
  HT =
    (t, e, n) =>
    ({ tr: r, dispatch: o, editor: i }) => {
      var s;
      if (o) {
        n = {
          parseOptions: i.options.parseOptions,
          updateSelection: !0,
          applyInputRules: !1,
          applyPasteRules: !1,
          ...n,
        };
        let a;
        try {
          a = Eu(e, i.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...n.parseOptions,
            },
            errorOnInvalidContent:
              (s = n.errorOnInvalidContent) !== null && s !== void 0
                ? s
                : i.options.enableContentCheck,
          });
        } catch (h) {
          return (
            i.emit("contentError", {
              editor: i,
              error: h,
              disableCollaboration: () => {
                i.storage.collaboration &&
                  (i.storage.collaboration.isDisabled = !0);
              },
            }),
            !1
          );
        }
        let { from: l, to: u } =
            typeof t == "number"
              ? { from: t, to: t }
              : { from: t.from, to: t.to },
          c = !0,
          d = !0;
        if (
          ((BT(a) ? a : [a]).forEach((h) => {
            h.check(),
              (c = c ? h.isText && h.marks.length === 0 : !1),
              (d = d ? h.isBlock : !1);
          }),
          l === u && d)
        ) {
          const { parent: h } = r.doc.resolve(l);
          h.isTextblock &&
            !h.type.spec.code &&
            !h.childCount &&
            ((l -= 1), (u += 1));
        }
        let p;
        if (c) {
          if (Array.isArray(e)) p = e.map((h) => h.text || "").join("");
          else if (e instanceof $) {
            let h = "";
            e.forEach((m) => {
              m.text && (h += m.text);
            }),
              (p = h);
          } else typeof e == "object" && e && e.text ? (p = e.text) : (p = e);
          r.insertText(p, l, u);
        } else (p = a), r.replaceWith(l, u, p);
        n.updateSelection && $T(r, r.steps.length - 1, -1),
          n.applyInputRules &&
            r.setMeta("applyInputRules", { from: l, text: p }),
          n.applyPasteRules &&
            r.setMeta("applyPasteRules", { from: l, text: p });
      }
      return !0;
    },
  FT =
    () =>
    ({ state: t, dispatch: e }) =>
      ap(t, e),
  zT =
    () =>
    ({ state: t, dispatch: e }) =>
      vC(t, e),
  VT =
    () =>
    ({ state: t, dispatch: e }) =>
      jy(t, e),
  UT =
    () =>
    ({ state: t, dispatch: e }) =>
      Gy(t, e),
  jT =
    () =>
    ({ state: t, dispatch: e, tr: n }) => {
      try {
        const r = Wc(t.doc, t.selection.$from.pos, -1);
        return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
      } catch {
        return !1;
      }
    },
  WT =
    () =>
    ({ state: t, dispatch: e, tr: n }) => {
      try {
        const r = Wc(t.doc, t.selection.$from.pos, 1);
        return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
      } catch {
        return !1;
      }
    },
  qT =
    () =>
    ({ state: t, dispatch: e }) =>
      bC(t, e),
  KT =
    () =>
    ({ state: t, dispatch: e }) =>
      yC(t, e);
function a0() {
  return (
    [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod",
    ].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document)
  );
}
function P_() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function GT(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l)) s = !0;
    else if (/^a(lt)?$/i.test(l)) r = !0;
    else if (/^(c|ctrl|control)$/i.test(l)) o = !0;
    else if (/^s(hift)?$/i.test(l)) i = !0;
    else if (/^mod$/i.test(l)) a0() || P_() ? (s = !0) : (o = !0);
    else throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return (
    r && (n = `Alt-${n}`),
    o && (n = `Ctrl-${n}`),
    s && (n = `Meta-${n}`),
    i && (n = `Shift-${n}`),
    n
  );
}
const JT =
  (t) =>
  ({ editor: e, view: n, tr: r, dispatch: o }) => {
    const i = GT(t).split(/-(?!$)/),
      s = i.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)),
      a = new KeyboardEvent("keydown", {
        key: s === "Space" ? " " : s,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: !0,
        cancelable: !0,
      }),
      l = e.captureTransaction(() => {
        n.someProp("handleKeyDown", (u) => u(n, a));
      });
    return (
      l == null ||
        l.steps.forEach((u) => {
          const c = u.map(r.mapping);
          c && o && r.maybeStep(c);
        }),
      !0
    );
  };
function Sn(t, e, n = {}) {
  const { from: r, to: o, empty: i } = t.selection,
    s = e ? lt(e, t.schema) : null,
    a = [];
  t.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText) return;
    const p = Math.max(r, f),
      h = Math.min(o, f + d.nodeSize);
    a.push({
      node: d,
      from: p,
      to: h,
    });
  });
  const l = o - r,
    u = a
      .filter((d) => (s ? s.name === d.node.type.name : !0))
      .filter((d) => Su(d.node.attrs, n, { strict: !1 }));
  return i ? !!u.length : u.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
const YT =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = lt(t, n.schema);
      return Sn(n, o, e) ? lp(n, r) : !1;
    },
  XT =
    () =>
    ({ state: t, dispatch: e }) =>
      Qy(t, e),
  ZT =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = lt(t, e.schema);
      return lM(r)(e, n);
    },
  QT =
    () =>
    ({ state: t, dispatch: e }) =>
      Yy(t, e);
function cd(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Lg(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce(
    (r, o) => (n.includes(o) || (r[o] = t[o]), r),
    {}
  );
}
const eO =
    (t, e) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        s = null;
      const a = cd(typeof t == "string" ? t : t.name, r.schema);
      return a
        ? (a === "node" && (i = lt(t, r.schema)),
          a === "mark" && (s = No(t, r.schema)),
          o &&
            n.selection.ranges.forEach((l) => {
              r.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
                i && i === u.type && n.setNodeMarkup(c, void 0, Lg(u.attrs, e)),
                  s &&
                    u.marks.length &&
                    u.marks.forEach((d) => {
                      s === d.type &&
                        n.addMark(c, c + u.nodeSize, s.create(Lg(d.attrs, e)));
                    });
              });
            }),
          !0)
        : !1;
    },
  tO =
    () =>
    ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
  nO =
    () =>
    ({ tr: t, dispatch: e }) => {
      if (e) {
        const n = new $t(t.doc);
        t.setSelection(n);
      }
      return !0;
    },
  rO =
    () =>
    ({ state: t, dispatch: e }) =>
      qy(t, e),
  oO =
    () =>
    ({ state: t, dispatch: e }) =>
      Jy(t, e),
  iO =
    () =>
    ({ state: t, dispatch: e }) =>
      up(t, e),
  sO =
    () =>
    ({ state: t, dispatch: e }) =>
      ov(t, e),
  aO =
    () =>
    ({ state: t, dispatch: e }) =>
      rv(t, e);
function Lp(t, e, n = {}, r = {}) {
  return Eu(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent,
  });
}
const lO =
  (t, e = !1, n = {}, r = {}) =>
  ({ editor: o, tr: i, dispatch: s, commands: a }) => {
    var l, u;
    const { doc: c } = i;
    if (n.preserveWhitespace !== "full") {
      const d = Lp(t, o.schema, n, {
        errorOnInvalidContent:
          (l = r.errorOnInvalidContent) !== null && l !== void 0
            ? l
            : o.options.enableContentCheck,
      });
      return (
        s && i.replaceWith(0, c.content.size, d).setMeta("preventUpdate", !e),
        !0
      );
    }
    return (
      s && i.setMeta("preventUpdate", !e),
      a.insertContentAt({ from: 0, to: c.content.size }, t, {
        parseOptions: n,
        errorOnInvalidContent:
          (u = r.errorOnInvalidContent) !== null && u !== void 0
            ? u
            : o.options.enableContentCheck,
      })
    );
  };
function $_(t, e) {
  const n = No(e, t.schema),
    { from: r, to: o, empty: i } = t.selection,
    s = [];
  i
    ? (t.storedMarks && s.push(...t.storedMarks),
      s.push(...t.selection.$head.marks()))
    : t.doc.nodesBetween(r, o, (l) => {
        s.push(...l.marks);
      });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function uO(t, e) {
  const n = new Nh(t);
  return (
    e.forEach((r) => {
      r.steps.forEach((o) => {
        n.step(o);
      });
    }),
    n
  );
}
function cO(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs()) return n;
  }
  return null;
}
function WV(t, e) {
  const n = [];
  return (
    t.descendants((r, o) => {
      e(r) &&
        n.push({
          node: r,
          pos: o,
        });
    }),
    n
  );
}
function dO(t, e, n) {
  const r = [];
  return (
    t.nodesBetween(e.from, e.to, (o, i) => {
      n(o) &&
        r.push({
          node: o,
          pos: i,
        });
    }),
    r
  );
}
function B_(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r,
      };
  }
}
function On(t) {
  return (e) => B_(e.$from, t);
}
function l0(t, e) {
  const n = Ko.resolve(t);
  return O_(n, e);
}
function qV(t, e) {
  const n = l0(e),
    r = qn.fromJSON(n, t);
  return ad(r.content, n);
}
function KV(t, e) {
  const n = l0(e),
    r = ys(t);
  return zr.fromSchema(n).parse(r).toJSON();
}
function u0(t, e) {
  const n = {
    from: 0,
    to: t.content.size,
  };
  return D_(t, n, e);
}
function GV(t, e, n) {
  const {
      blockSeparator: r = `

`,
      textSerializers: o = {},
    } = n || {},
    i = l0(e),
    s = qn.fromJSON(i, t);
  return u0(s, {
    blockSeparator: r,
    textSerializers: {
      ...ud(i),
      ...o,
    },
  });
}
function fO(t, e) {
  const n = lt(e, t.schema),
    { from: r, to: o } = t.selection,
    i = [];
  t.doc.nodesBetween(r, o, (a) => {
    i.push(a);
  });
  const s = i.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function H_(t, e) {
  const n = cd(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? fO(t, e) : n === "mark" ? $_(t, e) : {};
}
function pO(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const o = e(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0);
  });
}
function hO(t) {
  const e = pO(t);
  return e.length === 1
    ? e
    : e.filter(
        (n, r) =>
          !e
            .filter((i, s) => s !== r)
            .some(
              (i) =>
                n.oldRange.from >= i.oldRange.from &&
                n.oldRange.to <= i.oldRange.to &&
                n.newRange.from >= i.newRange.from &&
                n.newRange.to <= i.newRange.to
            )
      );
}
function mO(t) {
  const { mapping: e, steps: n } = t,
    r = [];
  return (
    e.maps.forEach((o, i) => {
      const s = [];
      if (o.ranges.length)
        o.forEach((a, l) => {
          s.push({ from: a, to: l });
        });
      else {
        const { from: a, to: l } = n[i];
        if (a === void 0 || l === void 0) return;
        s.push({ from: a, to: l });
      }
      s.forEach(({ from: a, to: l }) => {
        const u = e.slice(i).map(a, -1),
          c = e.slice(i).map(l),
          d = e.invert().map(u, -1),
          f = e.invert().map(c);
        r.push({
          oldRange: {
            from: d,
            to: f,
          },
          newRange: {
            from: u,
            to: c,
          },
        });
      });
    }),
    hO(r)
  );
}
function gO(t, e = 0) {
  const r = t.type === t.type.schema.topNodeType ? 0 : 1,
    o = e,
    i = o + t.nodeSize,
    s = t.marks.map((u) => {
      const c = {
        type: u.type.name,
      };
      return Object.keys(u.attrs).length && (c.attrs = { ...u.attrs }), c;
    }),
    a = { ...t.attrs },
    l = {
      type: t.type.name,
      from: o,
      to: i,
    };
  return (
    Object.keys(a).length && (l.attrs = a),
    s.length && (l.marks = s),
    t.content.childCount &&
      ((l.content = []),
      t.forEach((u, c) => {
        var d;
        (d = l.content) === null || d === void 0 || d.push(gO(u, e + c + r));
      })),
    t.text && (l.text = t.text),
    l
  );
}
function c0(t, e, n) {
  const r = [];
  return (
    t === e
      ? n
          .resolve(t)
          .marks()
          .forEach((o) => {
            const i = n.resolve(t),
              s = s0(i, o.type);
            s &&
              r.push({
                mark: o,
                ...s,
              });
          })
      : n.nodesBetween(t, e, (o, i) => {
          !o ||
            (o == null ? void 0 : o.nodeSize) === void 0 ||
            r.push(
              ...o.marks.map((s) => ({
                from: i,
                to: i + o.nodeSize,
                mark: s,
              }))
            );
        }),
    r
  );
}
const bO = (t, e, n, r = 20) => {
  const o = t.doc.resolve(n);
  let i = r,
    s = null;
  for (; i > 0 && s === null; ) {
    const a = o.node(i);
    (a == null ? void 0 : a.type.name) === e ? (s = a) : (i -= 1);
  }
  return [s, i];
};
function ql(t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = t.find((i) => i.type === e && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
function Rp(t, e, n = {}) {
  const { empty: r, ranges: o } = t.selection,
    i = e ? No(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks())
      .filter((d) => (i ? i.name === d.type.name : !0))
      .find((d) => Su(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (
    (o.forEach(({ $from: d, $to: f }) => {
      const p = d.pos,
        h = f.pos;
      t.doc.nodesBetween(p, h, (m, g) => {
        if (!m.isText && !m.marks.length) return;
        const b = Math.max(p, g),
          _ = Math.min(h, g + m.nodeSize),
          v = _ - b;
        (s += v),
          a.push(
            ...m.marks.map((y) => ({
              mark: y,
              from: b,
              to: _,
            }))
          );
      });
    }),
    s === 0)
  )
    return !1;
  const l = a
      .filter((d) => (i ? i.name === d.mark.type.name : !0))
      .filter((d) => Su(d.mark.attrs, n, { strict: !1 }))
      .reduce((d, f) => d + f.to - f.from, 0),
    u = a
      .filter((d) => (i ? d.mark.type !== i && d.mark.type.excludes(i) : !0))
      .reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + u : l) >= s;
}
function Jt(t, e, n = {}) {
  if (!e) return Sn(t, null, n) || Rp(t, null, n);
  const r = cd(e, t.schema);
  return r === "node" ? Sn(t, e, n) : r === "mark" ? Rp(t, e, n) : !1;
}
const yO = (t, e) => {
    const { $from: n, $to: r, $anchor: o } = t.selection;
    if (e) {
      const i = On((a) => a.type.name === e)(t.selection);
      if (!i) return !1;
      const s = t.doc.resolve(i.pos + 1);
      return o.pos + 1 === s.end();
    }
    return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
  },
  vO = (t) => {
    const { $from: e, $to: n } = t.selection;
    return !(e.parentOffset > 0 || e.pos !== n.pos);
  };
function Ip(t, e) {
  const { nodeExtensions: n } = sd(e),
    r = n.find((s) => s.name === t);
  if (!r) return !1;
  const o = {
      name: r.name,
      options: r.options,
      storage: r.storage,
    },
    i = le(K(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function dd(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak") return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText) return !t.text;
  if (t.isAtom || t.isLeaf) return !1;
  if (t.content.childCount === 0) return !0;
  if (e) {
    let o = !0;
    return (
      t.content.forEach((i) => {
        o !== !1 &&
          (dd(i, { ignoreWhitespace: n, checkChildren: e }) || (o = !1));
      }),
      o
    );
  }
  return !1;
}
function Mu(t) {
  return t instanceof Z;
}
function d0(t, e, n) {
  const o = t.state.doc.content.size,
    i = Hr(e, 0, o),
    s = Hr(n, 0, o),
    a = t.coordsAtPos(i),
    l = t.coordsAtPos(s, -1),
    u = Math.min(a.top, l.top),
    c = Math.max(a.bottom, l.bottom),
    d = Math.min(a.left, l.left),
    f = Math.max(a.right, l.right),
    p = f - d,
    h = c - u,
    b = {
      top: u,
      bottom: c,
      left: d,
      right: f,
      width: p,
      height: h,
      x: d,
      y: u,
    };
  return {
    ...b,
    toJSON: () => b,
  };
}
function F_({
  json: t,
  validMarks: e,
  validNodes: n,
  options: r,
  rewrittenContent: o = [],
}) {
  return (
    t.marks &&
      Array.isArray(t.marks) &&
      (t.marks = t.marks.filter((i) => {
        const s = typeof i == "string" ? i : i.type;
        return e.has(s)
          ? !0
          : (o.push({
              original: JSON.parse(JSON.stringify(i)),
              unsupported: s,
            }),
            !1);
      })),
    t.content &&
      Array.isArray(t.content) &&
      (t.content = t.content
        .map(
          (i) =>
            F_({
              json: i,
              validMarks: e,
              validNodes: n,
              options: r,
              rewrittenContent: o,
            }).json
        )
        .filter((i) => i != null)),
    t.type && !n.has(t.type)
      ? (o.push({
          original: JSON.parse(JSON.stringify(t)),
          unsupported: t.type,
        }),
        t.content &&
        Array.isArray(t.content) &&
        (r == null ? void 0 : r.fallbackToParagraph) !== !1
          ? ((t.type = "paragraph"),
            {
              json: t,
              rewrittenContent: o,
            })
          : {
              json: null,
              rewrittenContent: o,
            })
      : { json: t, rewrittenContent: o }
  );
}
function JV(t, e, n) {
  return F_({
    json: t,
    validNodes: new Set(Object.keys(e.nodes)),
    validMarks: new Set(Object.keys(e.marks)),
    options: n,
  });
}
function _O(t, e, n) {
  var r;
  const { selection: o } = e;
  let i = null;
  if ((Ia(o) && (i = o.$cursor), i)) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : i.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = o;
  return s.some(({ $from: a, $to: l }) => {
    let u =
      a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return (
      t.doc.nodesBetween(a.pos, l.pos, (c, d, f) => {
        if (u) return !1;
        if (c.isInline) {
          const p = !f || f.type.allowsMarkType(n),
            h =
              !!n.isInSet(c.marks) || !c.marks.some((m) => m.type.excludes(n));
          u = p && h;
        }
        return !u;
      }),
      u
    );
  });
}
const xO =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const { selection: i } = n,
        { empty: s, ranges: a } = i,
        l = No(t, r.schema);
      if (o)
        if (s) {
          const u = $_(r, l);
          n.addStoredMark(
            l.create({
              ...u,
              ...e,
            })
          );
        } else
          a.forEach((u) => {
            const c = u.$from.pos,
              d = u.$to.pos;
            r.doc.nodesBetween(c, d, (f, p) => {
              const h = Math.max(p, c),
                m = Math.min(p + f.nodeSize, d);
              f.marks.find((b) => b.type === l)
                ? f.marks.forEach((b) => {
                    l === b.type &&
                      n.addMark(
                        h,
                        m,
                        l.create({
                          ...b.attrs,
                          ...e,
                        })
                      );
                  })
                : n.addMark(h, m, l.create(e));
            });
          });
      return _O(r, n, l);
    },
  kO =
    (t, e) =>
    ({ tr: n }) => (n.setMeta(t, e), !0),
  wO =
    (t, e = {}) =>
    ({ state: n, dispatch: r, chain: o }) => {
      const i = lt(t, n.schema);
      let s;
      return (
        n.selection.$anchor.sameParent(n.selection.$head) &&
          (s = n.selection.$anchor.parent.attrs),
        i.isTextblock
          ? o()
              .command(({ commands: a }) =>
                dp(i, { ...s, ...e })(n) ? !0 : a.clearNodes()
              )
              .command(({ state: a }) => dp(i, { ...s, ...e })(a, r))
              .run()
          : (console.warn(
              '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
            ),
            !1)
      );
    },
  CO =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          o = Hr(t, 0, r.content.size),
          i = Z.create(r, o);
        e.setSelection(i);
      }
      return !0;
    },
  AO =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : t,
          s = q.atStart(r).from,
          a = q.atEnd(r).to,
          l = Hr(o, s, a),
          u = Hr(i, s, a),
          c = q.create(r, l, u);
        e.setSelection(c);
      }
      return !0;
    },
  SO =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = lt(t, e.schema);
      return dM(r)(e, n);
    };
function Rg(t, e) {
  const n =
    t.storedMarks ||
    (t.selection.$to.parentOffset && t.selection.$from.marks());
  if (n) {
    const r = n.filter((o) => (e == null ? void 0 : e.includes(o.type.name)));
    t.tr.ensureMarks(r);
  }
}
const EO =
    ({ keepMarks: t = !0 } = {}) =>
    ({ tr: e, state: n, dispatch: r, editor: o }) => {
      const { selection: i, doc: s } = e,
        { $from: a, $to: l } = i,
        u = o.extensionManager.attributes,
        c = ql(u, a.node().type.name, a.node().attrs);
      if (i instanceof Z && i.node.isBlock)
        return !a.parentOffset || !hr(s, a.pos)
          ? !1
          : (r &&
              (t && Rg(n, o.extensionManager.splittableMarks),
              e.split(a.pos).scrollIntoView()),
            !0);
      if (!a.parent.isBlock) return !1;
      const d = l.parentOffset === l.parent.content.size,
        f =
          a.depth === 0
            ? void 0
            : cO(a.node(-1).contentMatchAt(a.indexAfter(-1)));
      let p =
          d && f
            ? [
                {
                  type: f,
                  attrs: c,
                },
              ]
            : void 0,
        h = hr(e.doc, e.mapping.map(a.pos), 1, p);
      if (
        (!p &&
          !h &&
          hr(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) &&
          ((h = !0),
          (p = f
            ? [
                {
                  type: f,
                  attrs: c,
                },
              ]
            : void 0)),
        r)
      ) {
        if (
          h &&
          (i instanceof q && e.deleteSelection(),
          e.split(e.mapping.map(a.pos), 1, p),
          f && !d && !a.parentOffset && a.parent.type !== f)
        ) {
          const m = e.mapping.map(a.before()),
            g = e.doc.resolve(m);
          a.node(-1).canReplaceWith(g.index(), g.index() + 1, f) &&
            e.setNodeMarkup(e.mapping.map(a.before()), f);
        }
        t && Rg(n, o.extensionManager.splittableMarks), e.scrollIntoView();
      }
      return h;
    },
  MO =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o, editor: i }) => {
      var s;
      const a = lt(t, r.schema),
        { $from: l, $to: u } = r.selection,
        c = r.selection.node;
      if ((c && c.isBlock) || l.depth < 2 || !l.sameParent(u)) return !1;
      const d = l.node(-1);
      if (d.type !== a) return !1;
      const f = i.extensionManager.attributes;
      if (
        l.parent.content.size === 0 &&
        l.node(-1).childCount === l.indexAfter(-1)
      ) {
        if (
          l.depth === 2 ||
          l.node(-3).type !== a ||
          l.index(-2) !== l.node(-2).childCount - 1
        )
          return !1;
        if (o) {
          let b = $.empty;
          const _ = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
          for (let N = l.depth - _; N >= l.depth - 3; N -= 1)
            b = $.from(l.node(N).copy(b));
          const v =
              l.indexAfter(-1) < l.node(-2).childCount
                ? 1
                : l.indexAfter(-2) < l.node(-3).childCount
                ? 2
                : 3,
            y = {
              ...ql(f, l.node().type.name, l.node().attrs),
              ...e,
            },
            w =
              ((s = a.contentMatch.defaultType) === null || s === void 0
                ? void 0
                : s.createAndFill(y)) || void 0;
          b = b.append($.from(a.createAndFill(null, w) || void 0));
          const x = l.before(l.depth - (_ - 1));
          n.replace(x, l.after(-v), new W(b, 4 - _, 0));
          let M = -1;
          n.doc.nodesBetween(x, n.doc.content.size, (N, T) => {
            if (M > -1) return !1;
            N.isTextblock && N.content.size === 0 && (M = T + 1);
          }),
            M > -1 && n.setSelection(q.near(n.doc.resolve(M))),
            n.scrollIntoView();
        }
        return !0;
      }
      const p = u.pos === l.end() ? d.contentMatchAt(0).defaultType : null,
        h = {
          ...ql(f, d.type.name, d.attrs),
          ...e,
        },
        m = {
          ...ql(f, l.node().type.name, l.node().attrs),
          ...e,
        };
      n.delete(l.pos, u.pos);
      const g = p
        ? [
            { type: a, attrs: h },
            { type: p, attrs: m },
          ]
        : [{ type: a, attrs: h }];
      if (!hr(n.doc, l.pos, 2)) return !1;
      if (o) {
        const { selection: b, storedMarks: _ } = r,
          { splittableMarks: v } = i.extensionManager,
          y = _ || (b.$to.parentOffset && b.$from.marks());
        if ((n.split(l.pos, 2, g).scrollIntoView(), !y || !o)) return !0;
        const w = y.filter((x) => v.includes(x.type.name));
        n.ensureMarks(w);
      }
      return !0;
    },
  cf = (t, e) => {
    const n = On((s) => s.type === e)(t.selection);
    if (!n) return !0;
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0) return !0;
    const o = t.doc.nodeAt(r);
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        _r(t.doc, n.pos) &&
        t.join(n.pos),
      !0
    );
  },
  df = (t, e) => {
    const n = On((s) => s.type === e)(t.selection);
    if (!n) return !0;
    const r = t.doc.resolve(n.start).after(n.depth);
    if (r === void 0) return !0;
    const o = t.doc.nodeAt(r);
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        _r(t.doc, r) &&
        t.join(r),
      !0
    );
  },
  TO =
    (t, e, n, r = {}) =>
    ({
      editor: o,
      tr: i,
      state: s,
      dispatch: a,
      chain: l,
      commands: u,
      can: c,
    }) => {
      const { extensions: d, splittableMarks: f } = o.extensionManager,
        p = lt(t, s.schema),
        h = lt(e, s.schema),
        { selection: m, storedMarks: g } = s,
        { $from: b, $to: _ } = m,
        v = b.blockRange(_),
        y = g || (m.$to.parentOffset && m.$from.marks());
      if (!v) return !1;
      const w = On((x) => Ip(x.type.name, d))(m);
      if (v.depth >= 1 && w && v.depth - w.depth <= 1) {
        if (w.node.type === p) return u.liftListItem(h);
        if (Ip(w.node.type.name, d) && p.validContent(w.node.content) && a)
          return l()
            .command(() => (i.setNodeMarkup(w.pos, p), !0))
            .command(() => cf(i, p))
            .command(() => df(i, p))
            .run();
      }
      return !n || !y || !a
        ? l()
            .command(() => (c().wrapInList(p, r) ? !0 : u.clearNodes()))
            .wrapInList(p, r)
            .command(() => cf(i, p))
            .command(() => df(i, p))
            .run()
        : l()
            .command(() => {
              const x = c().wrapInList(p, r),
                M = y.filter((N) => f.includes(N.type.name));
              return i.ensureMarks(M), x ? !0 : u.clearNodes();
            })
            .wrapInList(p, r)
            .command(() => cf(i, p))
            .command(() => df(i, p))
            .run();
    },
  OO =
    (t, e = {}, n = {}) =>
    ({ state: r, commands: o }) => {
      const { extendEmptyMarkRange: i = !1 } = n,
        s = No(t, r.schema);
      return Rp(r, s, e)
        ? o.unsetMark(s, { extendEmptyMarkRange: i })
        : o.setMark(s, e);
    },
  DO =
    (t, e, n = {}) =>
    ({ state: r, commands: o }) => {
      const i = lt(t, r.schema),
        s = lt(e, r.schema),
        a = Sn(r, i, n);
      let l;
      return (
        r.selection.$anchor.sameParent(r.selection.$head) &&
          (l = r.selection.$anchor.parent.attrs),
        a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n })
      );
    },
  NO =
    (t, e = {}) =>
    ({ state: n, commands: r }) => {
      const o = lt(t, n.schema);
      return Sn(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
    },
  LO =
    () =>
    ({ state: t, dispatch: e }) => {
      const n = t.plugins;
      for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        let i;
        if (o.spec.isInputRules && (i = o.getState(t))) {
          if (e) {
            const s = t.tr,
              a = i.transform;
            for (let l = a.steps.length - 1; l >= 0; l -= 1)
              s.step(a.steps[l].invert(a.docs[l]));
            if (i.text) {
              const l = s.doc.resolve(i.from).marks();
              s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
            } else s.delete(i.from, i.to);
          }
          return !0;
        }
      }
      return !1;
    },
  RO =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        { empty: r, ranges: o } = n;
      return (
        r ||
          (e &&
            o.forEach((i) => {
              t.removeMark(i.$from.pos, i.$to.pos);
            })),
        !0
      );
    },
  IO =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      var i;
      const { extendEmptyMarkRange: s = !1 } = e,
        { selection: a } = n,
        l = No(t, r.schema),
        { $from: u, empty: c, ranges: d } = a;
      if (!o) return !0;
      if (c && s) {
        let { from: f, to: p } = a;
        const h =
            (i = u.marks().find((g) => g.type === l)) === null || i === void 0
              ? void 0
              : i.attrs,
          m = s0(u, l, h);
        m && ((f = m.from), (p = m.to)), n.removeMark(f, p, l);
      } else
        d.forEach((f) => {
          n.removeMark(f.$from.pos, f.$to.pos, l);
        });
      return n.removeStoredMark(l), !0;
    },
  PO =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        s = null;
      const a = cd(typeof t == "string" ? t : t.name, r.schema);
      return a
        ? (a === "node" && (i = lt(t, r.schema)),
          a === "mark" && (s = No(t, r.schema)),
          o &&
            n.selection.ranges.forEach((l) => {
              const u = l.$from.pos,
                c = l.$to.pos;
              let d, f, p, h;
              n.selection.empty
                ? r.doc.nodesBetween(u, c, (m, g) => {
                    i &&
                      i === m.type &&
                      ((p = Math.max(g, u)),
                      (h = Math.min(g + m.nodeSize, c)),
                      (d = g),
                      (f = m));
                  })
                : r.doc.nodesBetween(u, c, (m, g) => {
                    g < u &&
                      i &&
                      i === m.type &&
                      ((p = Math.max(g, u)),
                      (h = Math.min(g + m.nodeSize, c)),
                      (d = g),
                      (f = m)),
                      g >= u &&
                        g <= c &&
                        (i &&
                          i === m.type &&
                          n.setNodeMarkup(g, void 0, {
                            ...m.attrs,
                            ...e,
                          }),
                        s &&
                          m.marks.length &&
                          m.marks.forEach((b) => {
                            if (s === b.type) {
                              const _ = Math.max(g, u),
                                v = Math.min(g + m.nodeSize, c);
                              n.addMark(
                                _,
                                v,
                                s.create({
                                  ...b.attrs,
                                  ...e,
                                })
                              );
                            }
                          }));
                  }),
                f &&
                  (d !== void 0 &&
                    n.setNodeMarkup(d, void 0, {
                      ...f.attrs,
                      ...e,
                    }),
                  s &&
                    f.marks.length &&
                    f.marks.forEach((m) => {
                      s === m.type &&
                        n.addMark(
                          p,
                          h,
                          s.create({
                            ...m.attrs,
                            ...e,
                          })
                        );
                    }));
            }),
          !0)
        : !1;
    },
  $O =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = lt(t, n.schema);
      return cp(o, e)(n, r);
    },
  BO =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = lt(t, n.schema);
      return iM(o, e)(n, r);
    };
var HO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: _T,
  clearContent: xT,
  clearNodes: kT,
  command: wT,
  createParagraphNear: CT,
  cut: AT,
  deleteCurrentNode: ST,
  deleteNode: ET,
  deleteRange: MT,
  deleteSelection: TT,
  enter: OT,
  exitCode: DT,
  extendMarkRange: NT,
  first: LT,
  focus: RT,
  forEach: IT,
  insertContent: PT,
  insertContentAt: HT,
  joinBackward: VT,
  joinDown: zT,
  joinForward: UT,
  joinItemBackward: jT,
  joinItemForward: WT,
  joinTextblockBackward: qT,
  joinTextblockForward: KT,
  joinUp: FT,
  keyboardShortcut: JT,
  lift: YT,
  liftEmptyBlock: XT,
  liftListItem: ZT,
  newlineInCode: QT,
  resetAttributes: eO,
  scrollIntoView: tO,
  selectAll: nO,
  selectNodeBackward: rO,
  selectNodeForward: oO,
  selectParentNode: iO,
  selectTextblockEnd: sO,
  selectTextblockStart: aO,
  setContent: lO,
  setMark: xO,
  setMeta: kO,
  setNode: wO,
  setNodeSelection: CO,
  setTextSelection: AO,
  sinkListItem: SO,
  splitBlock: EO,
  splitListItem: MO,
  toggleList: TO,
  toggleMark: OO,
  toggleNode: DO,
  toggleWrap: NO,
  undoInputRule: LO,
  unsetAllMarks: RO,
  unsetMark: IO,
  updateAttributes: PO,
  wrapIn: $O,
  wrapInList: BO,
});
const z_ = Ne.create({
    name: "commands",
    addCommands() {
      return {
        ...HO,
      };
    },
  }),
  V_ = Ne.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("tiptapDrop"),
          props: {
            handleDrop: (t, e, n, r) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: e,
                slice: n,
                moved: r,
              });
            },
          },
        }),
      ];
    },
  }),
  U_ = Ne.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("editable"),
          props: {
            editable: () => this.editor.options.editable,
          },
        }),
      ];
    },
  }),
  j_ = Ne.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor: t } = this;
      return [
        new be({
          key: new ke("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (e, n) => {
                t.isFocused = !0;
                const r = t.state.tr
                  .setMeta("focus", { event: n })
                  .setMeta("addToHistory", !1);
                return e.dispatch(r), !1;
              },
              blur: (e, n) => {
                t.isFocused = !1;
                const r = t.state.tr
                  .setMeta("blur", { event: n })
                  .setMeta("addToHistory", !1);
                return e.dispatch(r), !1;
              },
            },
          },
        }),
      ];
    },
  }),
  W_ = Ne.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const t = () =>
          this.editor.commands.first(({ commands: s }) => [
            () => s.undoInputRule(),
            // maybe convert first text block node to default node
            () =>
              s.command(({ tr: a }) => {
                const { selection: l, doc: u } = a,
                  { empty: c, $anchor: d } = l,
                  { pos: f, parent: p } = d,
                  h = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d,
                  m = h.parent.type.spec.isolating,
                  g = d.pos - d.parentOffset,
                  b =
                    m && h.parent.childCount === 1
                      ? g === d.pos
                      : ee.atStart(u).from === f;
                return !c ||
                  !p.type.isTextblock ||
                  p.textContent.length ||
                  !b ||
                  (b && d.parent.type.name === "paragraph")
                  ? !1
                  : s.clearNodes();
              }),
            () => s.deleteSelection(),
            () => s.joinBackward(),
            () => s.selectNodeBackward(),
          ]),
        e = () =>
          this.editor.commands.first(({ commands: s }) => [
            () => s.deleteSelection(),
            () => s.deleteCurrentNode(),
            () => s.joinForward(),
            () => s.selectNodeForward(),
          ]),
        r = {
          Enter: () =>
            this.editor.commands.first(({ commands: s }) => [
              () => s.newlineInCode(),
              () => s.createParagraphNear(),
              () => s.liftEmptyBlock(),
              () => s.splitBlock(),
            ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: t,
          "Mod-Backspace": t,
          "Shift-Backspace": t,
          Delete: e,
          "Mod-Delete": e,
          "Mod-a": () => this.editor.commands.selectAll(),
        },
        o = {
          ...r,
        },
        i = {
          ...r,
          "Ctrl-h": t,
          "Alt-Backspace": t,
          "Ctrl-d": e,
          "Ctrl-Alt-Backspace": e,
          "Alt-Delete": e,
          "Alt-d": e,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
        };
      return a0() || P_() ? i : o;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
        // with many other commands.
        new be({
          key: new ke("clearDocument"),
          appendTransaction: (t, e, n) => {
            const r = t.some((m) => m.docChanged) && !e.doc.eq(n.doc),
              o = t.some((m) => m.getMeta("preventClearDocument"));
            if (!r || o) return;
            const { empty: i, from: s, to: a } = e.selection,
              l = ee.atStart(e.doc).from,
              u = ee.atEnd(e.doc).to;
            if (i || !(s === l && a === u) || !dd(n.doc)) return;
            const f = n.tr,
              p = od({
                state: n,
                transaction: f,
              }),
              { commands: h } = new id({
                editor: this.editor,
                state: p,
              });
            if ((h.clearNodes(), !!f.steps.length)) return f;
          },
        }),
      ];
    },
  }),
  q_ = Ne.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("tiptapPaste"),
          props: {
            handlePaste: (t, e, n) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: e,
                slice: n,
              });
            },
          },
        }),
      ];
    },
  }),
  K_ = Ne.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("tabindex"),
          props: {
            attributes: () => (this.editor.isEditable ? { tabindex: "0" } : {}),
          },
        }),
      ];
    },
  });
var YV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: N_,
  Commands: z_,
  Drop: V_,
  Editable: U_,
  FocusEvents: j_,
  Keymap: W_,
  Paste: q_,
  Tabindex: K_,
});
class jo {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, o = null) {
    (this.currentNode = null),
      (this.actualDepth = null),
      (this.isBlock = r),
      (this.resolvedPos = e),
      (this.editor = n),
      (this.currentNode = o);
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0
      ? e
      : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from,
      r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(
          `You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
        );
        return;
      }
      (n = this.from + 1), (r = this.to - 1);
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock
      ? this.pos
      : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to,
    };
  }
  get to() {
    return this.isBlock
      ? this.pos + this.size
      : this.resolvedPos.end(this.resolvedPos.depth) +
          (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
      n = this.resolvedPos.doc.resolve(e);
    return new jo(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return (
      e.depth !== this.depth &&
        (e = this.resolvedPos.doc.resolve(this.from - 3)),
      new jo(e, this.editor)
    );
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return (
      e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
      new jo(e, this.editor)
    );
  }
  get children() {
    const e = [];
    return (
      this.node.content.forEach((n, r) => {
        const o = n.isBlock && !n.isTextblock,
          i = n.isAtom && !n.isText,
          s = this.pos + r + (i ? 0 : 1),
          a = this.resolvedPos.doc.resolve(s);
        if (!o && a.depth <= this.depth) return;
        const l = new jo(a, this.editor, o, o ? n : null);
        o && (l.actualDepth = this.depth + 1),
          e.push(new jo(a, this.editor, o, o ? n : null));
      }),
      e
    );
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null,
      o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs,
            s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (i[l] !== n[l]) break;
          }
        } else r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0) return o;
    const i = Object.keys(n);
    return (
      this.children.forEach((s) => {
        (r && o.length > 0) ||
          (s.node.type.name === e &&
            i.every((l) => n[l] === s.node.attrs[l]) &&
            o.push(s),
          !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(e, n, r))));
      }),
      o
    );
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e,
    }),
      this.editor.view.dispatch(n);
  }
}
const FO = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function zO(t, e, n) {
  const r = document.querySelector(
    `style[data-tiptap-style${n ? `-${n}` : ""}]`
  );
  if (r !== null) return r;
  const o = document.createElement("style");
  return (
    e && o.setAttribute("nonce", e),
    o.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
    (o.innerHTML = t),
    document.getElementsByTagName("head")[0].appendChild(o),
    o
  );
}
let VO = class extends aT {
  constructor(e = {}) {
    super(),
      (this.isFocused = !1),
      (this.isInitialized = !1),
      (this.extensionStorage = {}),
      (this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: !0,
        injectNonce: void 0,
        extensions: [],
        autofocus: !1,
        editable: !0,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: !0,
        enablePasteRules: !0,
        enableCoreExtensions: !0,
        enableContentCheck: !1,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: n }) => {
          throw n;
        },
        onPaste: () => null,
        onDrop: () => null,
      }),
      (this.isCapturingTransaction = !1),
      (this.capturedTransaction = null),
      this.setOptions(e),
      this.createExtensionManager(),
      this.createCommandManager(),
      this.createSchema(),
      this.on("beforeCreate", this.options.onBeforeCreate),
      this.emit("beforeCreate", { editor: this }),
      this.on("contentError", this.options.onContentError),
      this.createView(),
      this.injectCSS(),
      this.on("create", this.options.onCreate),
      this.on("update", this.options.onUpdate),
      this.on("selectionUpdate", this.options.onSelectionUpdate),
      this.on("transaction", this.options.onTransaction),
      this.on("focus", this.options.onFocus),
      this.on("blur", this.options.onBlur),
      this.on("destroy", this.options.onDestroy),
      this.on("drop", ({ event: n, slice: r, moved: o }) =>
        this.options.onDrop(n, r, o)
      ),
      this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)),
      window.setTimeout(() => {
        this.isDestroyed ||
          (this.commands.focus(this.options.autofocus),
          this.emit("create", { editor: this }),
          (this.isInitialized = !0));
      }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS &&
      document &&
      (this.css = zO(FO, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    (this.options = {
      ...this.options,
      ...e,
    }),
      !(!this.view || !this.state || this.isDestroyed) &&
        (this.options.editorProps &&
          this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }),
      n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const r = T_(n)
        ? n(e, [...this.state.plugins])
        : [...this.state.plugins, e],
      o = this.state.reconfigure({ plugins: r });
    return this.view.updateState(o), o;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed) return;
    const n = this.state.plugins;
    let r = n;
    if (
      ([].concat(e).forEach((i) => {
        const s = typeof i == "string" ? `${i}$` : i.key;
        r = n.filter((a) => !a.key.startsWith(s));
      }),
      n.length === r.length)
    )
      return;
    const o = this.state.reconfigure({
      plugins: r,
    });
    return this.view.updateState(o), o;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const o = [
      ...(this.options.enableCoreExtensions
        ? [
            U_,
            N_.configure({
              blockSeparator:
                (n =
                  (e = this.options.coreExtensionOptions) === null ||
                  e === void 0
                    ? void 0
                    : e.clipboardTextSerializer) === null || n === void 0
                  ? void 0
                  : n.blockSeparator,
            }),
            z_,
            j_,
            W_,
            K_,
            V_,
            q_,
          ].filter((i) =>
            typeof this.options.enableCoreExtensions == "object"
              ? this.options.enableCoreExtensions[i.name] !== !1
              : !0
          )
        : []),
      ...this.options.extensions,
    ].filter((i) =>
      ["extension", "node", "mark"].includes(i == null ? void 0 : i.type)
    );
    this.extensionManager = new Ko(o, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new id({
      editor: this,
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = Lp(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck,
      });
    } catch (s) {
      if (
        !(s instanceof Error) ||
        ![
          "[tiptap error]: Invalid JSON content",
          "[tiptap error]: Invalid HTML content",
        ].includes(s.message)
      )
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration &&
            (this.storage.collaboration.isDisabled = !0),
            (this.options.extensions = this.options.extensions.filter(
              (a) => a.name !== "collaboration"
            )),
            this.createExtensionManager();
        },
      }),
        (n = Lp(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: !1,
        }));
    }
    const r = R_(n, this.options.autofocus);
    this.view = new mA(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...((e = this.options.editorProps) === null || e === void 0
          ? void 0
          : e.attributes),
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Ri.create({
        doc: n,
        selection: r || void 0,
      }),
    });
    const o = this.state.reconfigure({
      plugins: this.extensionManager.plugins,
    });
    this.view.updateState(o), this.createNodeViews(), this.prependClass();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed ||
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews,
      });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    (this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1);
    const n = this.capturedTransaction;
    return (this.capturedTransaction = null), n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed) return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0
          ? void 0
          : a.step(s);
      });
      return;
    }
    const n = this.state.apply(e),
      r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n,
    }),
      this.view.updateState(n),
      this.emit("transaction", {
        editor: this,
        transaction: e,
      }),
      r &&
        this.emit("selectionUpdate", {
          editor: this,
          transaction: e,
        });
    const o = e.getMeta("focus"),
      i = e.getMeta("blur");
    o &&
      this.emit("focus", {
        editor: this,
        event: o.event,
        transaction: e,
      }),
      i &&
        this.emit("blur", {
          editor: this,
          event: i.event,
          transaction: e,
        }),
      !(!e.docChanged || e.getMeta("preventUpdate")) &&
        this.emit("update", {
          editor: this,
          transaction: e,
        });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return H_(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null,
      o = typeof e == "string" ? n : e;
    return Jt(this.state, r, o);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return ad(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const {
      blockSeparator: n = `

`,
      textSerializers: r = {},
    } = e || {};
    return u0(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...ud(this.schema),
        ...r,
      },
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return dd(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return (
      console.warn(
        '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
      ),
      this.state.doc.content.size - 2
    );
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if ((this.emit("destroy"), this.view)) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelector(e, n)) || null
    );
  }
  $nodes(e, n) {
    var r;
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelectorAll(e, n)) || null
    );
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new jo(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function ci(t) {
  return new Ra({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = le(t.getAttributes, void 0, r);
      if (o === !1 || o === null) return null;
      const { tr: i } = e,
        s = r[r.length - 1],
        a = r[0];
      if (s) {
        const l = a.search(/\S/),
          u = n.from + a.indexOf(s),
          c = u + s.length;
        if (
          c0(n.from, n.to, e.doc)
            .filter((p) =>
              p.mark.type.excluded.find(
                (m) => m === t.type && m !== p.mark.type
              )
            )
            .filter((p) => p.to > u).length
        )
          return null;
        c < n.to && i.delete(c, n.to), u > n.from && i.delete(n.from + l, u);
        const f = n.from + l + s.length;
        i.addMark(n.from + l, f, t.type.create(o || {})),
          i.removeStoredMark(t.type);
      }
    },
  });
}
function Pa(t) {
  return new Ra({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = le(t.getAttributes, void 0, r) || {},
        { tr: i } = e,
        s = n.from;
      let a = n.to;
      const l = t.type.create(o);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let c = s + u;
        c > a ? (c = a) : (a = c + r[1].length);
        const d = r[0][r[0].length - 1];
        i.insertText(d, s + r[0].length - 1), i.replaceWith(c, a, l);
      } else if (r[0]) {
        const u = t.type.isInline ? s : s - 1;
        i.insert(u, t.type.create(o)).delete(
          i.mapping.map(s),
          i.mapping.map(a)
        );
      }
      i.scrollIntoView();
    },
  });
}
function Pp(t) {
  return new Ra({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = e.doc.resolve(n.from),
        i = le(t.getAttributes, void 0, r) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    },
  });
}
function ZV(t) {
  return new Ra({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      let o = t.replace,
        i = n.from;
      const s = n.to;
      if (r[1]) {
        const a = r[0].lastIndexOf(r[1]);
        (o += r[0].slice(a + r[1].length)), (i += a);
        const l = i - s;
        l > 0 && ((o = r[0].slice(a - l, a) + o), (i = s));
      }
      e.tr.insertText(o, i, s);
    },
  });
}
function Gi(t) {
  return new Ra({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: o }) => {
      const i = le(t.getAttributes, void 0, r) || {},
        s = e.tr.delete(n.from, n.to),
        l = s.doc.resolve(n.from).blockRange(),
        u = l && jc(l, t.type, i);
      if (!u) return null;
      if ((s.wrap(l, u), t.keepMarks && t.editor)) {
        const { selection: d, storedMarks: f } = e,
          { splittableMarks: p } = t.editor.extensionManager,
          h = f || (d.$to.parentOffset && d.$from.marks());
        if (h) {
          const m = h.filter((g) => p.includes(g.type.name));
          s.ensureMarks(m);
        }
      }
      if (t.keepAttributes) {
        const d =
          t.type.name === "bulletList" || t.type.name === "orderedList"
            ? "listItem"
            : "taskList";
        o().updateAttributes(d, i).run();
      }
      const c = s.doc.resolve(n.from - 1).nodeBefore;
      c &&
        c.type === t.type &&
        _r(s.doc, n.from - 1) &&
        (!t.joinPredicate || t.joinPredicate(r, c)) &&
        s.join(n.from - 1);
    },
  });
}
let Ze = class $p {
  constructor(e = {}) {
    (this.type = "node"),
      (this.name = "node"),
      (this.parent = null),
      (this.child = null),
      (this.config = {
        name: this.name,
        defaultOptions: {},
      }),
      (this.config = {
        ...this.config,
        ...e,
      }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = le(
          K(this, "addOptions", {
            name: this.name,
          })
        )),
      (this.storage =
        le(
          K(this, "addStorage", {
            name: this.name,
            options: this.options,
          })
        ) || {});
  }
  static create(e = {}) {
    return new $p(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => ld(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new $p(e);
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = le(
        K(n, "addOptions", {
          name: n.name,
        })
      )),
      (n.storage = le(
        K(n, "addStorage", {
          name: n.name,
          options: n.options,
        })
      )),
      n
    );
  }
};
function UO() {
  return (
    navigator.platform === "Android" || /android/i.test(navigator.userAgent)
  );
}
class jO {
  constructor(e, n, r) {
    (this.isDragging = !1),
      (this.component = e),
      (this.editor = n.editor),
      (this.options = {
        stopEvent: null,
        ignoreMutation: null,
        ...r,
      }),
      (this.extension = n.extension),
      (this.node = n.node),
      (this.decorations = n.decorations),
      (this.innerDecorations = n.innerDecorations),
      (this.view = n.view),
      (this.HTMLAttributes = n.HTMLAttributes),
      (this.getPos = n.getPos),
      this.mount();
  }
  mount() {}
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, r, o, i, s, a, l;
    const { view: u } = this.editor,
      c = e.target,
      d =
        c.nodeType === 3
          ? (n = c.parentElement) === null || n === void 0
            ? void 0
            : n.closest("[data-drag-handle]")
          : c.closest("[data-drag-handle]");
    if (
      !this.dom ||
      (!((r = this.contentDOM) === null || r === void 0) && r.contains(c)) ||
      !d
    )
      return;
    let f = 0,
      p = 0;
    if (this.dom !== d) {
      const b = this.dom.getBoundingClientRect(),
        _ = d.getBoundingClientRect(),
        v =
          (o = e.offsetX) !== null && o !== void 0
            ? o
            : (i = e.nativeEvent) === null || i === void 0
            ? void 0
            : i.offsetX,
        y =
          (s = e.offsetY) !== null && s !== void 0
            ? s
            : (a = e.nativeEvent) === null || a === void 0
            ? void 0
            : a.offsetY;
      (f = _.x - b.x + v), (p = _.y - b.y + y);
    }
    (l = e.dataTransfer) === null ||
      l === void 0 ||
      l.setDragImage(this.dom, f, p);
    const h = this.getPos();
    if (typeof h != "number") return;
    const m = Z.create(u.state.doc, h),
      g = u.state.tr.setSelection(m);
    u.dispatch(g);
  }
  stopEvent(e) {
    var n;
    if (!this.dom) return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const r = e.target;
    if (
      !(
        this.dom.contains(r) &&
        !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))
      )
    )
      return !1;
    const i = e.type.startsWith("drag"),
      s = e.type === "drop";
    if (
      (["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) ||
        r.isContentEditable) &&
      !s &&
      !i
    )
      return !0;
    const { isEditable: l } = this.editor,
      { isDragging: u } = this,
      c = !!this.node.type.spec.draggable,
      d = Z.isSelectable(this.node),
      f = e.type === "copy",
      p = e.type === "paste",
      h = e.type === "cut",
      m = e.type === "mousedown";
    if (
      (!c && d && i && e.target === this.dom && e.preventDefault(),
      c && i && !u && e.target === this.dom)
    )
      return e.preventDefault(), !1;
    if (c && l && !u && m) {
      const g = r.closest("[data-drag-handle]");
      g &&
        (this.dom === g || this.dom.contains(g)) &&
        ((this.isDragging = !0),
        document.addEventListener(
          "dragend",
          () => {
            this.isDragging = !1;
          },
          { once: !0 }
        ),
        document.addEventListener(
          "drop",
          () => {
            this.isDragging = !1;
          },
          { once: !0 }
        ),
        document.addEventListener(
          "mouseup",
          () => {
            this.isDragging = !1;
          },
          { once: !0 }
        ));
    }
    return !(u || s || f || p || h || (m && d));
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM
      ? !0
      : typeof this.options.ignoreMutation == "function"
      ? this.options.ignoreMutation({ mutation: e })
      : this.node.isLeaf || this.node.isAtom
      ? !0
      : e.type === "selection" ||
        (this.dom.contains(e.target) &&
          e.type === "childList" &&
          (a0() || UO()) &&
          this.editor.isFocused &&
          [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every(
            (r) => r.isContentEditable
          ))
      ? !1
      : this.contentDOM === e.target && e.type === "attributes"
      ? !0
      : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const r = this.getPos();
      return typeof r != "number"
        ? !1
        : (n.setNodeMarkup(r, void 0, {
            ...this.node.attrs,
            ...e,
          }),
          !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number") return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function So(t) {
  return new i0({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
      const i = le(t.getAttributes, void 0, r, o);
      if (i === !1 || i === null) return null;
      const { tr: s } = e,
        a = r[r.length - 1],
        l = r[0];
      let u = n.to;
      if (a) {
        const c = l.search(/\S/),
          d = n.from + l.indexOf(a),
          f = d + a.length;
        if (
          c0(n.from, n.to, e.doc)
            .filter((h) =>
              h.mark.type.excluded.find(
                (g) => g === t.type && g !== h.mark.type
              )
            )
            .filter((h) => h.to > d).length
        )
          return null;
        f < n.to && s.delete(f, n.to),
          d > n.from && s.delete(n.from + c, d),
          (u = n.from + c + a.length),
          s.addMark(n.from + c, u, t.type.create(i || {})),
          s.removeStoredMark(t.type);
      }
    },
  });
}
function WO(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function QV(t) {
  return typeof t == "string";
}
function qO(t) {
  return new i0({
    find: t.find,
    handler({ match: e, chain: n, range: r, pasteEvent: o }) {
      const i = le(t.getAttributes, void 0, e, o),
        s = le(t.getContent, void 0, i);
      if (i === !1 || i === null) return null;
      const a = { type: t.type.name, attrs: i };
      s && (a.content = s),
        e.input && n().deleteRange(r).insertContentAt(r.from, a);
    },
  });
}
function eU(t) {
  return new i0({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      let o = t.replace,
        i = n.from;
      const s = n.to;
      if (r[1]) {
        const a = r[0].lastIndexOf(r[1]);
        (o += r[0].slice(a + r[1].length)), (i += a);
        const l = i - s;
        l > 0 && ((o = r[0].slice(a - l, a) + o), (i = s));
      }
      e.tr.insertText(o, i, s);
    },
  });
}
class tU {
  constructor(e) {
    (this.transaction = e), (this.currentStep = this.transaction.steps.length);
  }
  map(e) {
    let n = !1;
    return {
      position: this.transaction.steps
        .slice(this.currentStep)
        .reduce((o, i) => {
          const s = i.getMap().mapResult(o);
          return s.deleted && (n = !0), s.pos;
        }, e),
      deleted: n,
    };
  }
}
var Yt = "top",
  Dn = "bottom",
  Nn = "right",
  Xt = "left",
  f0 = "auto",
  $a = [Yt, Dn, Nn, Xt],
  Ji = "start",
  ma = "end",
  KO = "clippingParents",
  G_ = "viewport",
  ps = "popper",
  GO = "reference",
  Ig = /* @__PURE__ */ $a.reduce(function (t, e) {
    return t.concat([e + "-" + Ji, e + "-" + ma]);
  }, []),
  J_ = /* @__PURE__ */ [].concat($a, [f0]).reduce(function (t, e) {
    return t.concat([e, e + "-" + Ji, e + "-" + ma]);
  }, []),
  JO = "beforeRead",
  YO = "read",
  XO = "afterRead",
  ZO = "beforeMain",
  QO = "main",
  e9 = "afterMain",
  t9 = "beforeWrite",
  n9 = "write",
  r9 = "afterWrite",
  o9 = [JO, YO, XO, ZO, QO, e9, t9, n9, r9];
function vr(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Ln(t) {
  if (t == null) return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return (e && e.defaultView) || window;
  }
  return t;
}
function di(t) {
  var e = Ln(t).Element;
  return t instanceof e || t instanceof Element;
}
function En(t) {
  var e = Ln(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function p0(t) {
  if (typeof ShadowRoot > "u") return !1;
  var e = Ln(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function i9(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function (n) {
    var r = e.styles[n] || {},
      o = e.attributes[n] || {},
      i = e.elements[n];
    !En(i) ||
      !vr(i) ||
      (Object.assign(i.style, r),
      Object.keys(o).forEach(function (s) {
        var a = o[s];
        a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a);
      }));
  });
}
function s9(t) {
  var e = t.state,
    n = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: {
        position: "absolute",
      },
      reference: {},
    };
  return (
    Object.assign(e.elements.popper.style, n.popper),
    (e.styles = n),
    e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
    function () {
      Object.keys(e.elements).forEach(function (r) {
        var o = e.elements[r],
          i = e.attributes[r] || {},
          s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
          a = s.reduce(function (l, u) {
            return (l[u] = ""), l;
          }, {});
        !En(o) ||
          !vr(o) ||
          (Object.assign(o.style, a),
          Object.keys(i).forEach(function (l) {
            o.removeAttribute(l);
          }));
      });
    }
  );
}
const Y_ = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: i9,
  effect: s9,
  requires: ["computeStyles"],
};
function mr(t) {
  return t.split("-")[0];
}
var ri = Math.max,
  Tu = Math.min,
  Yi = Math.round;
function Bp() {
  var t = navigator.userAgentData;
  return t != null && t.brands
    ? t.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
function X_() {
  return !/^((?!chrome|android).)*safari/i.test(Bp());
}
function Xi(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(),
    o = 1,
    i = 1;
  e &&
    En(t) &&
    ((o = (t.offsetWidth > 0 && Yi(r.width) / t.offsetWidth) || 1),
    (i = (t.offsetHeight > 0 && Yi(r.height) / t.offsetHeight) || 1));
  var s = di(t) ? Ln(t) : window,
    a = s.visualViewport,
    l = !X_() && n,
    u = (r.left + (l && a ? a.offsetLeft : 0)) / o,
    c = (r.top + (l && a ? a.offsetTop : 0)) / i,
    d = r.width / o,
    f = r.height / i;
  return {
    width: d,
    height: f,
    top: c,
    right: u + d,
    bottom: c + f,
    left: u,
    x: u,
    y: c,
  };
}
function h0(t) {
  var e = Xi(t),
    n = t.offsetWidth,
    r = t.offsetHeight;
  return (
    Math.abs(e.width - n) <= 1 && (n = e.width),
    Math.abs(e.height - r) <= 1 && (r = e.height),
    {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: n,
      height: r,
    }
  );
}
function Z_(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e)) return !0;
  if (n && p0(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r)) return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function jr(t) {
  return Ln(t).getComputedStyle(t);
}
function a9(t) {
  return ["table", "td", "th"].indexOf(vr(t)) >= 0;
}
function Lo(t) {
  return (
    (di(t)
      ? t.ownerDocument
      : // $FlowFixMe[prop-missing]
        t.document) || window.document
  ).documentElement;
}
function fd(t) {
  return vr(t) === "html"
    ? t
    : // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        t.parentNode || // DOM Element detected
        (p0(t) ? t.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        Lo(t);
}
function Pg(t) {
  return !En(t) || // https://github.com/popperjs/popper-core/issues/837
    jr(t).position === "fixed"
    ? null
    : t.offsetParent;
}
function l9(t) {
  var e = /firefox/i.test(Bp()),
    n = /Trident/i.test(Bp());
  if (n && En(t)) {
    var r = jr(t);
    if (r.position === "fixed") return null;
  }
  var o = fd(t);
  for (p0(o) && (o = o.host); En(o) && ["html", "body"].indexOf(vr(o)) < 0; ) {
    var i = jr(o);
    if (
      i.transform !== "none" ||
      i.perspective !== "none" ||
      i.contain === "paint" ||
      ["transform", "perspective"].indexOf(i.willChange) !== -1 ||
      (e && i.willChange === "filter") ||
      (e && i.filter && i.filter !== "none")
    )
      return o;
    o = o.parentNode;
  }
  return null;
}
function Ba(t) {
  for (var e = Ln(t), n = Pg(t); n && a9(n) && jr(n).position === "static"; )
    n = Pg(n);
  return n &&
    (vr(n) === "html" || (vr(n) === "body" && jr(n).position === "static"))
    ? e
    : n || l9(t) || e;
}
function m0(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function Ls(t, e, n) {
  return ri(t, Tu(e, n));
}
function u9(t, e, n) {
  var r = Ls(t, e, n);
  return r > n ? n : r;
}
function Q_() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
  };
}
function e3(t) {
  return Object.assign({}, Q_(), t);
}
function t3(t, e) {
  return e.reduce(function (n, r) {
    return (n[r] = t), n;
  }, {});
}
var c9 = function (e, n) {
  return (
    (e =
      typeof e == "function"
        ? e(
            Object.assign({}, n.rects, {
              placement: n.placement,
            })
          )
        : e),
    e3(typeof e != "number" ? e : t3(e, $a))
  );
};
function d9(t) {
  var e,
    n = t.state,
    r = t.name,
    o = t.options,
    i = n.elements.arrow,
    s = n.modifiersData.popperOffsets,
    a = mr(n.placement),
    l = m0(a),
    u = [Xt, Nn].indexOf(a) >= 0,
    c = u ? "height" : "width";
  if (!(!i || !s)) {
    var d = c9(o.padding, n),
      f = h0(i),
      p = l === "y" ? Yt : Xt,
      h = l === "y" ? Dn : Nn,
      m =
        n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c],
      g = s[l] - n.rects.reference[l],
      b = Ba(i),
      _ = b ? (l === "y" ? b.clientHeight || 0 : b.clientWidth || 0) : 0,
      v = m / 2 - g / 2,
      y = d[p],
      w = _ - f[c] - d[h],
      x = _ / 2 - f[c] / 2 + v,
      M = Ls(y, x, w),
      N = l;
    n.modifiersData[r] = ((e = {}), (e[N] = M), (e.centerOffset = M - x), e);
  }
}
function f9(t) {
  var e = t.state,
    n = t.options,
    r = n.element,
    o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null &&
    ((typeof o == "string" && ((o = e.elements.popper.querySelector(o)), !o)) ||
      (Z_(e.elements.popper, o) && (e.elements.arrow = o)));
}
const p9 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: d9,
  effect: f9,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function Zi(t) {
  return t.split("-")[1];
}
var h9 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto",
};
function m9(t) {
  var e = t.x,
    n = t.y,
    r = window,
    o = r.devicePixelRatio || 1;
  return {
    x: Yi(e * o) / o || 0,
    y: Yi(n * o) / o || 0,
  };
}
function $g(t) {
  var e,
    n = t.popper,
    r = t.popperRect,
    o = t.placement,
    i = t.variation,
    s = t.offsets,
    a = t.position,
    l = t.gpuAcceleration,
    u = t.adaptive,
    c = t.roundOffsets,
    d = t.isFixed,
    f = s.x,
    p = f === void 0 ? 0 : f,
    h = s.y,
    m = h === void 0 ? 0 : h,
    g =
      typeof c == "function"
        ? c({
            x: p,
            y: m,
          })
        : {
            x: p,
            y: m,
          };
  (p = g.x), (m = g.y);
  var b = s.hasOwnProperty("x"),
    _ = s.hasOwnProperty("y"),
    v = Xt,
    y = Yt,
    w = window;
  if (u) {
    var x = Ba(n),
      M = "clientHeight",
      N = "clientWidth";
    if (
      (x === Ln(n) &&
        ((x = Lo(n)),
        jr(x).position !== "static" &&
          a === "absolute" &&
          ((M = "scrollHeight"), (N = "scrollWidth"))),
      (x = x),
      o === Yt || ((o === Xt || o === Nn) && i === ma))
    ) {
      y = Dn;
      var T =
        d && x === w && w.visualViewport
          ? w.visualViewport.height
          : // $FlowFixMe[prop-missing]
            x[M];
      (m -= T - r.height), (m *= l ? 1 : -1);
    }
    if (o === Xt || ((o === Yt || o === Dn) && i === ma)) {
      v = Nn;
      var P =
        d && x === w && w.visualViewport
          ? w.visualViewport.width
          : // $FlowFixMe[prop-missing]
            x[N];
      (p -= P - r.width), (p *= l ? 1 : -1);
    }
  }
  var z = Object.assign(
      {
        position: a,
      },
      u && h9
    ),
    H =
      c === !0
        ? m9({
            x: p,
            y: m,
          })
        : {
            x: p,
            y: m,
          };
  if (((p = H.x), (m = H.y), l)) {
    var U;
    return Object.assign(
      {},
      z,
      ((U = {}),
      (U[y] = _ ? "0" : ""),
      (U[v] = b ? "0" : ""),
      (U.transform =
        (w.devicePixelRatio || 1) <= 1
          ? "translate(" + p + "px, " + m + "px)"
          : "translate3d(" + p + "px, " + m + "px, 0)"),
      U)
    );
  }
  return Object.assign(
    {},
    z,
    ((e = {}),
    (e[y] = _ ? m + "px" : ""),
    (e[v] = b ? p + "px" : ""),
    (e.transform = ""),
    e)
  );
}
function g9(t) {
  var e = t.state,
    n = t.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    s = i === void 0 ? !0 : i,
    a = n.roundOffsets,
    l = a === void 0 ? !0 : a,
    u = {
      placement: mr(e.placement),
      variation: Zi(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: o,
      isFixed: e.options.strategy === "fixed",
    };
  e.modifiersData.popperOffsets != null &&
    (e.styles.popper = Object.assign(
      {},
      e.styles.popper,
      $g(
        Object.assign({}, u, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: s,
          roundOffsets: l,
        })
      )
    )),
    e.modifiersData.arrow != null &&
      (e.styles.arrow = Object.assign(
        {},
        e.styles.arrow,
        $g(
          Object.assign({}, u, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: l,
          })
        )
      )),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement,
    }));
}
const b9 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: g9,
  data: {},
};
var gl = {
  passive: !0,
};
function y9(t) {
  var e = t.state,
    n = t.instance,
    r = t.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    s = r.resize,
    a = s === void 0 ? !0 : s,
    l = Ln(e.elements.popper),
    u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return (
    i &&
      u.forEach(function (c) {
        c.addEventListener("scroll", n.update, gl);
      }),
    a && l.addEventListener("resize", n.update, gl),
    function () {
      i &&
        u.forEach(function (c) {
          c.removeEventListener("scroll", n.update, gl);
        }),
        a && l.removeEventListener("resize", n.update, gl);
    }
  );
}
const v9 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: y9,
  data: {},
};
var _9 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
};
function Kl(t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return _9[e];
  });
}
var x9 = {
  start: "end",
  end: "start",
};
function Bg(t) {
  return t.replace(/start|end/g, function (e) {
    return x9[e];
  });
}
function g0(t) {
  var e = Ln(t),
    n = e.pageXOffset,
    r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r,
  };
}
function b0(t) {
  return Xi(Lo(t)).left + g0(t).scrollLeft;
}
function k9(t, e) {
  var n = Ln(t),
    r = Lo(t),
    o = n.visualViewport,
    i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    l = 0;
  if (o) {
    (i = o.width), (s = o.height);
    var u = X_();
    (u || (!u && e === "fixed")) && ((a = o.offsetLeft), (l = o.offsetTop));
  }
  return {
    width: i,
    height: s,
    x: a + b0(t),
    y: l,
  };
}
function w9(t) {
  var e,
    n = Lo(t),
    r = g0(t),
    o = (e = t.ownerDocument) == null ? void 0 : e.body,
    i = ri(
      n.scrollWidth,
      n.clientWidth,
      o ? o.scrollWidth : 0,
      o ? o.clientWidth : 0
    ),
    s = ri(
      n.scrollHeight,
      n.clientHeight,
      o ? o.scrollHeight : 0,
      o ? o.clientHeight : 0
    ),
    a = -r.scrollLeft + b0(t),
    l = -r.scrollTop;
  return (
    jr(o || n).direction === "rtl" &&
      (a += ri(n.clientWidth, o ? o.clientWidth : 0) - i),
    {
      width: i,
      height: s,
      x: a,
      y: l,
    }
  );
}
function y0(t) {
  var e = jr(t),
    n = e.overflow,
    r = e.overflowX,
    o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function n3(t) {
  return ["html", "body", "#document"].indexOf(vr(t)) >= 0
    ? t.ownerDocument.body
    : En(t) && y0(t)
    ? t
    : n3(fd(t));
}
function Rs(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = n3(t),
    o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
    i = Ln(r),
    s = o ? [i].concat(i.visualViewport || [], y0(r) ? r : []) : r,
    a = e.concat(s);
  return o
    ? a
    : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      a.concat(Rs(fd(s)));
}
function Hp(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height,
  });
}
function C9(t, e) {
  var n = Xi(t, !1, e === "fixed");
  return (
    (n.top = n.top + t.clientTop),
    (n.left = n.left + t.clientLeft),
    (n.bottom = n.top + t.clientHeight),
    (n.right = n.left + t.clientWidth),
    (n.width = t.clientWidth),
    (n.height = t.clientHeight),
    (n.x = n.left),
    (n.y = n.top),
    n
  );
}
function Hg(t, e, n) {
  return e === G_ ? Hp(k9(t, n)) : di(e) ? C9(e, n) : Hp(w9(Lo(t)));
}
function A9(t) {
  var e = Rs(fd(t)),
    n = ["absolute", "fixed"].indexOf(jr(t).position) >= 0,
    r = n && En(t) ? Ba(t) : t;
  return di(r)
    ? e.filter(function (o) {
        return di(o) && Z_(o, r) && vr(o) !== "body";
      })
    : [];
}
function S9(t, e, n, r) {
  var o = e === "clippingParents" ? A9(t) : [].concat(e),
    i = [].concat(o, [n]),
    s = i[0],
    a = i.reduce(function (l, u) {
      var c = Hg(t, u, r);
      return (
        (l.top = ri(c.top, l.top)),
        (l.right = Tu(c.right, l.right)),
        (l.bottom = Tu(c.bottom, l.bottom)),
        (l.left = ri(c.left, l.left)),
        l
      );
    }, Hg(t, s, r));
  return (
    (a.width = a.right - a.left),
    (a.height = a.bottom - a.top),
    (a.x = a.left),
    (a.y = a.top),
    a
  );
}
function r3(t) {
  var e = t.reference,
    n = t.element,
    r = t.placement,
    o = r ? mr(r) : null,
    i = r ? Zi(r) : null,
    s = e.x + e.width / 2 - n.width / 2,
    a = e.y + e.height / 2 - n.height / 2,
    l;
  switch (o) {
    case Yt:
      l = {
        x: s,
        y: e.y - n.height,
      };
      break;
    case Dn:
      l = {
        x: s,
        y: e.y + e.height,
      };
      break;
    case Nn:
      l = {
        x: e.x + e.width,
        y: a,
      };
      break;
    case Xt:
      l = {
        x: e.x - n.width,
        y: a,
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y,
      };
  }
  var u = o ? m0(o) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (i) {
      case Ji:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case ma:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function ga(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    o = r === void 0 ? t.placement : r,
    i = n.strategy,
    s = i === void 0 ? t.strategy : i,
    a = n.boundary,
    l = a === void 0 ? KO : a,
    u = n.rootBoundary,
    c = u === void 0 ? G_ : u,
    d = n.elementContext,
    f = d === void 0 ? ps : d,
    p = n.altBoundary,
    h = p === void 0 ? !1 : p,
    m = n.padding,
    g = m === void 0 ? 0 : m,
    b = e3(typeof g != "number" ? g : t3(g, $a)),
    _ = f === ps ? GO : ps,
    v = t.rects.popper,
    y = t.elements[h ? _ : f],
    w = S9(di(y) ? y : y.contextElement || Lo(t.elements.popper), l, c, s),
    x = Xi(t.elements.reference),
    M = r3({
      reference: x,
      element: v,
      strategy: "absolute",
      placement: o,
    }),
    N = Hp(Object.assign({}, v, M)),
    T = f === ps ? N : x,
    P = {
      top: w.top - T.top + b.top,
      bottom: T.bottom - w.bottom + b.bottom,
      left: w.left - T.left + b.left,
      right: T.right - w.right + b.right,
    },
    z = t.modifiersData.offset;
  if (f === ps && z) {
    var H = z[o];
    Object.keys(P).forEach(function (U) {
      var re = [Nn, Dn].indexOf(U) >= 0 ? 1 : -1,
        te = [Yt, Dn].indexOf(U) >= 0 ? "y" : "x";
      P[U] += H[te] * re;
    });
  }
  return P;
}
function E9(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    s = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    u = l === void 0 ? J_ : l,
    c = Zi(r),
    d = c
      ? a
        ? Ig
        : Ig.filter(function (h) {
            return Zi(h) === c;
          })
      : $a,
    f = d.filter(function (h) {
      return u.indexOf(h) >= 0;
    });
  f.length === 0 && (f = d);
  var p = f.reduce(function (h, m) {
    return (
      (h[m] = ga(t, {
        placement: m,
        boundary: o,
        rootBoundary: i,
        padding: s,
      })[mr(m)]),
      h
    );
  }, {});
  return Object.keys(p).sort(function (h, m) {
    return p[h] - p[m];
  });
}
function M9(t) {
  if (mr(t) === f0) return [];
  var e = Kl(t);
  return [Bg(t), e, Bg(e)];
}
function T9(t) {
  var e = t.state,
    n = t.options,
    r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (
      var o = n.mainAxis,
        i = o === void 0 ? !0 : o,
        s = n.altAxis,
        a = s === void 0 ? !0 : s,
        l = n.fallbackPlacements,
        u = n.padding,
        c = n.boundary,
        d = n.rootBoundary,
        f = n.altBoundary,
        p = n.flipVariations,
        h = p === void 0 ? !0 : p,
        m = n.allowedAutoPlacements,
        g = e.options.placement,
        b = mr(g),
        _ = b === g,
        v = l || (_ || !h ? [Kl(g)] : M9(g)),
        y = [g].concat(v).reduce(function (Qe, He) {
          return Qe.concat(
            mr(He) === f0
              ? E9(e, {
                  placement: He,
                  boundary: c,
                  rootBoundary: d,
                  padding: u,
                  flipVariations: h,
                  allowedAutoPlacements: m,
                })
              : He
          );
        }, []),
        w = e.rects.reference,
        x = e.rects.popper,
        M = /* @__PURE__ */ new Map(),
        N = !0,
        T = y[0],
        P = 0;
      P < y.length;
      P++
    ) {
      var z = y[P],
        H = mr(z),
        U = Zi(z) === Ji,
        re = [Yt, Dn].indexOf(H) >= 0,
        te = re ? "width" : "height",
        Q = ga(e, {
          placement: z,
          boundary: c,
          rootBoundary: d,
          altBoundary: f,
          padding: u,
        }),
        ne = re ? (U ? Nn : Xt) : U ? Dn : Yt;
      w[te] > x[te] && (ne = Kl(ne));
      var fe = Kl(ne),
        Le = [];
      if (
        (i && Le.push(Q[H] <= 0),
        a && Le.push(Q[ne] <= 0, Q[fe] <= 0),
        Le.every(function (Qe) {
          return Qe;
        }))
      ) {
        (T = z), (N = !1);
        break;
      }
      M.set(z, Le);
    }
    if (N)
      for (
        var We = h ? 3 : 1,
          Ee = function (He) {
            var qe = y.find(function (yt) {
              var nt = M.get(yt);
              if (nt)
                return nt.slice(0, He).every(function (Ct) {
                  return Ct;
                });
            });
            if (qe) return (T = qe), "break";
          },
          ze = We;
        ze > 0;
        ze--
      ) {
        var Ge = Ee(ze);
        if (Ge === "break") break;
      }
    e.placement !== T &&
      ((e.modifiersData[r]._skip = !0), (e.placement = T), (e.reset = !0));
  }
}
const O9 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: T9,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1,
  },
};
function Fg(t, e, n) {
  return (
    n === void 0 &&
      (n = {
        x: 0,
        y: 0,
      }),
    {
      top: t.top - e.height - n.y,
      right: t.right - e.width + n.x,
      bottom: t.bottom - e.height + n.y,
      left: t.left - e.width - n.x,
    }
  );
}
function zg(t) {
  return [Yt, Nn, Dn, Xt].some(function (e) {
    return t[e] >= 0;
  });
}
function D9(t) {
  var e = t.state,
    n = t.name,
    r = e.rects.reference,
    o = e.rects.popper,
    i = e.modifiersData.preventOverflow,
    s = ga(e, {
      elementContext: "reference",
    }),
    a = ga(e, {
      altBoundary: !0,
    }),
    l = Fg(s, r),
    u = Fg(a, o, i),
    c = zg(l),
    d = zg(u);
  (e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: d,
  }),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": c,
      "data-popper-escaped": d,
    }));
}
const N9 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: D9,
};
function L9(t, e, n) {
  var r = mr(t),
    o = [Xt, Yt].indexOf(r) >= 0 ? -1 : 1,
    i =
      typeof n == "function"
        ? n(
            Object.assign({}, e, {
              placement: t,
            })
          )
        : n,
    s = i[0],
    a = i[1];
  return (
    (s = s || 0),
    (a = (a || 0) * o),
    [Xt, Nn].indexOf(r) >= 0
      ? {
          x: a,
          y: s,
        }
      : {
          x: s,
          y: a,
        }
  );
}
function R9(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    s = J_.reduce(function (c, d) {
      return (c[d] = L9(d, e.rects, i)), c;
    }, {}),
    a = s[e.placement],
    l = a.x,
    u = a.y;
  e.modifiersData.popperOffsets != null &&
    ((e.modifiersData.popperOffsets.x += l),
    (e.modifiersData.popperOffsets.y += u)),
    (e.modifiersData[r] = s);
}
const I9 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: R9,
};
function P9(t) {
  var e = t.state,
    n = t.name;
  e.modifiersData[n] = r3({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement,
  });
}
const $9 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: P9,
  data: {},
};
function B9(t) {
  return t === "x" ? "y" : "x";
}
function H9(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    s = n.altAxis,
    a = s === void 0 ? !1 : s,
    l = n.boundary,
    u = n.rootBoundary,
    c = n.altBoundary,
    d = n.padding,
    f = n.tether,
    p = f === void 0 ? !0 : f,
    h = n.tetherOffset,
    m = h === void 0 ? 0 : h,
    g = ga(e, {
      boundary: l,
      rootBoundary: u,
      padding: d,
      altBoundary: c,
    }),
    b = mr(e.placement),
    _ = Zi(e.placement),
    v = !_,
    y = m0(b),
    w = B9(y),
    x = e.modifiersData.popperOffsets,
    M = e.rects.reference,
    N = e.rects.popper,
    T =
      typeof m == "function"
        ? m(
            Object.assign({}, e.rects, {
              placement: e.placement,
            })
          )
        : m,
    P =
      typeof T == "number"
        ? {
            mainAxis: T,
            altAxis: T,
          }
        : Object.assign(
            {
              mainAxis: 0,
              altAxis: 0,
            },
            T
          ),
    z = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
    H = {
      x: 0,
      y: 0,
    };
  if (x) {
    if (i) {
      var U,
        re = y === "y" ? Yt : Xt,
        te = y === "y" ? Dn : Nn,
        Q = y === "y" ? "height" : "width",
        ne = x[y],
        fe = ne + g[re],
        Le = ne - g[te],
        We = p ? -N[Q] / 2 : 0,
        Ee = _ === Ji ? M[Q] : N[Q],
        ze = _ === Ji ? -N[Q] : -M[Q],
        Ge = e.elements.arrow,
        Qe =
          p && Ge
            ? h0(Ge)
            : {
                width: 0,
                height: 0,
              },
        He = e.modifiersData["arrow#persistent"]
          ? e.modifiersData["arrow#persistent"].padding
          : Q_(),
        qe = He[re],
        yt = He[te],
        nt = Ls(0, M[Q], Qe[Q]),
        Ct = v
          ? M[Q] / 2 - We - nt - qe - P.mainAxis
          : Ee - nt - qe - P.mainAxis,
        ut = v
          ? -M[Q] / 2 + We + nt + yt + P.mainAxis
          : ze + nt + yt + P.mainAxis,
        nn = e.elements.arrow && Ba(e.elements.arrow),
        Rn = nn ? (y === "y" ? nn.clientTop || 0 : nn.clientLeft || 0) : 0,
        wr = (U = z == null ? void 0 : z[y]) != null ? U : 0,
        qr = ne + Ct - wr - Rn,
        Qn = ne + ut - wr,
        fn = Ls(p ? Tu(fe, qr) : fe, ne, p ? ri(Le, Qn) : Le);
      (x[y] = fn), (H[y] = fn - ne);
    }
    if (a) {
      var pn,
        er = y === "x" ? Yt : Xt,
        Kr = y === "x" ? Dn : Nn,
        A = x[w],
        E = w === "y" ? "height" : "width",
        B = A + g[er],
        G = A - g[Kr],
        Me = [Yt, Xt].indexOf(b) !== -1,
        oe = (pn = z == null ? void 0 : z[w]) != null ? pn : 0,
        L = Me ? B : A - M[E] - N[E] - oe + P.altAxis,
        F = Me ? A + M[E] + N[E] - oe - P.altAxis : G,
        Ce = p && Me ? u9(L, A, F) : Ls(p ? L : B, A, p ? F : G);
      (x[w] = Ce), (H[w] = Ce - A);
    }
    e.modifiersData[r] = H;
  }
}
const F9 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: H9,
  requiresIfExists: ["offset"],
};
function z9(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop,
  };
}
function V9(t) {
  return t === Ln(t) || !En(t) ? g0(t) : z9(t);
}
function U9(t) {
  var e = t.getBoundingClientRect(),
    n = Yi(e.width) / t.offsetWidth || 1,
    r = Yi(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function j9(t, e, n) {
  n === void 0 && (n = !1);
  var r = En(e),
    o = En(e) && U9(e),
    i = Lo(e),
    s = Xi(t, o, n),
    a = {
      scrollLeft: 0,
      scrollTop: 0,
    },
    l = {
      x: 0,
      y: 0,
    };
  return (
    (r || (!r && !n)) &&
      ((vr(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        y0(i)) &&
        (a = V9(e)),
      En(e)
        ? ((l = Xi(e, !0)), (l.x += e.clientLeft), (l.y += e.clientTop))
        : i && (l.x = b0(i))),
    {
      x: s.left + a.scrollLeft - l.x,
      y: s.top + a.scrollTop - l.y,
      width: s.width,
      height: s.height,
    }
  );
}
function W9(t) {
  var e = /* @__PURE__ */ new Map(),
    n = /* @__PURE__ */ new Set(),
    r = [];
  t.forEach(function (i) {
    e.set(i.name, i);
  });
  function o(i) {
    n.add(i.name);
    var s = [].concat(i.requires || [], i.requiresIfExists || []);
    s.forEach(function (a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && o(l);
      }
    }),
      r.push(i);
  }
  return (
    t.forEach(function (i) {
      n.has(i.name) || o(i);
    }),
    r
  );
}
function q9(t) {
  var e = W9(t);
  return o9.reduce(function (n, r) {
    return n.concat(
      e.filter(function (o) {
        return o.phase === r;
      })
    );
  }, []);
}
function K9(t) {
  var e;
  return function () {
    return (
      e ||
        (e = new Promise(function (n) {
          Promise.resolve().then(function () {
            (e = void 0), n(t());
          });
        })),
      e
    );
  };
}
function G9(t) {
  var e = t.reduce(function (n, r) {
    var o = n[r.name];
    return (
      (n[r.name] = o
        ? Object.assign({}, o, r, {
            options: Object.assign({}, o.options, r.options),
            data: Object.assign({}, o.data, r.data),
          })
        : r),
      n
    );
  }, {});
  return Object.keys(e).map(function (n) {
    return e[n];
  });
}
var Vg = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute",
};
function Ug() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function J9(t) {
  t === void 0 && (t = {});
  var e = t,
    n = e.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = e.defaultOptions,
    i = o === void 0 ? Vg : o;
  return function (a, l, u) {
    u === void 0 && (u = i);
    var c = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Vg, i),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l,
        },
        attributes: {},
        styles: {},
      },
      d = [],
      f = !1,
      p = {
        state: c,
        setOptions: function (b) {
          var _ = typeof b == "function" ? b(c.options) : b;
          m(),
            (c.options = Object.assign({}, i, c.options, _)),
            (c.scrollParents = {
              reference: di(a)
                ? Rs(a)
                : a.contextElement
                ? Rs(a.contextElement)
                : [],
              popper: Rs(l),
            });
          var v = q9(G9([].concat(r, c.options.modifiers)));
          return (
            (c.orderedModifiers = v.filter(function (y) {
              return y.enabled;
            })),
            h(),
            p.update()
          );
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function () {
          if (!f) {
            var b = c.elements,
              _ = b.reference,
              v = b.popper;
            if (Ug(_, v)) {
              (c.rects = {
                reference: j9(_, Ba(v), c.options.strategy === "fixed"),
                popper: h0(v),
              }),
                (c.reset = !1),
                (c.placement = c.options.placement),
                c.orderedModifiers.forEach(function (P) {
                  return (c.modifiersData[P.name] = Object.assign({}, P.data));
                });
              for (var y = 0; y < c.orderedModifiers.length; y++) {
                if (c.reset === !0) {
                  (c.reset = !1), (y = -1);
                  continue;
                }
                var w = c.orderedModifiers[y],
                  x = w.fn,
                  M = w.options,
                  N = M === void 0 ? {} : M,
                  T = w.name;
                typeof x == "function" &&
                  (c =
                    x({
                      state: c,
                      options: N,
                      name: T,
                      instance: p,
                    }) || c);
              }
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: K9(function () {
          return new Promise(function (g) {
            p.forceUpdate(), g(c);
          });
        }),
        destroy: function () {
          m(), (f = !0);
        },
      };
    if (!Ug(a, l)) return p;
    p.setOptions(u).then(function (g) {
      !f && u.onFirstUpdate && u.onFirstUpdate(g);
    });
    function h() {
      c.orderedModifiers.forEach(function (g) {
        var b = g.name,
          _ = g.options,
          v = _ === void 0 ? {} : _,
          y = g.effect;
        if (typeof y == "function") {
          var w = y({
              state: c,
              name: b,
              instance: p,
              options: v,
            }),
            x = function () {};
          d.push(w || x);
        }
      });
    }
    function m() {
      d.forEach(function (g) {
        return g();
      }),
        (d = []);
    }
    return p;
  };
}
var Y9 = [v9, $9, b9, Y_, I9, O9, F9, p9, N9],
  X9 = /* @__PURE__ */ J9({
    defaultModifiers: Y9,
  }),
  Z9 = "tippy-box",
  o3 = "tippy-content",
  Q9 = "tippy-backdrop",
  i3 = "tippy-arrow",
  s3 = "tippy-svg-arrow",
  zo = {
    passive: !0,
    capture: !0,
  },
  a3 = function () {
    return document.body;
  };
function ff(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function v0(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function l3(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function jg(t, e) {
  if (e === 0) return t;
  var n;
  return function (r) {
    clearTimeout(n),
      (n = setTimeout(function () {
        t(r);
      }, e));
  };
}
function eD(t) {
  return t.split(/\s+/).filter(Boolean);
}
function Ti(t) {
  return [].concat(t);
}
function Wg(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function tD(t) {
  return t.filter(function (e, n) {
    return t.indexOf(e) === n;
  });
}
function nD(t) {
  return t.split("-")[0];
}
function Ou(t) {
  return [].slice.call(t);
}
function qg(t) {
  return Object.keys(t).reduce(function (e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function Is() {
  return document.createElement("div");
}
function pd(t) {
  return ["Element", "Fragment"].some(function (e) {
    return v0(t, e);
  });
}
function rD(t) {
  return v0(t, "NodeList");
}
function oD(t) {
  return v0(t, "MouseEvent");
}
function iD(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function sD(t) {
  return pd(t)
    ? [t]
    : rD(t)
    ? Ou(t)
    : Array.isArray(t)
    ? t
    : Ou(document.querySelectorAll(t));
}
function pf(t, e) {
  t.forEach(function (n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function Kg(t, e) {
  t.forEach(function (n) {
    n && n.setAttribute("data-state", e);
  });
}
function aD(t) {
  var e,
    n = Ti(t),
    r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body
    ? r.ownerDocument
    : document;
}
function lD(t, e) {
  var n = e.clientX,
    r = e.clientY;
  return t.every(function (o) {
    var i = o.popperRect,
      s = o.popperState,
      a = o.props,
      l = a.interactiveBorder,
      u = nD(s.placement),
      c = s.modifiersData.offset;
    if (!c) return !0;
    var d = u === "bottom" ? c.top.y : 0,
      f = u === "top" ? c.bottom.y : 0,
      p = u === "right" ? c.left.x : 0,
      h = u === "left" ? c.right.x : 0,
      m = i.top - r + d > l,
      g = r - i.bottom - f > l,
      b = i.left - n + p > l,
      _ = n - i.right - h > l;
    return m || g || b || _;
  });
}
function hf(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function (o) {
    t[r](o, n);
  });
}
function Gg(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n)) return !0;
    n =
      n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var lr = {
    isTouch: !1,
  },
  Jg = 0;
function uD() {
  lr.isTouch ||
    ((lr.isTouch = !0),
    window.performance && document.addEventListener("mousemove", u3));
}
function u3() {
  var t = performance.now();
  t - Jg < 20 &&
    ((lr.isTouch = !1), document.removeEventListener("mousemove", u3)),
    (Jg = t);
}
function cD() {
  var t = document.activeElement;
  if (iD(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function dD() {
  document.addEventListener("touchstart", uD, zo),
    window.addEventListener("blur", cD);
}
var fD = typeof window < "u" && typeof document < "u",
  pD = fD
    ? // @ts-ignore
      !!window.msCrypto
    : !1,
  hD = {
    animateFill: !1,
    followCursor: !1,
    inlinePositioning: !1,
    sticky: !1,
  },
  mD = {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999,
  },
  jn = Object.assign(
    {
      appendTo: a3,
      aria: {
        content: "auto",
        expanded: "auto",
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: !0,
      ignoreAttributes: !1,
      interactive: !1,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function () {},
      onBeforeUpdate: function () {},
      onCreate: function () {},
      onDestroy: function () {},
      onHidden: function () {},
      onHide: function () {},
      onMount: function () {},
      onShow: function () {},
      onShown: function () {},
      onTrigger: function () {},
      onUntrigger: function () {},
      onClickOutside: function () {},
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: !1,
      touch: !0,
      trigger: "mouseenter focus",
      triggerTarget: null,
    },
    hD,
    mD
  ),
  gD = Object.keys(jn),
  bD = function (e) {
    var n = Object.keys(e);
    n.forEach(function (r) {
      jn[r] = e[r];
    });
  };
function c3(t) {
  var e = t.plugins || [],
    n = e.reduce(function (r, o) {
      var i = o.name,
        s = o.defaultValue;
      if (i) {
        var a;
        r[i] = t[i] !== void 0 ? t[i] : (a = jn[i]) != null ? a : s;
      }
      return r;
    }, {});
  return Object.assign({}, t, n);
}
function yD(t, e) {
  var n = e
      ? Object.keys(
          c3(
            Object.assign({}, jn, {
              plugins: e,
            })
          )
        )
      : gD,
    r = n.reduce(function (o, i) {
      var s = (t.getAttribute("data-tippy-" + i) || "").trim();
      if (!s) return o;
      if (i === "content") o[i] = s;
      else
        try {
          o[i] = JSON.parse(s);
        } catch {
          o[i] = s;
        }
      return o;
    }, {});
  return r;
}
function Yg(t, e) {
  var n = Object.assign(
    {},
    e,
    {
      content: l3(e.content, [t]),
    },
    e.ignoreAttributes ? {} : yD(t, e.plugins)
  );
  return (
    (n.aria = Object.assign({}, jn.aria, n.aria)),
    (n.aria = {
      expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
      content:
        n.aria.content === "auto"
          ? e.interactive
            ? null
            : "describedby"
          : n.aria.content,
    }),
    n
  );
}
var vD = function () {
  return "innerHTML";
};
function Fp(t, e) {
  t[vD()] = e;
}
function Xg(t) {
  var e = Is();
  return (
    t === !0
      ? (e.className = i3)
      : ((e.className = s3), pd(t) ? e.appendChild(t) : Fp(e, t)),
    e
  );
}
function Zg(t, e) {
  pd(e.content)
    ? (Fp(t, ""), t.appendChild(e.content))
    : typeof e.content != "function" &&
      (e.allowHTML ? Fp(t, e.content) : (t.textContent = e.content));
}
function zp(t) {
  var e = t.firstElementChild,
    n = Ou(e.children);
  return {
    box: e,
    content: n.find(function (r) {
      return r.classList.contains(o3);
    }),
    arrow: n.find(function (r) {
      return r.classList.contains(i3) || r.classList.contains(s3);
    }),
    backdrop: n.find(function (r) {
      return r.classList.contains(Q9);
    }),
  };
}
function d3(t) {
  var e = Is(),
    n = Is();
  (n.className = Z9),
    n.setAttribute("data-state", "hidden"),
    n.setAttribute("tabindex", "-1");
  var r = Is();
  (r.className = o3),
    r.setAttribute("data-state", "hidden"),
    Zg(r, t.props),
    e.appendChild(n),
    n.appendChild(r),
    o(t.props, t.props);
  function o(i, s) {
    var a = zp(e),
      l = a.box,
      u = a.content,
      c = a.arrow;
    s.theme
      ? l.setAttribute("data-theme", s.theme)
      : l.removeAttribute("data-theme"),
      typeof s.animation == "string"
        ? l.setAttribute("data-animation", s.animation)
        : l.removeAttribute("data-animation"),
      s.inertia
        ? l.setAttribute("data-inertia", "")
        : l.removeAttribute("data-inertia"),
      (l.style.maxWidth =
        typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth),
      s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"),
      (i.content !== s.content || i.allowHTML !== s.allowHTML) &&
        Zg(u, t.props),
      s.arrow
        ? c
          ? i.arrow !== s.arrow &&
            (l.removeChild(c), l.appendChild(Xg(s.arrow)))
          : l.appendChild(Xg(s.arrow))
        : c && l.removeChild(c);
  }
  return {
    popper: e,
    onUpdate: o,
  };
}
d3.$$tippy = !0;
var _D = 1,
  bl = [],
  mf = [];
function xD(t, e) {
  var n = Yg(t, Object.assign({}, jn, c3(qg(e)))),
    r,
    o,
    i,
    s = !1,
    a = !1,
    l = !1,
    u = !1,
    c,
    d,
    f,
    p = [],
    h = jg(qr, n.interactiveDebounce),
    m,
    g = _D++,
    b = null,
    _ = tD(n.plugins),
    v = {
      // Is the instance currently enabled?
      isEnabled: !0,
      // Is the tippy currently showing and not transitioning out?
      isVisible: !1,
      // Has the instance been destroyed?
      isDestroyed: !1,
      // Is the tippy currently mounted to the DOM?
      isMounted: !1,
      // Has the tippy finished transitioning in?
      isShown: !1,
    },
    y = {
      // properties
      id: g,
      reference: t,
      popper: Is(),
      popperInstance: b,
      props: n,
      state: v,
      plugins: _,
      // methods
      clearDelayTimeouts: L,
      setProps: F,
      setContent: Ce,
      show: Je,
      hide: tr,
      hideWithInteractivity: bi,
      enable: Me,
      disable: oe,
      unmount: Gr,
      destroy: Cd,
    };
  if (!n.render) return y;
  var w = n.render(y),
    x = w.popper,
    M = w.onUpdate;
  x.setAttribute("data-tippy-root", ""),
    (x.id = "tippy-" + y.id),
    (y.popper = x),
    (t._tippy = y),
    (x._tippy = y);
  var N = _.map(function (R) {
      return R.fn(y);
    }),
    T = t.hasAttribute("aria-expanded");
  return (
    nn(),
    We(),
    ne(),
    fe("onCreate", [y]),
    n.showOnCreate && B(),
    x.addEventListener("mouseenter", function () {
      y.props.interactive && y.state.isVisible && y.clearDelayTimeouts();
    }),
    x.addEventListener("mouseleave", function () {
      y.props.interactive &&
        y.props.trigger.indexOf("mouseenter") >= 0 &&
        re().addEventListener("mousemove", h);
    }),
    y
  );
  function P() {
    var R = y.props.touch;
    return Array.isArray(R) ? R : [R, 0];
  }
  function z() {
    return P()[0] === "hold";
  }
  function H() {
    var R;
    return !!((R = y.props.render) != null && R.$$tippy);
  }
  function U() {
    return m || t;
  }
  function re() {
    var R = U().parentNode;
    return R ? aD(R) : document;
  }
  function te() {
    return zp(x);
  }
  function Q(R) {
    return (y.state.isMounted && !y.state.isVisible) ||
      lr.isTouch ||
      (c && c.type === "focus")
      ? 0
      : ff(y.props.delay, R ? 0 : 1, jn.delay);
  }
  function ne(R) {
    R === void 0 && (R = !1),
      (x.style.pointerEvents = y.props.interactive && !R ? "" : "none"),
      (x.style.zIndex = "" + y.props.zIndex);
  }
  function fe(R, X, ae) {
    if (
      (ae === void 0 && (ae = !0),
      N.forEach(function (we) {
        we[R] && we[R].apply(we, X);
      }),
      ae)
    ) {
      var Re;
      (Re = y.props)[R].apply(Re, X);
    }
  }
  function Le() {
    var R = y.props.aria;
    if (R.content) {
      var X = "aria-" + R.content,
        ae = x.id,
        Re = Ti(y.props.triggerTarget || t);
      Re.forEach(function (we) {
        var Lt = we.getAttribute(X);
        if (y.state.isVisible) we.setAttribute(X, Lt ? Lt + " " + ae : ae);
        else {
          var hn = Lt && Lt.replace(ae, "").trim();
          hn ? we.setAttribute(X, hn) : we.removeAttribute(X);
        }
      });
    }
  }
  function We() {
    if (!(T || !y.props.aria.expanded)) {
      var R = Ti(y.props.triggerTarget || t);
      R.forEach(function (X) {
        y.props.interactive
          ? X.setAttribute(
              "aria-expanded",
              y.state.isVisible && X === U() ? "true" : "false"
            )
          : X.removeAttribute("aria-expanded");
      });
    }
  }
  function Ee() {
    re().removeEventListener("mousemove", h),
      (bl = bl.filter(function (R) {
        return R !== h;
      }));
  }
  function ze(R) {
    if (!(lr.isTouch && (l || R.type === "mousedown"))) {
      var X = (R.composedPath && R.composedPath()[0]) || R.target;
      if (!(y.props.interactive && Gg(x, X))) {
        if (
          Ti(y.props.triggerTarget || t).some(function (ae) {
            return Gg(ae, X);
          })
        ) {
          if (
            lr.isTouch ||
            (y.state.isVisible && y.props.trigger.indexOf("click") >= 0)
          )
            return;
        } else fe("onClickOutside", [y, R]);
        y.props.hideOnClick === !0 &&
          (y.clearDelayTimeouts(),
          y.hide(),
          (a = !0),
          setTimeout(function () {
            a = !1;
          }),
          y.state.isMounted || qe());
      }
    }
  }
  function Ge() {
    l = !0;
  }
  function Qe() {
    l = !1;
  }
  function He() {
    var R = re();
    R.addEventListener("mousedown", ze, !0),
      R.addEventListener("touchend", ze, zo),
      R.addEventListener("touchstart", Qe, zo),
      R.addEventListener("touchmove", Ge, zo);
  }
  function qe() {
    var R = re();
    R.removeEventListener("mousedown", ze, !0),
      R.removeEventListener("touchend", ze, zo),
      R.removeEventListener("touchstart", Qe, zo),
      R.removeEventListener("touchmove", Ge, zo);
  }
  function yt(R, X) {
    Ct(R, function () {
      !y.state.isVisible && x.parentNode && x.parentNode.contains(x) && X();
    });
  }
  function nt(R, X) {
    Ct(R, X);
  }
  function Ct(R, X) {
    var ae = te().box;
    function Re(we) {
      we.target === ae && (hf(ae, "remove", Re), X());
    }
    if (R === 0) return X();
    hf(ae, "remove", d), hf(ae, "add", Re), (d = Re);
  }
  function ut(R, X, ae) {
    ae === void 0 && (ae = !1);
    var Re = Ti(y.props.triggerTarget || t);
    Re.forEach(function (we) {
      we.addEventListener(R, X, ae),
        p.push({
          node: we,
          eventType: R,
          handler: X,
          options: ae,
        });
    });
  }
  function nn() {
    z() &&
      (ut("touchstart", wr, {
        passive: !0,
      }),
      ut("touchend", Qn, {
        passive: !0,
      })),
      eD(y.props.trigger).forEach(function (R) {
        if (R !== "manual")
          switch ((ut(R, wr), R)) {
            case "mouseenter":
              ut("mouseleave", Qn);
              break;
            case "focus":
              ut(pD ? "focusout" : "blur", fn);
              break;
            case "focusin":
              ut("focusout", fn);
              break;
          }
      });
  }
  function Rn() {
    p.forEach(function (R) {
      var X = R.node,
        ae = R.eventType,
        Re = R.handler,
        we = R.options;
      X.removeEventListener(ae, Re, we);
    }),
      (p = []);
  }
  function wr(R) {
    var X,
      ae = !1;
    if (!(!y.state.isEnabled || pn(R) || a)) {
      var Re = ((X = c) == null ? void 0 : X.type) === "focus";
      (c = R),
        (m = R.currentTarget),
        We(),
        !y.state.isVisible &&
          oD(R) &&
          bl.forEach(function (we) {
            return we(R);
          }),
        R.type === "click" &&
        (y.props.trigger.indexOf("mouseenter") < 0 || s) &&
        y.props.hideOnClick !== !1 &&
        y.state.isVisible
          ? (ae = !0)
          : B(R),
        R.type === "click" && (s = !ae),
        ae && !Re && G(R);
    }
  }
  function qr(R) {
    var X = R.target,
      ae = U().contains(X) || x.contains(X);
    if (!(R.type === "mousemove" && ae)) {
      var Re = E()
        .concat(x)
        .map(function (we) {
          var Lt,
            hn = we._tippy,
            yi = (Lt = hn.popperInstance) == null ? void 0 : Lt.state;
          return yi
            ? {
                popperRect: we.getBoundingClientRect(),
                popperState: yi,
                props: n,
              }
            : null;
        })
        .filter(Boolean);
      lD(Re, R) && (Ee(), G(R));
    }
  }
  function Qn(R) {
    var X = pn(R) || (y.props.trigger.indexOf("click") >= 0 && s);
    if (!X) {
      if (y.props.interactive) {
        y.hideWithInteractivity(R);
        return;
      }
      G(R);
    }
  }
  function fn(R) {
    (y.props.trigger.indexOf("focusin") < 0 && R.target !== U()) ||
      (y.props.interactive && R.relatedTarget && x.contains(R.relatedTarget)) ||
      G(R);
  }
  function pn(R) {
    return lr.isTouch ? z() !== R.type.indexOf("touch") >= 0 : !1;
  }
  function er() {
    Kr();
    var R = y.props,
      X = R.popperOptions,
      ae = R.placement,
      Re = R.offset,
      we = R.getReferenceClientRect,
      Lt = R.moveTransition,
      hn = H() ? zp(x).arrow : null,
      yi = we
        ? {
            getBoundingClientRect: we,
            contextElement: we.contextElement || U(),
          }
        : t,
      z0 = {
        name: "$$tippy",
        enabled: !0,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function (Ja) {
          var vi = Ja.state;
          if (H()) {
            var gx = te(),
              Sd = gx.box;
            ["placement", "reference-hidden", "escaped"].forEach(function (Ya) {
              Ya === "placement"
                ? Sd.setAttribute("data-placement", vi.placement)
                : vi.attributes.popper["data-popper-" + Ya]
                ? Sd.setAttribute("data-" + Ya, "")
                : Sd.removeAttribute("data-" + Ya);
            }),
              (vi.attributes.popper = {});
          }
        },
      },
      Io = [
        {
          name: "offset",
          options: {
            offset: Re,
          },
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5,
            },
          },
        },
        {
          name: "flip",
          options: {
            padding: 5,
          },
        },
        {
          name: "computeStyles",
          options: {
            adaptive: !Lt,
          },
        },
        z0,
      ];
    H() &&
      hn &&
      Io.push({
        name: "arrow",
        options: {
          element: hn,
          padding: 3,
        },
      }),
      Io.push.apply(Io, (X == null ? void 0 : X.modifiers) || []),
      (y.popperInstance = X9(
        yi,
        x,
        Object.assign({}, X, {
          placement: ae,
          onFirstUpdate: f,
          modifiers: Io,
        })
      ));
  }
  function Kr() {
    y.popperInstance && (y.popperInstance.destroy(), (y.popperInstance = null));
  }
  function A() {
    var R = y.props.appendTo,
      X,
      ae = U();
    (y.props.interactive && R === a3) || R === "parent"
      ? (X = ae.parentNode)
      : (X = l3(R, [ae])),
      X.contains(x) || X.appendChild(x),
      (y.state.isMounted = !0),
      er();
  }
  function E() {
    return Ou(x.querySelectorAll("[data-tippy-root]"));
  }
  function B(R) {
    y.clearDelayTimeouts(), R && fe("onTrigger", [y, R]), He();
    var X = Q(!0),
      ae = P(),
      Re = ae[0],
      we = ae[1];
    lr.isTouch && Re === "hold" && we && (X = we),
      X
        ? (r = setTimeout(function () {
            y.show();
          }, X))
        : y.show();
  }
  function G(R) {
    if (
      (y.clearDelayTimeouts(), fe("onUntrigger", [y, R]), !y.state.isVisible)
    ) {
      qe();
      return;
    }
    if (
      !(
        y.props.trigger.indexOf("mouseenter") >= 0 &&
        y.props.trigger.indexOf("click") >= 0 &&
        ["mouseleave", "mousemove"].indexOf(R.type) >= 0 &&
        s
      )
    ) {
      var X = Q(!1);
      X
        ? (o = setTimeout(function () {
            y.state.isVisible && y.hide();
          }, X))
        : (i = requestAnimationFrame(function () {
            y.hide();
          }));
    }
  }
  function Me() {
    y.state.isEnabled = !0;
  }
  function oe() {
    y.hide(), (y.state.isEnabled = !1);
  }
  function L() {
    clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
  }
  function F(R) {
    if (!y.state.isDestroyed) {
      fe("onBeforeUpdate", [y, R]), Rn();
      var X = y.props,
        ae = Yg(
          t,
          Object.assign({}, X, qg(R), {
            ignoreAttributes: !0,
          })
        );
      (y.props = ae),
        nn(),
        X.interactiveDebounce !== ae.interactiveDebounce &&
          (Ee(), (h = jg(qr, ae.interactiveDebounce))),
        X.triggerTarget && !ae.triggerTarget
          ? Ti(X.triggerTarget).forEach(function (Re) {
              Re.removeAttribute("aria-expanded");
            })
          : ae.triggerTarget && t.removeAttribute("aria-expanded"),
        We(),
        ne(),
        M && M(X, ae),
        y.popperInstance &&
          (er(),
          E().forEach(function (Re) {
            requestAnimationFrame(Re._tippy.popperInstance.forceUpdate);
          })),
        fe("onAfterUpdate", [y, R]);
    }
  }
  function Ce(R) {
    y.setProps({
      content: R,
    });
  }
  function Je() {
    var R = y.state.isVisible,
      X = y.state.isDestroyed,
      ae = !y.state.isEnabled,
      Re = lr.isTouch && !y.props.touch,
      we = ff(y.props.duration, 0, jn.duration);
    if (
      !(R || X || ae || Re) &&
      !U().hasAttribute("disabled") &&
      (fe("onShow", [y], !1), y.props.onShow(y) !== !1)
    ) {
      if (
        ((y.state.isVisible = !0),
        H() && (x.style.visibility = "visible"),
        ne(),
        He(),
        y.state.isMounted || (x.style.transition = "none"),
        H())
      ) {
        var Lt = te(),
          hn = Lt.box,
          yi = Lt.content;
        pf([hn, yi], 0);
      }
      (f = function () {
        var Io;
        if (!(!y.state.isVisible || u)) {
          if (
            ((u = !0),
            x.offsetHeight,
            (x.style.transition = y.props.moveTransition),
            H() && y.props.animation)
          ) {
            var Ad = te(),
              Ja = Ad.box,
              vi = Ad.content;
            pf([Ja, vi], we), Kg([Ja, vi], "visible");
          }
          Le(),
            We(),
            Wg(mf, y),
            (Io = y.popperInstance) == null || Io.forceUpdate(),
            fe("onMount", [y]),
            y.props.animation &&
              H() &&
              nt(we, function () {
                (y.state.isShown = !0), fe("onShown", [y]);
              });
        }
      }),
        A();
    }
  }
  function tr() {
    var R = !y.state.isVisible,
      X = y.state.isDestroyed,
      ae = !y.state.isEnabled,
      Re = ff(y.props.duration, 1, jn.duration);
    if (!(R || X || ae) && (fe("onHide", [y], !1), y.props.onHide(y) !== !1)) {
      if (
        ((y.state.isVisible = !1),
        (y.state.isShown = !1),
        (u = !1),
        (s = !1),
        H() && (x.style.visibility = "hidden"),
        Ee(),
        qe(),
        ne(!0),
        H())
      ) {
        var we = te(),
          Lt = we.box,
          hn = we.content;
        y.props.animation && (pf([Lt, hn], Re), Kg([Lt, hn], "hidden"));
      }
      Le(), We(), y.props.animation ? H() && yt(Re, y.unmount) : y.unmount();
    }
  }
  function bi(R) {
    re().addEventListener("mousemove", h), Wg(bl, h), h(R);
  }
  function Gr() {
    y.state.isVisible && y.hide(),
      y.state.isMounted &&
        (Kr(),
        E().forEach(function (R) {
          R._tippy.unmount();
        }),
        x.parentNode && x.parentNode.removeChild(x),
        (mf = mf.filter(function (R) {
          return R !== y;
        })),
        (y.state.isMounted = !1),
        fe("onHidden", [y]));
  }
  function Cd() {
    y.state.isDestroyed ||
      (y.clearDelayTimeouts(),
      y.unmount(),
      Rn(),
      delete t._tippy,
      (y.state.isDestroyed = !0),
      fe("onDestroy", [y]));
  }
}
function Ro(t, e) {
  e === void 0 && (e = {});
  var n = jn.plugins.concat(e.plugins || []);
  dD();
  var r = Object.assign({}, e, {
      plugins: n,
    }),
    o = sD(t),
    i = o.reduce(function (s, a) {
      var l = a && xD(a, r);
      return l && s.push(l), s;
    }, []);
  return pd(t) ? i[0] : i;
}
Ro.defaultProps = jn;
Ro.setDefaultProps = bD;
Ro.currentInput = lr;
Object.assign({}, Y_, {
  effect: function (e) {
    var n = e.state,
      r = {
        popper: {
          position: n.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: {
          position: "absolute",
        },
        reference: {},
      };
    Object.assign(n.elements.popper.style, r.popper),
      (n.styles = r),
      n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  },
});
var kD = {
  name: "sticky",
  defaultValue: !1,
  fn: function (e) {
    var n = e.reference,
      r = e.popper;
    function o() {
      return e.popperInstance ? e.popperInstance.state.elements.reference : n;
    }
    function i(u) {
      return e.props.sticky === !0 || e.props.sticky === u;
    }
    var s = null,
      a = null;
    function l() {
      var u = i("reference") ? o().getBoundingClientRect() : null,
        c = i("popper") ? r.getBoundingClientRect() : null;
      ((u && Qg(s, u)) || (c && Qg(a, c))) &&
        e.popperInstance &&
        e.popperInstance.update(),
        (s = u),
        (a = c),
        e.state.isMounted && requestAnimationFrame(l);
    }
    return {
      onMount: function () {
        e.props.sticky && l();
      },
    };
  },
};
function Qg(t, e) {
  return t && e
    ? t.top !== e.top ||
        t.right !== e.right ||
        t.bottom !== e.bottom ||
        t.left !== e.left
    : !0;
}
Ro.setDefaultProps({
  render: d3,
});
let wD = class {
  constructor({
    editor: e,
    element: n,
    view: r,
    tippyOptions: o = {},
    updateDelay: i = 250,
    shouldShow: s,
  }) {
    (this.preventHide = !1),
      (this.shouldShow = ({ view: a, state: l, from: u, to: c }) => {
        const { doc: d, selection: f } = l,
          { empty: p } = f,
          h = !d.textBetween(u, c).length && Ia(l.selection),
          m = this.element.contains(document.activeElement);
        return !(!(a.hasFocus() || m) || p || h || !this.editor.isEditable);
      }),
      (this.mousedownHandler = () => {
        this.preventHide = !0;
      }),
      (this.dragstartHandler = () => {
        this.hide();
      }),
      (this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      }),
      (this.blurHandler = ({ event: a }) => {
        var l;
        if (this.preventHide) {
          this.preventHide = !1;
          return;
        }
        (a != null &&
          a.relatedTarget &&
          !((l = this.element.parentNode) === null || l === void 0) &&
          l.contains(a.relatedTarget)) ||
          ((a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom &&
            this.hide());
      }),
      (this.tippyBlurHandler = (a) => {
        this.blurHandler({ event: a });
      }),
      (this.handleDebouncedUpdate = (a, l) => {
        const u = !(l != null && l.selection.eq(a.state.selection)),
          c = !(l != null && l.doc.eq(a.state.doc));
        (!u && !c) ||
          (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer),
          (this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, u, c, l);
          }, this.updateDelay)));
      }),
      (this.updateHandler = (a, l, u, c) => {
        var d, f, p;
        const { state: h, composing: m } = a,
          { selection: g } = h;
        if (m || (!l && !u)) return;
        this.createTooltip();
        const { ranges: _ } = g,
          v = Math.min(..._.map((x) => x.$from.pos)),
          y = Math.max(..._.map((x) => x.$to.pos));
        if (
          !((d = this.shouldShow) === null || d === void 0
            ? void 0
            : d.call(this, {
                editor: this.editor,
                element: this.element,
                view: a,
                state: h,
                oldState: c,
                from: v,
                to: y,
              }))
        ) {
          this.hide();
          return;
        }
        (f = this.tippy) === null ||
          f === void 0 ||
          f.setProps({
            getReferenceClientRect:
              ((p = this.tippyOptions) === null || p === void 0
                ? void 0
                : p.getReferenceClientRect) ||
              (() => {
                if (Mu(h.selection)) {
                  let x = a.nodeDOM(v);
                  if (x) {
                    const M = x.dataset.nodeViewWrapper
                      ? x
                      : x.querySelector("[data-node-view-wrapper]");
                    if ((M && (x = M.firstChild), x))
                      return x.getBoundingClientRect();
                  }
                }
                return d0(a, v, y);
              }),
          }),
          this.show();
      }),
      (this.editor = e),
      (this.element = n),
      (this.view = r),
      (this.updateDelay = i),
      s && (this.shouldShow = s),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.addEventListener("dragstart", this.dragstartHandler),
      this.editor.on("focus", this.focusHandler),
      this.editor.on("blur", this.blurHandler),
      (this.tippyOptions = o),
      this.element.remove(),
      (this.element.style.visibility = "visible");
  }
  createTooltip() {
    const { element: e } = this.editor.options,
      n = !!e.parentElement;
    this.tippy ||
      !n ||
      ((this.tippy = Ro(e, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle",
        ...this.tippyOptions,
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
  }
  update(e, n) {
    const { state: r } = e,
      o = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && o) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const i = !(n != null && n.selection.eq(e.state.selection)),
      s = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, i, s, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) &&
      e.popper.firstChild &&
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      ),
      (n = this.tippy) === null || n === void 0 || n.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler),
      this.editor.off("focus", this.focusHandler),
      this.editor.off("blur", this.blurHandler);
  }
};
const f3 = (t) =>
  new be({
    key: typeof t.pluginKey == "string" ? new ke(t.pluginKey) : t.pluginKey,
    view: (e) => new wD({ view: e, ...t }),
  });
Ne.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null,
    };
  },
  addProseMirrorPlugins() {
    return this.options.element
      ? [
          f3({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow,
          }),
        ]
      : [];
  },
});
class CD {
  getTextContent(e) {
    return u0(e, { textSerializers: ud(this.editor.schema) });
  }
  constructor({
    editor: e,
    element: n,
    view: r,
    tippyOptions: o = {},
    shouldShow: i,
  }) {
    (this.preventHide = !1),
      (this.shouldShow = ({ view: s, state: a }) => {
        const { selection: l } = a,
          { $anchor: u, empty: c } = l,
          d = u.depth === 1,
          f =
            u.parent.isTextblock &&
            !u.parent.type.spec.code &&
            !u.parent.textContent &&
            u.parent.childCount === 0 &&
            !this.getTextContent(u.parent);
        return !(!s.hasFocus() || !c || !d || !f || !this.editor.isEditable);
      }),
      (this.mousedownHandler = () => {
        this.preventHide = !0;
      }),
      (this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      }),
      (this.blurHandler = ({ event: s }) => {
        var a;
        if (this.preventHide) {
          this.preventHide = !1;
          return;
        }
        (s != null &&
          s.relatedTarget &&
          !((a = this.element.parentNode) === null || a === void 0) &&
          a.contains(s.relatedTarget)) ||
          ((s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom &&
            this.hide());
      }),
      (this.tippyBlurHandler = (s) => {
        this.blurHandler({ event: s });
      }),
      (this.editor = e),
      (this.element = n),
      (this.view = r),
      i && (this.shouldShow = i),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.editor.on("focus", this.focusHandler),
      this.editor.on("blur", this.blurHandler),
      (this.tippyOptions = o),
      this.element.remove(),
      (this.element.style.visibility = "visible");
  }
  createTooltip() {
    const { element: e } = this.editor.options,
      n = !!e.parentElement;
    this.tippy ||
      !n ||
      ((this.tippy = Ro(e, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "right",
        hideOnClick: "toggle",
        ...this.tippyOptions,
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
  }
  update(e, n) {
    var r, o, i;
    const { state: s } = e,
      { doc: a, selection: l } = s,
      { from: u, to: c } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l)) return;
    if (
      (this.createTooltip(),
      !((r = this.shouldShow) === null || r === void 0
        ? void 0
        : r.call(this, {
            editor: this.editor,
            view: e,
            state: s,
            oldState: n,
          })))
    ) {
      this.hide();
      return;
    }
    (o = this.tippy) === null ||
      o === void 0 ||
      o.setProps({
        getReferenceClientRect:
          ((i = this.tippyOptions) === null || i === void 0
            ? void 0
            : i.getReferenceClientRect) || (() => d0(e, u, c)),
      }),
      this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) &&
      e.popper.firstChild &&
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      ),
      (n = this.tippy) === null || n === void 0 || n.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.editor.off("focus", this.focusHandler),
      this.editor.off("blur", this.blurHandler);
  }
}
const p3 = (t) =>
  new be({
    key: typeof t.pluginKey == "string" ? new ke(t.pluginKey) : t.pluginKey,
    view: (e) => new CD({ view: e, ...t }),
  });
Ne.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null,
    };
  },
  addProseMirrorPlugins() {
    return this.options.element
      ? [
          p3({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow,
          }),
        ]
      : [];
  },
});
const rU = se({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu",
    },
    editor: {
      type: Object,
      required: !0,
    },
    updateDelay: {
      type: Number,
      default: void 0,
    },
    tippyOptions: {
      type: Object,
      default: () => ({}),
    },
    shouldShow: {
      type: Function,
      default: null,
    },
  },
  setup(t, { slots: e }) {
    const n = Te(null);
    return (
      Wr(() => {
        const {
          updateDelay: r,
          editor: o,
          pluginKey: i,
          shouldShow: s,
          tippyOptions: a,
        } = t;
        o.registerPlugin(
          f3({
            updateDelay: r,
            editor: o,
            element: n.value,
            pluginKey: i,
            shouldShow: s,
            tippyOptions: a,
          })
        );
      }),
      Ca(() => {
        const { pluginKey: r, editor: o } = t;
        o.unregisterPlugin(r);
      }),
      () => {
        var r;
        return Zt(
          "div",
          { ref: n },
          (r = e.default) === null || r === void 0 ? void 0 : r.call(e)
        );
      }
    );
  },
});
function e2(t) {
  return Dx((e, n) => ({
    get() {
      return e(), t;
    },
    set(r) {
      (t = r),
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            n();
          });
        });
    },
  }));
}
class h3 extends VO {
  constructor(e = {}) {
    return (
      super(e),
      (this.contentComponent = null),
      (this.appContext = null),
      (this.reactiveState = e2(this.view.state)),
      (this.reactiveExtensionStorage = e2(this.extensionStorage)),
      this.on("beforeTransaction", ({ nextState: n }) => {
        (this.reactiveState.value = n),
          (this.reactiveExtensionStorage.value = this.extensionStorage);
      }),
      k(this)
    );
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage
      ? this.reactiveExtensionStorage.value
      : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const r = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const AD = se({
    name: "EditorContent",
    props: {
      editor: {
        default: null,
        type: Object,
      },
    },
    setup(t) {
      const e = Te(),
        n = Lc();
      return (
        Tx(() => {
          const r = t.editor;
          r &&
            r.options.element &&
            e.value &&
            fh(() => {
              if (!e.value || !r.options.element.firstChild) return;
              const o = I(e.value);
              e.value.append(...r.options.element.childNodes),
                (r.contentComponent = n.ctx._),
                n &&
                  (r.appContext = {
                    ...n.appContext,
                    // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
                    // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
                    // @ts-expect-error forward instance's 'provides' into appContext
                    provides: n.provides,
                  }),
                r.setOptions({
                  element: o,
                }),
                r.createNodeViews();
            });
        }),
        Ca(() => {
          const r = t.editor;
          r && ((r.contentComponent = null), (r.appContext = null));
        }),
        { rootEl: e }
      );
    },
    render() {
      return Zt("div", {
        ref: (t) => {
          this.rootEl = t;
        },
      });
    },
  }),
  oU = se({
    name: "FloatingMenu",
    props: {
      pluginKey: {
        // TODO: TypeScript breaks :(
        // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
        type: null,
        default: "floatingMenu",
      },
      editor: {
        type: Object,
        required: !0,
      },
      tippyOptions: {
        type: Object,
        default: () => ({}),
      },
      shouldShow: {
        type: Function,
        default: null,
      },
    },
    setup(t, { slots: e }) {
      const n = Te(null);
      return (
        Wr(() => {
          const { pluginKey: r, editor: o, tippyOptions: i, shouldShow: s } = t;
          o.registerPlugin(
            p3({
              pluginKey: r,
              editor: o,
              element: n.value,
              tippyOptions: i,
              shouldShow: s,
            })
          );
        }),
        Ca(() => {
          const { pluginKey: r, editor: o } = t;
          o.unregisterPlugin(r);
        }),
        () => {
          var r;
          return Zt(
            "div",
            { ref: n },
            (r = e.default) === null || r === void 0 ? void 0 : r.call(e)
          );
        }
      );
    },
  }),
  SD = se({
    name: "NodeViewContent",
    props: {
      as: {
        type: String,
        default: "div",
      },
    },
    render() {
      return Zt(this.as, {
        style: {
          whiteSpace: "pre-wrap",
        },
        "data-node-view-content": "",
      });
    },
  }),
  Ha = se({
    name: "NodeViewWrapper",
    props: {
      as: {
        type: String,
        default: "div",
      },
    },
    inject: ["onDragStart", "decorationClasses"],
    render() {
      var t, e;
      return Zt(
        this.as,
        {
          // @ts-ignore
          class: this.decorationClasses,
          style: {
            whiteSpace: "normal",
          },
          "data-node-view-wrapper": "",
          // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
          onDragstart: this.onDragStart,
        },
        (e = (t = this.$slots).default) === null || e === void 0
          ? void 0
          : e.call(t)
      );
    },
  }),
  iU = (t = {}) => {
    const e = gb();
    return (
      Wr(() => {
        e.value = new h3(t);
      }),
      Ca(() => {
        var n, r, o;
        const i =
            (n = e.value) === null || n === void 0 ? void 0 : n.options.element,
          s = i == null ? void 0 : i.cloneNode(!0);
        (r = i == null ? void 0 : i.parentNode) === null ||
          r === void 0 ||
          r.replaceChild(s, i),
          (o = e.value) === null || o === void 0 || o.destroy();
      }),
      e
    );
  };
class m3 {
  constructor(e, { props: n = {}, editor: r }) {
    (this.editor = r),
      (this.component = k(e)),
      (this.el = document.createElement("div")),
      (this.props = Ox(n)),
      (this.renderedComponent = this.renderComponent());
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, r, o;
    return !(
      (n =
        (e = this.renderedComponent.vNode) === null || e === void 0
          ? void 0
          : e.component) === null || n === void 0
    ) && n.exposed
      ? this.renderedComponent.vNode.component.exposed
      : (o =
          (r = this.renderedComponent.vNode) === null || r === void 0
            ? void 0
            : r.component) === null || o === void 0
      ? void 0
      : o.proxy;
  }
  renderComponent() {
    let e = Zt(this.component, this.props);
    return (
      this.editor.appContext && (e.appContext = this.editor.appContext),
      typeof document < "u" && this.el && Ws(e, this.el),
      {
        vNode: e,
        destroy: () => {
          this.el && Ws(null, this.el), (this.el = null), (e = null);
        },
        el: this.el ? this.el.firstElementChild : null,
      }
    );
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, r]) => {
      this.props[n] = r;
    }),
      this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const sU = {
  editor: {
    type: Object,
    required: !0,
  },
  node: {
    type: Object,
    required: !0,
  },
  decorations: {
    type: Object,
    required: !0,
  },
  selected: {
    type: Boolean,
    required: !0,
  },
  extension: {
    type: Object,
    required: !0,
  },
  getPos: {
    type: Function,
    required: !0,
  },
  updateAttributes: {
    type: Function,
    required: !0,
  },
  deleteNode: {
    type: Function,
    required: !0,
  },
  view: {
    type: Object,
    required: !0,
  },
  innerDecorations: {
    type: Object,
    required: !0,
  },
  HTMLAttributes: {
    type: Object,
    required: !0,
  },
};
class ED extends jO {
  mount() {
    const e = {
        editor: this.editor,
        node: this.node,
        decorations: this.decorations,
        innerDecorations: this.innerDecorations,
        view: this.view,
        selected: !1,
        extension: this.extension,
        HTMLAttributes: this.HTMLAttributes,
        getPos: () => this.getPos(),
        updateAttributes: (o = {}) => this.updateAttributes(o),
        deleteNode: () => this.deleteNode(),
      },
      n = this.onDragStart.bind(this);
    this.decorationClasses = Te(this.getDecorationClasses());
    const r = se({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (o) => {
        var i, s;
        return (
          V0("onDragStart", n),
          V0("decorationClasses", this.decorationClasses),
          (s = (i = this.component).setup) === null || s === void 0
            ? void 0
            : s.call(i, o, {
                expose: () => {},
              })
        );
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file,
    });
    (this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)),
      this.editor.on("selectionUpdate", this.handleSelectionUpdate),
      (this.renderer = new m3(r, {
        editor: this.editor,
        props: e,
      }));
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (
      !this.renderer.element ||
      !this.renderer.element.hasAttribute("data-node-view-wrapper")
    )
      throw Error(
        "Please use the NodeViewWrapper component for your node view."
      );
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf
      ? null
      : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection,
      r = this.getPos();
    if (typeof r == "number")
      if (e <= r && n >= r + this.node.nodeSize) {
        if (this.renderer.props.selected) return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected) return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, r) {
    const o = (i) => {
      (this.decorationClasses.value = this.getDecorationClasses()),
        this.renderer.updateProps(i);
    };
    if (typeof this.options.update == "function") {
      const i = this.node,
        s = this.decorations,
        a = this.innerDecorations;
      return (
        (this.node = e),
        (this.decorations = n),
        (this.innerDecorations = r),
        this.options.update({
          oldNode: i,
          oldDecorations: s,
          newNode: e,
          newDecorations: n,
          oldInnerDecorations: a,
          innerDecorations: r,
          updateProps: () =>
            o({ node: e, decorations: n, innerDecorations: r }),
        })
      );
    }
    return e.type !== this.node.type
      ? !1
      : ((e === this.node &&
          this.decorations === n &&
          this.innerDecorations === r) ||
          ((this.node = e),
          (this.decorations = n),
          (this.innerDecorations = r),
          o({ node: e, decorations: n, innerDecorations: r })),
        !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0,
    }),
      this.renderer.element &&
        this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1,
    }),
      this.renderer.element &&
        this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations
      .map((e) => e.type.attrs.class)
      .flat()
      .join(" ");
  }
  destroy() {
    this.renderer.destroy(),
      this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Fa(t, e) {
  return (n) => {
    if (!n.editor.contentComponent) return {};
    const r = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
    return new ED(r, n, e);
  };
}
const Ci = [];
class MD {
  constructor({
    editor: e,
    element: n,
    view: r,
    tippyOptions: o = {},
    shouldShow: i,
    getRenderContainer: s,
    defaultAnimation: a = !0,
  }) {
    ue(this, "editor");
    ue(this, "element");
    ue(this, "view");
    ue(this, "preventHide", !1);
    ue(this, "tippy");
    ue(this, "tippyOptions");
    ue(this, "getRenderContainer");
    ue(this, "defaultAnimation");
    ue(this, "shouldShow", ({ view: e, state: n, from: r, to: o }) => {
      const { doc: i, selection: s } = n,
        { empty: a } = s,
        l = !i.textBetween(r || 0, o || 0).length && Ia(s);
      return !(!e.hasFocus() || a || l);
    });
    ue(this, "mousedownHandler", () => {
      this.preventHide = !0;
    });
    ue(this, "dragstartHandler", () => {
      this.hide();
    });
    ue(this, "blurHandler", ({ event: e }) => {
      var r, o;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      (e != null &&
        e.relatedTarget &&
        (r = this.element.parentNode) != null &&
        r.contains(e.relatedTarget)) ||
        (this.editor.isEditable &&
          (o = this.shouldShow) != null &&
          o.call(this, {
            editor: this.editor,
            state: this.editor.state,
          })) ||
        this.hide();
    });
    ue(this, "addActiveBubbleMenu", () => {
      Ci.findIndex((n) => {
        var r;
        return (
          (n == null ? void 0 : n.id) ===
          ((r = this.tippy) == null ? void 0 : r.id)
        );
      }) < 0 && Ci.push(this.tippy);
    });
    ue(this, "removeActiveBubbleMenu", () => {
      const e = Ci.findIndex((n) => {
        var r;
        return (
          (n == null ? void 0 : n.id) ===
          ((r = this.tippy) == null ? void 0 : r.id)
        );
      });
      e > -1 && Ci.splice(e, 1);
    });
    (this.editor = e),
      (this.element = n),
      (this.view = r),
      (this.getRenderContainer = s),
      (this.defaultAnimation = a),
      i && (this.shouldShow = i),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.addEventListener("dragstart", this.dragstartHandler),
      (this.tippyOptions = o || {}),
      this.element.remove(),
      (this.element.style.visibility = "visible");
  }
  createTooltip() {
    const { element: e } = this.editor.options,
      n = !!e.parentElement;
    this.tippy ||
      !n ||
      ((this.tippy = Ro(e, {
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "bottom-start",
        hideOnClick: "toggle",
        plugins: [kD],
        popperOptions: {
          modifiers: [
            {
              name: "customWidth",
              enabled: !0,
              phase: "beforeWrite",
              requires: ["computeStyles"],
              fn({ state: r }) {
                r.styles.popper.maxWidth = "98%";
              },
            },
          ],
        },
        ...Object.assign(
          {
            zIndex: 999,
            ...(this.defaultAnimation
              ? {
                  animation: "shift-toward-subtle",
                  moveTransition: "transform 0.2s ease-in-out",
                }
              : {}),
            fixed: !0,
          },
          this.tippyOptions
        ),
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener("blur", (r) => {
          this.blurHandler({ event: r });
        }));
  }
  update(e, n) {
    var w, x, M, N, T, P;
    const { state: r, composing: o } = e,
      { doc: i, selection: s } = r,
      a = n && n.doc.eq(i) && n.selection.eq(s);
    if (o || a) return;
    const { ranges: l } = s,
      u = Math.min(...l.map((z) => z.$from.pos)),
      c = Math.max(...l.map((z) => z.$to.pos)),
      d = e.domAtPos(u).node,
      p = e.nodeDOM(u) || d;
    if (
      !(
        this.editor.isEditable &&
        ((w = this.shouldShow) == null
          ? void 0
          : w.call(this, {
              editor: this.editor,
              view: e,
              node: p,
              state: r,
              oldState: n,
              from: u,
              to: c,
            }))
      )
    ) {
      this.hide();
      return;
    }
    this.createTooltip();
    const m = s.$anchor.pos,
      g =
        (x = this.tippyOptions) != null && x.placement
          ? (M = this.tippyOptions) == null
            ? void 0
            : M.placement
          : Mu(s)
          ? Ci.length > 1
            ? "bottom"
            : "top"
          : ((N = this.tippy) != null && N.props.fixed) ||
            Math.abs(m - c) <= Math.abs(m - u)
          ? "bottom-start"
          : "top-start",
      b = Ci.filter((z) => {
        var H;
        return (
          z.id !== ((H = this.tippy) == null ? void 0 : H.id) &&
          z.popperInstance &&
          z.popperInstance.state
        );
      }),
      _ = (T = this.tippyOptions) == null ? void 0 : T.offset,
      v = (_ == null ? void 0 : _[0]) ?? 0;
    let y = b.length
      ? b.reduce((z, H, U, re) => {
          var fe, Le, We, Ee, ze, Ge, Qe, He, qe, yt, nt, Ct, ut;
          const te = re[U - 1]
              ? ((ze =
                  (Ee =
                    (We =
                      (Le =
                        (fe = re[U - 1]) == null
                          ? void 0
                          : fe.popperInstance) == null
                        ? void 0
                        : Le.state) == null
                      ? void 0
                      : We.modifiersData) == null
                    ? void 0
                    : Ee.popperOffsets) == null
                  ? void 0
                  : ze.y) ?? 0
              : 0,
            Q =
              ((qe =
                (He =
                  (Qe =
                    (Ge = H == null ? void 0 : H.popperInstance) == null
                      ? void 0
                      : Ge.state) == null
                    ? void 0
                    : Qe.modifiersData) == null
                  ? void 0
                  : He.popperOffsets) == null
                ? void 0
                : qe.y) ?? 0,
            ne =
              ((ut =
                (Ct =
                  (nt =
                    (yt = H == null ? void 0 : H.popperInstance) == null
                      ? void 0
                      : yt.state) == null
                    ? void 0
                    : nt.rects) == null
                  ? void 0
                  : Ct.popper) == null
                ? void 0
                : ut.height) ?? 10;
          return Math.abs(te - Q) <= ne && (z += ne), z;
        }, 0)
      : (_ == null ? void 0 : _[1]) ?? 10;
    y || (y = 10),
      (P = this.tippy) == null ||
        P.setProps({
          offset: [v, y],
          placement: g,
          getReferenceClientRect: () => {
            let z = null;
            return (
              Mu(r.selection) &&
                this.getRenderContainer &&
                p &&
                (z = this.getRenderContainer(p)),
              this.getRenderContainer && p && (z = this.getRenderContainer(p)),
              z && z.getBoundingClientRect
                ? z.getBoundingClientRect()
                : p && p.getBoundingClientRect
                ? p.getBoundingClientRect()
                : d0(e, u, c)
            );
          },
        }),
      this.show();
  }
  show() {
    var e;
    this.addActiveBubbleMenu(), (e = this.tippy) == null || e.show();
  }
  hide() {
    var e;
    this.removeActiveBubbleMenu(), (e = this.tippy) == null || e.hide();
  }
  destroy() {
    var e;
    this.removeActiveBubbleMenu(),
      (e = this.tippy) == null || e.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
  }
}
const TD = (t) =>
    new be({
      key: typeof t.pluginKey == "string" ? new ke(t.pluginKey) : t.pluginKey,
      view: (e) => new MD({ view: e, ...t }),
    }),
  OD = /* @__PURE__ */ se({
    __name: "BubbleMenu",
    props: {
      pluginKey: {
        type: [String, Object],
        default: "bubbleMenu",
      },
      editor: {
        type: Object,
        required: !0,
      },
      tippyOptions: {
        type: Object,
        default: () => ({}),
      },
      shouldShow: {
        type: Function,
        default: null,
      },
      getRenderContainer: {
        type: Function,
        default: null,
      },
      defaultAnimation: {
        type: Boolean,
        default: !0,
      },
    },
    setup(t) {
      const e = t,
        n = Te(null);
      return (
        Wr(() => {
          const {
            editor: r,
            pluginKey: o,
            shouldShow: i,
            tippyOptions: s,
            getRenderContainer: a,
            defaultAnimation: l,
          } = e;
          r.registerPlugin(
            TD({
              editor: r,
              element: n.value,
              pluginKey: o,
              shouldShow: i,
              tippyOptions: s,
              getRenderContainer: a,
              defaultAnimation: l,
            })
          );
        }),
        Ca(() => {
          const { pluginKey: r, editor: o } = e;
          o.unregisterPlugin(r);
        }),
        (r, o) => (
          S(),
          O(
            "div",
            {
              ref_key: "root",
              ref: n,
            },
            [Kn(r.$slots, "default")],
            512
          )
        )
      );
    },
  }),
  DD = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function ND(t, e) {
  return (
    S(),
    O(
      "svg",
      DD,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m7 10l5 5l5-5z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const LD = k({ name: "mdi-menu-down", render: ND }),
  RD = ["disabled"],
  Xe = /* @__PURE__ */ se({
    __name: "ToolbarItem",
    props: {
      isActive: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      title: { default: void 0 },
      action: { type: Function, default: void 0 },
      icon: { default: void 0 },
      children: { default: void 0 },
    },
    setup(t) {
      return (e, n) => {
        var r;
        return je(
          (S(),
          O(
            "button",
            {
              class: $e([
                [
                  { "bg-gray-200/70": e.isActive },
                  { "cursor-not-allowed opacity-70": e.disabled },
                  { "hover:bg-gray-100": !e.disabled },
                ],
                "inline-flex items-center space-x-1 p-1.5 rounded-md",
              ]),
              disabled: e.disabled,
              tabindex: "-1",
              onClick:
                n[0] ||
                (n[0] = //@ts-ignore
                  (...o) => e.action && e.action(...o)),
            },
            [
              (S(), de(wn(e.icon))),
              (r = e.children) != null && r.length
                ? (S(), de(I(LD), { key: 0 }))
                : un("", !0),
            ],
            10,
            RD
          )),
          [[I(Sa), e.title]]
        );
      };
    },
  }),
  Ut = /* @__PURE__ */ se({
    __name: "ToolbarSubItem",
    props: {
      isActive: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      title: { default: void 0 },
      action: { type: Function, default: void 0 },
      icon: { default: void 0 },
    },
    setup(t) {
      const e = t,
        n = () => {
          var r;
          e.disabled || (r = e.action) == null || r.call(e);
        };
      return (r, o) => (
        S(),
        O(
          "div",
          {
            class: $e([
              [
                { "!bg-gray-100": r.isActive },
                { "cursor-not-allowed opacity-70 ": r.disabled },
                { "hover:bg-gray-100": !r.disabled },
              ],
              "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer",
            ]),
            onClick: n,
          },
          [
            (S(),
            de(
              wn(r.icon),
              {
                class: $e([
                  "bg-gray-100 p-1.5 rounded w-7 h-7",
                  [
                    { "!bg-white": r.isActive },
                    { "group-hover:bg-white": !r.disabled },
                  ],
                ]),
              },
              null,
              8,
              ["class"]
            )),
            C(
              "span",
              {
                class: $e([
                  "text-sm text-gray-600",
                  [
                    { "!text-gray-900 !font-medium": r.isActive },
                    {
                      "group-hover:font-medium group-hover:text-gray-900":
                        !r.disabled,
                    },
                  ],
                ]),
              },
              it(r.title),
              3
            ),
          ],
          2
        )
      );
    },
  }),
  ID = { class: "flex flex-col gap-0.5" },
  PD = {
    class:
      "text-sm text-gray-600 group-hover:font-medium group-hover:text-gray-900",
  },
  $D = {
    key: 0,
    class: "text-xs text-gray-500",
  },
  gi = /* @__PURE__ */ se({
    __name: "ToolboxItem",
    props: {
      editor: { default: void 0 },
      title: { default: void 0 },
      description: { default: void 0 },
      action: { type: Function, default: void 0 },
      icon: { default: void 0 },
    },
    setup(t) {
      const e = t,
        n = () => {
          var r;
          (r = e.action) == null || r.call(e);
        };
      return (r, o) => (
        S(),
        O(
          "div",
          {
            class:
              "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer hover:bg-gray-100",
            onClick: n,
          },
          [
            (S(),
            de(wn(r.icon), {
              class: "bg-gray-100 p-1.5 rounded w-7 h-7 group-hover:bg-white",
            })),
            C("div", ID, [
              C("span", PD, it(r.title), 1),
              r.description
                ? (S(), O("span", $D, it(r.description), 1))
                : un("", !0),
            ]),
          ]
        )
      );
    },
  }),
  BD = {
    class:
      "bubble-menu bg-white flex items-center rounded-md p-1 border shadow space-x-1",
  },
  HD = /* @__PURE__ */ se({
    __name: "EditorBubbleMenu",
    props: {
      editor: {
        type: Object,
        required: !0,
      },
    },
    setup(t) {
      const e = t,
        n = () => {
          var i;
          return (
            (i = e.editor) == null ? void 0 : i.extensionManager
          ).extensions
            .map((s) => {
              const { getBubbleMenu: a } = s.options;
              if (!a) return null;
              const l = a({
                editor: e.editor,
              });
              return (
                l.items &&
                  (l.items = l.items.sort((u, c) => u.priority - c.priority)),
                l
              );
            })
            .filter(Boolean);
        },
        r = (o, i) => {
          var s;
          return o.editor.isEditable
            ? (s = i.shouldShow) == null
              ? void 0
              : s.call(i, o)
            : !1;
        };
      return (o, i) => (
        S(!0),
        O(
          gt,
          null,
          Fr(
            n(),
            (s, a) => (
              S(),
              de(
                OD,
                {
                  key: a,
                  "plugin-key": s == null ? void 0 : s.pluginKey,
                  "should-show": (l) => r(l, s),
                  editor: t.editor,
                  "tippy-options": {
                    maxWidth: "100%",
                    ...s.tippyOptions,
                  },
                  "get-render-container": s.getRenderContainer,
                  "default-animation": s.defaultAnimation,
                },
                {
                  default: me(() => [
                    C("div", BD, [
                      s.items
                        ? (S(!0),
                          O(
                            gt,
                            { key: 0 },
                            Fr(
                              s.items,
                              (l, u) => (
                                S(),
                                O(
                                  gt,
                                  { key: u },
                                  [
                                    l.component
                                      ? (S(),
                                        de(
                                          wn(l.component),
                                          Fn(
                                            {
                                              key: 0,
                                              ref_for: !0,
                                            },
                                            l.props,
                                            { editor: t.editor }
                                          ),
                                          null,
                                          16,
                                          ["editor"]
                                        ))
                                      : (S(),
                                        de(
                                          Th,
                                          Fn(
                                            {
                                              key: 1,
                                              editor: t.editor,
                                              ref_for: !0,
                                            },
                                            l.props
                                          ),
                                          null,
                                          16,
                                          ["editor"]
                                        )),
                                  ],
                                  64
                                )
                              )
                            ),
                            128
                          ))
                        : s.component
                        ? (S(),
                          de(
                            wn(s == null ? void 0 : s.component),
                            {
                              key: 1,
                              editor: t.editor,
                            },
                            null,
                            8,
                            ["editor"]
                          ))
                        : un("", !0),
                    ]),
                  ]),
                  _: 2,
                },
                1032,
                [
                  "plugin-key",
                  "should-show",
                  "editor",
                  "tippy-options",
                  "get-render-container",
                  "default-animation",
                ]
              )
            )
          ),
          128
        )
      );
    },
  }),
  FD = /* @__PURE__ */ _h(HD, [["__scopeId", "data-v-c5e57b44"]]),
  zD = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function VD(t, e) {
  return (
    S(),
    O(
      "svg",
      zD,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4m-5-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const UD = k({ name: "mdi-plus-circle", render: VD }),
  jD = {
    class:
      "editor-header py-1 space-x-1 px-1 overflow-auto border-t shadow-sm bg-white text-center",
  },
  WD = { class: "h-full inline-flex items-center" },
  qD = {
    class: "p-1.5 rounded-md hover:bg-gray-100",
    tabindex: "-1",
  },
  KD = {
    class:
      "relative rounded-md bg-white overflow-hidden shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5",
  },
  GD = {
    class:
      "relative rounded-md bg-white overflow-hidden shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5",
  },
  JD = /* @__PURE__ */ se({
    __name: "EditorHeader",
    props: {
      editor: {
        type: h3,
        required: !0,
      },
    },
    setup(t) {
      const e = t;
      function n() {
        var i;
        return ((i = e.editor) == null ? void 0 : i.extensionManager).extensions
          .reduce((s, a) => {
            const { getToolbarItems: l } = a.options;
            if (!l) return s;
            const u = l({
              editor: e.editor,
            });
            return Array.isArray(u) ? [...s, ...u] : [...s, u];
          }, [])
          .sort((s, a) => s.priority - a.priority);
      }
      function r() {
        var i;
        return ((i = e.editor) == null ? void 0 : i.extensionManager).extensions
          .reduce((s, a) => {
            const { getToolboxItems: l } = a.options;
            if (!l) return s;
            const u = l({
              editor: e.editor,
            });
            return Array.isArray(u) ? [...s, ...u] : [...s, u];
          }, [])
          .sort((s, a) => s.priority - a.priority);
      }
      return (o, i) => (
        S(),
        O("div", jD, [
          C("div", WD, [
            J(I(ii), null, {
              popper: me(() => [
                C("div", KD, [
                  (S(!0),
                  O(
                    gt,
                    null,
                    Fr(
                      r(),
                      (s, a) => (
                        S(),
                        de(
                          wn(s.component),
                          Fn({ ref_for: !0 }, s.props, {
                            key: a,
                            tabindex: "-1",
                          }),
                          null,
                          16
                        )
                      )
                    ),
                    128
                  )),
                ]),
              ]),
              default: me(() => [
                C("button", qD, [J(I(UD), { class: "text-[#4CCBA0]" })]),
              ]),
              _: 1,
            }),
            i[0] ||
              (i[0] = C(
                "div",
                { class: "h-5 bg-gray-100 w-[1px] !mx-1" },
                null,
                -1
              )),
            (S(!0),
            O(
              gt,
              null,
              Fr(n(), (s, a) => {
                var l;
                return (
                  S(),
                  O("div", { key: a }, [
                    (l = s.children) != null && l.length
                      ? (S(),
                        de(
                          I(ii),
                          {
                            key: 1,
                            class: "inline-flex",
                            tabindex: "-1",
                            triggers: ["click"],
                            "popper-triggers": ["click"],
                          },
                          {
                            popper: me(() => [
                              C("div", GD, [
                                (S(!0),
                                O(
                                  gt,
                                  null,
                                  Fr(
                                    s.children,
                                    (u, c) => (
                                      S(),
                                      de(
                                        wn(u.component),
                                        Fn({ ref_for: !0 }, u.props, {
                                          key: c,
                                          tabindex: "-1",
                                        }),
                                        null,
                                        16
                                      )
                                    )
                                  ),
                                  128
                                )),
                              ]),
                            ]),
                            default: me(() => [
                              (S(),
                              de(
                                wn(s.component),
                                Fn({ ref_for: !0 }, s.props, {
                                  children: s.children,
                                  tabindex: "-1",
                                }),
                                null,
                                16,
                                ["children"]
                              )),
                            ]),
                            _: 2,
                          },
                          1024
                        ))
                      : (S(),
                        de(
                          wn(s.component),
                          Fn(
                            {
                              key: 0,
                              ref_for: !0,
                            },
                            s.props,
                            { tabindex: "-1" }
                          ),
                          null,
                          16
                        )),
                  ])
                );
              }),
              128
            )),
          ]),
        ])
      );
    },
  }),
  YD = {
    key: 0,
    class: "halo-rich-text-editor flex flex-col",
  },
  XD = { class: "overflow-y-auto flex-1 min-h-0 shrink bg-white relative" },
  ZD = {
    key: 0,
    class: "editor-header-extra",
  },
  QD = { class: "flex-none" },
  eN = /* @__PURE__ */ se({
    __name: "Editor",
    props: {
      editor: {
        type: Object,
        required: !0,
      },
      contentStyles: {
        type: Object,
        required: !1,
        default: () => ({}),
      },
      locale: {
        type: String,
        required: !1,
        default: "zh-CN",
      },
    },
    setup(t) {
      const e = t;
      return (
        jt(
          () => e.locale,
          () => {
            D.global.locale.value = e.locale;
          },
          {
            immediate: !0,
          }
        ),
        (n, r) =>
          t.editor
            ? (S(),
              O("div", YD, [
                J(FD, { editor: t.editor }, null, 8, ["editor"]),
                C("div", XD, [
                  n.$slots.content
                    ? (S(), O("div", ZD, [Kn(n.$slots, "content")]))
                    : un("", !0),
                  J(
                    I(AD),
                    {
                      editor: t.editor,
                      style: mt(t.contentStyles),
                      class: "editor-content markdown-body relative",
                    },
                    null,
                    8,
                    ["editor", "style"]
                  ),
                ]),
                C("div", QD, [
                  J(JD, { editor: t.editor }, null, 8, ["editor"]),
                ]),
              ]))
            : un("", !0)
      );
    },
  }),
  tN = Ze.create({
    name: "doc",
    topNode: !0,
    content: "block+",
  }),
  nN = Ne.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: void 0,
      };
    },
    addProseMirrorPlugins() {
      return [EC(this.options)];
    },
  }),
  rN = Ze.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: !0,
        HTMLAttributes: {},
      };
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    linebreakReplacement: !0,
    parseHTML() {
      return [{ tag: "br" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["br", ge(this.options.HTMLAttributes, t)];
    },
    renderText() {
      return `
`;
    },
    addCommands() {
      return {
        setHardBreak:
          () =>
          ({ commands: t, chain: e, state: n, editor: r }) =>
            t.first([
              () => t.exitCode(),
              () =>
                t.command(() => {
                  const { selection: o, storedMarks: i } = n;
                  if (o.$from.parent.type.spec.isolating) return !1;
                  const { keepMarks: s } = this.options,
                    { splittableMarks: a } = r.extensionManager,
                    l = i || (o.$to.parentOffset && o.$from.marks());
                  return e()
                    .insertContent({ type: this.name })
                    .command(({ tr: u, dispatch: c }) => {
                      if (c && l && s) {
                        const d = l.filter((f) => a.includes(f.type.name));
                        u.ensureMarks(d);
                      }
                      return !0;
                    })
                    .run();
                }),
            ]),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak(),
      };
    },
  }),
  oN = Ze.create({
    name: "horizontalRule",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    group: "block",
    parseHTML() {
      return [{ tag: "hr" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["hr", ge(this.options.HTMLAttributes, t)];
    },
    addCommands() {
      return {
        setHorizontalRule:
          () =>
          ({ chain: t, state: e }) => {
            const { selection: n } = e,
              { $from: r, $to: o } = n,
              i = t();
            return (
              r.parentOffset === 0
                ? i.insertContentAt(
                    {
                      from: Math.max(r.pos - 1, 0),
                      to: o.pos,
                    },
                    {
                      type: this.name,
                    }
                  )
                : Mu(n)
                ? i.insertContentAt(o.pos, {
                    type: this.name,
                  })
                : i.insertContent({ type: this.name }),
              i
                .command(({ tr: s, dispatch: a }) => {
                  var l;
                  if (a) {
                    const { $to: u } = s.selection,
                      c = u.end();
                    if (u.nodeAfter)
                      u.nodeAfter.isTextblock
                        ? s.setSelection(q.create(s.doc, u.pos + 1))
                        : u.nodeAfter.isBlock
                        ? s.setSelection(Z.create(s.doc, u.pos))
                        : s.setSelection(q.create(s.doc, u.pos));
                    else {
                      const d =
                        (l = u.parent.type.contentMatch.defaultType) === null ||
                        l === void 0
                          ? void 0
                          : l.create();
                      d &&
                        (s.insert(c, d),
                        s.setSelection(q.create(s.doc, c + 1)));
                    }
                    s.scrollIntoView();
                  }
                  return !0;
                })
                .run()
            );
          },
      };
    },
    addInputRules() {
      return [
        Pa({
          find: /^(?:---|-|___\s|\*\*\*\s)$/,
          type: this.type,
        }),
      ];
    },
  }),
  iN = Ne.create({
    name: "placeholder",
    addOptions() {
      return {
        emptyEditorClass: "is-editor-empty",
        emptyNodeClass: "is-empty",
        placeholder: "Write something ",
        showOnlyWhenEditable: !0,
        showOnlyCurrent: !0,
        includeChildren: !1,
      };
    },
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("placeholder"),
          props: {
            decorations: ({ doc: t, selection: e }) => {
              const n =
                  this.editor.isEditable || !this.options.showOnlyWhenEditable,
                { anchor: r } = e,
                o = [];
              if (!n) return null;
              const i = this.editor.isEmpty;
              return (
                t.descendants((s, a) => {
                  const l = r >= a && r <= a + s.nodeSize,
                    u = !s.isLeaf && dd(s);
                  if ((l || !this.options.showOnlyCurrent) && u) {
                    const c = [this.options.emptyNodeClass];
                    i && c.push(this.options.emptyEditorClass);
                    const d = Ve.node(a, a + s.nodeSize, {
                      class: c.join(" "),
                      "data-placeholder":
                        typeof this.options.placeholder == "function"
                          ? this.options.placeholder({
                              editor: this.editor,
                              node: s,
                              pos: a,
                              hasAnchor: l,
                            })
                          : this.options.placeholder,
                    });
                    o.push(d);
                  }
                  return this.options.includeChildren;
                }),
                ve.create(t, o)
              );
            },
          },
        }),
      ];
    },
  }),
  sN = /^\s*>\s$/,
  aN = Ze.create({
    name: "blockquote",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
      return [{ tag: "blockquote" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["blockquote", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setBlockquote:
          () =>
          ({ commands: t }) =>
            t.wrapIn(this.name),
        toggleBlockquote:
          () =>
          ({ commands: t }) =>
            t.toggleWrap(this.name),
        unsetBlockquote:
          () =>
          ({ commands: t }) =>
            t.lift(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-b": () => this.editor.commands.toggleBlockquote(),
      };
    },
    addInputRules() {
      return [
        Gi({
          find: sN,
          type: this.type,
        }),
      ];
    },
  }),
  lN = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function uN(t, e) {
  return (
    S(),
    O(
      "svg",
      lN,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m10 7l-2 4h3v6H5v-6l2-4zm8 0l-2 4h3v6h-6v-6l2-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const cN = k({ name: "mdi-format-quote-open", render: uN }),
  dN = aN.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 90,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("blockquote"),
              icon: k(cN),
              title: D.global.t("editor.common.quote"),
              action: () => {
                e.commands.toggleBlockquote();
              },
            },
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && n.parentElement && n.tagName !== "BLOCKQUOTE"; )
                n = n.parentElement;
              return {
                el: n,
              };
            },
          };
        },
      };
    },
  }),
  fN = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
  pN = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
  hN = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
  mN = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
  gN = tn.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong",
        },
        {
          tag: "b",
          getAttrs: (t) => t.style.fontWeight !== "normal" && null,
        },
        {
          style: "font-weight=400",
          clearMark: (t) => t.type.name === this.name,
        },
        {
          style: "font-weight",
          getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["strong", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setBold:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleBold:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetBold:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold(),
      };
    },
    addInputRules() {
      return [
        ci({
          find: fN,
          type: this.type,
        }),
        ci({
          find: hN,
          type: this.type,
        }),
      ];
    },
    addPasteRules() {
      return [
        So({
          find: pN,
          type: this.type,
        }),
        So({
          find: mN,
          type: this.type,
        }),
      ];
    },
  }),
  bN = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function yN(t, e) {
  return (
    S(),
    O(
      "svg",
      bN,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13.5 15.5H10v-3h3.5A1.5 1.5 0 0 1 15 14a1.5 1.5 0 0 1-1.5 1.5m-3.5-9h3A1.5 1.5 0 0 1 14.5 8A1.5 1.5 0 0 1 13 9.5h-3m5.6 1.29c.97-.68 1.65-1.79 1.65-2.79c0-2.26-1.75-4-4-4H7v14h7.04c2.1 0 3.71-1.7 3.71-3.79c0-1.52-.86-2.82-2.15-3.42",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const g3 = k({ name: "mdi-format-bold", render: yN }),
  vN = gN.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 40,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("bold"),
              icon: k(g3),
              title: D.global.t("editor.common.bold"),
              action: () => {
                e.chain().focus().toggleBold().run();
              },
            },
          };
        },
      };
    },
  }),
  _N = "listItem",
  t2 = "textStyle",
  n2 = /^\s*([-+*])\s$/,
  xN = Ze.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [{ tag: "ul" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["ul", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        toggleBulletList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(_N, this.editor.getAttributes(t2))
                  .run()
              : t.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList(),
      };
    },
    addInputRules() {
      let t = Gi({
        find: n2,
        type: this.type,
      });
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = Gi({
            find: n2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(t2),
            editor: this.editor,
          })),
        [t]
      );
    },
  }),
  b3 = Ze.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList",
      };
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
      return [
        {
          tag: "li",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["li", ge(this.options.HTMLAttributes, t), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      };
    },
  }),
  kN = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function wN(t, e) {
  return (
    S(),
    O(
      "svg",
      kN,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M7 5h14v2H7zm0 8v-2h14v2zM4 4.5A1.5 1.5 0 0 1 5.5 6A1.5 1.5 0 0 1 4 7.5A1.5 1.5 0 0 1 2.5 6A1.5 1.5 0 0 1 4 4.5m0 6A1.5 1.5 0 0 1 5.5 12A1.5 1.5 0 0 1 4 13.5A1.5 1.5 0 0 1 2.5 12A1.5 1.5 0 0 1 4 10.5M7 19v-2h14v2zm-3-2.5A1.5 1.5 0 0 1 5.5 18A1.5 1.5 0 0 1 4 19.5A1.5 1.5 0 0 1 2.5 18A1.5 1.5 0 0 1 4 16.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const r2 = k({ name: "mdi-format-list-bulleted", render: wN }),
  CN = xN.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 130,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("bulletList"),
              icon: k(r2),
              title: D.global.t("editor.common.bullet_list"),
              action: () => e.chain().focus().toggleBulletList().run(),
            },
          };
        },
        getCommandMenuItems() {
          return {
            priority: 130,
            icon: k(r2),
            title: "editor.common.bullet_list",
            keywords: ["bulletlist", "wuxuliebiao"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).toggleBulletList().run();
            },
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && n.tagName !== "LI"; ) n = n.parentElement;
              return {
                el: n,
                dragDomOffset: {
                  x: -12,
                },
              };
            },
          };
        },
      };
    },
    addExtensions() {
      return [b3];
    },
  }),
  AN = /(^|[^`])`([^`]+)`(?!`)/,
  SN = /(^|[^`])`([^`]+)`(?!`)/g,
  EN = tn.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
      return [{ tag: "code" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["code", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setCode:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleCode:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetCode:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode(),
      };
    },
    addInputRules() {
      return [
        ci({
          find: AN,
          type: this.type,
        }),
      ];
    },
    addPasteRules() {
      return [
        So({
          find: SN,
          type: this.type,
        }),
      ];
    },
  }),
  MN = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function TN(t, e) {
  return (
    S(),
    O(
      "svg",
      MN,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m14.6 16.6l4.6-4.6l-4.6-4.6L16 6l6 6l-6 6zm-5.2 0L4.8 12l4.6-4.6L8 6l-6 6l6 6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const y3 = k({ name: "mdi-code-tags", render: TN }),
  ON = EN.extend({
    exitable: !0,
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 100,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("code"),
              icon: k(y3),
              title: D.global.t("editor.common.code"),
              action: () => e.chain().focus().toggleCode().run(),
            },
          };
        },
      };
    },
  }),
  DN = (t) => {
    if (!t.children.length) return;
    const e = t.querySelectorAll("span");
    e &&
      e.forEach((n) => {
        var r, o;
        const i = n.getAttribute("style"),
          s =
            (o =
              (r = n.parentElement) === null || r === void 0
                ? void 0
                : r.closest("span")) === null || o === void 0
              ? void 0
              : o.getAttribute("style");
        n.setAttribute("style", `${s};${i}`);
      });
  },
  NN = tn.create({
    name: "textStyle",
    priority: 101,
    addOptions() {
      return {
        HTMLAttributes: {},
        mergeNestedSpanStyles: !1,
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (t) =>
            t.hasAttribute("style")
              ? (this.options.mergeNestedSpanStyles && DN(t), {})
              : !1,
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["span", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        removeEmptyTextStyle:
          () =>
          ({ tr: t }) => {
            const { selection: e } = t;
            return (
              t.doc.nodesBetween(e.from, e.to, (n, r) => {
                if (n.isTextblock) return !0;
                n.marks
                  .filter((o) => o.type === this.type)
                  .some((o) => Object.values(o.attrs).some((i) => !!i)) ||
                  t.removeMark(r, r + n.nodeSize, this.type);
              }),
              !0
            );
          },
      };
    },
  }),
  LN = Ne.create({
    name: "color",
    addOptions() {
      return {
        types: ["textStyle"],
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            color: {
              default: null,
              parseHTML: (t) => {
                var e;
                return (e = t.style.color) === null || e === void 0
                  ? void 0
                  : e.replace(/['"]+/g, "");
              },
              renderHTML: (t) =>
                t.color
                  ? {
                      style: `color: ${t.color}`,
                    }
                  : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setColor:
          (t) =>
          ({ chain: e }) =>
            e().setMark("textStyle", { color: t }).run(),
        unsetColor:
          () =>
          ({ chain: t }) =>
            t()
              .setMark("textStyle", { color: null })
              .removeEmptyTextStyle()
              .run(),
      };
    },
  }),
  v3 = NN.extend({
    // Set the priority of this extension to 110 to ensure it loads before other extensions.
    // It must load before the highlight plugin, otherwise, it will cause span and mark to display in parallel.
    priority: 110,
  }),
  RN = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function IN(t, e) {
  return (
    S(),
    O(
      "svg",
      RN,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              d: "M9.624 11.998L12 5.665l2.375 6.333m-3.375-9l-5.5 14h2.25l1.125-3h6.25l1.125 3h2.25l-5.5-14h-2z",
              fill: "currentColor",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const _3 = k({ name: "mdi-format-color", render: IN }),
  PN = "";
function ss(t, e) {
  e === void 0 && (e = {});
  var n = e.insertAt;
  if (!(!t || typeof document > "u")) {
    var r = document.head || document.getElementsByTagName("head")[0],
      o = document.createElement("style");
    (o.type = "text/css"),
      n === "top" && r.firstChild
        ? r.insertBefore(o, r.firstChild)
        : r.appendChild(o),
      o.styleSheet
        ? (o.styleSheet.cssText = t)
        : o.appendChild(document.createTextNode(t));
  }
}
const as = function (t, e) {
    const { componentPrefix: n = PN } = e || {};
    t.component(`${n}${this.name}`, this);
  },
  gf = {};
var za = {
  name: "Checkboard",
  props: {
    size: {
      type: [Number, String],
      default: 8,
    },
    white: {
      type: String,
      default: "#fff",
    },
    grey: {
      type: String,
      default: "#e6e6e6",
    },
  },
  computed: {
    bgStyle() {
      return {
        "background-image": `url(${BN(this.white, this.grey, this.size)})`,
      };
    },
  },
};
function $N(t, e, n) {
  if (typeof document > "u") return null;
  const r = document.createElement("canvas");
  r.width = r.height = n * 2;
  const o = r.getContext("2d");
  return o
    ? ((o.fillStyle = t),
      o.fillRect(0, 0, r.width, r.height),
      (o.fillStyle = e),
      o.fillRect(0, 0, n, n),
      o.translate(n, n),
      o.fillRect(0, 0, n, n),
      r.toDataURL())
    : null;
}
function BN(t, e, n) {
  const r = `${t},${e},${n}`;
  if (gf[r]) return gf[r];
  const o = $N(t, e, n);
  return (gf[r] = o), o;
}
function HN(t, e, n, r, o, i) {
  return (
    S(),
    O(
      "div",
      {
        class: "vc-checkerboard",
        style: mt(i.bgStyle),
      },
      null,
      4
      /* STYLE */
    )
  );
}
var FN =
  ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
ss(FN);
za.render = HN;
za.__file = "src/components/checkboard/checkboard.vue";
za.install = as;
var hd = {
  name: "Alpha",
  components: {
    Checkboard: za,
  },
  props: {
    value: Object,
    onChange: Function,
  },
  computed: {
    colors() {
      return this.value;
    },
    gradientColor() {
      const { rgba: t } = this.colors,
        e = [t.r, t.g, t.b].join(",");
      return `linear-gradient(to right, rgba(${e}, 0) 0%, rgba(${e}, 1) 100%)`;
    },
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n) return;
      const r = n.clientWidth,
        o = n.getBoundingClientRect().left + window.pageXOffset,
        s = (t.pageX || (t.touches ? t.touches[0].pageX : 0)) - o;
      let a;
      s < 0 ? (a = 0) : s > r ? (a = 1) : (a = Math.round((s * 100) / r) / 100),
        this.colors.a !== a &&
          this.$emit("change", {
            h: this.colors.hsl.h,
            s: this.colors.hsl.s,
            l: this.colors.hsl.l,
            a,
            source: "rgba",
          });
    },
    handleMouseDown(t) {
      this.handleChange(t, !0),
        window.addEventListener("mousemove", this.handleChange),
        window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp() {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange),
        window.removeEventListener("mouseup", this.handleMouseUp);
    },
  },
};
const zN = { class: "vc-alpha" },
  VN = { class: "vc-alpha-checkboard-wrap" },
  UN = /* @__PURE__ */ C(
    "div",
    { class: "vc-alpha-picker" },
    null,
    -1
    /* HOISTED */
  ),
  jN = [UN];
function WN(t, e, n, r, o, i) {
  const s = $n("Checkboard");
  return (
    S(),
    O("div", zN, [
      C("div", VN, [J(s)]),
      C(
        "div",
        {
          class: "vc-alpha-gradient",
          style: mt({ background: i.gradientColor }),
        },
        null,
        4
        /* STYLE */
      ),
      C(
        "div",
        {
          ref: "container",
          class: "vc-alpha-container",
          onMousedown:
            e[0] ||
            (e[0] = (...a) => i.handleMouseDown && i.handleMouseDown(...a)),
          onTouchmove:
            e[1] || (e[1] = (...a) => i.handleChange && i.handleChange(...a)),
          onTouchstart:
            e[2] || (e[2] = (...a) => i.handleChange && i.handleChange(...a)),
        },
        [
          C(
            "div",
            {
              class: "vc-alpha-pointer",
              style: mt({ left: `${i.colors.a * 100}%` }),
            },
            jN,
            4
            /* STYLE */
          ),
        ],
        544
        /* HYDRATE_EVENTS, NEED_PATCH */
      ),
    ])
  );
}
var qN =
  ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
ss(qN);
hd.render = WN;
hd.__file = "src/components/alpha/alpha.vue";
hd.install = as;
function wt(t, e) {
  KN(t) && (t = "100%");
  var n = GN(t);
  return (
    (t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t)))),
    n && (t = parseInt(String(t * e), 10) / 100),
    Math.abs(t - e) < 1e-6
      ? 1
      : (e === 360
          ? (t = (t < 0 ? (t % e) + e : t % e) / parseFloat(String(e)))
          : (t = (t % e) / parseFloat(String(e))),
        t)
  );
}
function yl(t) {
  return Math.min(1, Math.max(0, t));
}
function KN(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function GN(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function x3(t) {
  return (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function vl(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function Go(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function JN(t, e, n) {
  return {
    r: wt(t, 255) * 255,
    g: wt(e, 255) * 255,
    b: wt(n, 255) * 255,
  };
}
function o2(t, e, n) {
  (t = wt(t, 255)), (e = wt(e, 255)), (n = wt(n, 255));
  var r = Math.max(t, e, n),
    o = Math.min(t, e, n),
    i = 0,
    s = 0,
    a = (r + o) / 2;
  if (r === o) (s = 0), (i = 0);
  else {
    var l = r - o;
    switch (((s = a > 0.5 ? l / (2 - r - o) : l / (r + o)), r)) {
      case t:
        i = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        i = (n - t) / l + 2;
        break;
      case n:
        i = (t - e) / l + 4;
        break;
    }
    i /= 6;
  }
  return { h: i, s, l: a };
}
function bf(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * (6 * n)
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * (2 / 3 - n) * 6
      : t
  );
}
function YN(t, e, n) {
  var r, o, i;
  if (((t = wt(t, 360)), (e = wt(e, 100)), (n = wt(n, 100)), e === 0))
    (o = n), (i = n), (r = n);
  else {
    var s = n < 0.5 ? n * (1 + e) : n + e - n * e,
      a = 2 * n - s;
    (r = bf(a, s, t + 1 / 3)), (o = bf(a, s, t)), (i = bf(a, s, t - 1 / 3));
  }
  return { r: r * 255, g: o * 255, b: i * 255 };
}
function i2(t, e, n) {
  (t = wt(t, 255)), (e = wt(e, 255)), (n = wt(n, 255));
  var r = Math.max(t, e, n),
    o = Math.min(t, e, n),
    i = 0,
    s = r,
    a = r - o,
    l = r === 0 ? 0 : a / r;
  if (r === o) i = 0;
  else {
    switch (r) {
      case t:
        i = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        i = (n - t) / a + 2;
        break;
      case n:
        i = (t - e) / a + 4;
        break;
    }
    i /= 6;
  }
  return { h: i, s: l, v: s };
}
function XN(t, e, n) {
  (t = wt(t, 360) * 6), (e = wt(e, 100)), (n = wt(n, 100));
  var r = Math.floor(t),
    o = t - r,
    i = n * (1 - e),
    s = n * (1 - o * e),
    a = n * (1 - (1 - o) * e),
    l = r % 6,
    u = [n, s, i, i, a, n][l],
    c = [a, n, n, s, i, i][l],
    d = [i, i, a, n, n, s][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function s2(t, e, n, r) {
  var o = [
    Go(Math.round(t).toString(16)),
    Go(Math.round(e).toString(16)),
    Go(Math.round(n).toString(16)),
  ];
  return r &&
    o[0].startsWith(o[0].charAt(1)) &&
    o[1].startsWith(o[1].charAt(1)) &&
    o[2].startsWith(o[2].charAt(1))
    ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0)
    : o.join("");
}
function ZN(t, e, n, r, o) {
  var i = [
    Go(Math.round(t).toString(16)),
    Go(Math.round(e).toString(16)),
    Go(Math.round(n).toString(16)),
    Go(QN(r)),
  ];
  return o &&
    i[0].startsWith(i[0].charAt(1)) &&
    i[1].startsWith(i[1].charAt(1)) &&
    i[2].startsWith(i[2].charAt(1)) &&
    i[3].startsWith(i[3].charAt(1))
    ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0)
    : i.join("");
}
function QN(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function a2(t) {
  return rn(t) / 255;
}
function rn(t) {
  return parseInt(t, 16);
}
function eL(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255,
  };
}
var Vp = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
function tL(t) {
  var e = { r: 0, g: 0, b: 0 },
    n = 1,
    r = null,
    o = null,
    i = null,
    s = !1,
    a = !1;
  return (
    typeof t == "string" && (t = oL(t)),
    typeof t == "object" &&
      (Er(t.r) && Er(t.g) && Er(t.b)
        ? ((e = JN(t.r, t.g, t.b)),
          (s = !0),
          (a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb"))
        : Er(t.h) && Er(t.s) && Er(t.v)
        ? ((r = vl(t.s)),
          (o = vl(t.v)),
          (e = XN(t.h, r, o)),
          (s = !0),
          (a = "hsv"))
        : Er(t.h) &&
          Er(t.s) &&
          Er(t.l) &&
          ((r = vl(t.s)),
          (i = vl(t.l)),
          (e = YN(t.h, r, i)),
          (s = !0),
          (a = "hsl")),
      Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)),
    (n = x3(n)),
    {
      ok: s,
      format: t.format || a,
      r: Math.min(255, Math.max(e.r, 0)),
      g: Math.min(255, Math.max(e.g, 0)),
      b: Math.min(255, Math.max(e.b, 0)),
      a: n,
    }
  );
}
var nL = "[-\\+]?\\d+%?",
  rL = "[-\\+]?\\d*\\.\\d+%?",
  bo = "(?:".concat(rL, ")|(?:").concat(nL, ")"),
  yf = "[\\s|\\(]+("
    .concat(bo, ")[,|\\s]+(")
    .concat(bo, ")[,|\\s]+(")
    .concat(bo, ")\\s*\\)?"),
  vf = "[\\s|\\(]+("
    .concat(bo, ")[,|\\s]+(")
    .concat(bo, ")[,|\\s]+(")
    .concat(bo, ")[,|\\s]+(")
    .concat(bo, ")\\s*\\)?"),
  Pn = {
    CSS_UNIT: new RegExp(bo),
    rgb: new RegExp("rgb" + yf),
    rgba: new RegExp("rgba" + vf),
    hsl: new RegExp("hsl" + yf),
    hsla: new RegExp("hsla" + vf),
    hsv: new RegExp("hsv" + yf),
    hsva: new RegExp("hsva" + vf),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  };
function oL(t) {
  if (((t = t.trim().toLowerCase()), t.length === 0)) return !1;
  var e = !1;
  if (Vp[t]) (t = Vp[t]), (e = !0);
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = Pn.rgb.exec(t);
  return n
    ? { r: n[1], g: n[2], b: n[3] }
    : ((n = Pn.rgba.exec(t)),
      n
        ? { r: n[1], g: n[2], b: n[3], a: n[4] }
        : ((n = Pn.hsl.exec(t)),
          n
            ? { h: n[1], s: n[2], l: n[3] }
            : ((n = Pn.hsla.exec(t)),
              n
                ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                : ((n = Pn.hsv.exec(t)),
                  n
                    ? { h: n[1], s: n[2], v: n[3] }
                    : ((n = Pn.hsva.exec(t)),
                      n
                        ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                        : ((n = Pn.hex8.exec(t)),
                          n
                            ? {
                                r: rn(n[1]),
                                g: rn(n[2]),
                                b: rn(n[3]),
                                a: a2(n[4]),
                                format: e ? "name" : "hex8",
                              }
                            : ((n = Pn.hex6.exec(t)),
                              n
                                ? {
                                    r: rn(n[1]),
                                    g: rn(n[2]),
                                    b: rn(n[3]),
                                    format: e ? "name" : "hex",
                                  }
                                : ((n = Pn.hex4.exec(t)),
                                  n
                                    ? {
                                        r: rn(n[1] + n[1]),
                                        g: rn(n[2] + n[2]),
                                        b: rn(n[3] + n[3]),
                                        a: a2(n[4] + n[4]),
                                        format: e ? "name" : "hex8",
                                      }
                                    : ((n = Pn.hex3.exec(t)),
                                      n
                                        ? {
                                            r: rn(n[1] + n[1]),
                                            g: rn(n[2] + n[2]),
                                            b: rn(n[3] + n[3]),
                                            format: e ? "name" : "hex",
                                          }
                                        : !1)))))))));
}
function Er(t) {
  return !!Pn.CSS_UNIT.exec(String(t));
}
var iL =
  /** @class */
  (function () {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t) return e;
      typeof e == "number" && (e = eL(e)), (this.originalInput = e);
      var o = tL(e);
      (this.originalInput = e),
        (this.r = o.r),
        (this.g = o.g),
        (this.b = o.b),
        (this.a = o.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (r = n.format) !== null && r !== void 0 ? r : o.format),
        (this.gradientType = n.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = o.ok);
    }
    return (
      (t.prototype.isDark = function () {
        return this.getBrightness() < 128;
      }),
      (t.prototype.isLight = function () {
        return !this.isDark();
      }),
      (t.prototype.getBrightness = function () {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
      }),
      (t.prototype.getLuminance = function () {
        var e = this.toRgb(),
          n,
          r,
          o,
          i = e.r / 255,
          s = e.g / 255,
          a = e.b / 255;
        return (
          i <= 0.03928
            ? (n = i / 12.92)
            : (n = Math.pow((i + 0.055) / 1.055, 2.4)),
          s <= 0.03928
            ? (r = s / 12.92)
            : (r = Math.pow((s + 0.055) / 1.055, 2.4)),
          a <= 0.03928
            ? (o = a / 12.92)
            : (o = Math.pow((a + 0.055) / 1.055, 2.4)),
          0.2126 * n + 0.7152 * r + 0.0722 * o
        );
      }),
      (t.prototype.getAlpha = function () {
        return this.a;
      }),
      (t.prototype.setAlpha = function (e) {
        return (
          (this.a = x3(e)), (this.roundA = Math.round(100 * this.a) / 100), this
        );
      }),
      (t.prototype.isMonochrome = function () {
        var e = this.toHsl().s;
        return e === 0;
      }),
      (t.prototype.toHsv = function () {
        var e = i2(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
      }),
      (t.prototype.toHsvString = function () {
        var e = i2(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          o = Math.round(e.v * 100);
        return this.a === 1
          ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(o, "%)")
          : "hsva("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(o, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHsl = function () {
        var e = o2(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
      }),
      (t.prototype.toHslString = function () {
        var e = o2(this.r, this.g, this.b),
          n = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          o = Math.round(e.l * 100);
        return this.a === 1
          ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(o, "%)")
          : "hsla("
              .concat(n, ", ")
              .concat(r, "%, ")
              .concat(o, "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toHex = function (e) {
        return e === void 0 && (e = !1), s2(this.r, this.g, this.b, e);
      }),
      (t.prototype.toHexString = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex(e);
      }),
      (t.prototype.toHex8 = function (e) {
        return e === void 0 && (e = !1), ZN(this.r, this.g, this.b, this.a, e);
      }),
      (t.prototype.toHex8String = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex8(e);
      }),
      (t.prototype.toHexShortString = function (e) {
        return (
          e === void 0 && (e = !1),
          this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        );
      }),
      (t.prototype.toRgb = function () {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a,
        };
      }),
      (t.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          n = Math.round(this.g),
          r = Math.round(this.b);
        return this.a === 1
          ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")")
          : "rgba("
              .concat(e, ", ")
              .concat(n, ", ")
              .concat(r, ", ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toPercentageRgb = function () {
        var e = function (n) {
          return "".concat(Math.round(wt(n, 255) * 100), "%");
        };
        return {
          r: e(this.r),
          g: e(this.g),
          b: e(this.b),
          a: this.a,
        };
      }),
      (t.prototype.toPercentageRgbString = function () {
        var e = function (n) {
          return Math.round(wt(n, 255) * 100);
        };
        return this.a === 1
          ? "rgb("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%)")
          : "rgba("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%, ")
              .concat(this.roundA, ")");
      }),
      (t.prototype.toName = function () {
        if (this.a === 0) return "transparent";
        if (this.a < 1) return !1;
        for (
          var e = "#" + s2(this.r, this.g, this.b, !1),
            n = 0,
            r = Object.entries(Vp);
          n < r.length;
          n++
        ) {
          var o = r[n],
            i = o[0],
            s = o[1];
          if (e === s) return i;
        }
        return !1;
      }),
      (t.prototype.toString = function (e) {
        var n = !!e;
        e = e ?? this.format;
        var r = !1,
          o = this.a < 1 && this.a >= 0,
          i = !n && o && (e.startsWith("hex") || e === "name");
        return i
          ? e === "name" && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === "rgb" && (r = this.toRgbString()),
            e === "prgb" && (r = this.toPercentageRgbString()),
            (e === "hex" || e === "hex6") && (r = this.toHexString()),
            e === "hex3" && (r = this.toHexString(!0)),
            e === "hex4" && (r = this.toHex8String(!0)),
            e === "hex8" && (r = this.toHex8String()),
            e === "name" && (r = this.toName()),
            e === "hsl" && (r = this.toHslString()),
            e === "hsv" && (r = this.toHsvString()),
            r || this.toHexString());
      }),
      (t.prototype.toNumber = function () {
        return (
          (Math.round(this.r) << 16) +
          (Math.round(this.g) << 8) +
          Math.round(this.b)
        );
      }),
      (t.prototype.clone = function () {
        return new t(this.toString());
      }),
      (t.prototype.lighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l += e / 100), (n.l = yl(n.l)), new t(n);
      }),
      (t.prototype.brighten = function (e) {
        e === void 0 && (e = 10);
        var n = this.toRgb();
        return (
          (n.r = Math.max(
            0,
            Math.min(255, n.r - Math.round(255 * -(e / 100)))
          )),
          (n.g = Math.max(
            0,
            Math.min(255, n.g - Math.round(255 * -(e / 100)))
          )),
          (n.b = Math.max(
            0,
            Math.min(255, n.b - Math.round(255 * -(e / 100)))
          )),
          new t(n)
        );
      }),
      (t.prototype.darken = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.l -= e / 100), (n.l = yl(n.l)), new t(n);
      }),
      (t.prototype.tint = function (e) {
        return e === void 0 && (e = 10), this.mix("white", e);
      }),
      (t.prototype.shade = function (e) {
        return e === void 0 && (e = 10), this.mix("black", e);
      }),
      (t.prototype.desaturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s -= e / 100), (n.s = yl(n.s)), new t(n);
      }),
      (t.prototype.saturate = function (e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return (n.s += e / 100), (n.s = yl(n.s)), new t(n);
      }),
      (t.prototype.greyscale = function () {
        return this.desaturate(100);
      }),
      (t.prototype.spin = function (e) {
        var n = this.toHsl(),
          r = (n.h + e) % 360;
        return (n.h = r < 0 ? 360 + r : r), new t(n);
      }),
      (t.prototype.mix = function (e, n) {
        n === void 0 && (n = 50);
        var r = this.toRgb(),
          o = new t(e).toRgb(),
          i = n / 100,
          s = {
            r: (o.r - r.r) * i + r.r,
            g: (o.g - r.g) * i + r.g,
            b: (o.b - r.b) * i + r.b,
            a: (o.a - r.a) * i + r.a,
          };
        return new t(s);
      }),
      (t.prototype.analogous = function (e, n) {
        e === void 0 && (e = 6), n === void 0 && (n = 30);
        var r = this.toHsl(),
          o = 360 / n,
          i = [this];
        for (r.h = (r.h - ((o * e) >> 1) + 720) % 360; --e; )
          (r.h = (r.h + o) % 360), i.push(new t(r));
        return i;
      }),
      (t.prototype.complement = function () {
        var e = this.toHsl();
        return (e.h = (e.h + 180) % 360), new t(e);
      }),
      (t.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6);
        for (
          var n = this.toHsv(), r = n.h, o = n.s, i = n.v, s = [], a = 1 / e;
          e--;

        )
          s.push(new t({ h: r, s: o, v: i })), (i = (i + a) % 1);
        return s;
      }),
      (t.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          n = e.h;
        return [
          this,
          new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
          new t({ h: (n + 216) % 360, s: e.s, l: e.l }),
        ];
      }),
      (t.prototype.onBackground = function (e) {
        var n = this.toRgb(),
          r = new t(e).toRgb(),
          o = n.a + r.a * (1 - n.a);
        return new t({
          r: (n.r * n.a + r.r * r.a * (1 - n.a)) / o,
          g: (n.g * n.a + r.g * r.a * (1 - n.a)) / o,
          b: (n.b * n.a + r.b * r.a * (1 - n.a)) / o,
          a: o,
        });
      }),
      (t.prototype.triad = function () {
        return this.polyad(3);
      }),
      (t.prototype.tetrad = function () {
        return this.polyad(4);
      }),
      (t.prototype.polyad = function (e) {
        for (
          var n = this.toHsl(), r = n.h, o = [this], i = 360 / e, s = 1;
          s < e;
          s++
        )
          o.push(new t({ h: (r + s * i) % 360, s: n.s, l: n.l }));
        return o;
      }),
      (t.prototype.equals = function (e) {
        return this.toRgbString() === new t(e).toRgbString();
      }),
      t
    );
  })();
function io(...t) {
  return new iL(...t);
}
function _f(t, e) {
  const n = t && t.a;
  let r;
  t && t.hsl
    ? (r = io(t.hsl))
    : t && t.hex && t.hex.length > 0
    ? (r = io(t.hex))
    : t && t.hsv
    ? (r = io(t.hsv))
    : t && t.rgba
    ? (r = io(t.rgba))
    : t && t.rgb
    ? (r = io(t.rgb))
    : (r = io(t)),
    r && (r._a === void 0 || r._a === null) && r.setAlpha(n || r.getAlpha());
  const o = r.toHsl(),
    i = r.toHsv();
  return (
    o.s === 0 && (i.h = o.h = t.h || (t.hsl && t.hsl.h) || e || 0),
    i.v < 0.0164 &&
      ((i.h = t.h || (t.hsv && t.hsv.h) || 0),
      (i.s = t.s || (t.hsv && t.hsv.s) || 0)),
    o.l < 0.01 &&
      ((o.h = t.h || (t.hsl && t.hsl.h) || 0),
      (o.s = t.s || (t.hsl && t.hsl.s) || 0)),
    {
      hsl: o,
      hex: r.toHexString().toUpperCase(),
      hex8: r.toHex8String().toUpperCase(),
      rgba: r.toRgb(),
      hsv: i,
      oldHue: t.h || e || o.h,
      source: t.source,
      a: r.getAlpha(),
    }
  );
}
var sL = {
    model: {
      prop: "modelValue",
      event: "update:modelValue",
    },
    props: ["modelValue"],
    data() {
      return {
        val: _f(this.modelValue),
      };
    },
    computed: {
      colors: {
        get() {
          return this.val;
        },
        set(t) {
          (this.val = t), this.$emit("update:modelValue", t);
        },
      },
    },
    watch: {
      modelValue(t) {
        this.val = _f(t);
      },
    },
    methods: {
      colorChange(t, e) {
        (this.oldHue = this.colors.hsl.h),
          (this.colors = _f(t, e || this.oldHue));
      },
      isValidHex(t) {
        return io(t).isValid;
      },
      simpleCheckForValidColor(t) {
        const e = ["r", "g", "b", "a", "h", "s", "l", "v"];
        let n = 0,
          r = 0;
        for (let o = 0; o < e.length; o++) {
          const i = e[o];
          t[i] && (n++, isNaN(t[i]) || r++);
        }
        if (n === r) return t;
      },
      paletteUpperCase(t) {
        return t.map((e) => e.toUpperCase());
      },
      isTransparent(t) {
        return io(t).getAlpha() === 0;
      },
    },
  },
  md = {
    name: "EditableInput",
    props: {
      label: String,
      labelText: String,
      desc: String,
      value: [String, Number],
      max: Number,
      min: Number,
      arrowOffset: {
        type: Number,
        default: 1,
      },
    },
    computed: {
      val: {
        get() {
          return this.value;
        },
        set(t) {
          if (this.max !== void 0 && +t > this.max)
            this.$refs.input.value = this.max;
          else return t;
        },
      },
      labelId() {
        return `input__label__${this.label}__${Math.random()
          .toString()
          .slice(2, 5)}`;
      },
      labelSpanText() {
        return this.labelText || this.label;
      },
    },
    methods: {
      update(t) {
        this.handleChange(t.target.value);
      },
      handleChange(t) {
        const e = {};
        (e[this.label] = t),
          e.hex === void 0 && e["#"] === void 0
            ? this.$emit("change", e)
            : t.length > 5 && this.$emit("change", e);
      },
      // **** unused
      // handleBlur (e) {
      //   console.log(e)
      // },
      handleKeyDown(t) {
        let { val: e } = this;
        const n = Number(e);
        if (n) {
          const r = this.arrowOffset || 1;
          t.keyCode === 38 &&
            ((e = n + r), this.handleChange(e), t.preventDefault()),
            t.keyCode === 40 &&
              ((e = n - r), this.handleChange(e), t.preventDefault());
        }
      },
      // **** unused
      // handleDrag (e) {
      //   console.log(e)
      // },
      // handleMouseDown (e) {
      //   console.log(e)
      // }
    },
  };
const aL = { class: "vc-editable-input" },
  lL = ["aria-labelledby"],
  uL = ["id", "for"],
  cL = { class: "vc-input__desc" };
function dL(t, e, n, r, o, i) {
  return (
    S(),
    O("div", aL, [
      je(
        C(
          "input",
          {
            ref: "input",
            "onUpdate:modelValue": e[0] || (e[0] = (s) => (i.val = s)),
            "aria-labelledby": i.labelId,
            class: "vc-input__input",
            onKeydown:
              e[1] ||
              (e[1] = (...s) => i.handleKeyDown && i.handleKeyDown(...s)),
            onInput: e[2] || (e[2] = (...s) => i.update && i.update(...s)),
          },
          null,
          40,
          lL
        ),
        [[Ot, i.val]]
      ),
      C(
        "span",
        {
          id: i.labelId,
          for: n.label,
          class: "vc-input__label",
        },
        it(i.labelSpanText),
        9,
        uL
      ),
      C(
        "span",
        cL,
        it(n.desc),
        1
        /* TEXT */
      ),
    ])
  );
}
var fL =
  ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
ss(fL);
md.render = dL;
md.__file = "src/components/editable-input/editable-input.vue";
md.install = as;
function xf(t, e, n) {
  return e < n ? (t < e ? e : t > n ? n : t) : t < n ? n : t > e ? e : t;
}
var gd = {
  name: "Saturation",
  props: {
    value: Object,
  },
  computed: {
    colors() {
      return this.value;
    },
    bgColor() {
      return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
    },
    pointerTop() {
      return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
    },
    pointerLeft() {
      return `${this.colors.hsv.s * 100}%`;
    },
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n) return;
      const r = n.clientWidth,
        o = n.clientHeight,
        i = n.getBoundingClientRect().left + window.pageXOffset,
        s = n.getBoundingClientRect().top + window.pageYOffset,
        a = t.pageX || (t.touches ? t.touches[0].pageX : 0),
        l = t.pageY || (t.touches ? t.touches[0].pageY : 0),
        u = xf(a - i, 0, r),
        c = xf(l - s, 0, o),
        d = u / r,
        f = xf(-(c / o) + 1, 0, 1);
      this.onChange({
        h: this.colors.hsv.h,
        s: d,
        v: f,
        a: this.colors.hsv.a,
        source: "hsva",
      });
    },
    onChange(t) {
      this.$emit("change", t);
    },
    handleMouseDown(t) {
      window.addEventListener("mousemove", this.handleChange),
        window.addEventListener("mouseup", this.handleChange),
        window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(t) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange),
        window.removeEventListener("mouseup", this.handleChange),
        window.removeEventListener("mouseup", this.handleMouseUp);
    },
  },
};
const pL = /* @__PURE__ */ C(
    "div",
    { class: "vc-saturation--white" },
    null,
    -1
    /* HOISTED */
  ),
  hL = /* @__PURE__ */ C(
    "div",
    { class: "vc-saturation--black" },
    null,
    -1
    /* HOISTED */
  ),
  mL = /* @__PURE__ */ C(
    "div",
    { class: "vc-saturation-circle" },
    null,
    -1
    /* HOISTED */
  ),
  gL = [mL];
function bL(t, e, n, r, o, i) {
  return (
    S(),
    O(
      "div",
      {
        ref: "container",
        class: "vc-saturation",
        style: mt({ background: i.bgColor }),
        onMousedown:
          e[0] ||
          (e[0] = (...s) => i.handleMouseDown && i.handleMouseDown(...s)),
        onTouchmove:
          e[1] || (e[1] = (...s) => i.handleChange && i.handleChange(...s)),
        onTouchstart:
          e[2] || (e[2] = (...s) => i.handleChange && i.handleChange(...s)),
      },
      [
        pL,
        hL,
        C(
          "div",
          {
            class: "vc-saturation-pointer",
            style: mt({ top: i.pointerTop, left: i.pointerLeft }),
          },
          gL,
          4
          /* STYLE */
        ),
      ],
      36
      /* STYLE, HYDRATE_EVENTS */
    )
  );
}
var yL =
  ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
ss(yL);
gd.render = bL;
gd.__file = "src/components/saturation/saturation.vue";
gd.install = as;
var bd = {
  name: "Hue",
  props: {
    value: Object,
    direction: {
      type: String,
      // [horizontal | vertical]
      default: "horizontal",
    },
  },
  data() {
    return {
      oldHue: 0,
      pullDirection: "",
    };
  },
  computed: {
    colors() {
      return this.value;
    },
    directionClass() {
      return {
        "vc-hue--horizontal": this.direction === "horizontal",
        "vc-hue--vertical": this.direction === "vertical",
      };
    },
    pointerTop() {
      return this.direction === "vertical"
        ? this.colors.hsl.h === 0 && this.pullDirection === "right"
          ? 0
          : `${-((this.colors.hsl.h * 100) / 360) + 100}%`
        : 0;
    },
    pointerLeft() {
      return this.direction === "vertical"
        ? 0
        : this.colors.hsl.h === 0 && this.pullDirection === "right"
        ? "100%"
        : `${(this.colors.hsl.h * 100) / 360}%`;
    },
  },
  watch: {
    value: {
      handler(t, e) {
        const { h: n } = t.hsl;
        n !== 0 && n - this.oldHue > 0 && (this.pullDirection = "right"),
          n !== 0 && n - this.oldHue < 0 && (this.pullDirection = "left"),
          (this.oldHue = n);
      },
      deep: !0,
      immediate: !0,
    },
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n) return;
      const r = n.clientWidth,
        o = n.clientHeight,
        i = n.getBoundingClientRect().left + window.pageXOffset,
        s = n.getBoundingClientRect().top + window.pageYOffset,
        a = t.pageX || (t.touches ? t.touches[0].pageX : 0),
        l = t.pageY || (t.touches ? t.touches[0].pageY : 0),
        u = a - i,
        c = l - s;
      let d, f;
      this.direction === "vertical"
        ? (c < 0
            ? (d = 360)
            : c > o
            ? (d = 0)
            : ((f = -((c * 100) / o) + 100), (d = (360 * f) / 100)),
          this.colors.hsl.h !== d &&
            this.$emit("change", {
              h: d,
              s: this.colors.hsl.s,
              l: this.colors.hsl.l,
              a: this.colors.hsl.a,
              source: "hsl",
            }))
        : (u < 0
            ? (d = 0)
            : u > r
            ? (d = 360)
            : ((f = (u * 100) / r), (d = (360 * f) / 100)),
          this.colors.hsl.h !== d &&
            this.$emit("change", {
              h: d,
              s: this.colors.hsl.s,
              l: this.colors.hsl.l,
              a: this.colors.hsl.a,
              source: "hsl",
            }));
    },
    handleMouseDown(t) {
      this.handleChange(t, !0),
        window.addEventListener("mousemove", this.handleChange),
        window.addEventListener("mouseup", this.handleChange),
        window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(t) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange),
        window.removeEventListener("mouseup", this.handleChange),
        window.removeEventListener("mouseup", this.handleMouseUp);
    },
  },
};
const vL = ["aria-valuenow"],
  _L = /* @__PURE__ */ C(
    "div",
    { class: "vc-hue-picker" },
    null,
    -1
    /* HOISTED */
  ),
  xL = [_L];
function kL(t, e, n, r, o, i) {
  return (
    S(),
    O(
      "div",
      {
        class: $e(["vc-hue", [i.directionClass]]),
      },
      [
        C(
          "div",
          {
            ref: "container",
            class: "vc-hue-container",
            role: "slider",
            "aria-valuenow": i.colors.hsl.h,
            "aria-valuemin": "0",
            "aria-valuemax": "360",
            onMousedown:
              e[0] ||
              (e[0] = (...s) => i.handleMouseDown && i.handleMouseDown(...s)),
            onTouchmove:
              e[1] || (e[1] = (...s) => i.handleChange && i.handleChange(...s)),
            onTouchstart:
              e[2] || (e[2] = (...s) => i.handleChange && i.handleChange(...s)),
          },
          [
            C(
              "div",
              {
                class: "vc-hue-pointer",
                style: mt({ top: i.pointerTop, left: i.pointerLeft }),
                role: "presentation",
              },
              xL,
              4
              /* STYLE */
            ),
          ],
          40,
          vL
        ),
      ],
      2
      /* CLASS */
    )
  );
}
var wL =
  ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
ss(wL);
bd.render = kL;
bd.__file = "src/components/hue/hue.vue";
bd.install = as;
const CL = [
  "#D0021B",
  "#F5A623",
  "#F8E71C",
  "#8B572A",
  "#7ED321",
  "#417505",
  "#BD10E0",
  "#9013FE",
  "#4A90E2",
  "#50E3C2",
  "#B8E986",
  "#000000",
  "#4A4A4A",
  "#9B9B9B",
  "#FFFFFF",
  "rgba(0,0,0,0)",
];
var yd = {
  name: "Sketch",
  components: {
    Saturation: gd,
    Hue: bd,
    Alpha: hd,
    EdIn: md,
    Checkboard: za,
  },
  mixins: [sL],
  props: {
    presetColors: {
      type: Array,
      default() {
        return CL;
      },
    },
    disableAlpha: {
      type: Boolean,
      default: !1,
    },
    disableFields: {
      type: Boolean,
      default: !1,
    },
  },
  computed: {
    hex() {
      let t;
      return (
        this.colors.a < 1 ? (t = this.colors.hex8) : (t = this.colors.hex),
        t.replace("#", "")
      );
    },
    activeColor() {
      const { rgba: t } = this.colors;
      return `rgba(${[t.r, t.g, t.b, t.a].join(",")})`;
    },
  },
  methods: {
    handlePreset(t) {
      this.colorChange(t);
    },
    childChange(t) {
      this.colorChange(t);
    },
    inputChange(t) {
      t &&
        (t.hex
          ? this.isValidHex(t.hex) &&
            this.colorChange({
              hex: t.hex,
              source: "hex",
            })
          : (t.r || t.g || t.b || t.a) &&
            this.colorChange({
              r: t.r || this.colors.rgba.r,
              g: t.g || this.colors.rgba.g,
              b: t.b || this.colors.rgba.b,
              a: t.a || this.colors.rgba.a,
              source: "rgba",
            }));
    },
  },
};
const AL = { class: "vc-sketch-saturation-wrap" },
  SL = { class: "vc-sketch-controls" },
  EL = { class: "vc-sketch-sliders" },
  ML = { class: "vc-sketch-hue-wrap" },
  TL = {
    key: 0,
    class: "vc-sketch-alpha-wrap",
  },
  OL = { class: "vc-sketch-color-wrap" },
  DL = ["aria-label"],
  NL = {
    key: 0,
    class: "vc-sketch-field",
  },
  LL = { class: "vc-sketch-field--double" },
  RL = { class: "vc-sketch-field--single" },
  IL = { class: "vc-sketch-field--single" },
  PL = { class: "vc-sketch-field--single" },
  $L = {
    key: 0,
    class: "vc-sketch-field--single",
  },
  BL = {
    class: "vc-sketch-presets",
    role: "group",
    "aria-label": "A color preset, pick one to set as current color",
  },
  HL = ["aria-label", "onClick"],
  FL = ["aria-label", "onClick"];
function zL(t, e, n, r, o, i) {
  const s = $n("Saturation"),
    a = $n("Hue"),
    l = $n("Alpha"),
    u = $n("Checkboard"),
    c = $n("EdIn");
  return (
    S(),
    O(
      "div",
      {
        role: "application",
        "aria-label": "Sketch color picker",
        class: $e([
          "vc-sketch",
          [n.disableAlpha ? "vc-sketch__disable-alpha" : ""],
        ]),
      },
      [
        C("div", AL, [
          J(
            s,
            {
              value: t.colors,
              onChange: i.childChange,
            },
            null,
            8,
            ["value", "onChange"]
          ),
        ]),
        C("div", SL, [
          C("div", EL, [
            C("div", ML, [
              J(
                a,
                {
                  value: t.colors,
                  onChange: i.childChange,
                },
                null,
                8,
                ["value", "onChange"]
              ),
            ]),
            n.disableAlpha
              ? un("v-if", !0)
              : (S(),
                O("div", TL, [
                  J(
                    l,
                    {
                      value: t.colors,
                      onChange: i.childChange,
                    },
                    null,
                    8,
                    ["value", "onChange"]
                  ),
                ])),
          ]),
          C("div", OL, [
            C(
              "div",
              {
                "aria-label": `Current color is ${i.activeColor}`,
                class: "vc-sketch-active-color",
                style: mt({ background: i.activeColor }),
              },
              null,
              12,
              DL
            ),
            J(u),
          ]),
        ]),
        n.disableFields
          ? un("v-if", !0)
          : (S(),
            O("div", NL, [
              un(" rgba "),
              C("div", LL, [
                J(
                  c,
                  {
                    label: "hex",
                    value: i.hex,
                    onChange: i.inputChange,
                  },
                  null,
                  8,
                  ["value", "onChange"]
                ),
              ]),
              C("div", RL, [
                J(
                  c,
                  {
                    label: "r",
                    value: t.colors.rgba.r,
                    onChange: i.inputChange,
                  },
                  null,
                  8,
                  ["value", "onChange"]
                ),
              ]),
              C("div", IL, [
                J(
                  c,
                  {
                    label: "g",
                    value: t.colors.rgba.g,
                    onChange: i.inputChange,
                  },
                  null,
                  8,
                  ["value", "onChange"]
                ),
              ]),
              C("div", PL, [
                J(
                  c,
                  {
                    label: "b",
                    value: t.colors.rgba.b,
                    onChange: i.inputChange,
                  },
                  null,
                  8,
                  ["value", "onChange"]
                ),
              ]),
              n.disableAlpha
                ? un("v-if", !0)
                : (S(),
                  O("div", $L, [
                    J(
                      c,
                      {
                        label: "a",
                        value: t.colors.a,
                        "arrow-offset": 0.01,
                        max: 1,
                        onChange: i.inputChange,
                      },
                      null,
                      8,
                      ["value", "arrow-offset", "onChange"]
                    ),
                  ])),
            ])),
        C("div", BL, [
          (S(!0),
          O(
            gt,
            null,
            Fr(
              n.presetColors,
              (d) => (
                S(),
                O(
                  gt,
                  null,
                  [
                    t.isTransparent(d)
                      ? (S(),
                        O(
                          "div",
                          {
                            key: d,
                            "aria-label": `Color:${d}`,
                            class: "vc-sketch-presets-color",
                            onClick: (f) => i.handlePreset(d),
                          },
                          [J(u)],
                          8,
                          FL
                        ))
                      : (S(),
                        O(
                          "div",
                          {
                            key: `!${d}`,
                            class: "vc-sketch-presets-color",
                            "aria-label": `Color:${d}`,
                            style: mt({ background: d }),
                            onClick: (f) => i.handlePreset(d),
                          },
                          null,
                          12,
                          HL
                        )),
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )
              )
            ),
            256
            /* UNKEYED_FRAGMENT */
          )),
        ]),
      ],
      2
      /* CLASS */
    )
  );
}
var VL =
  ".vc-sketch{background:#fff;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.15),0 8px 16px rgba(0,0,0,.15);box-sizing:initial;padding:10px 10px 0;position:relative;width:200px}.vc-sketch-saturation-wrap{overflow:hidden;padding-bottom:75%;position:relative;width:100%}.vc-sketch-controls{display:flex}.vc-sketch-sliders{flex:1;padding:4px 0}.vc-sketch-sliders .vc-alpha-gradient,.vc-sketch-sliders .vc-hue{border-radius:2px}.vc-sketch-alpha-wrap,.vc-sketch-hue-wrap{height:10px;position:relative}.vc-sketch-alpha-wrap{margin-top:4px;overflow:hidden}.vc-sketch-color-wrap{border-radius:3px;height:24px;margin-left:4px;margin-top:4px;position:relative;width:24px}.vc-sketch-active-color{border-radius:2px;bottom:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15),inset 0 0 4px rgba(0,0,0,.25);left:0;position:absolute;right:0;top:0;z-index:2}.vc-sketch-color-wrap .vc-checkerboard{background-size:auto}.vc-sketch-field{display:flex;padding-top:4px}.vc-sketch-field .vc-input__input{border:none;box-shadow:inset 0 0 0 1px #ccc;font-size:10px;padding:4px 0 3px 10%;width:90%}.vc-sketch-field .vc-input__label{color:#222;display:block;font-size:11px;padding-bottom:4px;padding-top:3px;text-align:center;text-transform:capitalize}.vc-sketch-field--single{flex:1;padding-left:6px}.vc-sketch-field--double{flex:2}.vc-sketch-presets{border-top:1px solid #eee;margin-left:-10px;margin-right:-10px;padding-left:10px;padding-top:10px}.vc-sketch-presets-color{cursor:pointer;display:inline-block;height:16px;margin:0 10px 10px 0;overflow:hidden;position:relative;vertical-align:top;width:16px}.vc-sketch-presets-color,.vc-sketch-presets-color .vc-checkerboard{border-radius:3px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)}.vc-sketch__disable-alpha .vc-sketch-color-wrap{height:10px}";
ss(VL);
yd.render = zL;
yd.__file = "src/components/sketch/sketch.vue";
yd.install = as;
function UL(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var kf = {},
  wf = {},
  _l = { exports: {} },
  l2;
function jL() {
  if (l2) return _l.exports;
  l2 = 1;
  var t = String,
    e = function () {
      return {
        isColorSupported: !1,
        reset: t,
        bold: t,
        dim: t,
        italic: t,
        underline: t,
        inverse: t,
        hidden: t,
        strikethrough: t,
        black: t,
        red: t,
        green: t,
        yellow: t,
        blue: t,
        magenta: t,
        cyan: t,
        white: t,
        gray: t,
        bgBlack: t,
        bgRed: t,
        bgGreen: t,
        bgYellow: t,
        bgBlue: t,
        bgMagenta: t,
        bgCyan: t,
        bgWhite: t,
      };
    };
  return (_l.exports = e()), (_l.exports.createColors = e), _l.exports;
}
var u2;
function WL() {
  return (
    u2 ||
      ((u2 = 1),
      (function (t) {
        var e = {
          LDFLAGS: "-L/opt/homebrew/opt/node@22/lib",
          COREPACK_ROOT:
            "/opt/homebrew/Cellar/node@22/22.14.0_1/lib/node_modules/corepack",
          WASMER_CACHE_DIR: "/Users/ryanwang/.wasmer/cache",
          npm_config__f2ccloud_registry: "https://npm.pkg.github.com/",
          TERM_PROGRAM: "vscode",
          npm_package_scripts_prettier:
            "prettier --write './src/**/*.{vue,js,jsx,ts,tsx,css,scss,json,yml,yaml,html}'",
          npm_package_dependencies__tiptap_extension_link: "^2.11.2",
          npm_package_scripts_test_unit_coverage:
            "vitest run --environment jsdom --coverage",
          NODE: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
          ANDROID_HOME: "/Users/ryanwang/Library/Android/sdk",
          WASMER_DIR: "/Users/ryanwang/.wasmer",
          _P9K_TTY: "/dev/ttys005",
          npm_package_homepage:
            "https://github.com/halo-dev/halo/tree/main/ui/packages/editor#readme",
          npm_package_dependencies__tiptap_vue_3: "^2.11.2",
          INIT_CWD:
            "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
          SHELL: "/bin/zsh",
          TERM: "xterm-256color",
          npm_package_unpkg: "./dist/rich-text-editor.iife.js",
          npm_package_dependencies__tiptap_extension_task_item: "^2.11.2",
          npm_package_dependencies__tiptap_extension_heading: "^2.11.2",
          TMPDIR: "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/",
          CPPFLAGS: "-I/opt/homebrew/opt/node@22/include",
          npm_package_dependencies_linkifyjs: "^4.1.3",
          npm_package_scripts_lint:
            "eslint ./src --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
          npm_package_scripts_release: "release-it",
          TERM_PROGRAM_VERSION: "0.48.7",
          npm_package_dependencies__tiptap_extension_dropcursor: "^2.11.2",
          npm_package_dependencies_floating_vue: "^5.2.2",
          npm_package_scripts_dev: "vite",
          MallocNanoZone: "0",
          ORIGINAL_XDG_CURRENT_DESKTOP: "undefined",
          CURSOR_TRACE_ID: "f3aa1dd96f1a4d14ad3c22945b689fe9",
          ZDOTDIR: "/Users/ryanwang",
          npm_package_dependencies__tiptap_extension_document: "^2.11.2",
          npm_package_dependencies__tiptap_extension_highlight: "^2.11.2",
          SDKMAN_PLATFORM: "darwinarm64",
          npm_package_dependencies__tiptap_extension_placeholder: "^2.11.2",
          npm_config_registry: "https://registry.npmjs.org/",
          ZSH: "/Users/ryanwang/.oh-my-zsh",
          PNPM_HOME: "/Users/ryanwang/Library/pnpm",
          npm_package_repository_url: "https://github.com/halo-dev/halo.git",
          npm_package_dependencies__tiptap_extension_italic: "^2.11.2",
          npm_package_dependencies__tiptap_extension_list_keymap: "^2.11.2",
          npm_package_jsdelivr: "./dist/rich-text-editor.iife.js",
          npm_package_scripts_test_unit_ui:
            "vitest --environment jsdom --watch --ui",
          npm_package_dependencies__tiptap_pm: "^2.11.2",
          USER: "ryanwang",
          DEVECO_SDK_HOME: "/Applications/DevEco-Studio.app/Contents/sdk",
          npm_package_description: "Default editor for Halo",
          LS_COLORS:
            "di=1;36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43",
          npm_package_license: "GPL-3.0",
          COMMAND_MODE: "unix2003",
          npm_package_dependencies__tiptap_extension_paragraph: "^2.11.2",
          SDKMAN_CANDIDATES_API: "https://api.sdkman.io/2",
          npm_package_exports___import: "./dist/rich-text-editor.es.js",
          PNPM_SCRIPT_SRC_DIR:
            "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
          npm_package_repository_directory: "ui/packages/editor",
          npm_package_dependencies__tiptap_extension_history: "^2.11.2",
          npm_config_strict_peer_dependencies: "",
          SSH_AUTH_SOCK: "/private/tmp/com.apple.launchd.EWHtKwuaoy/Listeners",
          __CF_USER_TEXT_ENCODING: "0x1F5:0x0:0x0",
          npm_execpath:
            "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/bin/pnpm.cjs",
          PAGER: "less",
          npm_package_module: "./dist/rich-text-editor.es.js",
          npm_package_dependencies__tiptap_extension_text: "^2.11.2",
          LSCOLORS: "Gxfxcxdxbxegedabagacad",
          npm_package_dependencies__tiptap_extension_list_item: "^2.11.2",
          npm_package_dependencies_scroll_into_view_if_needed: "^3.1.0",
          npm_config_frozen_lockfile: "",
          npm_package_dependencies__tiptap_extension_horizontal_rule: "^2.11.2",
          npm_package_dependencies__tiptap_extension_text_style: "^2.11.2",
          npm_package_devDependencies__types_linkifyjs: "^2.1.7",
          PATH: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor/node_modules/.bin:/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node-gyp-bin:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/Applications/VMware Fusion.app/Contents/Public:/Users/ryanwang/Workspace/sdk/flutter/bin/cache/dart-sdk/bin/:/Users/ryanwang/.codeium/windsurf/bin:/Users/ryanwang/.sdkman/candidates/maven/current/bin:/Users/ryanwang/.sdkman/candidates/java/current/bin:/Users/ryanwang/.wasmer/bin:/Users/ryanwang/.bun/bin:/Users/ryanwang/Library/pnpm:/Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains:/Applications/DevEco-Studio.app/Contents/tools/hvigor/bin:/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin:/Users/ryanwang/.cargo/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin:/Users/ryanwang/.orbstack/bin:/Users/ryanwang/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/ryanwang/.cargo/bin:/opt/homebrew/opt/node@22/bin:/Users/ryanwang/Library/Python/3.9/bin:/Users/ryanwang/go/bin:/Users/ryanwang/Library/Android/sdk/cmdline-tools/latest/bin:/Users/ryanwang/Library/Android/sdk/platform-tools:/Users/ryanwang/.pub-cache/bin",
          MAVEN_HOME: "/Users/ryanwang/.sdkman/candidates/maven/current",
          npm_package_devDependencies_release_it: "^16.1.5",
          npm_package_scripts_typecheck:
            "vue-tsc --noEmit -p tsconfig.app.json --composite false",
          npm_package_peerDependencies_vue: "^3.5.13",
          __CFBundleIdentifier: "com.todesktop.230313mzl4w4u92",
          USER_ZDOTDIR: "/Users/ryanwang",
          COREPACK_ENABLE_DOWNLOAD_PROMPT: "0",
          npm_package_author: "@halo-dev",
          npm_package_dependencies__ckpack_vue_color: "^1.5.0",
          npm_config_auto_install_peers: "true",
          PWD: "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/packages/editor",
          npm_command: "run-script",
          JAVA_HOME: "/Users/ryanwang/.sdkman/candidates/java/current",
          VSCODE_NONCE: "078999c2-62af-4aa8-a7f9-164286e175fd",
          npm_package_bugs_url: "https://github.com/halo-dev/halo/issues",
          npm_package_dependencies__tiptap_extension_bold: "^2.11.2",
          EDITOR: "nvim",
          P9K_SSH: "0",
          npm_lifecycle_event: "build",
          LANG: "en_US.UTF-8",
          P9K_TTY: "old",
          npm_package_name: "@halo-dev/richtext-editor",
          npm_package_repository_type: "git",
          npm_package_types: "./dist/index.d.ts",
          npm_package_dependencies__tiptap_extension_hard_break: "^2.11.2",
          npm_package_dependencies__tiptap_extension_strike: "^2.11.2",
          npm_package_dependencies__tiptap_extension_superscript: "^2.11.2",
          npm_package_dependencies__tiptap_suggestion: "^2.11.2",
          NODE_PATH:
            "/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/bin/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules/vite/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/vite@6.0.3_@types+node@18.13.0_less@4.2.0_sass-embedded@1.83.0_sass@1.60.0_terser@5.37.0/node_modules:/Users/ryanwang/Workspace/github/ruibaby/halo-next/ui/node_modules/.pnpm/node_modules",
          npm_package_exports___types: "./dist/index.d.ts",
          npm_package_scripts_build: "vite build --config ./vite.lib.config.ts",
          XPC_FLAGS: "0x0",
          VSCODE_GIT_ASKPASS_EXTRA_ARGS: "",
          npm_package_dependencies__tiptap_extension_task_list: "^2.11.2",
          npm_package_dependencies_tippy_js: "^6.3.7",
          npm_package_main: "./dist/rich-text-editor.iife.js",
          npm_package_dependencies__tiptap_extension_bullet_list: "^2.11.2",
          npm_package_devDependencies_vite_plugin_dts: "^4.2.2",
          npm_config_node_gyp:
            "/Users/ryanwang/.cache/node/corepack/v1/pnpm/9.15.0/dist/node_modules/node-gyp/bin/node-gyp.js",
          XPC_SERVICE_NAME: "0",
          npm_package_version: "2.20.0",
          npm_package_devDependencies__iconify_json: "^2.2.117",
          VSCODE_INJECTION: "1",
          npm_package_dependencies__tiptap_core: "^2.11.2",
          npm_package_dependencies__tiptap_extension_code: "^2.11.2",
          HOME: "/Users/ryanwang",
          SHLVL: "2",
          npm_package_exports___dist_style_css: "./dist/style.css",
          VSCODE_GIT_ASKPASS_MAIN:
            "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js",
          npm_package_dependencies__tiptap_extension_image: "^2.11.2",
          npm_package_dependencies__tiptap_extension_subscript: "^2.11.2",
          npm_package_dependencies_github_markdown_css: "^5.2.0",
          npm_package_dependencies__tiptap_extension_ordered_list: "^2.11.2",
          npm_package_dependencies__tiptap_extension_code_block: "^2.11.2",
          LOGNAME: "ryanwang",
          LESS: "-R",
          SDKMAN_DIR: "/Users/ryanwang/.sdkman",
          npm_lifecycle_script: "vite build --config ./vite.lib.config.ts",
          VSCODE_GIT_IPC_HANDLE:
            "/var/folders/pl/2sj_41xn3nv98xvrfr7xyrl00000gn/T/vscode-git-506635f378.sock",
          npm_package_dependencies__tiptap_extension_table: "^2.11.2",
          npm_package_dependencies__tiptap_extension_underline: "^2.11.2",
          BUN_INSTALL: "/Users/ryanwang/.bun",
          npm_package_scripts_test_unit_watch:
            "vitest --environment jsdom --watch",
          npm_package_dependencies__tiptap_extension_color: "^2.11.2",
          npm_package_dependencies__tiptap_extension_text_align: "^2.11.2",
          npm_config_user_agent: "pnpm/9.15.0 npm/? node/v22.14.0 darwin arm64",
          SDKMAN_CANDIDATES_DIR: "/Users/ryanwang/.sdkman/candidates",
          GIT_ASKPASS:
            "/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh",
          VSCODE_GIT_ASKPASS_NODE:
            "/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)",
          _P9K_SSH_TTY: "/dev/ttys005",
          npm_package_dependencies__tiptap_extension_blockquote: "^2.11.2",
          npm_package_files_0: "dist",
          npm_package_dependencies__tiptap_extension_table_row: "^2.11.2",
          OHOS_TOOL_HOME: "/Applications/DevEco-Studio.app/Contents",
          COLORTERM: "truecolor",
          npm_node_execpath: "/opt/homebrew/Cellar/node@22/22.14.0_1/bin/node",
          NODE_ENV: "production",
        };
        Object.defineProperty(t, "__esModule", {
          value: !0,
        });
        function n(u, c) {
          for (var d in c)
            Object.defineProperty(u, d, {
              enumerable: !0,
              get: c[d],
            });
        }
        n(t, {
          dim: () => a,
          default: () => l,
        });
        const r = /* @__PURE__ */ o(/* @__PURE__ */ jL());
        function o(u) {
          return u && u.__esModule
            ? u
            : {
                default: u,
              };
        }
        let i = /* @__PURE__ */ new Set();
        function s(u, c, d) {
          (typeof process < "u" && e.JEST_WORKER_ID) ||
            (d && i.has(d)) ||
            (d && i.add(d),
            console.warn(""),
            c.forEach((f) => console.warn(u, "-", f)));
        }
        function a(u) {
          return r.default.dim(u);
        }
        const l = {
          info(u, c) {
            s(
              r.default.bold(r.default.cyan("info")),
              ...(Array.isArray(u) ? [u] : [c, u])
            );
          },
          warn(u, c) {
            s(
              r.default.bold(r.default.yellow("warn")),
              ...(Array.isArray(u) ? [u] : [c, u])
            );
          },
          risk(u, c) {
            s(
              r.default.bold(r.default.magenta("risk")),
              ...(Array.isArray(u) ? [u] : [c, u])
            );
          },
        };
      })(wf)),
    wf
  );
}
var c2;
function qL() {
  return (
    c2 ||
      ((c2 = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", {
          value: !0,
        }),
          Object.defineProperty(t, "default", {
            enumerable: !0,
            get: () => o,
          });
        const e = /* @__PURE__ */ n(WL());
        function n(i) {
          return i && i.__esModule
            ? i
            : {
                default: i,
              };
        }
        function r({ version: i, from: s, to: a }) {
          e.default.warn(`${s}-color-renamed`, [
            `As of Tailwind CSS ${i}, \`${s}\` has been renamed to \`${a}\`.`,
            "Update your configuration file to silence this warning.",
          ]);
        }
        const o = {
          inherit: "inherit",
          current: "currentColor",
          transparent: "transparent",
          black: "#000",
          white: "#fff",
          slate: {
            50: "#f8fafc",
            100: "#f1f5f9",
            200: "#e2e8f0",
            300: "#cbd5e1",
            400: "#94a3b8",
            500: "#64748b",
            600: "#475569",
            700: "#334155",
            800: "#1e293b",
            900: "#0f172a",
            950: "#020617",
          },
          gray: {
            50: "#f9fafb",
            100: "#f3f4f6",
            200: "#e5e7eb",
            300: "#d1d5db",
            400: "#9ca3af",
            500: "#6b7280",
            600: "#4b5563",
            700: "#374151",
            800: "#1f2937",
            900: "#111827",
            950: "#030712",
          },
          zinc: {
            50: "#fafafa",
            100: "#f4f4f5",
            200: "#e4e4e7",
            300: "#d4d4d8",
            400: "#a1a1aa",
            500: "#71717a",
            600: "#52525b",
            700: "#3f3f46",
            800: "#27272a",
            900: "#18181b",
            950: "#09090b",
          },
          neutral: {
            50: "#fafafa",
            100: "#f5f5f5",
            200: "#e5e5e5",
            300: "#d4d4d4",
            400: "#a3a3a3",
            500: "#737373",
            600: "#525252",
            700: "#404040",
            800: "#262626",
            900: "#171717",
            950: "#0a0a0a",
          },
          stone: {
            50: "#fafaf9",
            100: "#f5f5f4",
            200: "#e7e5e4",
            300: "#d6d3d1",
            400: "#a8a29e",
            500: "#78716c",
            600: "#57534e",
            700: "#44403c",
            800: "#292524",
            900: "#1c1917",
            950: "#0c0a09",
          },
          red: {
            50: "#fef2f2",
            100: "#fee2e2",
            200: "#fecaca",
            300: "#fca5a5",
            400: "#f87171",
            500: "#ef4444",
            600: "#dc2626",
            700: "#b91c1c",
            800: "#991b1b",
            900: "#7f1d1d",
            950: "#450a0a",
          },
          orange: {
            50: "#fff7ed",
            100: "#ffedd5",
            200: "#fed7aa",
            300: "#fdba74",
            400: "#fb923c",
            500: "#f97316",
            600: "#ea580c",
            700: "#c2410c",
            800: "#9a3412",
            900: "#7c2d12",
            950: "#431407",
          },
          amber: {
            50: "#fffbeb",
            100: "#fef3c7",
            200: "#fde68a",
            300: "#fcd34d",
            400: "#fbbf24",
            500: "#f59e0b",
            600: "#d97706",
            700: "#b45309",
            800: "#92400e",
            900: "#78350f",
            950: "#451a03",
          },
          yellow: {
            50: "#fefce8",
            100: "#fef9c3",
            200: "#fef08a",
            300: "#fde047",
            400: "#facc15",
            500: "#eab308",
            600: "#ca8a04",
            700: "#a16207",
            800: "#854d0e",
            900: "#713f12",
            950: "#422006",
          },
          lime: {
            50: "#f7fee7",
            100: "#ecfccb",
            200: "#d9f99d",
            300: "#bef264",
            400: "#a3e635",
            500: "#84cc16",
            600: "#65a30d",
            700: "#4d7c0f",
            800: "#3f6212",
            900: "#365314",
            950: "#1a2e05",
          },
          green: {
            50: "#f0fdf4",
            100: "#dcfce7",
            200: "#bbf7d0",
            300: "#86efac",
            400: "#4ade80",
            500: "#22c55e",
            600: "#16a34a",
            700: "#15803d",
            800: "#166534",
            900: "#14532d",
            950: "#052e16",
          },
          emerald: {
            50: "#ecfdf5",
            100: "#d1fae5",
            200: "#a7f3d0",
            300: "#6ee7b7",
            400: "#34d399",
            500: "#10b981",
            600: "#059669",
            700: "#047857",
            800: "#065f46",
            900: "#064e3b",
            950: "#022c22",
          },
          teal: {
            50: "#f0fdfa",
            100: "#ccfbf1",
            200: "#99f6e4",
            300: "#5eead4",
            400: "#2dd4bf",
            500: "#14b8a6",
            600: "#0d9488",
            700: "#0f766e",
            800: "#115e59",
            900: "#134e4a",
            950: "#042f2e",
          },
          cyan: {
            50: "#ecfeff",
            100: "#cffafe",
            200: "#a5f3fc",
            300: "#67e8f9",
            400: "#22d3ee",
            500: "#06b6d4",
            600: "#0891b2",
            700: "#0e7490",
            800: "#155e75",
            900: "#164e63",
            950: "#083344",
          },
          sky: {
            50: "#f0f9ff",
            100: "#e0f2fe",
            200: "#bae6fd",
            300: "#7dd3fc",
            400: "#38bdf8",
            500: "#0ea5e9",
            600: "#0284c7",
            700: "#0369a1",
            800: "#075985",
            900: "#0c4a6e",
            950: "#082f49",
          },
          blue: {
            50: "#eff6ff",
            100: "#dbeafe",
            200: "#bfdbfe",
            300: "#93c5fd",
            400: "#60a5fa",
            500: "#3b82f6",
            600: "#2563eb",
            700: "#1d4ed8",
            800: "#1e40af",
            900: "#1e3a8a",
            950: "#172554",
          },
          indigo: {
            50: "#eef2ff",
            100: "#e0e7ff",
            200: "#c7d2fe",
            300: "#a5b4fc",
            400: "#818cf8",
            500: "#6366f1",
            600: "#4f46e5",
            700: "#4338ca",
            800: "#3730a3",
            900: "#312e81",
            950: "#1e1b4b",
          },
          violet: {
            50: "#f5f3ff",
            100: "#ede9fe",
            200: "#ddd6fe",
            300: "#c4b5fd",
            400: "#a78bfa",
            500: "#8b5cf6",
            600: "#7c3aed",
            700: "#6d28d9",
            800: "#5b21b6",
            900: "#4c1d95",
            950: "#2e1065",
          },
          purple: {
            50: "#faf5ff",
            100: "#f3e8ff",
            200: "#e9d5ff",
            300: "#d8b4fe",
            400: "#c084fc",
            500: "#a855f7",
            600: "#9333ea",
            700: "#7e22ce",
            800: "#6b21a8",
            900: "#581c87",
            950: "#3b0764",
          },
          fuchsia: {
            50: "#fdf4ff",
            100: "#fae8ff",
            200: "#f5d0fe",
            300: "#f0abfc",
            400: "#e879f9",
            500: "#d946ef",
            600: "#c026d3",
            700: "#a21caf",
            800: "#86198f",
            900: "#701a75",
            950: "#4a044e",
          },
          pink: {
            50: "#fdf2f8",
            100: "#fce7f3",
            200: "#fbcfe8",
            300: "#f9a8d4",
            400: "#f472b6",
            500: "#ec4899",
            600: "#db2777",
            700: "#be185d",
            800: "#9d174d",
            900: "#831843",
            950: "#500724",
          },
          rose: {
            50: "#fff1f2",
            100: "#ffe4e6",
            200: "#fecdd3",
            300: "#fda4af",
            400: "#fb7185",
            500: "#f43f5e",
            600: "#e11d48",
            700: "#be123c",
            800: "#9f1239",
            900: "#881337",
            950: "#4c0519",
          },
          get lightBlue() {
            return (
              r({
                version: "v2.2",
                from: "lightBlue",
                to: "sky",
              }),
              this.sky
            );
          },
          get warmGray() {
            return (
              r({
                version: "v3.0",
                from: "warmGray",
                to: "stone",
              }),
              this.stone
            );
          },
          get trueGray() {
            return (
              r({
                version: "v3.0",
                from: "trueGray",
                to: "neutral",
              }),
              this.neutral
            );
          },
          get coolGray() {
            return (
              r({
                version: "v3.0",
                from: "coolGray",
                to: "gray",
              }),
              this.gray
            );
          },
          get blueGray() {
            return (
              r({
                version: "v3.0",
                from: "blueGray",
                to: "slate",
              }),
              this.slate
            );
          },
        };
      })(kf)),
    kf
  );
}
var Cf, d2;
function KL() {
  if (d2) return Cf;
  d2 = 1;
  let t = qL();
  return (Cf = (t.__esModule ? t : { default: t }).default), Cf;
}
var GL = KL();
const f2 = /* @__PURE__ */ UL(GL),
  JL = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function YL(t, e) {
  return (
    S(),
    O(
      "svg",
      JL,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M8.59 16.58L13.17 12L8.59 7.41L10 6l6 6l-6 6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const XL = k({ name: "mdi-chevron-right", render: YL }),
  ZL = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function QL(t, e) {
  return (
    S(),
    O(
      "svg",
      ZL,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M17.5 12a1.5 1.5 0 0 1-1.5-1.5A1.5 1.5 0 0 1 17.5 9a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m-3-4A1.5 1.5 0 0 1 13 6.5A1.5 1.5 0 0 1 14.5 5A1.5 1.5 0 0 1 16 6.5A1.5 1.5 0 0 1 14.5 8m-5 0A1.5 1.5 0 0 1 8 6.5A1.5 1.5 0 0 1 9.5 5A1.5 1.5 0 0 1 11 6.5A1.5 1.5 0 0 1 9.5 8m-3 4A1.5 1.5 0 0 1 5 10.5A1.5 1.5 0 0 1 6.5 9A1.5 1.5 0 0 1 8 10.5A1.5 1.5 0 0 1 6.5 12M12 3a9 9 0 0 0-9 9a9 9 0 0 0 9 9a1.5 1.5 0 0 0 1.5-1.5c0-.39-.15-.74-.39-1c-.23-.27-.38-.62-.38-1a1.5 1.5 0 0 1 1.5-1.5H16a5 5 0 0 0 5-5c0-4.42-4.03-8-9-8",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const e7 = k({ name: "mdi-palette", render: QL }),
  t7 = { class: "grid grid-cols-9 gap-1.5 p-2 pt-1" },
  n7 = ["title", "onClick"],
  r7 = { class: "p-1" },
  o7 = {
    class:
      "flex items-center rounded cursor-pointer hover:bg-gray-100 p-1 justify-between",
  },
  i7 = { class: "inline-flex items-center gap-2" },
  s7 = { class: "text-xs text-gray-600" },
  vd = /* @__PURE__ */ se({
    __name: "ColorPickerDropdown",
    props: {
      modelValue: { default: void 0 },
    },
    emits: ["update:modelValue"],
    setup(t, { emit: e }) {
      const n = e;
      function r() {
        const s = [],
          a = Object.keys(f2).reduce(
            (l, u) => (
              [
                "gray",
                "red",
                "orange",
                "yellow",
                "green",
                "blue",
                "purple",
                "pink",
              ].includes(u) && (l[u] = f2[u]),
              l
            ),
            {}
          );
        for (const l in a) {
          const u = a[l],
            f = Object.entries(u)
              .filter(([p]) => parseInt(p) >= 100 && parseInt(p) <= 900)
              .sort((p, h) => parseInt(h[0]) - parseInt(p[0]))
              .map(([p, h]) => ({
                color: h,
                name: `${l} ${p}`,
              }));
          s.push(...f);
        }
        return s;
      }
      function o(s) {
        n("update:modelValue", s);
      }
      function i(s) {
        o(s.hex);
      }
      return (s, a) => (
        S(),
        de(
          I(ii),
          { class: "inline-flex items-center" },
          {
            popper: me(() => [
              Kn(s.$slots, "prefix"),
              C("div", t7, [
                (S(!0),
                O(
                  gt,
                  null,
                  Fr(
                    r(),
                    (l) => (
                      S(),
                      O(
                        "div",
                        {
                          key: l.color,
                          style: mt({ backgroundColor: l.color }),
                          class:
                            "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                          title: l.name,
                          onClick: (u) => o(l.color),
                        },
                        null,
                        12,
                        n7
                      )
                    )
                  ),
                  128
                )),
              ]),
              J(
                I(ii),
                { placement: "right" },
                {
                  popper: me(() => [
                    J(I(yd), {
                      "model-value": "#000",
                      "onUpdate:modelValue": i,
                    }),
                  ]),
                  default: me(() => [
                    C("div", r7, [
                      C("div", o7, [
                        C("div", i7, [
                          J(I(e7)),
                          C(
                            "span",
                            s7,
                            it(
                              I(D).global.t(
                                "editor.components.color_picker.more_color"
                              )
                            ),
                            1
                          ),
                        ]),
                        C("div", null, [J(I(XL))]),
                      ]),
                    ]),
                  ]),
                  _: 1,
                }
              ),
            ]),
            default: me(() => [Kn(s.$slots, "default")]),
            _: 3,
          }
        )
      );
    },
  }),
  a7 = { class: "p-1" },
  l7 = { class: "text-xs text-gray-600" },
  u7 = /* @__PURE__ */ se({
    __name: "ColorToolbarItem",
    props: {
      editor: { default: void 0 },
      isActive: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      title: { default: void 0 },
      action: { type: Function, default: void 0 },
      icon: { default: void 0 },
    },
    setup(t) {
      const e = t;
      function n(o) {
        var i;
        o && ((i = e.editor) == null || i.chain().focus().setColor(o).run());
      }
      function r() {
        var o;
        (o = e.editor) == null || o.chain().focus().unsetColor().run();
      }
      return (o, i) => (
        S(),
        de(
          vd,
          { "onUpdate:modelValue": n },
          {
            prefix: me(() => [
              C("div", a7, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: r,
                  },
                  [
                    i[0] ||
                      (i[0] = C(
                        "div",
                        {
                          class:
                            "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black",
                        },
                        null,
                        -1
                      )),
                    C(
                      "span",
                      l7,
                      it(I(D).global.t("editor.common.button.restore_default")),
                      1
                    ),
                  ]
                ),
              ]),
            ]),
            default: me(() => [J(I(Xe), ph(hh(e)), null, 16)]),
            _: 1,
          }
        )
      );
    },
  }),
  c7 = LN.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 81,
            component: k(u7),
            props: {
              editor: e,
              isActive: !1,
              icon: k(_3),
              title: D.global.t("editor.common.color"),
            },
          };
        },
      };
    },
    addExtensions() {
      return [v3];
    },
  }),
  d7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function f7(t, e) {
  return (
    S(),
    O(
      "svg",
      d7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M2 4v3h5v12h3V7h5V4zm19 5h-9v3h3v7h3v-7h3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const p7 = k({ name: "mdi-format-size", render: f7 }),
  h7 = Ne.create({
    name: "fontSize",
    addOptions() {
      return {
        types: ["textStyle"],
        getToolbarItems({ editor: t }) {
          return {
            priority: 31,
            component: k(Xe),
            props: {
              editor: t,
              isActive: !1,
              icon: k(p7),
            },
            children: [
              {
                priority: 0,
                component: k(Ut),
                props: {
                  editor: t,
                  isActive: !1,
                  title: D.global.t("editor.common.text.default"),
                  action: () => t.chain().focus().unsetFontSize().run(),
                },
              },
              ...[8, 10, 12, 14, 16, 18, 20, 24, 30, 36, 48, 60, 72].map(
                (e) => ({
                  priority: e,
                  component: k(Ut),
                  props: {
                    editor: t,
                    isActive: !1,
                    title: `${e} px`,
                    action: () => t.chain().focus().setFontSize(e).run(),
                  },
                })
              ),
            ],
          };
        },
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            fontSize: {
              default: null,
              parseHTML: (t) => t.style.fontSize || "",
              renderHTML: (t) =>
                t.fontSize
                  ? {
                      style: `font-size: ${t.fontSize
                        .toString()
                        .replace("px", "")}px`,
                    }
                  : t,
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setFontSize:
          (t) =>
          ({ chain: e }) =>
            e().setMark("textStyle", { fontSize: t }).run(),
        unsetFontSize:
          () =>
          ({ chain: t }) =>
            t()
              .setMark("textStyle", { fontSize: null })
              .removeEmptyTextStyle()
              .run(),
      };
    },
    addExtensions() {
      return [v3];
    },
  });
function m7(t) {
  return encodeURIComponent(
    String(t).trim().toLowerCase().replace(/\s+/g, "-")
  );
}
const g7 = (t, e) => {
    const n = m7(t);
    let r = n;
    for (; e.includes(r); ) {
      const i = r.replace(n, "").match(/-(\d+)$/);
      i ? (r = `${n}-${Number(i[1]) + 1}`) : (r = `${n}-1`);
    }
    return r;
  },
  ba = (t) => (e) => {
    if (t.depth)
      for (let r = t.depth; r > 0; r--)
        return e.delete(t.before(r), t.after(r)).scrollIntoView(), !0;
    else {
      const r = t.parent;
      if (!r.isTextblock && r.nodeSize)
        return e.setSelection(Z.create(t.doc, t.pos)).deleteSelection(), !0;
    }
    const n = t.pos;
    return n ? (e.delete(n, n + t.node().nodeSize), !0) : !1;
  },
  ls = (t, e) => {
    const { state: n } = e,
      r = n.selection.$anchor,
      o = !1;
    if (r.depth) {
      for (let i = r.depth; i > 0; i--)
        if (r.node(i).type.name === t)
          return (
            e.dispatchTransaction &&
              e.dispatchTransaction(
                n.tr.delete(r.before(i), r.after(i)).scrollIntoView()
              ),
            !0
          );
    } else {
      const i = n.selection.node;
      if (i && i.type.name === t) return e.chain().deleteSelection().run(), !0;
    }
    {
      const i = r.pos;
      if (i) {
        const s = n.tr.doc.nodeAt(i);
        if (s && s.type.name === t)
          return (
            e.dispatchTransaction &&
              e.dispatchTransaction(n.tr.delete(i, i + s.nodeSize)),
            !0
          );
      }
    }
    return o;
  },
  _0 = (t) =>
    t.extensionManager.extensions
      .filter((r) => {
        const o = {
            name: r.name,
            options: r.options,
            storage: r.storage,
          },
          i = le(K(r, "group", o));
        return typeof i != "string" ? !1 : i.split(" ").includes("list");
      })
      .some((r) => Jt(t.state, r.name)),
  k3 = (t) => b7(t) || y7(t),
  b7 = (t) => {
    var r;
    const e = (r = t.type.createAndFill()) == null ? void 0 : r.toJSON(),
      n = t.toJSON();
    return JSON.stringify(e) === JSON.stringify(n);
  },
  y7 = (t) =>
    t.type.name !== "paragraph" || t.childCount > 0
      ? !1
      : t.textContent.length === 0,
  v7 = Ze.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [{ tag: "p" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["p", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setParagraph:
          () =>
          ({ commands: t }) =>
            t.setNode(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => this.editor.commands.setParagraph(),
      };
    },
  }),
  _7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function x7(t, e) {
  return (
    S(),
    O(
      "svg",
      _7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "none",
              stroke: "currentColor",
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "m3 8l3-3l3 3m-6 8l3 3l3-3M6 5v14m7-13h7m-7 6h7m-7 6h7",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const k7 = k({ name: "tabler-line-height", render: x7 }),
  Ii = v7.extend({
    addAttributes() {
      return {
        lineHeight: {
          default: null,
          parseHTML: (t) => t.style.lineHeight,
          renderHTML: (t) => {
            const e = t.lineHeight;
            return e
              ? {
                  style: `line-height: ${e}`,
                }
              : {};
          },
        },
      };
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && n.tagName !== "P"; ) n = n.parentElement;
              return {
                el: n,
                dragDomOffset: {
                  y: -1,
                },
              };
            },
            allowPropagationDownward: !0,
          };
        },
        getToolbarItems({ editor: e }) {
          var n;
          return {
            priority: 220,
            component: k(Xe),
            props: {
              editor: e,
              isActive: !!(
                (n = e.getAttributes(Ii.name)) != null && n.lineHeight
              ),
              icon: k(k7),
              title: D.global.t("editor.common.line_height"),
            },
            children: [0, 1, 1.5, 2, 2.5, 3].map((r) => {
              var o;
              return {
                priority: r,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive:
                    ((o = e.getAttributes(Ii.name)) == null
                      ? void 0
                      : o.lineHeight) === r,
                  title: r
                    ? String(r)
                    : D.global.t("editor.common.text.default"),
                  action: () =>
                    e
                      .chain()
                      .focus()
                      .updateAttributes(Ii.name, {
                        lineHeight: r,
                      })
                      .run(),
                },
              };
            }),
          };
        },
      };
    },
    addKeyboardShortcuts() {
      return {
        Backspace: ({ editor: t }) => {
          const { state: e, view: n } = t,
            { selection: r } = e;
          if (_0(t) || !Jt(e, Ii.name) || !(r instanceof q) || !r.empty)
            return !1;
          const { $from: o } = r;
          if (o.parentOffset !== 0) return !1;
          const i = o.before(o.depth);
          return k3(o.parent)
            ? w7(o, i, e, n.dispatch)
            : i === 0
            ? !1
            : C7(o, i, e, n.dispatch);
        },
      };
    },
  });
function w7(t, e, n, r) {
  const { tr: o } = n;
  return ba(t)(o) && r
    ? (e !== 0 && o.setSelection(q.near(o.doc.resolve(e - 1), -1)), r(o), !0)
    : !1;
}
function C7(t, e, n, r) {
  const { tr: o } = n;
  if (!r) return !1;
  const s = t.doc.resolve(e).nodeBefore;
  return !s || !s.type.isBlock || s.type.isText || s.type.name === Ii.name
    ? !1
    : ba(t.doc.resolve(e - 1))(o)
    ? (r(o), !0)
    : !1;
}
const A7 = Ze.create({
    name: "heading",
    addOptions() {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {},
      };
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: !1,
        },
      };
    },
    parseHTML() {
      return this.options.levels.map((t) => ({
        tag: `h${t}`,
        attrs: { level: t },
      }));
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        `h${
          this.options.levels.includes(t.attrs.level)
            ? t.attrs.level
            : this.options.levels[0]
        }`,
        ge(this.options.HTMLAttributes, e),
        0,
      ];
    },
    addCommands() {
      return {
        setHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level)
              ? e.setNode(this.name, t)
              : !1,
        toggleHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level)
              ? e.toggleNode(this.name, "paragraph", t)
              : !1,
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce(
        (t, e) => ({
          ...t,
          [`Mod-Alt-${e}`]: () =>
            this.editor.commands.toggleHeading({ level: e }),
        }),
        {}
      );
    },
    addInputRules() {
      return this.options.levels.map((t) =>
        Pp({
          find: new RegExp(
            `^(#{${Math.min(...this.options.levels)},${t}})\\s$`
          ),
          type: this.type,
          getAttributes: {
            level: t,
          },
        })
      );
    },
  }),
  S7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function E7(t, e) {
  return (
    S(),
    O(
      "svg",
      S7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm11 14v-2h2V6.31l-2.5 1.44V5.44L16 4h2v12h2v2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const p2 = k({ name: "mdi-format-header-1", render: E7 }),
  M7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function T7(t, e) {
  return (
    S(),
    O(
      "svg",
      M7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm18 14h-6a2 2 0 0 1-2-2c0-.53.2-1 .54-1.36l4.87-5.23c.37-.36.59-.86.59-1.41a2 2 0 0 0-2-2a2 2 0 0 0-2 2h-2a4 4 0 0 1 4-4a4 4 0 0 1 4 4c0 1.1-.45 2.1-1.17 2.83L15 16h6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const h2 = k({ name: "mdi-format-header-2", render: T7 }),
  O7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function D7(t, e) {
  return (
    S(),
    O(
      "svg",
      O7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-1h2v1h4v-4h-4v-2h4V6h-4v1h-2V6a2 2 0 0 1 2-2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const m2 = k({ name: "mdi-format-header-3", render: D7 }),
  N7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function L7(t, e) {
  return (
    S(),
    O(
      "svg",
      N7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm15 14v-5h-5v-2l5-7h2v7h1v2h-1v5zm0-7V7.42L15.45 11z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const g2 = k({ name: "mdi-format-header-4", render: L7 }),
  R7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function I7(t, e) {
  return (
    S(),
    O(
      "svg",
      R7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h5v2h-5v4h2a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2a2 2 0 0 1-2-2v-1h2v1h2a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const b2 = k({ name: "mdi-format-header-5", render: I7 }),
  P7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function $7(t, e) {
  return (
    S(),
    O(
      "svg",
      P7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v1h-2V6h-4v4h4a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 8v4h4v-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const y2 = k({ name: "mdi-format-header-6", render: $7 }),
  B7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function H7(t, e) {
  return (
    S(),
    O(
      "svg",
      B7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm10 4h2.31l.32-3h2l-.32 3h2l.32-3h2l-.32 3H23v2h-1.9l-.2 2H23v2h-2.31l-.32 3h-2l.32-3h-2l-.32 3h-2l.32-3H13v-2h1.9l.2-2H13zm4.1 2l-.2 2h2l.2-2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const F7 = k({ name: "mdi-format-header-pound", render: H7 }),
  z7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function V7(t, e) {
  return (
    S(),
    O(
      "svg",
      z7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13 4a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2v6H9V4zm0 6a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2v4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const v2 = k({ name: "mdi-format-paragraph", render: V7 }),
  Up = A7.extend({
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        `h${
          this.options.levels.includes(t.attrs.level)
            ? t.attrs.level
            : this.options.levels[0]
        }`,
        ge(this.options.HTMLAttributes, e),
        0,
      ];
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 30,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("paragraph") || e.isActive("heading"),
              icon: k(F7),
            },
            children: [
              {
                priority: 10,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("paragraph"),
                  icon: k(v2),
                  title: D.global.t("editor.common.heading.paragraph"),
                  action: () => e.chain().focus().setParagraph().run(),
                },
              },
              {
                priority: 20,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 1 }),
                  icon: k(p2),
                  title: D.global.t("editor.common.heading.header1"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 1 }).run(),
                },
              },
              {
                priority: 30,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 2 }),
                  icon: k(h2),
                  title: D.global.t("editor.common.heading.header2"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 2 }).run(),
                },
              },
              {
                priority: 40,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 3 }),
                  icon: k(m2),
                  title: D.global.t("editor.common.heading.header3"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 3 }).run(),
                },
              },
              {
                priority: 50,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 4 }),
                  icon: k(g2),
                  title: D.global.t("editor.common.heading.header4"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 4 }).run(),
                },
              },
              {
                priority: 60,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 5 }),
                  icon: k(b2),
                  title: D.global.t("editor.common.heading.header5"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 5 }).run(),
                },
              },
              {
                priority: 70,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive("heading", { level: 6 }),
                  icon: k(y2),
                  title: D.global.t("editor.common.heading.header6"),
                  action: () =>
                    e.chain().focus().toggleHeading({ level: 6 }).run(),
                },
              },
            ],
          };
        },
        getCommandMenuItems() {
          return [
            {
              priority: 10,
              icon: k(v2),
              title: "editor.common.heading.paragraph",
              keywords: ["paragraph", "text", "putongwenben"],
              command: ({ editor: e, range: n }) => {
                e.chain().focus().deleteRange(n).setParagraph().run();
              },
            },
            {
              priority: 20,
              icon: k(p2),
              title: "editor.common.heading.header1",
              keywords: ["h1", "header1", "1", "yijibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 1 })
                  .run();
              },
            },
            {
              priority: 30,
              icon: k(h2),
              title: "editor.common.heading.header2",
              keywords: ["h2", "header2", "2", "erjibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 2 })
                  .run();
              },
            },
            {
              priority: 40,
              icon: k(m2),
              title: "editor.common.heading.header3",
              keywords: ["h3", "header3", "3", "sanjibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 3 })
                  .run();
              },
            },
            {
              priority: 50,
              icon: k(g2),
              title: "editor.common.heading.header4",
              keywords: ["h4", "header4", "4", "sijibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 4 })
                  .run();
              },
            },
            {
              priority: 60,
              icon: k(b2),
              title: "editor.common.heading.header5",
              keywords: ["h5", "header5", "5", "wujibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 5 })
                  .run();
              },
            },
            {
              priority: 70,
              icon: k(y2),
              title: "editor.common.heading.header6",
              keywords: ["h6", "header6", "6", "liujibiaoti"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .setNode("heading", { level: 6 })
                  .run();
              },
            },
          ];
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              const n = ["H1", "H2", "H3", "H4", "H5", "H6"];
              let r = e;
              for (; r && !n.includes(r.tagName); ) r = r.parentElement;
              if (!r)
                return {
                  el: e,
                };
              let o;
              switch (r == null ? void 0 : r.tagName) {
                case "H1":
                  o = 10;
                  break;
                case "H2":
                  o = 2;
                  break;
                case "H3":
                  o = 0;
                  break;
                case "H4":
                  o = -3;
                  break;
                case "H5":
                  o = -5;
                  break;
                case "H6":
                  o = -5;
                  break;
                default:
                  o = 0;
                  break;
              }
              return {
                el: r,
                dragDomOffset: {
                  y: o,
                },
              };
            },
          };
        },
      };
    },
    addExtensions() {
      return [Ii];
    },
    addProseMirrorPlugins() {
      let t;
      return [
        new be({
          key: new ke("generate-heading-id"),
          appendTransaction: (e, n, r) => {
            if (
              e.some((i) => {
                const s = this.editor.view.composing;
                if (t !== void 0 && !s) return (t = void 0), !0;
                if (i.docChanged) {
                  if (i.getMeta("paste")) return !0;
                  t = s;
                  const a = i.selection,
                    { $from: l } = a;
                  return l.parent.type.name === Up.name && !s;
                }
                return !1;
              })
            ) {
              const i = r.tr,
                s = [];
              return (
                r.doc.descendants((a, l) => {
                  if (a.type.name === Up.name) {
                    const u = g7(a.textContent, s);
                    i.step(new ei(l, "id", u)), s.push(u);
                  }
                }),
                i
              );
            }
          },
        }),
      ];
    },
  }),
  U7 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/,
  j7 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g,
  W7 = tn.create({
    name: "highlight",
    addOptions() {
      return {
        multicolor: !1,
        HTMLAttributes: {},
      };
    },
    addAttributes() {
      return this.options.multicolor
        ? {
            color: {
              default: null,
              parseHTML: (t) =>
                t.getAttribute("data-color") || t.style.backgroundColor,
              renderHTML: (t) =>
                t.color
                  ? {
                      "data-color": t.color,
                      style: `background-color: ${t.color}; color: inherit`,
                    }
                  : {},
            },
          }
        : {};
    },
    parseHTML() {
      return [
        {
          tag: "mark",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["mark", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setHighlight:
          (t) =>
          ({ commands: e }) =>
            e.setMark(this.name, t),
        toggleHighlight:
          (t) =>
          ({ commands: e }) =>
            e.toggleMark(this.name, t),
        unsetHighlight:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-h": () => this.editor.commands.toggleHighlight(),
      };
    },
    addInputRules() {
      return [
        ci({
          find: U7,
          type: this.type,
        }),
      ];
    },
    addPasteRules() {
      return [
        So({
          find: j7,
          type: this.type,
        }),
      ];
    },
  }),
  q7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function K7(t, e) {
  return (
    S(),
    O(
      "svg",
      q7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m4 17l2.75-2.75l-.03-.02c-.58-.59-.58-1.54 0-2.12l4.74-4.74l4.24 4.24l-4.74 4.74c-.57.58-1.5.58-2.09.02l-.63.63zM15.91 2.91c.59-.58 1.54-.58 2.12 0l2.13 2.12c.58.59.58 1.54 0 2.13l-3.3 3.29l-4.24-4.24z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const w3 = k({ name: "mdi-format-color-highlight", render: K7 }),
  G7 = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function J7(t, e) {
  return (
    S(),
    O(
      "svg",
      G7,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16.5 8C14 8 12 10 12 12.5s2 4.5 4.5 4.5s4.5-2 4.5-4.5S19 8 16.5 8m0 7.5c-1.7 0-3-1.3-3-3c0-.6.2-1.1.4-1.5l4.1 4.1c-.4.2-.9.4-1.5.4m2.6-1.5L15 9.9c.4-.3.9-.4 1.5-.4c1.7 0 3 1.3 3 3c0 .6-.2 1.1-.4 1.5m-7-6.3l-1.5-1.5l3.3-3.3c.6-.6 1.5-.6 2.1 0L18.2 5c.4.4.5.8.4 1.3c-.6-.2-1.3-.3-2-.3c-1.8 0-3.3.7-4.5 1.7m-1.6 7.2L9 16.3c-.6.6-1.5.6-2.1 0l-.7.7H2l2.8-2.8c-.6-.6-.6-1.5 0-2.1l4.7-4.7L11.1 9c-.7 1-1.1 2.2-1.1 3.5c0 .8.2 1.6.5 2.4",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const C3 = k({ name: "mdi-format-color-marker-cancel", render: J7 }),
  Y7 = { class: "p-1" },
  X7 = { class: "inline-flex items-center gap-2" },
  Z7 = { class: "text-xs text-gray-600" },
  Q7 = { class: "p-1" },
  eR = { class: "text-xs text-gray-600" },
  tR = /* @__PURE__ */ se({
    __name: "HighlightToolbarItem",
    props: {
      editor: { default: void 0 },
      isActive: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      title: { default: void 0 },
      action: { type: Function, default: void 0 },
      icon: { default: void 0 },
    },
    setup(t) {
      const e = t;
      function n(o) {
        var i;
        (i = e.editor) == null ||
          i
            .chain()
            .focus()
            .setHighlight(o ? { color: o } : void 0)
            .run();
      }
      function r() {
        var o;
        (o = e.editor) == null || o.chain().focus().unsetHighlight().run();
      }
      return (o, i) => (
        S(),
        de(
          vd,
          { "onUpdate:modelValue": n },
          {
            prefix: me(() => [
              C("div", Y7, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: r,
                  },
                  [
                    C("div", X7, [
                      J(I(C3)),
                      C(
                        "span",
                        Z7,
                        it(I(D).global.t("editor.extensions.highlight.unset")),
                        1
                      ),
                    ]),
                  ]
                ),
              ]),
              C("div", Q7, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: i[1] || (i[1] = (s) => n()),
                  },
                  [
                    i[2] ||
                      (i[2] = C(
                        "div",
                        {
                          class:
                            "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                          style: { "background-color": "#fff8c5" },
                        },
                        null,
                        -1
                      )),
                    C(
                      "span",
                      eR,
                      it(I(D).global.t("editor.common.button.restore_default")),
                      1
                    ),
                  ]
                ),
              ]),
            ]),
            default: me(() => [
              J(
                I(Xe),
                Fn(e, {
                  onClick: i[0] || (i[0] = (s) => n()),
                }),
                null,
                16
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  nR = W7.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 80,
            component: k(tR),
            props: {
              editor: e,
              isActive: e.isActive("highlight"),
              icon: k(w3),
              title: D.global.t("editor.common.highlight"),
            },
          };
        },
      };
    },
  }).configure({ multicolor: !0 }),
  rR = Ne.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500,
      };
    },
    addCommands() {
      return {
        undo:
          () =>
          ({ state: t, dispatch: e }) =>
            xu(t, e),
        redo:
          () =>
          ({ state: t, dispatch: e }) =>
            ku(t, e),
      };
    },
    addProseMirrorPlugins() {
      return [NA(this.options)];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        // Russian keyboard layouts
        "Mod-": () => this.editor.commands.undo(),
        "Shift-Mod-": () => this.editor.commands.redo(),
      };
    },
  }),
  oR = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function iR(t, e) {
  return (
    S(),
    O(
      "svg",
      oR,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10.5 7A6.5 6.5 0 0 0 4 13.5a6.5 6.5 0 0 0 6.5 6.5H14v-2h-3.5C8 18 6 16 6 13.5S8 9 10.5 9h5.67l-3.08 3.09l1.41 1.41L20 8l-5.5-5.5l-1.42 1.41L16.17 7zM18 18h-2v2h2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const sR = k({ name: "mdi-redo-variant", render: iR }),
  aR = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function lR(t, e) {
  return (
    S(),
    O(
      "svg",
      aR,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13.5 7a6.5 6.5 0 0 1 6.5 6.5a6.5 6.5 0 0 1-6.5 6.5H10v-2h3.5c2.5 0 4.5-2 4.5-4.5S16 9 13.5 9H7.83l3.08 3.09L9.5 13.5L4 8l5.5-5.5l1.42 1.41L7.83 7zM6 18h2v2H6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const uR = k({ name: "mdi-undo-variant", render: lR }),
  cR = rR.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return [
            {
              priority: 10,
              component: k(Xe),
              props: {
                editor: e,
                isActive: !1,
                icon: k(uR),
                title: D.global.t("editor.menus.undo"),
                action: () => e.chain().undo().focus().run(),
              },
            },
            {
              priority: 20,
              component: k(Xe),
              props: {
                editor: e,
                isActive: !1,
                icon: k(sR),
                title: D.global.t("editor.menus.redo"),
                action: () => e.chain().redo().focus().run(),
              },
            },
          ];
        },
      };
    },
  }),
  dR = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
  fR = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
  pR = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
  hR = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
  mR = tn.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "em",
        },
        {
          tag: "i",
          getAttrs: (t) => t.style.fontStyle !== "normal" && null,
        },
        {
          style: "font-style=normal",
          clearMark: (t) => t.type.name === this.name,
        },
        {
          style: "font-style=italic",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["em", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setItalic:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleItalic:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetItalic:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic(),
      };
    },
    addInputRules() {
      return [
        ci({
          find: dR,
          type: this.type,
        }),
        ci({
          find: pR,
          type: this.type,
        }),
      ];
    },
    addPasteRules() {
      return [
        So({
          find: fR,
          type: this.type,
        }),
        So({
          find: hR,
          type: this.type,
        }),
      ];
    },
  }),
  gR = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function bR(t, e) {
  return (
    S(),
    O(
      "svg",
      gR,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const A3 = k({ name: "mdi-format-italic", render: bR }),
  yR = mR.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 50,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("italic"),
              icon: k(A3),
              title: D.global.t("editor.common.italic"),
              action: () => e.chain().focus().toggleItalic().run(),
            },
          };
        },
      };
    },
  }),
  vR =
    "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
  _R =
    "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
  Qi = (t, e) => {
    for (const n in e) t[n] = e[n];
    return t;
  },
  jp = "numeric",
  Wp = "ascii",
  qp = "alpha",
  Ps = "asciinumeric",
  vs = "alphanumeric",
  Kp = "domain",
  S3 = "emoji",
  xR = "scheme",
  kR = "slashscheme",
  Af = "whitespace";
function wR(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Jo(t, e, n) {
  e[jp] && ((e[Ps] = !0), (e[vs] = !0)),
    e[Wp] && ((e[Ps] = !0), (e[qp] = !0)),
    e[Ps] && (e[vs] = !0),
    e[qp] && (e[vs] = !0),
    e[vs] && (e[Kp] = !0),
    e[S3] && (e[Kp] = !0);
  for (const r in e) {
    const o = wR(r, n);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function CR(t, e) {
  const n = {};
  for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Wt(t = null) {
  (this.j = {}), (this.jr = []), (this.jd = null), (this.t = t);
}
Wt.groups = {};
Wt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this,
      n = e.j[t];
    if (n) return n;
    for (let r = 0; r < e.jr.length; r++) {
      const o = e.jr[r][0],
        i = e.jr[r][1];
      if (i && o.test(t)) return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || Wt.groups;
    let o;
    return (
      e && e.j ? (o = e) : ((o = new Wt(e)), n && r && Jo(e, n, r)),
      this.jr.push([t, o]),
      o
    );
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let o = this;
    const i = t.length;
    if (!i) return o;
    for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
    return o.tt(t[i - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || Wt.groups;
    const o = this;
    if (e && e.j) return (o.j[t] = e), e;
    const i = e;
    let s,
      a = o.go(t);
    if (
      (a
        ? ((s = new Wt()),
          Qi(s.j, a.j),
          s.jr.push.apply(s.jr, a.jr),
          (s.jd = a.jd),
          (s.t = a.t))
        : (s = new Wt()),
      i)
    ) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = Qi(CR(s.t, r), n);
          Jo(i, l, r);
        } else n && Jo(i, n, r);
      s.t = i;
    }
    return (o.j[t] = s), s;
  },
};
const pe = (t, e, n, r, o) => t.ta(e, n, r, o),
  et = (t, e, n, r, o) => t.tr(e, n, r, o),
  _2 = (t, e, n, r, o) => t.ts(e, n, r, o),
  V = (t, e, n, r, o) => t.tt(e, n, r, o),
  Dr = "WORD",
  Gp = "UWORD",
  E3 = "ASCIINUMERICAL",
  M3 = "ALPHANUMERICAL",
  ya = "LOCALHOST",
  Jp = "TLD",
  Yp = "UTLD",
  Gl = "SCHEME",
  Oi = "SLASH_SCHEME",
  x0 = "NUM",
  Xp = "WS",
  k0 = "NL",
  $s = "OPENBRACE",
  Bs = "CLOSEBRACE",
  Du = "OPENBRACKET",
  Nu = "CLOSEBRACKET",
  Lu = "OPENPAREN",
  Ru = "CLOSEPAREN",
  Iu = "OPENANGLEBRACKET",
  Pu = "CLOSEANGLEBRACKET",
  $u = "FULLWIDTHLEFTPAREN",
  Bu = "FULLWIDTHRIGHTPAREN",
  Hu = "LEFTCORNERBRACKET",
  Fu = "RIGHTCORNERBRACKET",
  zu = "LEFTWHITECORNERBRACKET",
  Vu = "RIGHTWHITECORNERBRACKET",
  Uu = "FULLWIDTHLESSTHAN",
  ju = "FULLWIDTHGREATERTHAN",
  Wu = "AMPERSAND",
  w0 = "APOSTROPHE",
  qu = "ASTERISK",
  so = "AT",
  Ku = "BACKSLASH",
  Gu = "BACKTICK",
  Ju = "CARET",
  fo = "COLON",
  C0 = "COMMA",
  Yu = "DOLLAR",
  rr = "DOT",
  Xu = "EQUALS",
  A0 = "EXCLAMATION",
  vn = "HYPHEN",
  Hs = "PERCENT",
  Zu = "PIPE",
  Qu = "PLUS",
  ec = "POUND",
  Fs = "QUERY",
  S0 = "QUOTE",
  T3 = "FULLWIDTHMIDDLEDOT",
  E0 = "SEMI",
  or = "SLASH",
  zs = "TILDE",
  tc = "UNDERSCORE",
  O3 = "EMOJI",
  nc = "SYM";
var D3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: Dr,
  UWORD: Gp,
  ASCIINUMERICAL: E3,
  ALPHANUMERICAL: M3,
  LOCALHOST: ya,
  TLD: Jp,
  UTLD: Yp,
  SCHEME: Gl,
  SLASH_SCHEME: Oi,
  NUM: x0,
  WS: Xp,
  NL: k0,
  OPENBRACE: $s,
  CLOSEBRACE: Bs,
  OPENBRACKET: Du,
  CLOSEBRACKET: Nu,
  OPENPAREN: Lu,
  CLOSEPAREN: Ru,
  OPENANGLEBRACKET: Iu,
  CLOSEANGLEBRACKET: Pu,
  FULLWIDTHLEFTPAREN: $u,
  FULLWIDTHRIGHTPAREN: Bu,
  LEFTCORNERBRACKET: Hu,
  RIGHTCORNERBRACKET: Fu,
  LEFTWHITECORNERBRACKET: zu,
  RIGHTWHITECORNERBRACKET: Vu,
  FULLWIDTHLESSTHAN: Uu,
  FULLWIDTHGREATERTHAN: ju,
  AMPERSAND: Wu,
  APOSTROPHE: w0,
  ASTERISK: qu,
  AT: so,
  BACKSLASH: Ku,
  BACKTICK: Gu,
  CARET: Ju,
  COLON: fo,
  COMMA: C0,
  DOLLAR: Yu,
  DOT: rr,
  EQUALS: Xu,
  EXCLAMATION: A0,
  HYPHEN: vn,
  PERCENT: Hs,
  PIPE: Zu,
  PLUS: Qu,
  POUND: ec,
  QUERY: Fs,
  QUOTE: S0,
  FULLWIDTHMIDDLEDOT: T3,
  SEMI: E0,
  SLASH: or,
  TILDE: zs,
  UNDERSCORE: tc,
  EMOJI: O3,
  SYM: nc,
});
const Mr = /[a-z]/,
  hs = new RegExp("\\p{L}", "u"),
  Sf = new RegExp("\\p{Emoji}", "u"),
  Tr = /\d/,
  Ef = /\s/,
  x2 = "\r",
  Mf = `
`,
  AR = "",
  SR = "",
  Tf = "";
let xl = null,
  kl = null;
function ER(t = []) {
  const e = {};
  Wt.groups = e;
  const n = new Wt();
  xl == null && (xl = k2(vR)),
    kl == null && (kl = k2(_R)),
    V(n, "'", w0),
    V(n, "{", $s),
    V(n, "}", Bs),
    V(n, "[", Du),
    V(n, "]", Nu),
    V(n, "(", Lu),
    V(n, ")", Ru),
    V(n, "<", Iu),
    V(n, ">", Pu),
    V(n, "", $u),
    V(n, "", Bu),
    V(n, "", Hu),
    V(n, "", Fu),
    V(n, "", zu),
    V(n, "", Vu),
    V(n, "", Uu),
    V(n, "", ju),
    V(n, "&", Wu),
    V(n, "*", qu),
    V(n, "@", so),
    V(n, "`", Gu),
    V(n, "^", Ju),
    V(n, ":", fo),
    V(n, ",", C0),
    V(n, "$", Yu),
    V(n, ".", rr),
    V(n, "=", Xu),
    V(n, "!", A0),
    V(n, "-", vn),
    V(n, "%", Hs),
    V(n, "|", Zu),
    V(n, "+", Qu),
    V(n, "#", ec),
    V(n, "?", Fs),
    V(n, '"', S0),
    V(n, "/", or),
    V(n, ";", E0),
    V(n, "~", zs),
    V(n, "_", tc),
    V(n, "\\", Ku),
    V(n, "", T3);
  const r = et(n, Tr, x0, {
    [jp]: !0,
  });
  et(r, Tr, r);
  const o = et(r, Mr, E3, {
      [Ps]: !0,
    }),
    i = et(r, hs, M3, {
      [vs]: !0,
    }),
    s = et(n, Mr, Dr, {
      [Wp]: !0,
    });
  et(s, Tr, o), et(s, Mr, s), et(o, Tr, o), et(o, Mr, o);
  const a = et(n, hs, Gp, {
    [qp]: !0,
  });
  et(a, Mr), et(a, Tr, i), et(a, hs, a), et(i, Tr, i), et(i, Mr), et(i, hs, i);
  const l = V(n, Mf, k0, {
      [Af]: !0,
    }),
    u = V(n, x2, Xp, {
      [Af]: !0,
    }),
    c = et(n, Ef, Xp, {
      [Af]: !0,
    });
  V(n, Tf, c),
    V(u, Mf, l),
    V(u, Tf, c),
    et(u, Ef, c),
    V(c, x2),
    V(c, Mf),
    et(c, Ef, c),
    V(c, Tf, c);
  const d = et(n, Sf, O3, {
    [S3]: !0,
  });
  V(d, "#"), et(d, Sf, d), V(d, AR, d);
  const f = V(d, SR);
  V(f, "#"), et(f, Sf, d);
  const p = [
      [Mr, s],
      [Tr, o],
    ],
    h = [
      [Mr, null],
      [hs, a],
      [Tr, i],
    ];
  for (let m = 0; m < xl.length; m++) Yr(n, xl[m], Jp, Dr, p);
  for (let m = 0; m < kl.length; m++) Yr(n, kl[m], Yp, Gp, h);
  Jo(
    Jp,
    {
      tld: !0,
      ascii: !0,
    },
    e
  ),
    Jo(
      Yp,
      {
        utld: !0,
        alpha: !0,
      },
      e
    ),
    Yr(n, "file", Gl, Dr, p),
    Yr(n, "mailto", Gl, Dr, p),
    Yr(n, "http", Oi, Dr, p),
    Yr(n, "https", Oi, Dr, p),
    Yr(n, "ftp", Oi, Dr, p),
    Yr(n, "ftps", Oi, Dr, p),
    Jo(
      Gl,
      {
        scheme: !0,
        ascii: !0,
      },
      e
    ),
    Jo(
      Oi,
      {
        slashscheme: !0,
        ascii: !0,
      },
      e
    ),
    (t = t.sort((m, g) => (m[0] > g[0] ? 1 : -1)));
  for (let m = 0; m < t.length; m++) {
    const g = t[m][0],
      _ = t[m][1]
        ? {
            [xR]: !0,
          }
        : {
            [kR]: !0,
          };
    g.indexOf("-") >= 0
      ? (_[Kp] = !0)
      : Mr.test(g)
      ? Tr.test(g)
        ? (_[Ps] = !0)
        : (_[Wp] = !0)
      : (_[jp] = !0),
      _2(n, g, g, _);
  }
  return (
    _2(n, "localhost", ya, {
      ascii: !0,
    }),
    (n.jd = new Wt(nc)),
    {
      start: n,
      tokens: Qi(
        {
          groups: e,
        },
        D3
      ),
    }
  );
}
function N3(t, e) {
  const n = MR(e.replace(/[A-Z]/g, (a) => a.toLowerCase())),
    r = n.length,
    o = [];
  let i = 0,
    s = 0;
  for (; s < r; ) {
    let a = t,
      l = null,
      u = 0,
      c = null,
      d = -1,
      f = -1;
    for (; s < r && (l = a.go(n[s])); )
      (a = l),
        a.accepts()
          ? ((d = 0), (f = 0), (c = a))
          : d >= 0 && ((d += n[s].length), f++),
        (u += n[s].length),
        (i += n[s].length),
        s++;
    (i -= d),
      (s -= f),
      (u -= d),
      o.push({
        t: c.t,
        // token type/name
        v: e.slice(i - u, i),
        // string value
        s: i - u,
        // start index
        e: i,
        // end index (excluding)
      });
  }
  return o;
}
function MR(t) {
  const e = [],
    n = t.length;
  let r = 0;
  for (; r < n; ) {
    let o = t.charCodeAt(r),
      i,
      s =
        o < 55296 ||
        o > 56319 ||
        r + 1 === n ||
        (i = t.charCodeAt(r + 1)) < 56320 ||
        i > 57343
          ? t[r]
          : t.slice(r, r + 2);
    e.push(s), (r += s.length);
  }
  return e;
}
function Yr(t, e, n, r, o) {
  let i;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? (i = t.j[l]) : ((i = new Wt(r)), (i.jr = o.slice()), (t.j[l] = i)),
      (t = i);
  }
  return (i = new Wt(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
}
function k2(t) {
  const e = [],
    n = [];
  let r = 0,
    o = "0123456789";
  for (; r < t.length; ) {
    let i = 0;
    for (; o.indexOf(t[r + i]) >= 0; ) i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--) n.pop();
      r += i;
    } else n.push(t[r]), r++;
  }
  return e;
}
const va = {
  defaultProtocol: "http",
  events: null,
  format: w2,
  formatHref: w2,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
};
function M0(t, e = null) {
  let n = Qi({}, va);
  t && (n = Qi(n, t instanceof M0 ? t.o : t));
  const r = n.ignoreTags,
    o = [];
  for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
  (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
}
M0.prototype = {
  o: va,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let o = this.o[t];
    return (
      o &&
      (typeof o == "object"
        ? ((o = n.t in o ? o[n.t] : va[t]),
          typeof o == "function" && r && (o = o(e, n)))
        : typeof o == "function" && r && (o = o(e, n.t, n)),
      o)
    );
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  },
};
function w2(t) {
  return t;
}
function L3(t, e) {
  (this.t = "token"), (this.v = t), (this.tk = e);
}
L3.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(),
      n = t.get("truncate", e, this),
      r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = va.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this,
      n = this.toHref(t.get("defaultProtocol")),
      r = t.get("formatHref", n, this),
      o = t.get("tagName", n, e),
      i = this.toFormattedString(t),
      s = {},
      a = t.get("className", n, e),
      l = t.get("target", n, e),
      u = t.get("rel", n, e),
      c = t.getObj("attributes", n, e),
      d = t.getObj("events", n, e);
    return (
      (s.href = r),
      a && (s.class = a),
      l && (s.target = l),
      u && (s.rel = u),
      c && Qi(s, c),
      {
        tagName: o,
        attributes: s,
        content: i,
        eventListeners: d,
      }
    );
  },
};
function _d(t, e) {
  class n extends L3 {
    constructor(o, i) {
      super(o, i), (this.t = t);
    }
  }
  for (const r in e) n.prototype[r] = e[r];
  return (n.t = t), n;
}
const C2 = _d("email", {
    isLink: !0,
    toHref() {
      return "mailto:" + this.toString();
    },
  }),
  A2 = _d("text"),
  TR = _d("nl"),
  wl = _d("url", {
    isLink: !0,
    /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
    toHref(t = va.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${t}://${this.v}`;
    },
    /**
     * Check whether this URL token has a protocol
     * @return {boolean}
     */
    hasProtocol() {
      const t = this.tk;
      return t.length >= 2 && t[0].t !== ya && t[1].t === fo;
    },
  }),
  mn = (t) => new Wt(t);
function OR({ groups: t }) {
  const e = t.domain.concat([
      Wu,
      qu,
      so,
      Ku,
      Gu,
      Ju,
      Yu,
      Xu,
      vn,
      x0,
      Hs,
      Zu,
      Qu,
      ec,
      or,
      nc,
      zs,
      tc,
    ]),
    n = [
      fo,
      C0,
      rr,
      A0,
      Hs,
      Fs,
      S0,
      E0,
      Iu,
      Pu,
      $s,
      Bs,
      Nu,
      Du,
      Lu,
      Ru,
      $u,
      Bu,
      Hu,
      Fu,
      zu,
      Vu,
      Uu,
      ju,
    ],
    r = [
      Wu,
      w0,
      qu,
      Ku,
      Gu,
      Ju,
      Yu,
      Xu,
      vn,
      $s,
      Bs,
      Hs,
      Zu,
      Qu,
      ec,
      Fs,
      or,
      nc,
      zs,
      tc,
    ],
    o = mn(),
    i = V(o, zs);
  pe(i, r, i), pe(i, t.domain, i);
  const s = mn(),
    a = mn(),
    l = mn();
  pe(o, t.domain, s),
    pe(o, t.scheme, a),
    pe(o, t.slashscheme, l),
    pe(s, r, i),
    pe(s, t.domain, s);
  const u = V(s, so);
  V(i, so, u), V(a, so, u), V(l, so, u);
  const c = V(i, rr);
  pe(c, r, i), pe(c, t.domain, i);
  const d = mn();
  pe(u, t.domain, d), pe(d, t.domain, d);
  const f = V(d, rr);
  pe(f, t.domain, d);
  const p = mn(C2);
  pe(f, t.tld, p), pe(f, t.utld, p), V(u, ya, p);
  const h = V(d, vn);
  V(h, vn, h), pe(h, t.domain, d), pe(p, t.domain, d), V(p, rr, f), V(p, vn, h);
  const m = V(p, fo);
  pe(m, t.numeric, C2);
  const g = V(s, vn),
    b = V(s, rr);
  V(g, vn, g), pe(g, t.domain, s), pe(b, r, i), pe(b, t.domain, s);
  const _ = mn(wl);
  pe(b, t.tld, _),
    pe(b, t.utld, _),
    pe(_, t.domain, s),
    pe(_, r, i),
    V(_, rr, b),
    V(_, vn, g),
    V(_, so, u);
  const v = V(_, fo),
    y = mn(wl);
  pe(v, t.numeric, y);
  const w = mn(wl),
    x = mn();
  pe(w, e, w), pe(w, n, x), pe(x, e, w), pe(x, n, x), V(_, or, w), V(y, or, w);
  const M = V(a, fo),
    N = V(l, fo),
    T = V(N, or),
    P = V(T, or);
  pe(a, t.domain, s),
    V(a, rr, b),
    V(a, vn, g),
    pe(l, t.domain, s),
    V(l, rr, b),
    V(l, vn, g),
    pe(M, t.domain, w),
    V(M, or, w),
    V(M, Fs, w),
    pe(P, t.domain, w),
    pe(P, e, w),
    V(P, or, w);
  const z = [
    [$s, Bs],
    // {}
    [Du, Nu],
    // []
    [Lu, Ru],
    // ()
    [Iu, Pu],
    // <>
    [$u, Bu],
    // 
    [Hu, Fu],
    // 
    [zu, Vu],
    // 
    [Uu, ju],
    // 
  ];
  for (let H = 0; H < z.length; H++) {
    const [U, re] = z[H],
      te = V(w, U);
    V(x, U, te), V(te, re, w);
    const Q = mn(wl);
    pe(te, e, Q);
    const ne = mn();
    pe(te, n),
      pe(Q, e, Q),
      pe(Q, n, ne),
      pe(ne, e, Q),
      pe(ne, n, ne),
      V(Q, re, w),
      V(ne, re, w);
  }
  return (
    V(o, ya, _),
    V(o, k0, TR),
    {
      start: o,
      tokens: D3,
    }
  );
}
function DR(t, e, n) {
  let r = n.length,
    o = 0,
    i = [],
    s = [];
  for (; o < r; ) {
    let a = t,
      l = null,
      u = null,
      c = 0,
      d = null,
      f = -1;
    for (; o < r && !(l = a.go(n[o].t)); ) s.push(n[o++]);
    for (; o < r && (u = l || a.go(n[o].t)); )
      (l = null),
        (a = u),
        a.accepts() ? ((f = 0), (d = a)) : f >= 0 && f++,
        o++,
        c++;
    if (f < 0) (o -= c), o < r && (s.push(n[o]), o++);
    else {
      s.length > 0 && (i.push(Of(A2, e, s)), (s = [])), (o -= f), (c -= f);
      const p = d.t,
        h = n.slice(o - c, o);
      i.push(Of(p, e, h));
    }
  }
  return s.length > 0 && i.push(Of(A2, e, s)), i;
}
function Of(t, e, n) {
  const r = n[0].s,
    o = n[n.length - 1].e,
    i = e.slice(r, o);
  return new t(i, n);
}
const NR = (typeof console < "u" && console && console.warn) || (() => {}),
  LR =
    "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
  Ke = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1,
  };
function RR() {
  return (
    (Wt.groups = {}),
    (Ke.scanner = null),
    (Ke.parser = null),
    (Ke.tokenQueue = []),
    (Ke.pluginQueue = []),
    (Ke.customSchemes = []),
    (Ke.initialized = !1),
    Ke
  );
}
function S2(t, e = !1) {
  if (
    (Ke.initialized &&
      NR(
        `linkifyjs: already initialized - will not register custom scheme "${t}" ${LR}`
      ),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
  )
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Ke.customSchemes.push([t, e]);
}
function IR() {
  Ke.scanner = ER(Ke.customSchemes);
  for (let t = 0; t < Ke.tokenQueue.length; t++)
    Ke.tokenQueue[t][1]({
      scanner: Ke.scanner,
    });
  Ke.parser = OR(Ke.scanner.tokens);
  for (let t = 0; t < Ke.pluginQueue.length; t++)
    Ke.pluginQueue[t][1]({
      scanner: Ke.scanner,
      parser: Ke.parser,
    });
  return (Ke.initialized = !0), Ke;
}
function T0(t) {
  return (
    Ke.initialized || IR(), DR(Ke.parser.start, t, N3(Ke.scanner.start, t))
  );
}
T0.scan = N3;
function R3(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    (n = e), (e = null);
  }
  const r = new M0(n),
    o = T0(t),
    i = [];
  for (let s = 0; s < o.length; s++) {
    const a = o[s];
    a.isLink &&
      (!e || a.t === e) &&
      r.check(a) &&
      i.push(a.toFormattedObject(r));
  }
  return i;
}
function PR(t) {
  return t.length === 1
    ? t[0].isLink
    : t.length === 3 && t[1].isLink
    ? ["()", "[]"].includes(t[0].value + t[2].value)
    : !1;
}
function $R(t) {
  return new be({
    key: new ke("autolink"),
    appendTransaction: (e, n, r) => {
      const o = e.some((u) => u.docChanged) && !n.doc.eq(r.doc),
        i = e.some((u) => u.getMeta("preventAutolink"));
      if (!o || i) return;
      const { tr: s } = r,
        a = uO(n.doc, [...e]);
      if (
        (mO(a).forEach(({ newRange: u }) => {
          const c = dO(r.doc, u, (p) => p.isTextblock);
          let d, f;
          if (
            (c.length > 1
              ? ((d = c[0]),
                (f = r.doc.textBetween(
                  d.pos,
                  d.pos + d.node.nodeSize,
                  void 0,
                  " "
                )))
              : c.length &&
                r.doc.textBetween(u.from, u.to, " ", " ").endsWith(" ") &&
                ((d = c[0]), (f = r.doc.textBetween(d.pos, u.to, void 0, " "))),
            d && f)
          ) {
            const p = f.split(" ").filter((b) => b !== "");
            if (p.length <= 0) return !1;
            const h = p[p.length - 1],
              m = d.pos + f.lastIndexOf(h);
            if (!h) return !1;
            const g = T0(h).map((b) => b.toObject(t.defaultProtocol));
            if (!PR(g)) return !1;
            g.filter((b) => b.isLink)
              .map((b) => ({
                ...b,
                from: m + b.start + 1,
                to: m + b.end + 1,
              }))
              .filter((b) =>
                r.schema.marks.code
                  ? !r.doc.rangeHasMark(b.from, b.to, r.schema.marks.code)
                  : !0
              )
              .filter((b) => t.validate(b.value))
              .filter((b) => t.shouldAutoLink(b.value))
              .forEach((b) => {
                c0(b.from, b.to, r.doc).some((_) => _.mark.type === t.type) ||
                  s.addMark(
                    b.from,
                    b.to,
                    t.type.create({
                      href: b.href,
                    })
                  );
              });
          }
        }),
        !!s.steps.length)
      )
        return s;
    },
  });
}
function BR(t) {
  return new be({
    key: new ke("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var o, i;
        if (r.button !== 0 || !e.editable) return !1;
        let s = r.target;
        const a = [];
        for (; s.nodeName !== "DIV"; ) a.push(s), (s = s.parentNode);
        if (!a.find((f) => f.nodeName === "A")) return !1;
        const l = H_(e.state, t.type.name),
          u = r.target,
          c =
            (o = u == null ? void 0 : u.href) !== null && o !== void 0
              ? o
              : l.href,
          d =
            (i = u == null ? void 0 : u.target) !== null && i !== void 0
              ? i
              : l.target;
        return u && c ? (window.open(c, d), !0) : !1;
      },
    },
  });
}
function HR(t) {
  return new be({
    key: new ke("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: o } = e,
          { selection: i } = o,
          { empty: s } = i;
        if (s) return !1;
        let a = "";
        r.content.forEach((u) => {
          a += u.textContent;
        });
        const l = R3(a, { defaultProtocol: t.defaultProtocol }).find(
          (u) => u.isLink && u.value === a
        );
        return !a || !l
          ? !1
          : t.editor.commands.setMark(t.type, {
              href: l.href,
            });
      },
    },
  });
}
const FR = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function Ho(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp",
  ];
  return (
    e &&
      e.forEach((r) => {
        const o = typeof r == "string" ? r : r.scheme;
        o && n.push(o);
      }),
    !t ||
      t.replace(FR, "").match(
        new RegExp(
          // eslint-disable-next-line no-useless-escape
          `^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
          "i"
        )
      )
  );
}
const zR = tn.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
      this.options.validate &&
        !this.options.shouldAutoLink &&
        ((this.options.shouldAutoLink = this.options.validate),
        console.warn(
          "The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead."
        )),
        this.options.protocols.forEach((t) => {
          if (typeof t == "string") {
            S2(t);
            return;
          }
          S2(t.scheme, t.optionalSlashes);
        });
    },
    onDestroy() {
      RR();
    },
    inclusive() {
      return this.options.autolink;
    },
    addOptions() {
      return {
        openOnClick: !0,
        linkOnPaste: !0,
        autolink: !0,
        protocols: [],
        defaultProtocol: "http",
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null,
        },
        isAllowedUri: (t, e) => !!Ho(t, e.protocols),
        validate: (t) => !!t,
        shouldAutoLink: (t) => !!t,
      };
    },
    addAttributes() {
      return {
        href: {
          default: null,
          parseHTML(t) {
            return t.getAttribute("href");
          },
        },
        target: {
          default: this.options.HTMLAttributes.target,
        },
        rel: {
          default: this.options.HTMLAttributes.rel,
        },
        class: {
          default: this.options.HTMLAttributes.class,
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "a[href]",
          getAttrs: (t) => {
            const e = t.getAttribute("href");
            return !e ||
              !this.options.isAllowedUri(e, {
                defaultValidate: (n) => !!Ho(n, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol,
              })
              ? !1
              : null;
          },
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return this.options.isAllowedUri(t.href, {
        defaultValidate: (e) => !!Ho(e, this.options.protocols),
        protocols: this.options.protocols,
        defaultProtocol: this.options.defaultProtocol,
      })
        ? ["a", ge(this.options.HTMLAttributes, t), 0]
        : ["a", ge(this.options.HTMLAttributes, { ...t, href: "" }), 0];
    },
    addCommands() {
      return {
        setLink:
          (t) =>
          ({ chain: e }) => {
            const { href: n } = t;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Ho(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run()
              : !1;
          },
        toggleLink:
          (t) =>
          ({ chain: e }) => {
            const { href: n } = t;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Ho(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? e()
                  .toggleMark(this.name, t, { extendEmptyMarkRange: !0 })
                  .setMeta("preventAutolink", !0)
                  .run()
              : !1;
          },
        unsetLink:
          () =>
          ({ chain: t }) =>
            t()
              .unsetMark(this.name, { extendEmptyMarkRange: !0 })
              .setMeta("preventAutolink", !0)
              .run(),
      };
    },
    addPasteRules() {
      return [
        So({
          find: (t) => {
            const e = [];
            if (t) {
              const { protocols: n, defaultProtocol: r } = this.options,
                o = R3(t).filter(
                  (i) =>
                    i.isLink &&
                    this.options.isAllowedUri(i.value, {
                      defaultValidate: (s) => !!Ho(s, n),
                      protocols: n,
                      defaultProtocol: r,
                    })
                );
              o.length &&
                o.forEach((i) =>
                  e.push({
                    text: i.value,
                    data: {
                      href: i.href,
                    },
                    index: i.start,
                  })
                );
            }
            return e;
          },
          type: this.type,
          getAttributes: (t) => {
            var e;
            return {
              href: (e = t.data) === null || e === void 0 ? void 0 : e.href,
            };
          },
        }),
      ];
    },
    addProseMirrorPlugins() {
      const t = [],
        { protocols: e, defaultProtocol: n } = this.options;
      return (
        this.options.autolink &&
          t.push(
            $R({
              type: this.type,
              defaultProtocol: this.options.defaultProtocol,
              validate: (r) =>
                this.options.isAllowedUri(r, {
                  defaultValidate: (o) => !!Ho(o, e),
                  protocols: e,
                  defaultProtocol: n,
                }),
              shouldAutoLink: this.options.shouldAutoLink,
            })
          ),
        this.options.openOnClick === !0 &&
          t.push(
            BR({
              type: this.type,
            })
          ),
        this.options.linkOnPaste &&
          t.push(
            HR({
              editor: this.editor,
              defaultProtocol: this.options.defaultProtocol,
              type: this.type,
            })
          ),
        t
      );
    },
  }),
  Zp = zR.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        HTMLAttributes: {
          rel: null,
        },
      };
    },
    addPasteRules() {
      return [];
    },
  }),
  Va = (t, e) => {
    const { $from: n } = e.selection,
      r = lt(t, e.schema);
    let o = null,
      i = n.depth,
      s = n.pos,
      a = null;
    for (; i > 0 && a === null; )
      (o = n.node(i)), o.type === r ? (a = i) : ((i -= 1), (s -= 1));
    return a === null ? null : { $pos: e.doc.resolve(s), depth: a };
  },
  O0 = (t, e) => {
    const n = Va(t, e);
    if (!n) return !1;
    const [, r] = bO(e, t, n.$pos.pos + 4);
    return r;
  },
  I3 = (t, e, n) => {
    const { $anchor: r } = t.selection,
      o = Math.max(0, r.pos - 2),
      i = t.doc.resolve(o).node();
    return !(!i || !n.includes(i.type.name));
  },
  P3 = (t, e) => {
    var n;
    const { $anchor: r } = e.selection,
      o = e.doc.resolve(r.pos - 2);
    return !(
      o.index() === 0 ||
      ((n = o.nodeBefore) === null || n === void 0 ? void 0 : n.type.name) !== t
    );
  },
  $3 = (t, e, n) => {
    if (!n) return !1;
    const r = lt(t, e.schema);
    let o = !1;
    return (
      n.descendants((i) => {
        i.type === r && (o = !0);
      }),
      o
    );
  },
  Qp = (t, e, n) => {
    if (t.commands.undoInputRule()) return !0;
    if (t.state.selection.from !== t.state.selection.to) return !1;
    if (!Sn(t.state, e) && I3(t.state, e, n)) {
      const { $anchor: a } = t.state.selection,
        l = t.state.doc.resolve(a.before() - 1),
        u = [];
      l.node().descendants((f, p) => {
        f.type.name === e && u.push({ node: f, pos: p });
      });
      const c = u.at(-1);
      if (!c) return !1;
      const d = t.state.doc.resolve(l.start() + c.pos + 1);
      return t
        .chain()
        .cut({ from: a.start() - 1, to: a.end() + 1 }, d.end())
        .joinForward()
        .run();
    }
    if (!Sn(t.state, e) || !vO(t.state)) return !1;
    const r = Va(e, t.state);
    if (!r) return !1;
    const i = t.state.doc.resolve(r.$pos.pos - 2).node(r.depth),
      s = $3(e, t.state, i);
    return P3(e, t.state) && !s
      ? t.commands.joinItemBackward()
      : t.chain().liftListItem(e).run();
  },
  B3 = (t, e) => {
    const n = O0(t, e),
      r = Va(t, e);
    return !r || !n ? !1 : n > r.depth;
  },
  H3 = (t, e) => {
    const n = O0(t, e),
      r = Va(t, e);
    return !r || !n ? !1 : n < r.depth;
  },
  eh = (t, e) => {
    if (!Sn(t.state, e) || !yO(t.state, e)) return !1;
    const { selection: n } = t.state,
      { $from: r, $to: o } = n;
    return !n.empty && r.sameParent(o)
      ? !1
      : B3(e, t.state)
      ? t
          .chain()
          .focus(t.state.selection.from + 4)
          .lift(e)
          .joinBackward()
          .run()
      : H3(e, t.state)
      ? t.chain().joinForward().joinBackward().run()
      : t.commands.joinItemForward();
  },
  VR = (t, e) => {
    var n;
    const { $anchor: r } = e.selection,
      o = e.doc.resolve(r.pos - r.parentOffset - 2);
    return !(
      o.index() === o.parent.childCount - 1 ||
      ((n = o.nodeAfter) === null || n === void 0 ? void 0 : n.type.name) !== t
    );
  };
var UR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  findListItemPos: Va,
  getNextListDepth: O0,
  handleBackspace: Qp,
  handleDelete: eh,
  hasListBefore: I3,
  hasListItemAfter: VR,
  hasListItemBefore: P3,
  listItemHasSubList: $3,
  nextListIsDeeper: B3,
  nextListIsHigher: H3,
});
const jR = Ne.create({
    name: "listKeymap",
    addOptions() {
      return {
        listTypes: [
          {
            itemName: "listItem",
            wrapperNames: ["bulletList", "orderedList"],
          },
          {
            itemName: "taskItem",
            wrapperNames: ["taskList"],
          },
        ],
      };
    },
    addKeyboardShortcuts() {
      return {
        Delete: ({ editor: t }) => {
          let e = !1;
          return (
            this.options.listTypes.forEach(({ itemName: n }) => {
              t.state.schema.nodes[n] !== void 0 && eh(t, n) && (e = !0);
            }),
            e
          );
        },
        "Mod-Delete": ({ editor: t }) => {
          let e = !1;
          return (
            this.options.listTypes.forEach(({ itemName: n }) => {
              t.state.schema.nodes[n] !== void 0 && eh(t, n) && (e = !0);
            }),
            e
          );
        },
        Backspace: ({ editor: t }) => {
          let e = !1;
          return (
            this.options.listTypes.forEach(
              ({ itemName: n, wrapperNames: r }) => {
                t.state.schema.nodes[n] !== void 0 && Qp(t, n, r) && (e = !0);
              }
            ),
            e
          );
        },
        "Mod-Backspace": ({ editor: t }) => {
          let e = !1;
          return (
            this.options.listTypes.forEach(
              ({ itemName: n, wrapperNames: r }) => {
                t.state.schema.nodes[n] !== void 0 && Qp(t, n, r) && (e = !0);
              }
            ),
            e
          );
        },
      };
    },
  }),
  aU = jR.extend({
    addKeyboardShortcuts() {
      const t = (e) => {
        let n = !1;
        return e.state.selection.empty
          ? (this.options.listTypes.forEach(
              ({ itemName: r, wrapperNames: o }) => {
                UR.handleBackspace(e, r, o) && (n = !0);
              }
            ),
            n)
          : !1;
      };
      return {
        Backspace: ({ editor: e }) => t(e),
        "Mod-Backspace": ({ editor: e }) => t(e),
      };
    },
  }),
  WR = "listItem",
  E2 = "textStyle",
  M2 = /^(\d+)\.\s$/,
  qR = Ze.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (t) =>
            t.hasAttribute("start")
              ? parseInt(t.getAttribute("start") || "", 10)
              : 1,
        },
        type: {
          default: void 0,
          parseHTML: (t) => t.getAttribute("type"),
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "ol",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      const { start: e, ...n } = t;
      return e === 1
        ? ["ol", ge(this.options.HTMLAttributes, n), 0]
        : ["ol", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        toggleOrderedList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(WR, this.editor.getAttributes(E2))
                  .run()
              : t.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
      };
    },
    addInputRules() {
      let t = Gi({
        find: M2,
        type: this.type,
        getAttributes: (e) => ({ start: +e[1] }),
        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      });
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = Gi({
            find: M2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (e) => ({
              start: +e[1],
              ...this.editor.getAttributes(E2),
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            editor: this.editor,
          })),
        [t]
      );
    },
  }),
  KR = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function GR(t, e) {
  return (
    S(),
    O(
      "svg",
      KR,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M7 13v-2h14v2zm0 6v-2h14v2zM7 7V5h14v2zM3 8V5H2V4h2v4zm-1 9v-1h3v4H2v-1h2v-.5H3v-1h1V17zm2.25-7a.75.75 0 0 1 .75.75c0 .2-.08.39-.21.52L3.12 13H5v1H2v-.92L4 11H2v-1z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const T2 = k({ name: "mdi-format-list-numbered", render: GR }),
  JR = qR.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 140,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("orderedList"),
              icon: k(T2),
              title: D.global.t("editor.common.ordered_list"),
              action: () => e.chain().focus().toggleOrderedList().run(),
            },
          };
        },
        getCommandMenuItems() {
          return {
            priority: 140,
            icon: k(T2),
            title: "editor.common.ordered_list",
            keywords: ["orderedlist", "youxuliebiao"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).toggleOrderedList().run();
            },
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && n.tagName !== "LI"; ) n = n.parentElement;
              return {
                el: n,
                dragDomOffset: {
                  x: -16,
                  y: -1,
                },
              };
            },
          };
        },
      };
    },
    addExtensions() {
      return [b3];
    },
  }),
  YR = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
  XR = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
  ZR = tn.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "s",
        },
        {
          tag: "del",
        },
        {
          tag: "strike",
        },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (t) => (t.includes("line-through") ? {} : !1),
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["s", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setStrike:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleStrike:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetStrike:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-s": () => this.editor.commands.toggleStrike(),
      };
    },
    addInputRules() {
      return [
        ci({
          find: YR,
          type: this.type,
        }),
      ];
    },
    addPasteRules() {
      return [
        So({
          find: XR,
          type: this.type,
        }),
      ];
    },
  }),
  QR = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function eI(t, e) {
  return (
    S(),
    O(
      "svg",
      QR,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 14h18v-2H3m2-8v3h5v3h4V7h5V4m-9 15h4v-3h-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const F3 = k({ name: "mdi-format-strikethrough", render: eI }),
  tI = ZR.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 70,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("strike"),
              icon: k(F3),
              title: D.global.t("editor.common.strike"),
              action: () => e.chain().focus().toggleStrike().run(),
            },
          };
        },
      };
    },
  }),
  nI = tn.create({
    name: "subscript",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "sub",
        },
        {
          style: "vertical-align",
          getAttrs(t) {
            return t !== "sub" ? !1 : null;
          },
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["sub", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setSubscript:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleSubscript:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetSubscript:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-,": () => this.editor.commands.toggleSubscript(),
      };
    },
  }),
  rI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function oI(t, e) {
  return (
    S(),
    O(
      "svg",
      rI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zm5.85 13.62h-4.88v-1l.89-.8c.76-.65 1.32-1.19 1.7-1.63c.37-.44.56-.85.57-1.24a.9.9 0 0 0-.27-.7c-.18-.16-.47-.28-.86-.28c-.31 0-.58.06-.84.18l-.66.38l-.45-1.17c.27-.21.59-.39.98-.53s.82-.24 1.29-.24c.78.04 1.38.25 1.78.66s.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.47-.76.92-1.27 1.36l-.64.52v.02h2.58z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const z3 = k({ name: "mdi-format-subscript", render: oI }),
  iI = nI.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 120,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("subscript"),
              icon: k(z3),
              title: D.global.t("editor.common.subscript"),
              action: () => e.chain().focus().toggleSubscript().run(),
            },
          };
        },
      };
    },
  }),
  sI = tn.create({
    name: "superscript",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "sup",
        },
        {
          style: "vertical-align",
          getAttrs(t) {
            return t !== "super" ? !1 : null;
          },
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["sup", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setSuperscript:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleSuperscript:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetSuperscript:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-.": () => this.editor.commands.toggleSuperscript(),
      };
    },
  }),
  aI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function lI(t, e) {
  return (
    S(),
    O(
      "svg",
      aI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zM21.85 9h-4.88V8l.89-.82c.76-.64 1.32-1.18 1.7-1.63q.555-.66.57-1.23a.88.88 0 0 0-.27-.7c-.18-.19-.47-.28-.86-.29c-.31.01-.58.07-.84.17l-.66.39l-.45-1.17c.27-.22.59-.39.98-.53S18.85 2 19.32 2c.78 0 1.38.2 1.78.61c.4.39.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.48-.76.93-1.27 1.36l-.64.52v.02h2.58z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const V3 = k({ name: "mdi-format-superscript", render: lI }),
  uI = sI.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 110,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("superscript"),
              icon: k(V3),
              title: D.global.t("editor.common.superscript"),
              action: () => e.chain().focus().toggleSuperscript().run(),
            },
          };
        },
      };
    },
  });
function th(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function O2(t, e, n, r, o, i) {
  var s;
  let a = 0,
    l = !0,
    u = e.firstChild;
  const c = t.firstChild;
  if (c !== null)
    for (let d = 0, f = 0; d < c.childCount; d += 1) {
      const { colspan: p, colwidth: h } = c.child(d).attrs;
      for (let m = 0; m < p; m += 1, f += 1) {
        const g = o === f ? i : h && h[m],
          b = g ? `${g}px` : "";
        if (((a += g || r), g || (l = !1), u)) {
          if (u.style.width !== b) {
            const [_, v] = th(r, g);
            u.style.setProperty(_, v);
          }
          u = u.nextSibling;
        } else {
          const _ = document.createElement("col"),
            [v, y] = th(r, g);
          _.style.setProperty(v, y), e.appendChild(_);
        }
      }
    }
  for (; u; ) {
    const d = u.nextSibling;
    (s = u.parentNode) === null || s === void 0 || s.removeChild(u), (u = d);
  }
  l
    ? ((n.style.width = `${a}px`), (n.style.minWidth = ""))
    : ((n.style.width = ""), (n.style.minWidth = `${a}px`));
}
let cI = class {
  constructor(e, n) {
    (this.node = e),
      (this.cellMinWidth = n),
      (this.dom = document.createElement("div")),
      (this.dom.className = "tableWrapper"),
      (this.table = this.dom.appendChild(document.createElement("table"))),
      (this.colgroup = this.table.appendChild(
        document.createElement("colgroup")
      )),
      O2(e, this.colgroup, this.table, n),
      (this.contentDOM = this.table.appendChild(
        document.createElement("tbody")
      ));
  }
  update(e) {
    return e.type !== this.node.type
      ? !1
      : ((this.node = e),
        O2(e, this.colgroup, this.table, this.cellMinWidth),
        !0);
  }
  ignoreMutation(e) {
    return (
      e.type === "attributes" &&
      (e.target === this.table || this.colgroup.contains(e.target))
    );
  }
};
function U3(t, e, n, r) {
  let o = 0,
    i = !0;
  const s = [],
    a = t.firstChild;
  if (!a) return {};
  for (let d = 0, f = 0; d < a.childCount; d += 1) {
    const { colspan: p, colwidth: h } = a.child(d).attrs;
    for (let m = 0; m < p; m += 1, f += 1) {
      const g = n === f ? r : h && h[m];
      (o += g || e), g || (i = !1);
      const [b, _] = th(e, g);
      s.push(["col", { style: `${b}: ${_}` }]);
    }
  }
  const l = i ? `${o}px` : "",
    u = i ? "" : `${o}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: u };
}
function D2(t, e) {
  return t.createAndFill();
}
function dI(t) {
  if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
  const e = {};
  return (
    Object.keys(t.nodes).forEach((n) => {
      const r = t.nodes[n];
      r.spec.tableRole && (e[r.spec.tableRole] = r);
    }),
    (t.cached.tableNodeTypes = e),
    e
  );
}
function fI(t, e, n, r, o) {
  const i = dI(t),
    s = [],
    a = [];
  for (let u = 0; u < n; u += 1) {
    const c = D2(i.cell);
    if ((c && a.push(c), r)) {
      const d = D2(i.header_cell);
      d && s.push(d);
    }
  }
  const l = [];
  for (let u = 0; u < e; u += 1)
    l.push(i.row.createChecked(null, r && u === 0 ? s : a));
  return i.table.createChecked(null, l);
}
function pI(t) {
  return t instanceof De;
}
const Cl = ({ editor: t }) => {
    const { selection: e } = t.state;
    if (!pI(e)) return !1;
    let n = 0;
    const r = B_(e.ranges[0].$from, (i) => i.type.name === "table");
    return (
      r == null ||
        r.node.descendants((i) => {
          if (i.type.name === "table") return !1;
          ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
        }),
      n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
    );
  },
  hI = Ze.create({
    name: "table",
    // @ts-ignore
    addOptions() {
      return {
        HTMLAttributes: {},
        resizable: !1,
        handleWidth: 5,
        cellMinWidth: 25,
        // TODO: fix
        View: cI,
        lastColumnResizable: !0,
        allowTableNodeSelection: !1,
      };
    },
    content: "tableRow+",
    tableRole: "table",
    isolating: !0,
    group: "block",
    parseHTML() {
      return [{ tag: "table" }];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      const {
        colgroup: n,
        tableWidth: r,
        tableMinWidth: o,
      } = U3(t, this.options.cellMinWidth);
      return [
        "table",
        ge(this.options.HTMLAttributes, e, {
          style: r ? `width: ${r}` : `min-width: ${o}`,
        }),
        n,
        ["tbody", 0],
      ];
    },
    addCommands() {
      return {
        insertTable:
          ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) =>
          ({ tr: r, dispatch: o, editor: i }) => {
            const s = fI(i.schema, t, e, n);
            if (o) {
              const a = r.selection.from + 1;
              r.replaceSelectionWith(s)
                .scrollIntoView()
                .setSelection(q.near(r.doc.resolve(a)));
            }
            return !0;
          },
        addColumnBefore:
          () =>
          ({ state: t, dispatch: e }) =>
            EM(t, e),
        addColumnAfter:
          () =>
          ({ state: t, dispatch: e }) =>
            w_(t, e),
        deleteColumn:
          () =>
          ({ state: t, dispatch: e }) =>
            TM(t, e),
        addRowBefore:
          () =>
          ({ state: t, dispatch: e }) =>
            DM(t, e),
        addRowAfter:
          () =>
          ({ state: t, dispatch: e }) =>
            A_(t, e),
        deleteRow:
          () =>
          ({ state: t, dispatch: e }) =>
            LM(t, e),
        deleteTable:
          () =>
          ({ state: t, dispatch: e }) =>
            FM(t, e),
        mergeCells:
          () =>
          ({ state: t, dispatch: e }) =>
            bg(t, e),
        splitCell:
          () =>
          ({ state: t, dispatch: e }) =>
            yg(t, e),
        toggleHeaderColumn:
          () =>
          ({ state: t, dispatch: e }) =>
            ha("column")(t, e),
        toggleHeaderRow:
          () =>
          ({ state: t, dispatch: e }) =>
            ha("row")(t, e),
        toggleHeaderCell:
          () =>
          ({ state: t, dispatch: e }) =>
            BM(t, e),
        mergeOrSplit:
          () =>
          ({ state: t, dispatch: e }) =>
            bg(t, e) ? !0 : yg(t, e),
        setCellAttribute:
          (t, e) =>
          ({ state: n, dispatch: r }) =>
            PM(t, e)(n, r),
        goToNextCell:
          () =>
          ({ state: t, dispatch: e }) =>
            _g(1)(t, e),
        goToPreviousCell:
          () =>
          ({ state: t, dispatch: e }) =>
            _g(-1)(t, e),
        fixTables:
          () =>
          ({ state: t, dispatch: e }) => (e && x_(t), !0),
        setCellSelection:
          (t) =>
          ({ tr: e, dispatch: n }) => {
            if (n) {
              const r = De.create(e.doc, t.anchorCell, t.headCell);
              e.setSelection(r);
            }
            return !0;
          },
      };
    },
    addKeyboardShortcuts() {
      return {
        Tab: () =>
          this.editor.commands.goToNextCell()
            ? !0
            : this.editor.can().addRowAfter()
            ? this.editor.chain().addRowAfter().goToNextCell().run()
            : !1,
        "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
        Backspace: Cl,
        "Mod-Backspace": Cl,
        Delete: Cl,
        "Mod-Delete": Cl,
      };
    },
    addProseMirrorPlugins() {
      return [
        ...(this.options.resizable && this.editor.isEditable
          ? [
              YM({
                handleWidth: this.options.handleWidth,
                cellMinWidth: this.options.cellMinWidth,
                defaultCellMinWidth: this.options.cellMinWidth,
                View: this.options.View,
                lastColumnResizable: this.options.lastColumnResizable,
              }),
            ]
          : []),
        sT({
          allowTableNodeSelection: this.options.allowTableNodeSelection,
        }),
      ];
    },
    extendNodeSchema(t) {
      const e = {
        name: t.name,
        options: t.options,
        storage: t.storage,
      };
      return {
        tableRole: le(K(t, "tableRole", e)),
      };
    },
  }),
  mI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function gI(t, e) {
  return (
    S(),
    O(
      "svg",
      mI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 6.25A3.25 3.25 0 0 1 6.25 3h11.5A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75zM6.25 4.5A1.75 1.75 0 0 0 4.5 6.25V8.5h4v-4zM4.5 10v4h4v-4zm5.5 0v4h4v-4zm5.5 0v4h4v-4zm0 9.5h2.25a1.75 1.75 0 0 0 1.75-1.75V15.5h-4zm0-11h4V6.25a1.75 1.75 0 0 0-1.75-1.75H15.5zm-11 7v2.25c0 .966.784 1.75 1.75 1.75H8.5v-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const bI = k({ name: "fluent-table-column-top-bottom-24-regular", render: gI }),
  yI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function vI(t, e) {
  return (
    S(),
    O(
      "svg",
      yI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M5 4h14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 4v4h6V8zm8 0v4h6V8zm-8 6v4h6v-4zm8 0v4h6v-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const _I = k({ name: "mdi-table", render: vI }),
  xI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function kI(t, e) {
  return (
    S(),
    O(
      "svg",
      xI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M11 2a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H2V2zm-7 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm11 7h3V8h2v3h3v2h-3v3h-2v-3h-3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const wI = k({ name: "mdi-table-column-plus-after", render: kI }),
  CI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function AI(t, e) {
  return (
    S(),
    O(
      "svg",
      CI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9V2zm7 8v4h-7v-4zm0 6v4h-7v-4zm0-12v4h-7V4zM9 11H6V8H4v3H1v2h3v3h2v-3h3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const SI = k({ name: "mdi-table-column-plus-before", render: AI }),
  EI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function MI(t, e) {
  return (
    S(),
    O(
      "svg",
      EI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M4 2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m0 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm13.59 8L15 9.41L16.41 8L19 10.59L21.59 8L23 9.41L20.41 12L23 14.59L21.59 16L19 13.41L16.41 16L15 14.59z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const TI = k({ name: "mdi-table-column-remove", render: MI }),
  OI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function DI(t, e) {
  return (
    S(),
    O(
      "svg",
      OI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M1 6v13a2 2 0 0 0 2 2h6V11h12V6a2 2 0 0 0-2-2H3a2 2 0 0 0-2 2m2 0h4v3H3m4 10H3v-3h4m0-2H3v-3h4m2-2V6h4v3m6 0h-4V6h4m-2 10a1 1 0 1 1-1 1a1 1 0 0 1 1-1m0-3a6.45 6.45 0 0 1 6 4a6.5 6.5 0 0 1-12 0a6.45 6.45 0 0 1 6-4m0 1.5a2.5 2.5 0 1 0 2.5 2.5a2.5 2.5 0 0 0-2.5-2.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const N2 = k({ name: "mdi-table-headers-eye", render: DI }),
  NI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function LI(t, e) {
  return (
    S(),
    O(
      "svg",
      NI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M5 10H3V4h8v2H5zm14 8h-6v2h8v-6h-2zM5 18v-4H3v6h8v-2zM21 4h-8v2h6v4h2zM8 13v2l3-3l-3-3v2H3v2zm8-2V9l-3 3l3 3v-2h5v-2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const RI = k({ name: "mdi-table-merge-cells", render: LI }),
  II = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function PI(t, e) {
  return (
    S(),
    O(
      "svg",
      II,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M18 14h2v3h3v2h-3v3h-2v-3h-3v-2h3zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const $I = k({ name: "mdi-table-plus", render: PI }),
  BI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function HI(t, e) {
  return (
    S(),
    O(
      "svg",
      BI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m15.46 15.88l1.42-1.42L19 16.59l2.12-2.13l1.42 1.42L20.41 18l2.13 2.12l-1.42 1.42L19 19.41l-2.12 2.13l-1.42-1.42L17.59 18zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const FI = k({ name: "mdi-table-remove", render: HI }),
  zI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function VI(t, e) {
  return (
    S(),
    O(
      "svg",
      zI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M22 10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V3h2v2h4V3h2v2h4V3h2v2h4V3h2zM4 10h4V7H4zm6 0h4V7h-4zm10 0V7h-4v3zm-9 4h2v3h3v2h-3v3h-2v-3H8v-2h3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const UI = k({ name: "mdi-table-row-plus-after", render: VI }),
  jI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function WI(t, e) {
  return (
    S(),
    O(
      "svg",
      jI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M22 14a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7h2v-2h4v2h2v-2h4v2h2v-2h4v2h2zM4 14h4v3H4zm6 0h4v3h-4zm10 0v3h-4v-3zm-9-4h2V7h3V5h-3V2h-2v3H8v2h3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const qI = k({ name: "mdi-table-row-plus-before", render: WI }),
  KI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function GI(t, e) {
  return (
    S(),
    O(
      "svg",
      KI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M9.41 13L12 15.59L14.59 13L16 14.41L13.41 17L16 19.59L14.59 21L12 18.41L9.41 21L8 19.59L10.59 17L8 14.41zM22 9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2zM4 9h4V6H4zm6 0h4V6h-4zm6 0h4V6h-4z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const JI = k({ name: "mdi-table-row-remove", render: GI }),
  YI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function XI(t, e) {
  return (
    S(),
    O(
      "svg",
      YI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M19 14h2v6H3v-6h2v4h14zM3 4v6h2V6h14v4h2V4zm8 7v2H8v2l-3-3l3-3v2zm5 0V9l3 3l-3 3v-2h-3v-2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const ZI = k({ name: "mdi-table-split-cell", render: XI }),
  QI = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function eP(t, e) {
  return (
    S(),
    O(
      "svg",
      QI,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const j3 = k({ name: "mdi-plus", render: eP }),
  W3 = (t) => {
    const e = xd(t.selection);
    if (e) {
      const { map: n } = Ae.get(e.node);
      if (n && n.length) {
        const r = e.start + n[0],
          o = e.start + n[n.length - 1],
          i = t.doc.resolve(r),
          s = t.doc.resolve(o);
        return t.setSelection(new De(s, i));
      }
    }
    return t;
  },
  q3 = (t) => (e) => (n) => {
    const r = xd(n.selection),
      o = t === "row";
    if (r) {
      const i = Ae.get(r.node);
      if (e >= 0 && e < (o ? i.height : i.width)) {
        const s = o
            ? i.cellsInRect({
                left: 0,
                right: 1,
                top: 0,
                bottom: i.height,
              })
            : i.cellsInRect({
                left: 0,
                right: i.width,
                top: 0,
                bottom: 1,
              }),
          a = i.findCell(s[e]),
          l = {
            left: o ? i.width - 1 : a.left,
            right: o ? i.width : a.right,
            top: o ? a.top : i.height - 1,
            bottom: o ? a.bottom : i.height,
          };
        let u = i.cellsInRect(l);
        for (; u.length === 0; )
          o ? (l.left -= 1) : (l.top -= 1), (u = i.cellsInRect(l));
        const c = r.start + s[e],
          d = r.start + u[u.length - 1],
          f = n.doc.resolve(c),
          p = n.doc.resolve(d);
        return n.setSelection(new De(p, f));
      }
    }
    return n;
  },
  tP = q3("column"),
  nP = q3("row"),
  rP = (t) => (e) => {
    const n = xd(e);
    if (n) {
      const r = Ae.get(n.node);
      return (Array.isArray(t) ? t : Array.from([t])).reduce((i, s) => {
        if (s >= 0 && s <= r.width - 1) {
          const a = r.cellsInRect({
            left: s,
            right: s + 1,
            top: 0,
            bottom: r.height,
          });
          return i.concat(
            a.map((l) => {
              const u = n.node.nodeAt(l),
                c = l + n.start;
              return { pos: c, start: c + 1, node: u };
            })
          );
        }
        return i;
      }, []);
    }
  },
  oP = (t) => (e) => {
    const n = xd(e);
    if (n) {
      const r = Ae.get(n.node);
      return (Array.isArray(t) ? t : Array.from([t])).reduce((i, s) => {
        if (s >= 0 && s <= r.height - 1) {
          const a = r.cellsInRect({
            left: 0,
            right: r.width,
            top: s,
            bottom: s + 1,
          });
          return i.concat(
            a.map((l) => {
              const u = n.node.nodeAt(l),
                c = l + n.start;
              return { pos: c, start: c + 1, node: u };
            })
          );
        }
        return i;
      }, []);
    }
  },
  xd = (t) => On((e) => e.type.spec.tableRole === "table")(t),
  D0 = (t) => (e) => {
    const n = Ae.get(e.$anchorCell.node(-1)),
      r = e.$anchorCell.start(-1),
      o = n.cellsInRect(t),
      i = n.cellsInRect(
        n.rectBetween(e.$anchorCell.pos - r, e.$headCell.pos - r)
      );
    for (let s = 0, a = o.length; s < a; s++)
      if (i.indexOf(o[s]) === -1) return !1;
    return !0;
  },
  kd = (t) => t instanceof De,
  iP = (t) => (e) => {
    if (kd(e)) {
      const n = Ae.get(e.$anchorCell.node(-1)),
        r = n.cellsInRect({
          left: 0,
          right: n.width,
          top: 0,
          bottom: 1,
        });
      if (t >= r.length) return !1;
      const o = n.findCell(r[t]);
      return D0({
        left: o.left,
        right: o.right,
        top: 0,
        bottom: n.height,
      })(e);
    }
    return !1;
  },
  sP = (t) => (e) => {
    if (kd(e)) {
      const n = Ae.get(e.$anchorCell.node(-1)),
        r = n.cellsInRect({
          left: 0,
          right: 1,
          top: 0,
          bottom: n.height,
        });
      if (t >= r.length) return !1;
      const o = n.findCell(r[t]);
      return D0({
        left: 0,
        right: n.width,
        top: o.top,
        bottom: o.bottom,
      })(e);
    }
    return !1;
  },
  nh = (t) => {
    if (kd(t)) {
      const e = Ae.get(t.$anchorCell.node(-1));
      return D0({
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height,
      })(t);
    }
    return !1;
  },
  aP = (t) => {
    const { $anchor: e } = t.selection,
      n = Math.max(0, e.pos - 2),
      r = t.doc.resolve(n).node();
    return !(!r || r.type.name !== "table");
  },
  L2 = (t) => K3(1)(t),
  lP = (t) => K3(-1)(t),
  K3 = (t) => (e) => {
    const n = Zn(e);
    if (n.table) {
      const r = n.map,
        o = r.cellsInRect(n),
        i = uP(r)(o[o.length - 1], t);
      if (i) {
        const { top: s, left: a } = i,
          l = r.map[s * r.width + a];
        return {
          start: l + n.tableStart + 2,
          node: n.table.nodeAt(l),
        };
      }
      return;
    }
  },
  uP = (t) => (e, n) => {
    function r({ top: s, left: a, right: l, bottom: u }) {
      const c = {
        top: s,
        left: a,
        right: l,
        bottom: u,
      };
      if (l + 1 > t.width) {
        if (u === t.height) return;
        c.top++, (c.left = 0), (c.right = 1), c.bottom++;
      } else c.left++, c.right++;
      const d = t.map[c.top * t.width + c.left],
        f = t.findCell(d);
      return f.top != c.top || f.left < c.left
        ? r({
            ...c,
            right: f.right,
          })
        : d;
    }
    function o({ top: s, left: a, right: l, bottom: u }) {
      const c = {
        top: s,
        left: a,
        right: l,
        bottom: u,
      };
      if (a - 1 < 0) {
        if (s === 0) return;
        c.top--, (c.left = t.width - 1), (c.right = t.width), c.bottom--;
      } else c.left--, c.right--;
      const d = t.map[c.top * t.width + c.left];
      return t.findCell(d).top != c.top ? o(c) : d;
    }
    function i(s, a) {
      const { top: l, left: u, right: c, bottom: d } = t.findCell(s);
      if (a == 0)
        return {
          top: l,
          left: u,
          right: c,
          bottom: d,
        };
      const f = {
        top: l,
        left: u,
        right: c,
        bottom: d,
      };
      let p;
      if ((a > 0 ? ((p = r(f)), a--) : ((p = o(f)), a++), !!p)) return i(p, a);
    }
    return i(e, n);
  },
  R2 = Ze.create({
    name: "tableCell",
    content: "block+",
    tableRole: "cell",
    isolating: !0,
    fakeSelection: !0,
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        colspan: {
          default: 1,
          parseHTML: (e) => {
            const n = e.getAttribute("colspan");
            return n ? parseInt(n, 10) : 1;
          },
        },
        rowspan: {
          default: 1,
          parseHTML: (e) => {
            const n = e.getAttribute("rowspan");
            return n ? parseInt(n, 10) : 1;
          },
        },
        colwidth: {
          default: [100],
          parseHTML: (e) => {
            const n = e.getAttribute("colwidth");
            return n ? n.split(",").map((o) => parseInt(o, 10)) : null;
          },
        },
        style: {
          default: null,
        },
      };
    },
    parseHTML() {
      return [{ tag: "td" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["td", ge(this.options.HTMLAttributes, t), 0];
    },
    addStorage() {
      return {
        gripMap: /* @__PURE__ */ new Map(),
      };
    },
    onDestroy() {
      this.storage.gripMap.clear();
    },
    addProseMirrorPlugins() {
      const t = this.editor,
        e = this.storage;
      return [
        new be({
          key: new ke("table-cell-control"),
          props: {
            decorations(n) {
              const { doc: r, selection: o } = n,
                i = [],
                s = rP(0)(o);
              return (
                s &&
                  s.forEach(({ pos: a }, l) => {
                    l === 0 &&
                      i.push(
                        Ve.widget(a + 1, () => {
                          const u = "table" + l;
                          let c = "grip-table";
                          nh(o) && (c += " selected");
                          let f = e.gripMap.get(u);
                          return (
                            f ||
                              ((f = document.createElement("a")),
                              f.addEventListener("mousedown", (p) => {
                                p.preventDefault(),
                                  p.stopImmediatePropagation(),
                                  t.view.dispatch(W3(t.state.tr));
                              })),
                            (f.className = c),
                            e.gripMap.set(u, f),
                            f
                          );
                        })
                      ),
                      i.push(
                        Ve.widget(a + 1, () => {
                          const u = "row" + l,
                            c = sP(l)(o);
                          let d = "grip-row";
                          c && (d += " selected"),
                            l === 0 && (d += " first"),
                            l === s.length - 1 && (d += " last");
                          let f = e.gripMap.get(u);
                          if (!f) {
                            f = document.createElement("a");
                            const p = Zt(
                              Bb,
                              {
                                triggers: ["hover"],
                              },
                              {
                                default: () => Zt(j3, { class: "plus-icon" }),
                                popper: () =>
                                  D.global.t(
                                    "editor.menus.table.add_row_after"
                                  ),
                              }
                            );
                            Ws(p, f),
                              f.addEventListener(
                                "mousedown",
                                (h) => {
                                  h.preventDefault(),
                                    h.stopImmediatePropagation(),
                                    t.view.dispatch(nP(l)(t.state.tr)),
                                    h.target !== f &&
                                      A_(t.state, t.view.dispatch);
                                },
                                !0
                              );
                          }
                          return (f.className = d), e.gripMap.set(u, f), f;
                        })
                      );
                  }),
                ve.create(r, i)
              );
            },
          },
        }),
      ];
    },
  }),
  I2 = Ze.create({
    name: "tableHeader",
    content: "block+",
    tableRole: "header_cell",
    isolating: !0,
    fakeSelection: !0,
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    addAttributes() {
      return {
        colspan: {
          default: 1,
        },
        rowspan: {
          default: 1,
        },
        colwidth: {
          default: [100],
          parseHTML: (t) => {
            const e = t.getAttribute("colwidth");
            return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
          },
        },
        style: {
          default: null,
        },
      };
    },
    parseHTML() {
      return [{ tag: "th" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["th", ge(this.options.HTMLAttributes, t), 0];
    },
    addStorage() {
      return {
        gripMap: /* @__PURE__ */ new Map(),
      };
    },
    onDestroy() {
      this.storage.gripMap.clear();
    },
    addProseMirrorPlugins() {
      const t = this.editor,
        e = this.storage;
      return [
        new be({
          key: new ke("table-header-control"),
          props: {
            decorations(n) {
              const { doc: r, selection: o } = n,
                i = [],
                s = oP(0)(o);
              return (
                s &&
                  s.forEach(({ pos: a }, l) => {
                    i.push(
                      Ve.widget(a + 1, () => {
                        const u = "column" + l,
                          c = iP(l)(o);
                        let d = "grip-column";
                        c && (d += " selected"),
                          l === 0
                            ? (d += " first")
                            : l === s.length - 1 && (d += " last");
                        let f = e.gripMap.get(u);
                        if (!f) {
                          f = document.createElement("a");
                          const p = Zt(
                            Bb,
                            {
                              triggers: ["hover"],
                            },
                            {
                              default: () => Zt(j3, { class: "plus-icon" }),
                              popper: () =>
                                D.global.t(
                                  "editor.menus.table.add_column_after"
                                ),
                            }
                          );
                          Ws(p, f),
                            f.addEventListener("mousedown", (h) => {
                              h.preventDefault(),
                                h.stopImmediatePropagation(),
                                t.view.dispatch(tP(l)(t.state.tr)),
                                h.target !== f && w_(t.state, t.view.dispatch);
                            });
                        }
                        return (f.className = d), e.gripMap.set(u, f), f;
                      })
                    );
                  }),
                ve.create(r, i)
              );
            },
          },
        }),
      ];
    },
  }),
  cP = Ze.create({
    name: "tableRow",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    content: "(tableCell | tableHeader)*",
    tableRole: "row",
    parseHTML() {
      return [{ tag: "tr" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["tr", ge(this.options.HTMLAttributes, t), 0];
    },
  }),
  dP = cP.extend({
    allowGapCursor: !1,
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        style: {
          default: "height: 60px;",
          parseHTML: (e) => e.getAttribute("style"),
        },
      };
    },
  });
function P2(t, e, n, r, o, i) {
  var c;
  let s = 0,
    a = !0,
    l = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d += 1) {
      const { colspan: p, colwidth: h } = u.child(d).attrs;
      for (let m = 0; m < p; m += 1, f += 1) {
        const g = o === f ? i : h && h[m],
          b = g ? `${g}px` : "";
        (s += g || r),
          g || (a = !1),
          l
            ? (l.style.width !== b && (l.style.width = b), (l = l.nextSibling))
            : (e.appendChild(document.createElement("col")).style.width = b);
      }
    }
    for (; l; ) {
      const d = l.nextSibling;
      (c = l.parentNode) == null || c.removeChild(l), (l = d);
    }
    a
      ? ((n.style.width = `${s}px`), (n.style.minWidth = ""))
      : ((n.style.width = ""), (n.style.minWidth = `${s}px`));
  }
}
let rh;
class fP {
  constructor(e, n) {
    ue(this, "node");
    ue(this, "cellMinWidth");
    ue(this, "dom");
    ue(this, "scrollDom");
    ue(this, "table");
    ue(this, "colgroup");
    ue(this, "contentDOM");
    ue(this, "containerDOM");
    (this.node = e),
      (this.cellMinWidth = n),
      (this.dom = document.createElement("div")),
      (this.dom.className = "table-container"),
      (this.containerDOM = this.dom.appendChild(document.createElement("div"))),
      (this.containerDOM.className = "tableWrapper"),
      this.containerDOM.addEventListener("wheel", (r) =>
        this.handleHorizontalWheel(this.containerDOM, r)
      ),
      this.containerDOM.addEventListener("scroll", () => {
        if (!rh) return !1;
        const { view: r } = rh;
        r.dispatch(r.state.tr);
      }),
      (this.scrollDom = document.createElement("div")),
      (this.scrollDom.className = "scrollWrapper"),
      this.containerDOM.appendChild(this.scrollDom),
      (this.table = this.scrollDom.appendChild(
        document.createElement("table")
      )),
      (this.colgroup = this.table.appendChild(
        document.createElement("colgroup")
      )),
      P2(e, this.colgroup, this.table, n),
      (this.contentDOM = this.table.appendChild(
        document.createElement("tbody")
      )),
      setTimeout(() => {
        this.updateTableShadow();
      });
  }
  update(e) {
    return e.type !== this.node.type
      ? !1
      : ((this.node = e),
        P2(e, this.colgroup, this.table, this.cellMinWidth),
        this.updateTableShadow(),
        !0);
  }
  updateTableShadow() {
    const { scrollWidth: e, clientWidth: n, scrollLeft: r } = this.containerDOM;
    e > n && r < e - n
      ? this.dom.classList.add("table-right-shadow")
      : this.dom.classList.remove("table-right-shadow"),
      r > 0
        ? this.dom.classList.add("table-left-shadow")
        : this.dom.classList.remove("table-left-shadow");
  }
  ignoreMutation(e) {
    return (
      e.type === "attributes" &&
      (e.target === this.table ||
        e.target === this.dom ||
        this.colgroup.contains(e.target))
    );
  }
  handleHorizontalWheel(e, n) {
    const { scrollWidth: r, clientWidth: o } = e;
    r > o &&
      (n.stopPropagation(), n.preventDefault(), e.scrollBy({ left: n.deltaY }));
  }
}
const Vo = hI
    .extend({
      allowGapCursor: !0,
      addExtensions() {
        return [R2, dP, I2];
      },
      addOptions() {
        var t;
        return {
          ...((t = this.parent) == null ? void 0 : t.call(this)),
          HTMLAttributes: {},
          resizable: !0,
          handleWidth: 5,
          cellMinWidth: 25,
          View: fP,
          lastColumnResizable: !0,
          allowTableNodeSelection: !1,
          getToolboxItems({ editor: e }) {
            return {
              priority: 15,
              component: k(gi),
              props: {
                editor: e,
                icon: k($I),
                title: D.global.t("editor.menus.table.add"),
                action: () =>
                  e
                    .chain()
                    .focus()
                    .insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
                    .run(),
              },
            };
          },
          getCommandMenuItems() {
            return {
              priority: 120,
              icon: k(_I),
              title: "editor.extensions.commands_menu.table",
              keywords: ["table", "biaoge"],
              command: ({ editor: e, range: n }) => {
                e.chain()
                  .focus()
                  .deleteRange(n)
                  .insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
                  .run();
              },
            };
          },
          getBubbleMenu({ editor: e }) {
            return {
              pluginKey: "tableBubbleMenu",
              shouldShow: ({ state: n }) => Jt(n, Vo.name),
              getRenderContainer(n) {
                let r = n;
                for (
                  r.nodeName === "#text" && (r = n.parentElement);
                  r && r.classList && !r.classList.contains("tableWrapper");

                )
                  r = r.parentElement;
                return r;
              },
              tippyOptions: {
                offset: [26, 0],
              },
              items: [
                {
                  priority: 10,
                  props: {
                    icon: k(SI),
                    title: D.global.t("editor.menus.table.add_column_before"),
                    action: () => {
                      e.chain().focus().addColumnBefore().run();
                    },
                  },
                },
                {
                  priority: 20,
                  props: {
                    icon: k(wI),
                    title: D.global.t("editor.menus.table.add_column_after"),
                    action: () => e.chain().focus().addColumnAfter().run(),
                  },
                },
                {
                  priority: 30,
                  props: {
                    icon: k(TI),
                    title: D.global.t("editor.menus.table.delete_column"),
                    action: () => e.chain().focus().deleteColumn().run(),
                  },
                },
                {
                  priority: 40,
                  component: k(ot),
                },
                {
                  priority: 50,
                  props: {
                    icon: k(qI),
                    title: D.global.t("editor.menus.table.add_row_before"),
                    action: () => e.chain().focus().addRowBefore().run(),
                  },
                },
                {
                  priority: 60,
                  props: {
                    icon: k(UI),
                    title: D.global.t("editor.menus.table.add_row_after"),
                    action: () => e.chain().focus().addRowAfter().run(),
                  },
                },
                {
                  priority: 70,
                  props: {
                    icon: k(JI),
                    title: D.global.t("editor.menus.table.delete_row"),
                    action: () => e.chain().focus().deleteRow().run(),
                  },
                },
                {
                  priority: 80,
                  component: k(ot),
                },
                {
                  priority: 90,
                  props: {
                    icon: k(N2),
                    title: D.global.t(
                      "editor.menus.table.toggle_header_column"
                    ),
                    action: () => e.chain().focus().toggleHeaderColumn().run(),
                  },
                },
                {
                  priority: 100,
                  props: {
                    icon: k(N2),
                    title: D.global.t("editor.menus.table.toggle_header_row"),
                    action: () => e.chain().focus().toggleHeaderRow().run(),
                  },
                },
                {
                  priority: 101,
                  props: {
                    icon: k(bI),
                    title: D.global.t("editor.menus.table.toggle_header_cell"),
                    action: () => e.chain().focus().toggleHeaderCell().run(),
                  },
                },
                {
                  priority: 110,
                  component: k(ot),
                },
                {
                  priority: 120,
                  props: {
                    icon: k(RI),
                    title: D.global.t("editor.menus.table.merge_cells"),
                    action: () => e.chain().focus().mergeCells().run(),
                  },
                },
                {
                  priority: 130,
                  props: {
                    icon: k(ZI),
                    title: D.global.t("editor.menus.table.split_cell"),
                    action: () => e.chain().focus().splitCell().run(),
                  },
                },
                {
                  priority: 140,
                  component: k(ot),
                },
                {
                  priority: 150,
                  props: {
                    icon: k(FI),
                    title: D.global.t("editor.menus.table.delete_table"),
                    action: () => e.chain().focus().deleteTable().run(),
                  },
                },
              ],
            };
          },
          getDraggable() {
            return {
              getRenderContainer({ dom: e }) {
                let n = e;
                for (; n && !n.classList.contains("tableWrapper"); )
                  n = n.parentElement;
                return {
                  el: n,
                  dragDomOffset: {
                    x: 20,
                    y: 20,
                  },
                };
              },
              handleDrop({ view: e, event: n, slice: r, insertPos: o }) {
                const { state: i } = e,
                  s = i.selection.$anchor;
                for (let a = s.depth; a > 0; a--)
                  if (s.node(a).type.spec.tableRole == "table") {
                    if (
                      !e.posAtCoords({
                        left: n.clientX,
                        top: n.clientY,
                      }) ||
                      !r
                    )
                      return;
                    let c = i.tr;
                    c = c.delete(s.before(a), s.after(a));
                    const d = c.mapping.map(o);
                    return (
                      (c = c.replaceRange(d, d, r).scrollIntoView()),
                      c ? (e.dispatch(c), n.preventDefault(), !0) : !1
                    );
                  }
              },
            };
          },
        };
      },
      addKeyboardShortcuts() {
        const t = () => {
          const { editor: e } = this;
          if (e.commands.undoInputRule()) return !0;
          const { selection: n } = e.state;
          return !Sn(e.state, Vo.name) && aP(e.state) && n.empty
            ? (e.commands.selectNodeBackward(), !0)
            : Sn(e.state, Vo.name) && nh(e.state.selection)
            ? (e.commands.deleteTable(), !0)
            : !1;
        };
        return {
          Backspace: () => t(),
          "Mod-Backspace": () => t(),
          "Mod-a": ({ editor: e }) => {
            if (!Sn(e.state, Vo.name)) return !1;
            const { tr: n, selection: r } = e.state;
            if (nh(r)) return !0;
            if (kd(r)) return W3(n), e.view.dispatch(n), !0;
            let o = On((i) => i.type.name === R2.name)(r);
            return (
              o || (o = On((i) => i.type.name === I2.name)(r)),
              o ? (e.commands.setNodeSelection(o.pos), !0) : !1
            );
          },
          Tab: ({ editor: e }) => {
            var s;
            const { state: n } = e;
            if (!Jt(e.state, Vo.name)) return !1;
            let r = e.view,
              o = e.state.tr,
              i = L2(n);
            return (
              i ||
                e
                  .chain()
                  .addRowAfter()
                  .command(
                    ({ tr: a, view: l, state: u }) => (
                      (r = l), (o = a), (i = L2(u)), !0
                    )
                  ),
              i
                ? (o.setSelection(
                    new q(
                      o.doc.resolve(i.start),
                      o.doc.resolve(
                        i.start +
                          (((s = i.node) == null ? void 0 : s.nodeSize) || 0) -
                          4
                      )
                    )
                  ),
                  o.scrollIntoView(),
                  r.dispatch(o),
                  !0)
                : !1
            );
          },
          "Shift-Tab": ({ editor: e }) => {
            var o;
            const { tr: n } = e.state;
            if (!Jt(e.state, Vo.name)) return !1;
            const r = lP(e.state);
            return (
              r &&
                (n.setSelection(
                  new q(
                    n.doc.resolve(r.start),
                    n.doc.resolve(
                      r.start +
                        (((o = r.node) == null ? void 0 : o.nodeSize) || 0) -
                        4
                    )
                  )
                ),
                n.scrollIntoView(),
                e.view.dispatch(n)),
              !0
            );
          },
        };
      },
      renderHTML({ node: t, HTMLAttributes: e }) {
        const {
          colgroup: n,
          tableWidth: r,
          tableMinWidth: o,
        } = U3(t, this.options.cellMinWidth);
        return [
          "div",
          { style: "overflow-x: auto; overflow-y: hidden;" },
          [
            "table",
            ge(this.options.HTMLAttributes, e, {
              style: r ? `width: ${r}` : `minWidth: ${o}`,
            }),
            n,
            ["tbody", 0],
          ],
        ];
      },
      onTransaction() {
        rh = this.editor;
      },
    })
    .configure({ resizable: !0 }),
  pP = /^\s*(\[([( |x])?\])\s$/,
  hP = Ze.create({
    name: "taskItem",
    addOptions() {
      return {
        nested: !1,
        HTMLAttributes: {},
        taskListTypeName: "taskList",
      };
    },
    content() {
      return this.options.nested ? "paragraph block*" : "paragraph+";
    },
    defining: !0,
    addAttributes() {
      return {
        checked: {
          default: !1,
          keepOnSplit: !1,
          parseHTML: (t) => {
            const e = t.getAttribute("data-checked");
            return e === "" || e === "true";
          },
          renderHTML: (t) => ({
            "data-checked": t.checked,
          }),
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: `li[data-type="${this.name}"]`,
          priority: 51,
        },
      ];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        "li",
        ge(this.options.HTMLAttributes, e, {
          "data-type": this.name,
        }),
        [
          "label",
          [
            "input",
            {
              type: "checkbox",
              checked: t.attrs.checked ? "checked" : null,
            },
          ],
          ["span"],
        ],
        ["div", 0],
      ];
    },
    addKeyboardShortcuts() {
      const t = {
        Enter: () => this.editor.commands.splitListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      };
      return this.options.nested
        ? {
            ...t,
            Tab: () => this.editor.commands.sinkListItem(this.name),
          }
        : t;
    },
    addNodeView() {
      return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
        const o = document.createElement("li"),
          i = document.createElement("label"),
          s = document.createElement("span"),
          a = document.createElement("input"),
          l = document.createElement("div");
        return (
          (i.contentEditable = "false"),
          (a.type = "checkbox"),
          a.addEventListener("mousedown", (u) => u.preventDefault()),
          a.addEventListener("change", (u) => {
            if (!r.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked;
              return;
            }
            const { checked: c } = u.target;
            r.isEditable &&
              typeof n == "function" &&
              r
                .chain()
                .focus(void 0, { scrollIntoView: !1 })
                .command(({ tr: d }) => {
                  const f = n();
                  if (typeof f != "number") return !1;
                  const p = d.doc.nodeAt(f);
                  return (
                    d.setNodeMarkup(f, void 0, {
                      ...(p == null ? void 0 : p.attrs),
                      checked: c,
                    }),
                    !0
                  );
                })
                .run(),
              !r.isEditable &&
                this.options.onReadOnlyChecked &&
                (this.options.onReadOnlyChecked(t, c) ||
                  (a.checked = !a.checked));
          }),
          Object.entries(this.options.HTMLAttributes).forEach(([u, c]) => {
            o.setAttribute(u, c);
          }),
          (o.dataset.checked = t.attrs.checked),
          (a.checked = t.attrs.checked),
          i.append(a, s),
          o.append(i, l),
          Object.entries(e).forEach(([u, c]) => {
            o.setAttribute(u, c);
          }),
          {
            dom: o,
            contentDOM: l,
            update: (u) =>
              u.type !== this.type
                ? !1
                : ((o.dataset.checked = u.attrs.checked),
                  (a.checked = u.attrs.checked),
                  !0),
          }
        );
      };
    },
    addInputRules() {
      return [
        Gi({
          find: pP,
          type: this.type,
          getAttributes: (t) => ({
            checked: t[t.length - 1] === "x",
          }),
        }),
      ];
    },
  }),
  mP = Ze.create({
    name: "taskList",
    addOptions() {
      return {
        itemTypeName: "taskItem",
        HTMLAttributes: {},
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [
        {
          tag: `ul[data-type="${this.name}"]`,
          priority: 51,
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return [
        "ul",
        ge(this.options.HTMLAttributes, t, { "data-type": this.name }),
        0,
      ];
    },
    addCommands() {
      return {
        toggleTaskList:
          () =>
          ({ commands: t }) =>
            t.toggleList(this.name, this.options.itemTypeName),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-9": () => this.editor.commands.toggleTaskList(),
      };
    },
  }),
  gP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function bP(t, e) {
  return (
    S(),
    O(
      "svg",
      gP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M21 19v-2H8v2zm0-6v-2H8v2zM8 7h13V5H8zM4 5v2h2V5zM3 5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const $2 = k({ name: "mdi-format-list-checkbox", render: bP }),
  yP = mP.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 150,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("taskList"),
              icon: k($2),
              title: D.global.t("editor.common.task_list"),
              action: () => e.chain().focus().toggleTaskList().run(),
            },
          };
        },
        getCommandMenuItems() {
          return {
            priority: 150,
            icon: k($2),
            title: "editor.common.task_list",
            keywords: ["tasklist", "renwuliebiao"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).toggleTaskList().run();
            },
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && n.tagName !== "LI"; ) n = n.parentElement;
              return {
                el: n,
                dragDomOffset: {
                  y: -1,
                },
              };
            },
          };
        },
      };
    },
    addExtensions() {
      return [hP];
    },
  }),
  vP = Ne.create({
    name: "textAlign",
    addOptions() {
      return {
        types: [],
        alignments: ["left", "center", "right", "justify"],
        defaultAlignment: null,
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            textAlign: {
              default: this.options.defaultAlignment,
              parseHTML: (t) => {
                const e = t.style.textAlign;
                return this.options.alignments.includes(e)
                  ? e
                  : this.options.defaultAlignment;
              },
              renderHTML: (t) =>
                t.textAlign ? { style: `text-align: ${t.textAlign}` } : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setTextAlign:
          (t) =>
          ({ commands: e }) =>
            this.options.alignments.includes(t)
              ? this.options.types
                  .map((n) => e.updateAttributes(n, { textAlign: t }))
                  .every((n) => n)
              : !1,
        unsetTextAlign:
          () =>
          ({ commands: t }) =>
            this.options.types
              .map((e) => t.resetAttributes(e, "textAlign"))
              .every((e) => e),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
        "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
        "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
        "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify"),
      };
    },
  }),
  _P = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function xP(t, e) {
  return (
    S(),
    O(
      "svg",
      _P,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 3h18v2H3zm4 4h10v2H7zm-4 4h18v2H3zm4 4h10v2H7zm-4 4h18v2H3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Ua = k({ name: "mdi-format-align-center", render: xP }),
  kP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function wP(t, e) {
  return (
    S(),
    O(
      "svg",
      kP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 3h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const ja = k({ name: "mdi-format-align-justify", render: wP }),
  CP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function AP(t, e) {
  return (
    S(),
    O(
      "svg",
      CP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 3h18v2H3zm0 4h12v2H3zm0 4h18v2H3zm0 4h12v2H3zm0 4h18v2H3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const us = k({ name: "mdi-format-align-left", render: AP }),
  SP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function EP(t, e) {
  return (
    S(),
    O(
      "svg",
      SP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 3h18v2H3zm6 4h12v2H9zm-6 4h18v2H3zm6 4h12v2H9zm-6 4h18v2H3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Wa = k({ name: "mdi-format-align-right", render: EP }),
  MP = {
    left: us,
    center: Ua,
    right: Wa,
    justify: ja,
  },
  TP = (t) => {
    let e = us;
    return (
      Object.entries(MP).forEach(([n, r]) => {
        if (t.isActive({ textAlign: n })) {
          e = r;
          return;
        }
      }),
      e
    );
  },
  OP = vP.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 180,
            component: k(Xe),
            props: {
              editor: e,
              isActive: !1,
              icon: k(TP(e)),
              title: D.global.t("editor.common.align_method"),
            },
            children: [
              {
                priority: 0,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive({ textAlign: "left" }),
                  icon: k(us),
                  title: D.global.t("editor.common.align_left"),
                  action: () => e.chain().focus().setTextAlign("left").run(),
                },
              },
              {
                priority: 10,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive({ textAlign: "center" }),
                  icon: k(Ua),
                  title: D.global.t("editor.common.align_center"),
                  action: () => e.chain().focus().setTextAlign("center").run(),
                },
              },
              {
                priority: 20,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive({ textAlign: "right" }),
                  icon: k(Wa),
                  title: D.global.t("editor.common.align_right"),
                  action: () => e.chain().focus().setTextAlign("right").run(),
                },
              },
              {
                priority: 30,
                component: k(Ut),
                props: {
                  editor: e,
                  isActive: e.isActive({ textAlign: "justify" }),
                  icon: k(ja),
                  title: D.global.t("editor.common.align_justify"),
                  action: () => e.chain().focus().setTextAlign("justify").run(),
                },
              },
            ],
          };
        },
      };
    },
  }),
  DP = tn.create({
    name: "underline",
    addOptions() {
      return {
        HTMLAttributes: {},
      };
    },
    parseHTML() {
      return [
        {
          tag: "u",
        },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (t) => (t.includes("underline") ? {} : !1),
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["u", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setUnderline:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleUnderline:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetUnderline:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline(),
      };
    },
  }),
  NP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function LP(t, e) {
  return (
    S(),
    O(
      "svg",
      NP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M5 21h14v-2H5zm7-4a6 6 0 0 0 6-6V3h-2.5v8a3.5 3.5 0 0 1-3.5 3.5A3.5 3.5 0 0 1 8.5 11V3H6v8a6 6 0 0 0 6 6",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const G3 = k({ name: "mdi-format-underline", render: LP }),
  RP = DP.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          return {
            priority: 60,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("underline"),
              icon: k(G3),
              title: D.global.t("editor.common.underline"),
              action: () => e.chain().focus().toggleUnderline().run(),
            },
          };
        },
      };
    },
  }),
  IP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function PP(t, e) {
  return (
    S(),
    O(
      "svg",
      IP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-8 5H9v2c0 1.1-.9 2-2 2c1.1 0 2 .9 2 2v2h2v2H9c-1.1 0-2-.9-2-2v-1c0-1.1-.9-2-2-2v-2c1.1 0 2-.9 2-2V8c0-1.1.9-2 2-2h2zm8 5c-1.1 0-2 .9-2 2v1c0 1.1-.9 2-2 2h-2v-2h2v-2c0-1.1.9-2 2-2c-1.1 0-2-.9-2-2V8h-2V6h2c1.1 0 2 .9 2 2v1c0 1.1.9 2 2 2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Df = k({ name: "mdi-code-braces-box", render: PP });
function $P(t) {
  return Lx() ? (Rx(t), !0) : !1;
}
function BP(t) {
  return typeof t == "function" ? t() : I(t);
}
const HP = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const FP = () => {};
function zP(t, e, n = {}) {
  const { immediate: r = !0 } = n,
    o = Te(!1);
  let i = null;
  function s() {
    i && (clearTimeout(i), (i = null));
  }
  function a() {
    (o.value = !1), s();
  }
  function l(...u) {
    s(),
      (o.value = !0),
      (i = setTimeout(() => {
        (o.value = !1), (i = null), t(...u);
      }, BP(e)));
  }
  return (
    r && ((o.value = !0), HP && l()),
    $P(a),
    {
      isPending: Nx(o),
      start: l,
      stop: a,
    }
  );
}
function VP(t = 1e3, e = {}) {
  const { controls: n = !1, callback: r } = e,
    o = zP(r ?? FP, t, e),
    i = ce(() => !o.isPending.value);
  return n
    ? {
        ready: i,
        ...o,
      }
    : i;
}
const UP = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em",
};
function jP(t, e) {
  return (
    S(),
    O(
      "svg",
      UP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              d: "M14 8H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V10c0-1.103-.897-2-2-2z",
              fill: "currentColor",
            },
            null,
            -1
          ),
          C(
            "path",
            {
              d: "M20 2H10a2 2 0 0 0-2 2v2h8a2 2 0 0 1 2 2v8h2a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z",
              fill: "currentColor",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const WP = k({ name: "bx-bxs-copy", render: jP }),
  qP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function KP(t, e) {
  return (
    S(),
    O(
      "svg",
      qP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m12 16l-6-6h12z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const GP = k({ name: "ri-arrow-down-s-fill", render: KP }),
  JP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function YP(t, e) {
  return (
    S(),
    O(
      "svg",
      JP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m16 12l-6 6V6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const XP = k({ name: "ri-arrow-right-s-fill", render: YP }),
  ZP = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function QP(t, e) {
  return (
    S(),
    O(
      "svg",
      ZP,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m-.997-4L6.76 11.757l1.414-1.414l2.829 2.829l5.657-5.657l1.414 1.414z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const e$ = k({ name: "ri-checkbox-circle-line", render: QP }),
  t$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function n$(t, e) {
  return (
    S(),
    O(
      "svg",
      t$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m12 13.171l4.95-4.95l1.414 1.415L12 16L5.636 9.636L7.05 8.222z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const r$ = k({ name: "ri-arrow-down-s-line", render: n$ }),
  o$ = { class: "h-8" },
  i$ = { class: "absolute top-0 bottom-0" },
  s$ = ["placeholder"],
  a$ = { class: "bg-white" },
  l$ = { class: "select max-h-64 cursor-pointer p-1" },
  u$ = ["index", "onMousedown"],
  c$ = { class: "flex-1 text-ellipsis text-sm" },
  d$ = {
    key: 1,
    class: "w-full h-8 flex items-center rounded-md text-base px-3 py-1",
  },
  f$ = /* @__PURE__ */ se({
    __name: "CodeBlockSelect",
    props: /* @__PURE__ */ U0(
      {
        container: {},
        containerClass: {},
        options: {},
        filterSort: { type: Function },
      },
      {
        modelValue: {
          default: "",
        },
        modelModifiers: {},
      }
    ),
    emits: /* @__PURE__ */ U0(["select"], ["update:modelValue"]),
    setup(t, { emit: e }) {
      const n = t,
        r = Ix(t, "modelValue"),
        o = e,
        i = Te(!1),
        s = Te(""),
        a = Te(null),
        l = Te(null),
        u = ce(() => (a.value ? a.value.label : r.value)),
        c = ce(() =>
          s.value
            ? n.options.filter((b) =>
                b.value
                  .toLocaleLowerCase()
                  .includes(s.value.toLocaleLowerCase())
              )
            : n.options
        ),
        d = () => {
          (i.value = !0),
            setTimeout(() => {
              g();
            }, 50);
        },
        f = () => {
          (i.value = !1), s.value && ((r.value = s.value), (s.value = ""));
        },
        p = (b) => {
          var _;
          (a.value = b),
            (r.value = b.value),
            (s.value = ""),
            (_ = l.value) == null || _.blur(),
            o("select");
        },
        h = Te(-1),
        m = (b) => {
          const _ = b.key;
          if (_ === "ArrowUp")
            return (
              (h.value = (h.value - 1 + c.value.length) % c.value.length), !0
            );
          if (_ === "ArrowDown")
            return (h.value = (h.value + 1) % c.value.length), !0;
          if (_ === "Enter") return h.value === -1 || p(c.value[h.value]), !0;
        };
      jt(
        r,
        (b) => {
          b &&
            ((a.value = n.options.find((_) => _.value === b) || null),
            (h.value = n.options.findIndex((_) => _.value === b)));
        },
        {
          immediate: !0,
        }
      ),
        jt(
          h,
          () => {
            setTimeout(() => {
              g();
            });
          },
          {
            immediate: !0,
          }
        );
      const g = () => {
        if (h.value === -1) return;
        const b = document.querySelector(
          `.select > div:nth-child(${h.value + 1})`
        );
        b &&
          b.scrollIntoView({
            behavior: "instant",
            block: "nearest",
            inline: "nearest",
          });
      };
      return (b, _) => (
        S(),
        de(
          I(ii),
          {
            triggers: [],
            shown: i.value,
            "auto-hide": !1,
            distance: 0,
            "auto-size": "",
            container: b.container || "body",
          },
          {
            popper: me(() => [
              C("div", a$, [
                C("div", l$, [
                  c.value && c.value.length > 0
                    ? (S(!0),
                      O(
                        gt,
                        { key: 0 },
                        Fr(
                          c.value,
                          (v, y) => (
                            S(),
                            O(
                              "div",
                              {
                                key: v.value,
                                index: y,
                                class: $e([
                                  "w-full h-8 flex items-center rounded-md text-base px-3 py-1 hover:bg-zinc-100",
                                  {
                                    "bg-zinc-200": v.value === r.value,
                                    "bg-zinc-100": h.value === y,
                                  },
                                ]),
                                onMousedown: (w) => p(v),
                              },
                              [C("span", c$, it(v.label), 1)],
                              42,
                              u$
                            )
                          )
                        ),
                        128
                      ))
                    : (S(),
                      O(
                        "div",
                        d$,
                        _[2] ||
                          (_[2] = [
                            C(
                              "span",
                              { class: "flex-1 text-ellipsis text-sm" },
                              "No options",
                              -1
                            ),
                          ])
                      )),
                ]),
              ]),
            ]),
            default: me(() => [
              C(
                "div",
                {
                  class: "relative inline-block w-full",
                  onKeydown: m,
                },
                [
                  C("div", o$, [
                    C(
                      "div",
                      {
                        class: $e([
                          "select-input w-full h-full grid items-center text-sm rounded-md px-3 cursor-pointer box-border",
                          {
                            "bg-white": i.value,
                            "border-[1px]": i.value,
                          },
                        ]),
                      },
                      [
                        C("span", i$, [
                          je(
                            C(
                              "input",
                              {
                                ref_key: "inputRef",
                                ref: l,
                                "onUpdate:modelValue":
                                  _[0] || (_[0] = (v) => (s.value = v)),
                                class:
                                  "appearance-none bg-transparent h-full ps-0 pe-0 border-none outline-none m-0 p-0 cursor-auto",
                                placeholder: i.value ? u.value : "",
                                onFocus: d,
                                onBlur: f,
                              },
                              null,
                              40,
                              s$
                            ),
                            [[Ot, s.value]]
                          ),
                        ]),
                        je(
                          C(
                            "span",
                            { class: "text-ellipsis text-sm" },
                            it(u.value),
                            513
                          ),
                          [[mh, !i.value]]
                        ),
                        C(
                          "span",
                          {
                            class: "justify-self-end",
                            onClick:
                              _[1] ||
                              (_[1] = (v) => {
                                var y;
                                return (y = l.value) == null
                                  ? void 0
                                  : y.focus();
                              }),
                          },
                          [J(I(r$))]
                        ),
                      ],
                      2
                    ),
                  ]),
                ],
                32
              ),
            ]),
            _: 1,
          },
          8,
          ["shown", "container"]
        )
      );
    },
  }),
  B2 = /* @__PURE__ */ _h(f$, [["__scopeId", "data-v-0ea43cd6"]]),
  p$ = {
    contenteditable: "false",
    class:
      "bg-neutral-100 border-b-[1px] border-b-gray-100 py-1 flex items-center justify-between",
  },
  h$ = { class: "pr-3 flex items-center" },
  m$ = { class: "pr-3 flex items-center" },
  g$ = /* @__PURE__ */ se({
    __name: "CodeBlockViewRenderer",
    props: {
      decorations: {},
      selected: { type: Boolean },
      updateAttributes: { type: Function },
      deleteNode: { type: Function },
      node: {},
      view: {},
      getPos: { type: Function },
      innerDecorations: {},
      editor: {},
      extension: {},
      HTMLAttributes: {},
    },
    setup(t) {
      const e = t,
        n = ce(() => {
          let c = [];
          const d = e.extension.options.languages;
          return (
            typeof d == "function" ? (c = d(e.editor.state)) : (c = d),
            (c = c || []),
            c.map((p) => p.value).indexOf("auto") === -1 &&
              c.unshift({
                label: "Auto",
                value: "auto",
              }),
            c
          );
        }),
        r = ce({
          get: () => {
            var c;
            return ((c = e.node) == null ? void 0 : c.attrs.language) || "auto";
          },
          set: (c) => {
            e.updateAttributes({ language: c });
          },
        }),
        o = ce(() => {
          let c = [];
          const d = e.extension.options.themes;
          if ((typeof d == "function" ? (c = d(e.editor.state)) : (c = d), !!c))
            return c;
        }),
        i = ce({
          get: () => {
            var c, d;
            return (
              ((c = e.node) == null ? void 0 : c.attrs.theme) ||
              ((d = o.value) == null ? void 0 : d[0].value)
            );
          },
          set: (c) => {
            e.updateAttributes({ theme: c });
          },
        }),
        s = ce({
          get: () => e.node.attrs.collapsed || !1,
          set: (c) => {
            e.updateAttributes({ collapsed: c });
          },
        }),
        { ready: a, start: l } = VP(2e3, { controls: !0, immediate: !1 }),
        u = () => {
          if (!a.value) return;
          const c = e.node.textContent;
          navigator.clipboard.writeText(c).then(() => {
            l();
          });
        };
      return (c, d) => {
        const f = Px("tooltip");
        return (
          S(),
          de(
            I(Ha),
            {
              as: "div",
              class: "code-node border-[1px] rounded mt-3 overflow-hidden",
            },
            {
              default: me(() => [
                C("div", p$, [
                  C(
                    "div",
                    {
                      class: "flex-1 flex items-center pl-3",
                      onClick:
                        d[5] ||
                        (d[5] = xs(
                          (p) => (s.value ? (s.value = !1) : null),
                          ["self"]
                        )),
                    },
                    [
                      C("div", h$, [
                        C(
                          "div",
                          {
                            class:
                              "w-8 h-8 cursor-pointer rounded flex items-center justify-center hover:bg-zinc-200",
                            onClick:
                              d[0] ||
                              (d[0] = xs(
                                (p) => (s.value = !s.value),
                                ["stop"]
                              )),
                          },
                          [
                            s.value
                              ? (S(), de(I(XP), { key: 0 }))
                              : (S(), de(I(GP), { key: 1 })),
                          ]
                        ),
                      ]),
                      J(
                        B2,
                        {
                          modelValue: r.value,
                          "onUpdate:modelValue":
                            d[1] || (d[1] = (p) => (r.value = p)),
                          class: "w-48",
                          container: c.editor.options.element,
                          options: n.value,
                          onSelect:
                            d[2] || (d[2] = (p) => c.editor.commands.focus()),
                        },
                        null,
                        8,
                        ["modelValue", "container", "options"]
                      ),
                      o.value && o.value.length > 0
                        ? (S(),
                          de(
                            B2,
                            {
                              key: 0,
                              modelValue: i.value,
                              "onUpdate:modelValue":
                                d[3] || (d[3] = (p) => (i.value = p)),
                              container: c.editor.options.element,
                              class: "w-48",
                              options: o.value,
                              onSelect:
                                d[4] ||
                                (d[4] = (p) => c.editor.commands.focus()),
                            },
                            null,
                            8,
                            ["modelValue", "container", "options"]
                          ))
                        : un("", !0),
                    ]
                  ),
                  C("div", m$, [
                    je(
                      (S(),
                      O(
                        "div",
                        {
                          class: $e([
                            "w-8 h-8 cursor-pointer rounded flex items-center justify-center",
                            { "hover:bg-zinc-200": I(a) },
                          ]),
                          onClick: u,
                        },
                        [
                          I(a)
                            ? (S(),
                              de(I(WP), {
                                key: 1,
                                class: "w-4 h-4 text-gray-500",
                              }))
                            : (S(),
                              de(I(e$), {
                                key: 0,
                                class: "w-4 h-4 text-green-500",
                              })),
                        ],
                        2
                      )),
                      [
                        [
                          f,
                          I(a)
                            ? I(D).global.t("editor.common.codeblock.copy_code")
                            : I(D).global.t(
                                "editor.common.codeblock.copy_code_success"
                              ),
                        ],
                      ]
                    ),
                  ]),
                ]),
                je(
                  C(
                    "pre",
                    null,
                    [
                      J(I(SD), {
                        as: "code",
                        class: "hljs",
                      }),
                    ],
                    512
                  ),
                  [[mh, !s.value]]
                ),
              ]),
              _: 1,
            }
          )
        );
      };
    },
  }),
  b$ = /^```([a-z]+)?[\s\n]$/,
  y$ = /^~~~([a-z]+)?[\s\n]$/,
  Al = Ze.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: !0,
        exitOnArrowDown: !0,
        defaultLanguage: null,
        HTMLAttributes: {},
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (t) => {
            var e;
            const { languageClassPrefix: n } = this.options,
              i = [
                ...(((e = t.firstElementChild) === null || e === void 0
                  ? void 0
                  : e.classList) || []),
              ]
                .filter((s) => s.startsWith(n))
                .map((s) => s.replace(n, ""))[0];
            return i || null;
          },
          rendered: !1,
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "pre",
          preserveWhitespace: "full",
        },
      ];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        "pre",
        ge(this.options.HTMLAttributes, e),
        [
          "code",
          {
            class: t.attrs.language
              ? this.options.languageClassPrefix + t.attrs.language
              : null,
          },
          0,
        ],
      ];
    },
    addCommands() {
      return {
        setCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.setNode(this.name, t),
        toggleCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.toggleNode(this.name, "paragraph", t),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        // remove code block when at start of document or code block is empty
        Backspace: () => {
          const { empty: t, $anchor: e } = this.editor.state.selection,
            n = e.pos === 1;
          return !t || e.parent.type.name !== this.name
            ? !1
            : n || !e.parent.textContent.length
            ? this.editor.commands.clearNodes()
            : !1;
        },
        // exit node on triple enter
        Enter: ({ editor: t }) => {
          if (!this.options.exitOnTripleEnter) return !1;
          const { state: e } = t,
            { selection: n } = e,
            { $from: r, empty: o } = n;
          if (!o || r.parent.type !== this.type) return !1;
          const i = r.parentOffset === r.parent.nodeSize - 2,
            s = r.parent.textContent.endsWith(`

`);
          return !i || !s
            ? !1
            : t
                .chain()
                .command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0))
                .exitCode()
                .run();
        },
        // exit node on arrow down
        ArrowDown: ({ editor: t }) => {
          if (!this.options.exitOnArrowDown) return !1;
          const { state: e } = t,
            { selection: n, doc: r } = e,
            { $from: o, empty: i } = n;
          if (
            !i ||
            o.parent.type !== this.type ||
            !(o.parentOffset === o.parent.nodeSize - 2)
          )
            return !1;
          const a = o.after();
          return a === void 0
            ? !1
            : r.nodeAt(a)
            ? t.commands.command(
                ({ tr: u }) => (u.setSelection(ee.near(r.resolve(a))), !0)
              )
            : t.commands.exitCode();
        },
      };
    },
    addInputRules() {
      return [
        Pp({
          find: b$,
          type: this.type,
          getAttributes: (t) => ({
            language: t[1],
          }),
        }),
        Pp({
          find: y$,
          type: this.type,
          getAttributes: (t) => ({
            language: t[1],
          }),
        }),
      ];
    },
    addProseMirrorPlugins() {
      return [
        // this plugin creates a code block for pasted content from VS Code
        // we can also detect the copied code language
        new be({
          key: new ke("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (t, e) => {
              if (!e.clipboardData || this.editor.isActive(this.type.name))
                return !1;
              const n = e.clipboardData.getData("text/plain"),
                r = e.clipboardData.getData("vscode-editor-data"),
                o = r ? JSON.parse(r) : void 0,
                i = o == null ? void 0 : o.mode;
              if (!n || !i) return !1;
              const { tr: s, schema: a } = t.state,
                l = a.text(
                  n.replace(
                    /\r\n?/g,
                    `
`
                  )
                );
              return (
                s.replaceSelectionWith(this.type.create({ language: i }, l)),
                s.selection.$from.parent.type !== this.type &&
                  s.setSelection(
                    q.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))
                  ),
                s.setMeta("paste", !0),
                t.dispatch(s),
                !0
              );
            },
          },
        }),
      ];
    },
  }),
  H2 = (t, e) => {
    const { doc: n, selection: r } = t;
    if (!n || !r || !(r instanceof q)) return t;
    const { from: o, to: i } = r;
    return (
      n.nodesBetween(o, i, (s, a) => {
        if (o - i == 0 && e === "indent") return t.insertText("  ", o, i), !1;
        const u = n.textBetween(
            a + 1,
            o,
            `
`
          ).lastIndexOf(`
`),
          c = u === -1 ? a + 1 : a + u + 1,
          d = n.textBetween(
            c,
            i,
            `
`
          );
        if (e === "indent") {
          let f = d.replace(
            /\n/g,
            `
  `
          );
          c === a + 1 && (f = "  " + f), t.insertText(f, c, i);
        } else {
          let f = d.replace(
            /\n {2}/g,
            `
`
          );
          c === a + 1 && f.indexOf("  ") == 0 && (f = f.replace("  ", "")),
            t.insertText(f, c, i);
        }
        return !1;
      }),
      t
    );
  },
  F2 = (t) => {
    let e = t;
    for (
      e.nodeName === "#text" && (e = t.parentElement);
      e && e.classList && !e.classList.contains("code-node");

    )
      e = e.parentElement;
    return e;
  },
  v$ = Al.extend({
    allowGapCursor: !0,
    // It needs to have a higher priority than range-selection,
    // otherwise the Mod-a shortcut key will be overridden.
    priority: 110,
    fakeSelection: !0,
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        collapsed: {
          default: !1,
          parseHTML: (e) => !!e.getAttribute("collapsed"),
          renderHTML: (e) =>
            e.collapsed
              ? {
                  collapsed: e.collapsed,
                }
              : {},
        },
        theme: {
          default: this.options.defaultTheme,
          parseHTML: (e) => e.getAttribute("theme") || null,
          renderHTML: (e) =>
            e.theme
              ? {
                  theme: e.theme,
                }
              : {},
        },
      };
    },
    addCommands() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        codeIndent:
          () =>
          ({ tr: e, state: n, dispatch: r }) => {
            const { selection: o } = n;
            return (
              (e = e.setSelection(o)),
              (e = H2(e, "indent")),
              e.docChanged && r ? (r(e), !0) : !1
            );
          },
        codeOutdent:
          () =>
          ({ tr: e, state: n, dispatch: r }) => {
            const { selection: o } = n;
            return (
              (e = e.setSelection(o)),
              (e = H2(e, "outdent")),
              e.docChanged && r ? (r(e), !0) : !1
            );
          },
      };
    },
    addKeyboardShortcuts() {
      return {
        Backspace: ({ editor: t }) => {
          if (!Sn(t.state, this.name)) return !1;
          const { selection: e } = t.state;
          if (!e.empty)
            return (
              t
                .chain()
                .focus()
                .deleteSelection()
                .setTextSelection(e.$from.pos)
                .run(),
              !0
            );
          const { $anchor: n } = e;
          return n.parentOffset === 0 || !n.parent.textContent.length;
        },
        Tab: () =>
          this.editor.isActive("codeBlock")
            ? this.editor.chain().focus().codeIndent().run()
            : !1,
        "Shift-Tab": () =>
          this.editor.isActive("codeBlock")
            ? this.editor.chain().focus().codeOutdent().run()
            : !1,
        "Mod-a": () => {
          if (this.editor.isActive("codeBlock")) {
            const { tr: t, selection: e } = this.editor.state,
              n = On((a) => a.type.name === Al.name)(e);
            if (!n) return !1;
            const r = n.start,
              o = n.start + n.node.nodeSize - 1,
              i = t.doc.resolve(r),
              s = t.doc.resolve(o);
            return this.editor.view.dispatch(t.setSelection(new q(i, s))), !0;
          }
          return !1;
        },
      };
    },
    addNodeView() {
      return Fa(g$);
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        languages: [],
        themes: [],
        defaultLanguage: null,
        defaultTheme: null,
        getToolbarItems({ editor: e }) {
          return {
            priority: 160,
            component: k(Xe),
            props: {
              editor: e,
              isActive: e.isActive("codeBlock"),
              icon: k(Df),
              title: D.global.t("editor.common.codeblock.title"),
              action: () => e.chain().focus().toggleCodeBlock().run(),
            },
          };
        },
        getCommandMenuItems() {
          return {
            priority: 80,
            icon: k(Df),
            title: "editor.common.codeblock.title",
            keywords: ["codeblock", "daimakuai"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setCodeBlock().run();
            },
          };
        },
        getToolboxItems({ editor: e }) {
          return [
            {
              priority: 50,
              component: k(gi),
              props: {
                editor: e,
                icon: k(Df),
                title: D.global.t("editor.common.codeblock.title"),
                action: () => {
                  e.chain().focus().setCodeBlock().run();
                },
              },
            },
          ];
        },
        getBubbleMenu() {
          return {
            pluginKey: "codeBlockBubbleMenu",
            shouldShow: ({ state: e }) => Jt(e, Al.name),
            getRenderContainer: (e) => F2(e),
            items: [
              {
                priority: 10,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: e }) => ls(Al.name, e),
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              return {
                el: F2(e),
              };
            },
          };
        },
      };
    },
    addProseMirrorPlugins() {
      var t;
      return [
        // Solve the paste problem. Because the upstream has not been
        // able to deal with this problem for a long time, it is
        // handled manually locally.
        // see: https://github.com/ueberdosis/tiptap/pull/3606
        new be({
          key: new ke("codeBlockVSCodeHandlerFixPaste"),
          props: {
            handlePaste: (e, n) => {
              if (!n.clipboardData || this.editor.isActive(this.type.name))
                return !1;
              const r = n.clipboardData.getData("text/plain"),
                o = n.clipboardData.getData("vscode-editor-data"),
                i = o ? JSON.parse(o) : void 0,
                s = i == null ? void 0 : i.mode;
              if (!r || !s) return !1;
              const { tr: a, schema: l } = e.state,
                u = l.text(
                  r.replace(
                    /\r\n?/g,
                    `
`
                  )
                );
              a.replaceSelectionWith(this.type.create({ language: s }, u));
              const { selection: c } = a;
              let d = Math.max(0, c.from - 1);
              for (
                ;
                d > 0 && a.doc.resolve(d).parent.type.name !== this.type.name;

              )
                d--;
              return (
                a.setSelection(q.near(a.doc.resolve(d))),
                a.setMeta("paste", !0),
                e.dispatch(a),
                !0
              );
            },
          },
        }),
        ...(((t = this.parent) == null ? void 0 : t.call(this)) || []),
      ];
    },
  });
function _$(t) {
  var e;
  const {
      char: n,
      allowSpaces: r,
      allowToIncludeChar: o,
      allowedPrefixes: i,
      startOfLine: s,
      $position: a,
    } = t,
    l = r && !o,
    u = WO(n),
    c = new RegExp(`\\s${u}$`),
    d = s ? "^" : "",
    f = o ? "" : u,
    p = l
      ? new RegExp(`${d}${u}.*?(?=\\s${f}|$)`, "gm")
      : new RegExp(`${d}(?:^)?${u}[^\\s${f}]*`, "gm"),
    h =
      ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) &&
      a.nodeBefore.text;
  if (!h) return null;
  const m = a.pos - h.length,
    g = Array.from(h.matchAll(p)).pop();
  if (!g || g.input === void 0 || g.index === void 0) return null;
  const b = g.input.slice(Math.max(0, g.index - 1), g.index),
    _ = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(b);
  if (i !== null && !_) return null;
  const v = m + g.index;
  let y = v + g[0].length;
  return (
    l && c.test(h.slice(y - 1, y + 1)) && ((g[0] += " "), (y += 1)),
    v < a.pos && y >= a.pos
      ? {
          range: {
            from: v,
            to: y,
          },
          query: g[0].slice(n.length),
          text: g[0],
        }
      : null
  );
}
const x$ = new ke("suggestion");
function k$({
  pluginKey: t = x$,
  editor: e,
  char: n = "@",
  allowSpaces: r = !1,
  allowToIncludeChar: o = !1,
  allowedPrefixes: i = [" "],
  startOfLine: s = !1,
  decorationTag: a = "span",
  decorationClass: l = "suggestion",
  command: u = () => null,
  items: c = () => [],
  render: d = () => ({}),
  allow: f = () => !0,
  findSuggestionMatch: p = _$,
}) {
  let h;
  const m = d == null ? void 0 : d(),
    g = new be({
      key: t,
      view() {
        return {
          update: async (b, _) => {
            var v, y, w, x, M, N, T;
            const P =
                (v = this.key) === null || v === void 0
                  ? void 0
                  : v.getState(_),
              z =
                (y = this.key) === null || y === void 0
                  ? void 0
                  : y.getState(b.state),
              H = P.active && z.active && P.range.from !== z.range.from,
              U = !P.active && z.active,
              re = P.active && !z.active,
              te = !U && !re && P.query !== z.query,
              Q = U || (H && te),
              ne = te || H,
              fe = re || (H && te);
            if (!Q && !ne && !fe) return;
            const Le = fe && !Q ? P : z,
              We = b.dom.querySelector(
                `[data-decoration-id="${Le.decorationId}"]`
              );
            (h = {
              editor: e,
              range: Le.range,
              query: Le.query,
              text: Le.text,
              items: [],
              command: (Ee) =>
                u({
                  editor: e,
                  range: Le.range,
                  props: Ee,
                }),
              decorationNode: We,
              // virtual node for popper.js or tippy.js
              // this can be used for building popups without a DOM node
              clientRect: We
                ? () => {
                    var Ee;
                    const { decorationId: ze } =
                        (Ee = this.key) === null || Ee === void 0
                          ? void 0
                          : Ee.getState(e.state),
                      Ge = b.dom.querySelector(`[data-decoration-id="${ze}"]`);
                    return (
                      (Ge == null ? void 0 : Ge.getBoundingClientRect()) || null
                    );
                  }
                : null,
            }),
              Q &&
                ((w = m == null ? void 0 : m.onBeforeStart) === null ||
                  w === void 0 ||
                  w.call(m, h)),
              ne &&
                ((x = m == null ? void 0 : m.onBeforeUpdate) === null ||
                  x === void 0 ||
                  x.call(m, h)),
              (ne || Q) &&
                (h.items = await c({
                  editor: e,
                  query: Le.query,
                })),
              fe &&
                ((M = m == null ? void 0 : m.onExit) === null ||
                  M === void 0 ||
                  M.call(m, h)),
              ne &&
                ((N = m == null ? void 0 : m.onUpdate) === null ||
                  N === void 0 ||
                  N.call(m, h)),
              Q &&
                ((T = m == null ? void 0 : m.onStart) === null ||
                  T === void 0 ||
                  T.call(m, h));
          },
          destroy: () => {
            var b;
            h &&
              ((b = m == null ? void 0 : m.onExit) === null ||
                b === void 0 ||
                b.call(m, h));
          },
        };
      },
      state: {
        // Initialize the plugin's internal state.
        init() {
          return {
            active: !1,
            range: {
              from: 0,
              to: 0,
            },
            query: null,
            text: null,
            composing: !1,
          };
        },
        // Apply changes to the plugin state from a view transaction.
        apply(b, _, v, y) {
          const { isEditable: w } = e,
            { composing: x } = e.view,
            { selection: M } = b,
            { empty: N, from: T } = M,
            P = { ..._ };
          if (((P.composing = x), w && (N || e.view.composing))) {
            (T < _.range.from || T > _.range.to) &&
              !x &&
              !_.composing &&
              (P.active = !1);
            const z = p({
                char: n,
                allowSpaces: r,
                allowToIncludeChar: o,
                allowedPrefixes: i,
                startOfLine: s,
                $position: M.$from,
              }),
              H = `id_${Math.floor(Math.random() * 4294967295)}`;
            z &&
            f({
              editor: e,
              state: y,
              range: z.range,
              isActive: _.active,
            })
              ? ((P.active = !0),
                (P.decorationId = _.decorationId ? _.decorationId : H),
                (P.range = z.range),
                (P.query = z.query),
                (P.text = z.text))
              : (P.active = !1);
          } else P.active = !1;
          return (
            P.active ||
              ((P.decorationId = null),
              (P.range = { from: 0, to: 0 }),
              (P.query = null),
              (P.text = null)),
            P
          );
        },
      },
      props: {
        // Call the keydown hook if suggestion is active.
        handleKeyDown(b, _) {
          var v;
          const { active: y, range: w } = g.getState(b.state);
          return (
            (y &&
              ((v = m == null ? void 0 : m.onKeyDown) === null || v === void 0
                ? void 0
                : v.call(m, { view: b, event: _, range: w }))) ||
            !1
          );
        },
        // Setup decorator on the currently active suggestion.
        decorations(b) {
          const { active: _, range: v, decorationId: y } = g.getState(b);
          return _
            ? ve.create(b.doc, [
                Ve.inline(v.from, v.to, {
                  nodeName: a,
                  class: l,
                  "data-decoration-id": y,
                }),
              ])
            : null;
        },
      },
    });
  return g;
}
const z2 = (t) => typeof t == "object" && t != null && t.nodeType === 1,
  V2 = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
  Nf = (t, e) => {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
      const n = getComputedStyle(t, null);
      return (
        V2(n.overflowY, e) ||
        V2(n.overflowX, e) ||
        ((r) => {
          const o = ((i) => {
            if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
            try {
              return i.ownerDocument.defaultView.frameElement;
            } catch {
              return null;
            }
          })(r);
          return (
            !!o &&
            (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth)
          );
        })(t)
      );
    }
    return !1;
  },
  Sl = (t, e, n, r, o, i, s, a) =>
    (i < t && s > e) || (i > t && s < e)
      ? 0
      : (i <= t && a <= n) || (s >= e && a >= n)
      ? i - t - r
      : (s > e && a < n) || (i < t && a > n)
      ? s - e + o
      : 0,
  w$ = (t) => {
    const e = t.parentElement;
    return e ?? (t.getRootNode().host || null);
  },
  U2 = (t, e) => {
    var n, r, o, i;
    if (typeof document > "u") return [];
    const {
        scrollMode: s,
        block: a,
        inline: l,
        boundary: u,
        skipOverflowHiddenElements: c,
      } = e,
      d = typeof u == "function" ? u : (H) => H !== u;
    if (!z2(t)) throw new TypeError("Invalid target");
    const f = document.scrollingElement || document.documentElement,
      p = [];
    let h = t;
    for (; z2(h) && d(h); ) {
      if (((h = w$(h)), h === f)) {
        p.push(h);
        break;
      }
      (h != null &&
        h === document.body &&
        Nf(h) &&
        !Nf(document.documentElement)) ||
        (h != null && Nf(h, c) && p.push(h));
    }
    const m =
        (r = (n = window.visualViewport) == null ? void 0 : n.width) != null
          ? r
          : innerWidth,
      g =
        (i = (o = window.visualViewport) == null ? void 0 : o.height) != null
          ? i
          : innerHeight,
      { scrollX: b, scrollY: _ } = window,
      {
        height: v,
        width: y,
        top: w,
        right: x,
        bottom: M,
        left: N,
      } = t.getBoundingClientRect();
    let T = a === "start" || a === "nearest" ? w : a === "end" ? M : w + v / 2,
      P = l === "center" ? N + y / 2 : l === "end" ? x : N;
    const z = [];
    for (let H = 0; H < p.length; H++) {
      const U = p[H],
        {
          height: re,
          width: te,
          top: Q,
          right: ne,
          bottom: fe,
          left: Le,
        } = U.getBoundingClientRect();
      if (
        s === "if-needed" &&
        w >= 0 &&
        N >= 0 &&
        M <= g &&
        x <= m &&
        w >= Q &&
        M <= fe &&
        N >= Le &&
        x <= ne
      )
        return z;
      const We = getComputedStyle(U),
        Ee = parseInt(We.borderLeftWidth, 10),
        ze = parseInt(We.borderTopWidth, 10),
        Ge = parseInt(We.borderRightWidth, 10),
        Qe = parseInt(We.borderBottomWidth, 10);
      let He = 0,
        qe = 0;
      const yt =
          "offsetWidth" in U ? U.offsetWidth - U.clientWidth - Ee - Ge : 0,
        nt =
          "offsetHeight" in U ? U.offsetHeight - U.clientHeight - ze - Qe : 0,
        Ct =
          "offsetWidth" in U
            ? U.offsetWidth === 0
              ? 0
              : te / U.offsetWidth
            : 0,
        ut =
          "offsetHeight" in U
            ? U.offsetHeight === 0
              ? 0
              : re / U.offsetHeight
            : 0;
      if (f === U)
        (He =
          a === "start"
            ? T
            : a === "end"
            ? T - g
            : a === "nearest"
            ? Sl(_, _ + g, g, ze, Qe, _ + T, _ + T + v, v)
            : T - g / 2),
          (qe =
            l === "start"
              ? P
              : l === "center"
              ? P - m / 2
              : l === "end"
              ? P - m
              : Sl(b, b + m, m, Ee, Ge, b + P, b + P + y, y)),
          (He = Math.max(0, He + _)),
          (qe = Math.max(0, qe + b));
      else {
        (He =
          a === "start"
            ? T - Q - ze
            : a === "end"
            ? T - fe + Qe + nt
            : a === "nearest"
            ? Sl(Q, fe, re, ze, Qe + nt, T, T + v, v)
            : T - (Q + re / 2) + nt / 2),
          (qe =
            l === "start"
              ? P - Le - Ee
              : l === "center"
              ? P - (Le + te / 2) + yt / 2
              : l === "end"
              ? P - ne + Ge + yt
              : Sl(Le, ne, te, Ee, Ge + yt, P, P + y, y));
        const { scrollLeft: nn, scrollTop: Rn } = U;
        (He = Math.max(
          0,
          Math.min(Rn + He / ut, U.scrollHeight - re / ut + nt)
        )),
          (qe = Math.max(
            0,
            Math.min(nn + qe / Ct, U.scrollWidth - te / Ct + yt)
          )),
          (T += Rn - He),
          (P += nn - qe);
      }
      z.push({ el: U, top: He, left: qe });
    }
    return z;
  },
  C$ = (t) =>
    t === !1
      ? { block: "end", inline: "nearest" }
      : ((e) => e === Object(e) && Object.keys(e).length !== 0)(t)
      ? t
      : { block: "start", inline: "nearest" };
function J3(t, e) {
  if (
    !t.isConnected ||
    !((o) => {
      let i = o;
      for (; i && i.parentNode; ) {
        if (i.parentNode === document) return !0;
        i =
          i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
      }
      return !1;
    })(t)
  )
    return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return {
      top: parseFloat(i.scrollMarginTop) || 0,
      right: parseFloat(i.scrollMarginRight) || 0,
      bottom: parseFloat(i.scrollMarginBottom) || 0,
      left: parseFloat(i.scrollMarginLeft) || 0,
    };
  })(t);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(e))
    return e.behavior(U2(t, e));
  const r = typeof e == "boolean" || e == null ? void 0 : e.behavior;
  for (const { el: o, top: i, left: s } of U2(t, C$(e))) {
    const a = i - n.top + n.bottom,
      l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
const A$ = { class: "command-items" },
  S$ = ["id", "onClick"],
  E$ = {
    class: "command-title group-hover:text-gray-900 group-hover:font-medium",
  },
  M$ = {
    key: 1,
    class: "command-empty",
  },
  T$ = /* @__PURE__ */ se({
    __name: "CommandsView",
    props: {
      items: {
        type: Array,
        required: !0,
      },
      command: {
        type: Function,
        required: !0,
      },
    },
    setup(t, { expose: e }) {
      const n = t,
        r = Te(0);
      jt(
        () => n.items,
        () => {
          r.value = 0;
        }
      );
      function o({ event: u }) {
        return u.key === "ArrowUp" || (u.key === "k" && u.ctrlKey)
          ? (i(), !0)
          : u.key === "ArrowDown" || (u.key === "j" && u.ctrlKey)
          ? (s(), !0)
          : u.key === "Enter"
          ? (a(), !0)
          : !1;
      }
      function i() {
        r.value = (r.value + n.items.length - 1) % n.items.length;
      }
      function s() {
        r.value = (r.value + 1) % n.items.length;
      }
      function a() {
        l(r.value);
      }
      function l(u) {
        const c = n.items[u];
        c && n.command(c);
      }
      return (
        jt(
          () => r.value,
          () => {
            const u = document.getElementById(`command-item-${r.value}`);
            u && J3(u, { behavior: "smooth", scrollMode: "if-needed" });
          }
        ),
        e({
          onKeyDown: o,
        }),
        (u, c) => (
          S(),
          O("div", A$, [
            t.items.length
              ? (S(!0),
                O(
                  gt,
                  { key: 0 },
                  Fr(
                    t.items,
                    (d, f) => (
                      S(),
                      O(
                        "div",
                        {
                          id: `command-item-${f}`,
                          key: f,
                          class: $e([
                            { "is-selected": f === r.value },
                            "command-item group hover:bg-gray-100",
                          ]),
                          onClick: (p) => l(f),
                        },
                        [
                          (S(),
                          de(wn(d.icon), {
                            class: "command-icon group-hover:!bg-white",
                          })),
                          C("span", E$, it(I(D).global.t(d.title)), 1),
                        ],
                        10,
                        S$
                      )
                    )
                  ),
                  128
                ))
              : (S(),
                O("div", M$, [
                  C(
                    "span",
                    null,
                    it(
                      I(D).global.t(
                        "editor.extensions.commands_menu.no_results"
                      )
                    ),
                    1
                  ),
                ])),
          ])
        )
      );
    },
  }),
  O$ = Ne.create({
    name: "commands-menu",
    addProseMirrorPlugins() {
      const t = D$(this.editor);
      return [
        k$({
          editor: this.editor,
          char: "/",
          // @ts-ignore
          command: ({ editor: e, range: n, props: r }) => {
            r.command({ editor: e, range: n });
          },
          items: ({ query: e }) =>
            t.filter((n) =>
              [...n.keywords, n.title].some((r) => r.includes(e))
            ),
          render: () => {
            let e, n;
            return {
              onStart: (r) => {
                (e = new m3(T$, {
                  props: r,
                  editor: r.editor,
                })),
                  r.clientRect &&
                    (n = Ro("body", {
                      getReferenceClientRect: r.clientRect,
                      appendTo: () => document.body,
                      content: e.element,
                      showOnCreate: !0,
                      interactive: !0,
                      trigger: "manual",
                      placement: "bottom-start",
                    }));
              },
              onUpdate(r) {
                e.updateProps(r),
                  r.clientRect &&
                    n[0].setProps({
                      getReferenceClientRect: r.clientRect,
                    });
              },
              onKeyDown(r) {
                var o;
                return r.event.key === "Escape"
                  ? (n[0].hide(), !0)
                  : (o = e.ref) == null
                  ? void 0
                  : o.onKeyDown(r);
              },
              onExit() {
                n[0].destroy(), e.destroy();
              },
            };
          },
        }),
      ];
    },
  });
function D$(t) {
  return (t == null ? void 0 : t.extensionManager).extensions
    .reduce((n, r) => {
      const { getCommandMenuItems: o } = r.options;
      if (!o) return n;
      const i = o();
      return Array.isArray(i) ? [...n, ...i] : [...n, i];
    }, [])
    .sort((n, r) => n.priority - r.priority);
}
const N$ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em",
};
function L$(t, e) {
  return (
    S(),
    O(
      "svg",
      N$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10.59 13.41c.41.39.41 1.03 0 1.42c-.39.39-1.03.39-1.42 0a5.003 5.003 0 0 1 0-7.07l3.54-3.54a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.53 3.53a2.98 2.98 0 0 0 0 4.24m2.82-4.24c.39-.39 1.03-.39 1.42 0a5.003 5.003 0 0 1 0 7.07l-3.54 3.54a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l3.53-3.53a2.98 2.98 0 0 0 0-4.24a.973.973 0 0 1 0-1.42",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const qa = k({ name: "mdi-link-variant", render: L$ }),
  R$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function I$(t, e) {
  return (
    S(),
    O(
      "svg",
      R$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5M18 12c0-3.33-2.67-6-6-6s-6 2.67-6 6s2.67 6 6 6s6-2.67 6-6m-3 0l-5 3V9",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Y3 = k({ name: "mdi-motion-play", render: I$ }),
  P$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function $$(t, e) {
  return (
    S(),
    O(
      "svg",
      P$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m10 16.5l6-4.5l-6-4.5M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const X3 = k({ name: "mdi-motion-play-outline", render: $$ }),
  B$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function H$(t, e) {
  return (
    S(),
    O(
      "svg",
      B$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16 9h-3v5.5a2.5 2.5 0 0 1-2.5 2.5A2.5 2.5 0 0 1 8 14.5a2.5 2.5 0 0 1 2.5-2.5c.57 0 1.08.19 1.5.5V7h4zm-4-7a10 10 0 0 1 10 10a10 10 0 0 1-10 10A10 10 0 0 1 2 12A10 10 0 0 1 12 2m0 2a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const j2 = k({ name: "mdi-music-circle-outline", render: H$ }),
  F$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function z$(t, e) {
  return (
    S(),
    O(
      "svg",
      F$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10 16.5v-9l6 4.5M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Z3 = k({ name: "mdi-play-circle", render: z$ }),
  V$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function U$(t, e) {
  return (
    S(),
    O(
      "svg",
      V$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M12 20c-4.41 0-8-3.59-8-8s3.59-8 8-8s8 3.59 8 8s-3.59 8-8 8m0-18A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2m-2 14.5l6-4.5l-6-4.5z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Q3 = k({ name: "mdi-play-circle-outline", render: U$ }),
  j$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function W$(t, e) {
  return (
    S(),
    O(
      "svg",
      j$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m21 12l-7-7v4C7 10 4 15 3 20c2.5-3.5 6-5.1 11-5.1V19z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Ka = k({ name: "mdi-share", render: W$ }),
  q$ = {
    class:
      "inline-block overflow-hidden transition-all text-center relative h-full w-full",
  },
  K$ = {
    key: 0,
    class: "p-1.5",
  },
  G$ = ["placeholder"],
  J$ = ["autoplay", "loop", "src"],
  Y$ = /* @__PURE__ */ se({
    __name: "AudioView",
    props: {
      decorations: {},
      selected: { type: Boolean },
      updateAttributes: { type: Function },
      deleteNode: { type: Function },
      node: {},
      view: {},
      getPos: { type: Function },
      innerDecorations: {},
      editor: {},
      extension: {},
      HTMLAttributes: {},
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            var a;
            return (a = e.node) == null ? void 0 : a.attrs.src;
          },
          set: (a) => {
            e.updateAttributes({ src: a });
          },
        }),
        r = ce(() => e.node.attrs.autoplay),
        o = ce(() => e.node.attrs.loop);
      function i() {
        e.editor.commands.setNodeSelection(e.getPos());
      }
      const s = Te();
      return (
        Wr(() => {
          n.value || s.value.focus();
        }),
        (a, l) => (
          S(),
          de(
            I(Ha),
            {
              as: "div",
              class: "inline-block w-full",
            },
            {
              default: me(() => [
                C("div", q$, [
                  n.value
                    ? (S(),
                      O(
                        "audio",
                        {
                          key: 1,
                          controls: "",
                          autoplay: r.value,
                          loop: o.value,
                          src: a.node.attrs.src,
                          onMouseenter: i,
                        },
                        null,
                        40,
                        J$
                      ))
                    : (S(),
                      O("div", K$, [
                        je(
                          C(
                            "input",
                            {
                              ref_key: "inputRef",
                              ref: s,
                              "onUpdate:modelValue":
                                l[0] || (l[0] = (u) => (n.value = u)),
                              class:
                                "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                              placeholder: I(D).global.t(
                                "editor.common.placeholder.link_input"
                              ),
                              tabindex: "-1",
                              onFocus: i,
                            },
                            null,
                            40,
                            G$
                          ),
                          [[Ot, n.value, void 0, { lazy: !0 }]]
                        ),
                      ])),
                ]),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  }),
  X$ = ["placeholder"],
  Z$ = /* @__PURE__ */ se({
    __name: "BubbleItemAudioLink",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            var r;
            return (r = e.editor.getAttributes(At.name)) == null
              ? void 0
              : r.src;
          },
          set: (r) => {
            e.editor
              .chain()
              .updateAttributes(At.name, { src: r })
              .setNodeSelection(e.editor.state.selection.from)
              .focus()
              .run();
          },
        });
      return (r, o) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
              placeholder: I(D).global.t(
                "editor.common.placeholder.link_input"
              ),
              class:
                "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
            },
            null,
            8,
            X$
          )),
          [[Ot, n.value, void 0, { lazy: !0 }]]
        );
    },
  }),
  At = Ze.create({
    name: "audio",
    fakeSelection: !0,
    inline() {
      return !0;
    },
    group() {
      return "inline";
    },
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        src: {
          default: null,
          parseHTML: (e) => e.getAttribute("src"),
        },
        autoplay: {
          default: null,
          parseHTML: (e) => e.getAttribute("autoplay"),
          renderHTML: (e) => ({
            autoplay: e.autoplay,
          }),
        },
        controls: {
          default: !0,
          parseHTML: (e) => e.getAttribute("controls"),
          renderHTML: (e) => ({
            controls: e.controls,
          }),
        },
        loop: {
          default: null,
          parseHTML: (e) => e.getAttribute("loop"),
          renderHTML: (e) => ({
            loop: e.loop,
          }),
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "audio",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["audio", ge(t)];
    },
    addCommands() {
      return {
        setAudio:
          (t) =>
          ({ commands: e }) =>
            e.insertContent({
              type: this.name,
              attrs: t,
            }),
      };
    },
    addInputRules() {
      return [
        Pa({
          find: /^\$audio\$$/,
          type: this.type,
          getAttributes: () => ({ width: "100%" }),
        }),
      ];
    },
    addNodeView() {
      return Fa(Y$);
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getCommandMenuItems() {
          return {
            priority: 110,
            icon: k(j2),
            title: "editor.extensions.commands_menu.audio",
            keywords: ["audio", "yinpin"],
            command: ({ editor: e, range: n }) => {
              e.chain()
                .focus()
                .deleteRange(n)
                .insertContent([
                  { type: "audio", attrs: { src: "" } },
                  { type: "paragraph", content: "" },
                ])
                .run();
            },
          };
        },
        getToolboxItems({ editor: e }) {
          return {
            priority: 20,
            component: k(gi),
            props: {
              editor: e,
              icon: k(j2),
              title: D.global.t("editor.extensions.commands_menu.audio"),
              action: () => {
                e.chain()
                  .focus()
                  .insertContent([{ type: "audio", attrs: { src: "" } }])
                  .run();
              },
            },
          };
        },
        getBubbleMenu({ editor: e }) {
          return {
            pluginKey: "audioBubbleMenu",
            shouldShow: ({ state: n }) => Jt(n, At.name),
            items: [
              {
                priority: 10,
                props: {
                  isActive: () => e.getAttributes(At.name).autoplay,
                  icon: k(e.getAttributes(At.name).autoplay ? Z3 : Q3),
                  action: () => {
                    e.chain()
                      .updateAttributes(At.name, {
                        autoplay: e.getAttributes(At.name).autoplay ? null : !0,
                      })
                      .setNodeSelection(e.state.selection.from)
                      .focus()
                      .run();
                  },
                  title: e.getAttributes(At.name).autoplay
                    ? D.global.t("editor.extensions.audio.disable_autoplay")
                    : D.global.t("editor.extensions.audio.enable_autoplay"),
                },
              },
              {
                priority: 20,
                props: {
                  isActive: () => e.getAttributes(At.name).loop,
                  icon: k(e.getAttributes(At.name).loop ? Y3 : X3),
                  action: () => {
                    e.chain()
                      .updateAttributes(At.name, {
                        loop: e.getAttributes(At.name).loop ? null : !0,
                      })
                      .setNodeSelection(e.state.selection.from)
                      .focus()
                      .run();
                  },
                  title: e.getAttributes(At.name).loop
                    ? D.global.t("editor.extensions.audio.disable_loop")
                    : D.global.t("editor.extensions.audio.enable_loop"),
                },
              },
              {
                priority: 30,
                component: k(ot),
              },
              {
                priority: 40,
                props: {
                  icon: k(qa),
                  title: D.global.t("editor.common.button.edit_link"),
                  action: () => k(Z$),
                },
              },
              {
                priority: 50,
                props: {
                  icon: k(Ka),
                  title: D.global.t("editor.common.tooltip.open_link"),
                  action: () => {
                    window.open(e.getAttributes(At.name).src, "_blank");
                  },
                },
              },
              {
                priority: 60,
                component: k(ot),
              },
              {
                priority: 70,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: n }) => {
                    ls(At.name, n);
                  },
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e }) {
              let n = e;
              for (; n && !n.hasAttribute("data-node-view-wrapper"); )
                n = n.parentElement;
              return {
                el: n,
              };
            },
          };
        },
      };
    },
  }),
  Q$ = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function eB(t, e) {
  return (
    S(),
    O(
      "svg",
      Q$,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "m16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.01 4.01 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53l-4.95-4.95z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const tB = k({ name: "mdi-eraser", render: eB }),
  nB = Ne.create({
    name: "clearFormat",
    addOptions() {
      return {
        getToolbarItems({ editor: t }) {
          return {
            priority: 23,
            component: k(Xe),
            props: {
              editor: t,
              isActive: !1,
              icon: k(tB),
              title: D.global.t("editor.common.clear_format"),
              action: () => t.chain().focus().unsetAllMarks().run(),
            },
          };
        },
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-\\": () => this.editor.chain().focus().unsetAllMarks().run(),
      };
    },
  }),
  N0 = Ze.create({
    name: "column",
    content: "block+",
    isolating: !0,
    fakeSelection: !0,
    addOptions() {
      return {
        HTMLAttributes: {
          class: "column",
        },
      };
    },
    addAttributes() {
      return {
        index: {
          default: 0,
          parseHTML: (t) => t.getAttribute("index"),
        },
        style: {
          default: "min-width: 0;flex: 1 1;box-sizing: border-box;",
          parseHTML: (t) => t.getAttribute("style"),
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "div[class=column]",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["div", ge(this.options.HTMLAttributes, t), 0];
    },
  }),
  rB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function oB(t, e) {
  return (
    S(),
    O(
      "svg",
      rB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M5 3c-1.11 0-2 .89-2 2v14c0 1.11.89 2 2 2h6V3m2 0v8h8V5c0-1.11-.89-2-2-2m-6 10v8h6c1.11 0 2-.89 2-2v-6",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const W2 = k({ name: "mdi-collage", render: oB }),
  iB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function sB(t, e) {
  return (
    S(),
    O(
      "svg",
      iB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M12 3a1 1 0 0 1 1 1v8a5 5 0 1 1 .213 8.152L13 20a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2H7v14h4zm8 10h-6v2h6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const aB = k({ name: "ri-delete-column", render: sB }),
  lB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function uB(t, e) {
  return (
    S(),
    O(
      "svg",
      lB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M20 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2h-4v14h4zM6 7a5 5 0 1 1 0 10A5 5 0 0 1 6 7m1 2H5v1.999L3 11v2l2-.001V15h2v-2.001L9 13v-2l-2-.001z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const cB = k({ name: "ri-insert-column-left", render: uB }),
  dB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function fB(t, e) {
  return (
    S(),
    O(
      "svg",
      dB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM9 5H5v14h4zm9 2a5 5 0 1 1 0 10a5 5 0 0 1 0-10m1 2h-2v1.999L15 11v2l2-.001V15h2v-2.001L21 13v-2l-2-.001z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const pB = k({ name: "ri-insert-column-right", render: fB }),
  hB = (t, e) => {
    const n = mB(t),
      r = [];
    for (let o = 0; o < e; o += 1) {
      const i = n.column.createAndFill({ index: o });
      i && r.push(i);
    }
    return n.columns.createChecked({ cols: e }, r);
  },
  mB = (t) => {
    if (t.cached.columnsNodeTypes) return t.cached.columnsNodeTypes;
    const e = {
      columns: t.nodes.columns,
      column: t.nodes.column,
    };
    return (t.cached.columnsNodeTypes = e), e;
  },
  Lf = (t, e, n) => {
    const r = On((i) => i.type.name === _a.name)(e.selection),
      o = On((i) => i.type.name === N0.name)(e.selection);
    if (t && r && o) {
      const i = r.node,
        s = o.node.attrs.index,
        a = i.toJSON();
      let l = s;
      n === "delete"
        ? ((l = s - 1), a.content.splice(s, 1))
        : ((l = n === "addBefore" ? s : s + 1),
          a.content.splice(l, 0, {
            type: "column",
            attrs: {
              index: s,
            },
            content: [
              {
                type: "paragraph",
              },
            ],
          })),
        (a.attrs.cols = a.content.length),
        a.content.forEach((f, p) => {
          f.attrs.index = p;
        });
      const u = qn.fromJSON(e.schema, a);
      let c = r.pos;
      u.content.forEach((f, p, h) => {
        h < l && (c += f.nodeSize);
      });
      const d = e.tr.setTime(Date.now());
      d
        .replaceWith(r.pos, r.pos + r.node.nodeSize, u)
        .setSelection(q.near(d.doc.resolve(c))),
        t(d);
    }
    return !0;
  },
  q2 = (t, e, n) => {
    const r = On((i) => i.type.name === _a.name)(t.selection),
      o = On((i) => i.type.name === N0.name)(t.selection);
    if (e && r && o) {
      const i = r.node,
        s = o.node.attrs.index;
      let a = 0;
      n === "before"
        ? (a = (s - 1 + i.attrs.cols) % i.attrs.cols)
        : (a = (s + 1) % i.attrs.cols);
      let l = r.pos;
      i.content.forEach((c, d, f) => {
        f < a && (l += c.nodeSize);
      });
      const u = t.tr.setTime(Date.now());
      return u.setSelection(q.near(u.doc.resolve(l))), e(u), !0;
    }
    return !1;
  },
  _a = Ze.create({
    name: "columns",
    group: "block",
    priority: 10,
    defining: !0,
    isolating: !0,
    allowGapCursor: !0,
    content: "column{1,}",
    fakeSelection: !1,
    addOptions() {
      return {
        HTMLAttributes: {
          class: "columns",
        },
        getToolboxItems({ editor: t }) {
          return [
            {
              priority: 50,
              component: k(gi),
              props: {
                editor: t,
                icon: k(W2),
                title: D.global.t("editor.extensions.commands_menu.columns"),
                action: () => {
                  t.chain()
                    .focus()
                    .insertColumns({
                      cols: 2,
                    })
                    .run();
                },
              },
            },
          ];
        },
        getCommandMenuItems() {
          return {
            priority: 70,
            icon: k(W2),
            title: "editor.extensions.commands_menu.columns",
            keywords: ["fenlan", "columns"],
            command: ({ editor: t, range: e }) => {
              t.chain()
                .focus()
                .deleteRange(e)
                .insertColumns({
                  cols: 2,
                })
                .run();
            },
          };
        },
        getBubbleMenu() {
          return {
            pluginKey: "columnsBubbleMenu",
            shouldShow: ({ state: t }) => Jt(t, _a.name),
            getRenderContainer: (t) => {
              let e = t;
              for (
                e.nodeName === "#text" && (e = t.parentElement);
                e && e.classList && !e.classList.contains("column");

              )
                e = e.parentElement;
              return e;
            },
            items: [
              {
                priority: 10,
                props: {
                  icon: k(cB),
                  title: D.global.t(
                    "editor.extensions.columns.add_column_before"
                  ),
                  action: ({ editor: t }) => {
                    t.chain().focus().addColBefore().run();
                  },
                },
              },
              {
                priority: 20,
                props: {
                  icon: k(pB),
                  title: D.global.t(
                    "editor.extensions.columns.add_column_after"
                  ),
                  action: ({ editor: t }) => {
                    t.chain().focus().addColAfter().run();
                  },
                },
              },
              {
                priority: 30,
                props: {
                  icon: k(aB),
                  title: D.global.t("editor.extensions.columns.delete_column"),
                  action: ({ editor: t }) => {
                    t.chain().focus().deleteCol().run();
                  },
                },
              },
              {
                priority: 40,
                component: k(ot),
              },
              {
                priority: 50,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: t }) => {
                    ls(_a.name, t);
                  },
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: t }) {
              let e = t;
              for (; e && !e.classList.contains("columns"); )
                e = e.parentElement;
              return {
                el: e,
                dragDomOffset: {
                  y: -5,
                },
              };
            },
            allowPropagationDownward: !0,
          };
        },
      };
    },
    addAttributes() {
      return {
        cols: {
          default: 2,
          parseHTML: (t) => t.getAttribute("cols"),
        },
        style: {
          default: "display: flex;width: 100%;gap: 1em;",
          parseHTML: (t) => t.getAttribute("style"),
        },
      };
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["div", ge(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        insertColumns:
          (t) =>
          ({ tr: e, dispatch: n, editor: r }) => {
            const o = hB(r.schema, (t && t.cols) || 3);
            if (n) {
              const i = e.selection.anchor + 1;
              e.replaceSelectionWith(o)
                .scrollIntoView()
                .setSelection(q.near(e.doc.resolve(i)));
            }
            return !0;
          },
        addColBefore:
          () =>
          ({ dispatch: t, state: e }) =>
            Lf(t, e, "addBefore"),
        addColAfter:
          () =>
          ({ dispatch: t, state: e }) =>
            Lf(t, e, "addAfter"),
        deleteCol:
          () =>
          ({ dispatch: t, state: e }) =>
            Lf(t, e, "delete"),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-G": () => this.editor.commands.insertColumns(),
        Tab: () => q2(this.editor.state, this.editor.view.dispatch, "after"),
        "Shift-Tab": () =>
          q2(this.editor.state, this.editor.view.dispatch, "before"),
      };
    },
  });
let gn,
  ye = null,
  on,
  rt = null,
  oi = null,
  Jl,
  xa = !1,
  Ga = !1;
const gB = () => {
    const t = document.createElement("div");
    return (
      t.classList.add("draggable"),
      (t.draggable = !0),
      t.setAttribute("data-drag-handle", "true"),
      t
    );
  },
  ex = () => {
    var t, e;
    (t = ye == null ? void 0 : ye.classList) == null || t.add("show"),
      (e = ye == null ? void 0 : ye.classList) == null || e.remove("hide");
  },
  _s = () => {
    var t, e, n;
    (t = ye == null ? void 0 : ye.classList) == null || t.remove("show"),
      (e = ye == null ? void 0 : ye.classList) == null || e.remove("active"),
      (n = ye == null ? void 0 : ye.classList) == null || n.add("hide");
  },
  bB = (t, e) => {
    const n = t.dom.parentElement;
    if (!n || !ye) return;
    const r = e == null ? void 0 : e.el;
    if (!r) return;
    const o = r.getBoundingClientRect(),
      i = n.getBoundingClientRect(),
      s = ye.getBoundingClientRect(),
      a = o.left - i.left - s.width - 5 + e.domOffsetLeft,
      l = o.top - i.top + s.height / 2 + n.scrollTop + e.domOffsetTop;
    (ye.style.left = `${a}px`), (ye.style.top = `${l - 2}px`), ex();
  },
  K2 = () => {
    rt && ((Ga = !0), on.dispatch(on.state.tr), clearTimeout(Jl), ex());
  },
  G2 = () => {
    rt && ((Ga = !1), on.dispatch(on.state.tr), _s());
  },
  J2 = () => {
    if (!rt) return null;
    if (((Ga = !1), on.dispatch(on.state.tr), Z.isSelectable(rt.node))) {
      const t = Z.create(on.state.doc, rt.$pos.pos - rt.offset);
      return on.dispatch(on.state.tr.setSelection(t)), on.focus(), (oi = t), t;
    }
    return null;
  },
  Y2 = () => {
    xa && ((xa = !1), (oi = null), (rt = null));
  },
  X2 = (t) => {
    if (((xa = !0), (Ga = !1), t.dataTransfer && rt && oi)) {
      const e = oi.content();
      t.dataTransfer.effectAllowed = "move";
      const { dom: n, text: r } = hA(on, e);
      t.dataTransfer.clearData(),
        t.dataTransfer.setData("text/html", n.innerHTML),
        t.dataTransfer.setData("text/plain", r),
        t.dataTransfer.setDragImage(rt == null ? void 0 : rt.el, 0, 0),
        (on.dragging = {
          slice: e,
          move: !0,
        });
    }
  },
  yB = (t, e, n) => {
    const { node: r } = t.domAtPos(n.pos);
    let o = r,
      i = o.parentElement;
    for (; i && i !== e && n.pos === t.posAtDOM(i, 0); )
      (o = i), (i = i.parentElement);
    return o;
  },
  tx = (t, e) => {
    const n = t.posAtDOM(e, 0);
    return n < 0 ? null : t.state.doc.resolve(n);
  },
  nx = (t, e) => {
    const n = e.dom.parentElement;
    if (!n) return null;
    const r = tx(e, t);
    if (!r) return null;
    const o = r.node(),
      i = yB(e, n, r);
    return {
      node: o,
      $pos: r,
      el: i,
      offset: 1,
      domOffsetLeft: 0,
      domOffsetTop: 0,
    };
  },
  vB = (t, e) => {
    var o, i;
    const n = t.extensionManager.extensions.find((s) => s.name === e.type.name);
    return n
      ? (i = (o = n.options).getDraggable) == null
        ? void 0
        : i.call(o, {
            editor: t,
          })
      : void 0;
  },
  rx = (t, e, n) => {
    var i, s, a;
    const r =
        (i = e == null ? void 0 : e.getRenderContainer) == null
          ? void 0
          : i.call(e, { dom: n, view: t }),
      o = nx((r == null ? void 0 : r.el) || n, t);
    return {
      el: (r == null ? void 0 : r.el) || n,
      node: (r == null ? void 0 : r.node) || (o == null ? void 0 : o.node),
      $pos: (r == null ? void 0 : r.$pos) || (o == null ? void 0 : o.$pos),
      offset:
        (r == null ? void 0 : r.nodeOffset) || (o == null ? void 0 : o.offset),
      domOffsetLeft:
        ((s = r == null ? void 0 : r.dragDomOffset) == null ? void 0 : s.x) ||
        0,
      domOffsetTop:
        ((a = r == null ? void 0 : r.dragDomOffset) == null ? void 0 : a.y) ||
        0,
    };
  },
  _B = (t, e, n = 1) => {
    const r = tx(t, e);
    if (!r) return;
    if (n > r.depth) {
      if (n - r.depth == 1) {
        const i = r.node();
        if (i.firstChild && !i.firstChild.type.isBlock) return i.firstChild;
      }
      return;
    }
    const o = r.node(n);
    if (o) return o;
  },
  oh = ({ editor: t, view: e, dom: n, event: r, depth: o = 1 }) => {
    const i = _B(e, n, o);
    if (!i) return;
    const s = vB(t, i);
    if (s) {
      if (typeof s == "boolean") return s;
      const a = rx(e, s, n),
        l = { left: r.clientX, top: r.clientY },
        u = e.posAtCoords(l);
      if (
        u &&
        (u.inside == -1 ||
          !(u.inside >= a.$pos.start() && u.inside <= a.$pos.end()))
      )
        return s;
      if (s.allowPropagationDownward) {
        const c = oh({
          editor: t,
          view: e,
          dom: n,
          event: r,
          depth: ++o,
        });
        if (c) return c;
      }
      return s;
    }
    return oh({
      editor: t,
      view: e,
      dom: n,
      event: r,
      depth: ++o,
    });
  },
  xB = (t, e, n) => {
    var i, s;
    const r = t.resolve(e);
    if (!n.content.size) return e;
    let o = n.content;
    for (let a = 0; a < n.openStart; a++)
      o = (i = o == null ? void 0 : o.firstChild) == null ? void 0 : i.content;
    for (let a = 1; a <= (n.openStart == 0 && n.size ? 2 : 1); a++)
      for (let l = r.depth; l >= 0; l--) {
        const u =
            l == r.depth
              ? 0
              : r.pos <= (r.start(l + 1) + r.end(l + 1)) / 2
              ? -1
              : 1,
          c = r.index(l) + (u > 0 ? 1 : 0),
          d = r.node(l);
        let f = !1;
        if (a == 1) f = d.canReplace(c, c, o);
        else {
          const p = d
            .contentMatchAt(c)
            .findWrapping(
              (s = o == null ? void 0 : o.firstChild) == null ? void 0 : s.type
            );
          f = (p && d.canReplaceWith(c, c, p[0])) || !1;
        }
        if (f) return u == 0 ? r.pos : u < 0 ? r.before(l + 1) : r.after(l + 1);
      }
    return null;
  },
  uU = Ne.create({
    name: "draggable",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("node-draggable"),
          view: (t) => {
            (ye = gB()),
              ye.addEventListener("mouseenter", K2),
              ye.addEventListener("mouseleave", G2),
              ye.addEventListener("mousedown", J2),
              ye.addEventListener("mouseup", Y2),
              ye.addEventListener("dragstart", X2);
            const e = t.dom.parentNode;
            return (
              e.appendChild(ye),
              (e.style.position = "relative"),
              {
                update: (n) => {
                  on = n;
                },
                destroy: () => {
                  ye &&
                    (clearTimeout(Jl),
                    ye.removeEventListener("mouseenter", K2),
                    ye.removeEventListener("mouseleave", G2),
                    ye.removeEventListener("mousedown", J2),
                    ye.removeEventListener("mouseup", Y2),
                    ye.removeEventListener("dragstart", X2),
                    ye.remove());
                },
              }
            );
          },
          props: {
            handleDOMEvents: {
              // @ts-ignore
              mousemove: (t, e) => {
                var l;
                const n = { left: e.clientX, top: e.clientY },
                  r = t.posAtCoords(n);
                if (!r || !r.pos) return !1;
                const o = r.inside > -1 ? r.inside : r.pos,
                  i =
                    t.nodeDOM(o) ||
                    ((l = t.domAtPos(o)) == null ? void 0 : l.node) ||
                    e.target;
                if (!i) return _s(), !1;
                let s = i;
                for (; s && s.nodeType === 3; ) s = s.parentElement;
                if (!(s instanceof HTMLElement)) return _s(), !1;
                const a = this.editor;
                if (
                  ((gn = oh({
                    // @ts-ignore
                    editor: a,
                    view: t,
                    dom: s,
                    event: e,
                  })),
                  !gn)
                )
                  return !1;
                if (
                  (typeof gn == "boolean"
                    ? (rt = nx(s, t))
                    : (rt = rx(t, gn, s)),
                  !!rt)
                )
                  return bB(t, rt), !1;
              },
              mouseleave: () => (
                clearTimeout(Jl),
                (Jl = setTimeout(() => {
                  _s();
                }, 400)),
                !1
              ),
            },
            handleKeyDown() {
              return ye && ((gn = void 0), _s()), !1;
            },
            handleDrop: (t, e, n) => {
              var a;
              if (!ye || !oi) return !1;
              const r = t.posAtCoords({
                left: e.clientX,
                top: e.clientY,
              });
              if (!r) return !0;
              const o = t.state.doc.resolve(r.pos),
                i = xB(t.state.doc, o.pos, n);
              if (!i) return !1;
              let s = !1;
              if (xa && typeof gn != "boolean") {
                const l =
                  (a = gn == null ? void 0 : gn.handleDrop) == null
                    ? void 0
                    : a.call(gn, {
                        view: t,
                        event: e,
                        slice: n,
                        insertPos: i,
                        node: rt == null ? void 0 : rt.node,
                        selection: oi,
                      });
                typeof l == "boolean" && (s = l);
              }
              return (xa = !1), (gn = void 0), (oi = null), (rt = null), s;
            },
            decorations: (t) => {
              if (!Ga || !rt) return ve.empty;
              const { $pos: e } = rt;
              return ve.create(t.doc, [
                Ve.node(e.before(), e.after(), {
                  class: "has-draggable-handle",
                }),
              ]);
            },
          },
        }),
      ];
    },
  }),
  kB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function wB(t, e) {
  return (
    S(),
    O(
      "svg",
      kB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M8 3C5.79 3 4 4.79 4 7v7c0 1.1.9 2 2 2h3v4c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2v-4h3c1.1 0 2-.9 2-2V3zm0 2h4v2h2V5h1v4h2V5h1v5H6V7c0-1.1.9-2 2-2m-2 9v-2h12v2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const CB = k({ name: "mdi-brush-variant", render: wB }),
  AB = (t) => {
    const e = [],
      { doc: n, selection: r } = t,
      { from: o, to: i, empty: s } = r;
    if (s) return e;
    let a = !1;
    return (
      n.nodesBetween(o, i, (l, u) => {
        if (
          !(!l || (l == null ? void 0 : l.nodeSize) === void 0) &&
          l.isText &&
          !a
        )
          return (
            (a = !0),
            e.push(
              ...l.marks.map((c) => ({
                from: u,
                to: u + l.nodeSize,
                mark: c,
              }))
            ),
            !1
          );
      }),
      e
    );
  },
  SB = (t, e, n) => {
    const { selection: r } = t,
      o = n || t.tr,
      { from: i, to: s } = r;
    return (
      r instanceof De
        ? r.ranges.forEach((a) => {
            const l = {
              from: a.$from.pos,
              to: a.$to.pos,
            };
            Z2(o, t, l, e);
          })
        : Z2(
            o,
            t,
            {
              from: i,
              to: s,
            },
            e
          ),
      o
    );
  },
  Z2 = (t, e, n, r) => {
    const { from: o, to: i } = n;
    e.doc.nodesBetween(o, i, (s, a) => {
      if (!(!s || (s == null ? void 0 : s.nodeSize) === void 0)) {
        if (s.isText) {
          const l = {
            from: Math.max(a, o),
            to: Math.min(a + s.nodeSize, i),
          };
          s.marks.forEach((u) => {
            t.step(new Un(l.from, l.to, u));
          }),
            r.forEach((u) => {
              t.step(new Pr(l.from, l.to, u.mark));
            });
        }
        return !0;
      }
    });
  },
  EB = Ne.create({
    name: "formatBrush",
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolbarItems({ editor: e }) {
          const n = e.view.dom.classList.contains("format-brush-mode");
          return {
            priority: 25,
            component: k(Xe),
            props: {
              editor: e,
              isActive: n,
              icon: k(CB),
              title: n
                ? D.global.t(
                    "editor.extensions.format_brush.toolbar_item.cancel"
                  )
                : D.global.t(
                    "editor.extensions.format_brush.toolbar_item.title"
                  ),
              action: () => {
                n
                  ? e.commands.pasteFormatBrush()
                  : e.commands.copyFormatBrush();
              },
            },
          };
        },
      };
    },
    addCommands() {
      return {
        copyFormatBrush:
          () =>
          ({ state: t }) => {
            const e = AB(t);
            return (
              (this.storage.formatBrushMarks = e),
              (this.storage.formatBrush = !0),
              this.editor.view.dom.classList.add("format-brush-mode"),
              !0
            );
          },
        pasteFormatBrush: () => () => (
          (this.storage.formatBrushMarks = []),
          (this.storage.formatBrush = !1),
          this.editor.view.dom.classList.remove("format-brush-mode"),
          !0
        ),
      };
    },
    addStorage() {
      return {
        formatBrush: !1,
        formatBrushMarks: [],
      };
    },
    addProseMirrorPlugins() {
      const t = this.storage,
        e = this.editor;
      return [
        new be({
          key: new ke("formatBrushPlugin"),
          props: {
            handleDOMEvents: {
              mouseup(n) {
                t.formatBrush &&
                  e
                    .chain()
                    .command(
                      ({ tr: r }) => (SB(n.state, t.formatBrushMarks, r), !0)
                    )
                    .pasteFormatBrush()
                    .run();
              },
            },
          },
        }),
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Shift-Mod-c": () => (this.editor.commands.copyFormatBrush(), !0),
      };
    },
  });
class Fe extends ee {
  constructor(n) {
    super(n, n);
    ue(this, "start", !1);
    this.start = OB(n);
  }
  map(n, r) {
    const o = n.resolve(r.map(this.head));
    return Fe.valid(o) ? new Fe(o) : ee.near(o);
  }
  content() {
    return W.empty;
  }
  eq(n) {
    return n instanceof Fe && n.head == this.head;
  }
  toJSON() {
    return { type: "node-gap-cursor", pos: this.head };
  }
  get isStart() {
    return this.start;
  }
  static fromJSON(n, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for GapCursorSelection.fromJSON");
    return new Fe(n.resolve(r.pos));
  }
  getBookmark() {
    return new L0(this.anchor);
  }
  /**
   * Validates if a GapCursor can be placed at the given position
   *
   * This function checks whether a GapCursor can be placed at the specified position in the document.
   * It ensures that the position is not within a text block, and that the node at the position allows a GapCursor.
   *
   * @param {ResolvedPos} $pos - The resolved position in the document to validate.
   * @returns {boolean} - Returns true if a GapCursor can be placed at the given position, false otherwise.
   */
  static valid(n) {
    if (n.depth < 1) return !1;
    const o = n.doc.childBefore(n.pos).node;
    return !o ||
      n.parent.isTextblock ||
      (!MB(n) && !TB(n)) ||
      !o.type.spec.allowGapCursor
      ? !1
      : !o.type.inlineContent;
  }
  static findGapCursorFrom(n, r, o = !1) {
    let i = !0;
    for (; i; ) {
      if (!o && Fe.valid(n)) return n;
      let s = n.pos,
        a = null;
      for (let l = n.depth; l >= 0; l--) {
        const u = n.node(l),
          c = r > 0 ? n.indexAfter(l) : n.index(l) - 1;
        if (r > 0 ? c < u.childCount : c >= 0) {
          a = u.child(c);
          break;
        }
        if (l == 0) return null;
        s += r;
        const d = n.doc.resolve(s);
        if (Fe.valid(d)) return d;
      }
      for (; a; ) {
        const l = r > 0 ? a.firstChild : a.lastChild;
        if (!l) {
          if (a.isAtom && !a.isText && !Z.isSelectable(a)) {
            (n = n.doc.resolve(s + a.nodeSize * r)), (o = !1);
            break;
          }
          i = !1;
          break;
        }
        (a = l), (s += r);
        const u = n.doc.resolve(s);
        if (Fe.valid(u)) return u;
      }
      a || (i = !1);
    }
    return null;
  }
}
Fe.prototype.visible = !1;
Fe.findFrom = Fe.findGapCursorFrom;
ee.jsonID("node-gap-cursor", Fe);
class L0 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new L0(e.map(this.pos));
  }
  resolve(e) {
    const n = e.resolve(this.pos);
    return Fe.valid(n) ? new Fe(n) : ee.near(n);
  }
}
function MB(t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.index(e),
      r = t.node(e);
    if (n === 0) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    if (ox(r.child(n - 1), !1)) return !0;
  }
  return !0;
}
function TB(t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.indexAfter(e),
      r = t.node(e);
    if (n === r.childCount) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    if (ox(r.child(n), !0)) return !0;
  }
  return !0;
}
function ox(t, e) {
  for (; t; ) {
    if (
      (t.childCount === 0 && !t.inlineContent) ||
      t.isAtom ||
      t.type.spec.isolating
    )
      return !0;
    if (t.inlineContent) return !1;
    t = e ? t.firstChild : t.lastChild;
  }
  return !1;
}
function OB(t) {
  if (t.depth < 1) return null;
  const e = t.start(1),
    n = t.end(1);
  return t.pos < e + (n - e) / 2;
}
const DB = Ne.create({
  priority: 9999,
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      new be({
        key: new ke("custom-gap-cursor"),
        props: {
          decorations: RB,
          // If a GapCursor can be created at the current position, use GapCursor instead of other selection types
          createSelectionBetween(t, e, n) {
            return e.pos == n.pos && Fe.valid(n) ? new Fe(n) : null;
          },
          handleClick(t, e, n) {
            if (!t || !t.editable) return !1;
            const r = t.posAtCoords({
              left: n.clientX,
              top: n.clientY,
            });
            if (r && r.inside > -1) return !1;
            const o = t.state.doc.resolve(e);
            return Fe.valid(o)
              ? (t.dispatch(t.state.tr.setSelection(new Fe(o))), !0)
              : !1;
          },
          handleKeyDown: Gc({
            ArrowLeft: El("horiz", -1),
            ArrowRight: El("horiz", 1),
            ArrowUp: El("vert", -1),
            ArrowDown: El("vert", 1),
            Enter: (t, e) => {
              const n = Ml(t, !1);
              return n && e ? (e(n), !0) : !1;
            },
            Backspace: (t, e) => {
              const { selection: n, tr: r } = t;
              if (
                Jt(t, "paragraph") &&
                k3(t.selection.$from.parent) &&
                n instanceof q &&
                n.empty
              ) {
                const { $from: u } = n;
                return ba(u)(r), e && ix(-1, "left", t)(r) ? (e(r), !0) : !1;
              }
              if (!(n instanceof Fe) || !e) return !1;
              const { isStart: o, $from: i } = n,
                s = t.doc.childBefore(i.pos),
                a = s.index,
                l = t.doc.resolve(0).posAtIndex(a);
              return o
                ? NB(l, t, e)
                : s.node && ba(t.doc.resolve(l))(r)
                ? (e(r), !0)
                : !1;
            },
            Tab: (t, e) => {
              const n = Ml(t);
              return n && e ? (e(n), !0) : !1;
            },
          }),
          handleTextInput(t) {
            const { state: e, dispatch: n } = t,
              r = Ml(e);
            return r && n && n(r), !1;
          },
          handleDOMEvents: {
            /**
             * Solve the issue of inserting text during composition input events, e.g., Chinese input
             */
            beforeinput: (t, e) => {
              const { state: n, dispatch: r } = t;
              if (
                e.inputType != "insertCompositionText" ||
                !(n.selection instanceof Fe)
              )
                return !1;
              const o = Ml(n);
              return o && r && r(o), !1;
            },
          },
        },
      }),
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage,
    };
    return {
      allowGapCursor: le(K(t, "allowGapCursor", e)) ?? null,
    };
  },
});
function NB(t, e, n) {
  const { tr: r } = e;
  if (t == 0) return !1;
  const o = e.doc.resolve(t - 1),
    i = o.parent;
  return i.inlineContent || i.isTextblock
    ? LB(o, e, n)
    : Fe.valid(o) && n
    ? (n(r.setSelection(new Fe(o))), !0)
    : ba(o)(r) && n
    ? (n(r), !0)
    : !1;
}
function LB(t, e, n) {
  return t.parentOffset == 0 && t.pos > 1 && n
    ? (n(e.tr.delete(t.pos - 1, t.pos)), !0)
    : (n && n(e.tr.setSelection(q.create(e.doc, t.pos))), !0);
}
function El(t, e) {
  const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
  return (r, o, i) => {
    const { tr: s } = r;
    return ix(e, n, r, i)(s) && o ? (o(s), !0) : !1;
  };
}
const ix = (t, e, n, r) => (o) => {
  const i = n.selection;
  let s = t > 0 ? i.$to : i.$from,
    a = i.empty;
  if (i instanceof q) {
    if (s.depth == 0 || (r && !r.endOfTextblock(e))) return;
    if (
      ((a = !1),
      (s = n.doc.resolve(t > 0 ? s.after() : s.before())),
      s.depth > 0)
    ) {
      const u = s.pos,
        c = s.start(1) + 1,
        d = s.end(1) - 1;
      if (u != c && u != d) return;
    }
  }
  if (i instanceof Fe) return;
  const l = Fe.findGapCursorFrom(s, t, a);
  if (l) return o.setSelection(new Fe(l)), l;
};
function Ml(t, e = !0) {
  const { tr: n } = t;
  if (!(t.selection instanceof Fe)) return;
  const { isStart: r, $from: o } = t.selection;
  if (t.selection instanceof $t || o.parent.inlineContent) return;
  const i = t.doc.resolve(0),
    s = t.doc.childBefore(o.pos),
    a = r ? s.index : s.index + 1,
    l = i.posAtIndex(a);
  return (
    n.insert(l, t.schema.nodes.paragraph.create()),
    (e || !r) && (n.setSelection(q.create(n.doc, l + 1)), n.scrollIntoView()),
    n
  );
}
function RB(t) {
  if (!(t.selection instanceof Fe)) return null;
  const e = t.selection.$head;
  if (e.depth < 1) return null;
  const n = e.node(1),
    r = e.start(1) - 1,
    o = t.selection.isStart;
  return ve.create(t.doc, [
    Ve.node(r, r + n.nodeSize, {
      key: "node-gap-cursor",
      class: `card-gap-cursor ${o ? "start" : "end"}-card-gap-cursor`,
    }),
  ]);
}
const IB = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g,
  PB =
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
function rc(t) {
  return !t || t.replace(IB, "").match(PB);
}
const $B = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em",
};
function BB(t, e) {
  return (
    S(),
    O(
      "svg",
      $B,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3 21V3h18v18zM5 5v14h14V5z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const HB = k({ name: "mdi-border-all-variant", render: BB }),
  FB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function zB(t, e) {
  return (
    S(),
    O(
      "svg",
      FB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M15 5h2V3h-2m0 18h2v-2h-2M11 5h2V3h-2m8 2h2V3h-2m0 6h2V7h-2m0 14h2v-2h-2m0-6h2v-2h-2m0 6h2v-2h-2M3 5h2V3H3m0 6h2V7H3m0 6h2v-2H3m0 6h2v-2H3m0 6h2v-2H3m8 2h2v-2h-2m-4 2h2v-2H7M7 5h2V3H7z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const VB = k({ name: "mdi-border-none-variant", render: zB }),
  UB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function jB(t, e) {
  return (
    S(),
    O(
      "svg",
      UB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              d: "M16 18H7V4h9m-4.5 18a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m4-21h-8A2.5 2.5 0 0 0 5 3.5v17A2.5 2.5 0 0 0 7.5 23h8a2.5 2.5 0 0 0 2.5-2.5v-17A2.5 2.5 0 0 0 15.5 1z",
              fill: "currentColor",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const WB = k({ name: "mdi-cellphone-iphone", render: jB }),
  qB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function KB(t, e) {
  return (
    S(),
    O(
      "svg",
      qB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M21 14H3V4h18m0-2H3c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h7l-2 3v1h8v-1l-2-3h7a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2Z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const GB = k({ name: "mdi-desktop-mac", render: KB }),
  JB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function YB(t, e) {
  return (
    S(),
    O(
      "svg",
      JB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              d: "M19 19H4V3h15m-7.5 20a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m7-23h-14A2.5 2.5 0 0 0 2 2.5v19A2.5 2.5 0 0 0 4.5 24h14a2.5 2.5 0 0 0 2.5-2.5v-19A2.5 2.5 0 0 0 18.5 0z",
              fill: "currentColor",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Q2 = k({ name: "mdi-tablet-ipad", render: YB }),
  XB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function ZB(t, e) {
  return (
    S(),
    O(
      "svg",
      XB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2m-5.15 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 0 1-4.33 3.56M14.34 14H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2M12 19.96c-.83-1.2-1.5-2.53-1.91-3.96h3.82c-.41 1.43-1.08 2.76-1.91 3.96M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m-2.92 8H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16m-.82-2C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2M12 4.03c.83 1.2 1.5 2.54 1.91 3.97h-3.82c.41-1.43 1.08-2.77 1.91-3.97M18.92 8h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M12 2C6.47 2 2 6.5 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const eb = k({ name: "mdi-web", render: ZB }),
  QB = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function eH(t, e) {
  return (
    S(),
    O(
      "svg",
      QB,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16.5 11.74c0-.59-.07-1.16-.14-1.74h3.38c.08.33.15.67.19 1c.72.07 1.41.23 2.07.5C21.71 6.21 17.35 2 12 2C6.47 2 2 6.5 2 12s4.5 10 10 10c.87 0 1.71-.12 2.5-.33a6.6 6.6 0 0 1-1.46-3.47c-.31.61-.65 1.2-1.04 1.76c-.83-1.2-1.5-2.53-1.91-3.96h3.09c.17-.72.46-1.39.85-2H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2c0 .5-.04 1-.1 1.5a6.4 6.4 0 0 1 2.1-1.76M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2zm.82 2H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m2.09 0c.41-1.43 1.08-2.77 1.91-3.97c.83 1.2 1.5 2.54 1.91 3.97zm8.83 0h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M23 17.5c0 .82-.25 1.58-.67 2.21l-1.09-1.09c.17-.34.26-.72.26-1.12A2.5 2.5 0 0 0 19 15v1.5l-2.25-2.25L19 12v1.5c2.21 0 4 1.79 4 4m-4 1l2.25 2.25L19 23v-1.5c-2.21 0-4-1.79-4-4c0-.82.25-1.58.67-2.21l1.09 1.09c-.17.34-.26.72-.26 1.12A2.5 2.5 0 0 0 19 20z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const tH = k({ name: "mdi-web-sync", render: eH }),
  nH = ["placeholder"],
  rH = /* @__PURE__ */ se({
    __name: "BubbleItemIframeLink",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(ft.name).src,
          set: (r) => {
            !r ||
              !rc(r) ||
              e.editor.chain().updateAttributes(ft.name, { src: r }).run();
          },
        });
      return (r, o) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
              placeholder: I(D).global.t(
                "editor.common.placeholder.link_input"
              ),
              class:
                "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
            },
            null,
            8,
            nH
          )),
          [[Ot, n.value, void 0, { lazy: !0 }]]
        );
    },
  }),
  oH = /* @__PURE__ */ se({
    __name: "BubbleItemIframeSize",
    props: {
      editor: {},
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(ft.name).width,
          set: (i) => {
            o(i, r.value);
          },
        }),
        r = ce({
          get: () => e.editor.getAttributes(ft.name).height,
          set: (i) => {
            o(n.value, i);
          },
        }),
        o = (i, s) => {
          e.editor
            .chain()
            .updateAttributes(ft.name, { width: i, height: s })
            .focus()
            .setNodeSelection(e.editor.state.selection.from)
            .run();
        };
      return (i, s) => (
        S(),
        O(
          gt,
          null,
          [
            J(
              I(Fi),
              {
                modelValue: n.value,
                "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_width_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
            J(
              I(Fi),
              {
                modelValue: r.value,
                "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_height_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
            J(I(ot)),
          ],
          64
        )
      );
    },
  }),
  iH = {
    key: 0,
    class: "p-1.5",
  },
  sH = ["placeholder"],
  aH = ["src", "width", "height", "frameborder"],
  lH = /* @__PURE__ */ se({
    __name: "IframeView",
    props: {
      decorations: {},
      selected: { type: Boolean },
      updateAttributes: { type: Function },
      deleteNode: { type: Function },
      node: {},
      view: {},
      getPos: { type: Function },
      innerDecorations: {},
      editor: {},
      extension: {},
      HTMLAttributes: {},
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            var s;
            return (s = e.node) == null ? void 0 : s.attrs.src;
          },
          set: (s) => {
            !s || !rc(s) || e.updateAttributes({ src: s });
          },
        }),
        r = ce(() => e.node.attrs.frameborder);
      function o() {
        e.editor.commands.setNodeSelection(e.getPos());
      }
      const i = Te();
      return (
        Wr(() => {
          n.value || i.value.focus();
        }),
        (s, a) => (
          S(),
          de(
            I(Ha),
            {
              as: "div",
              class: "inline-block w-full",
            },
            {
              default: me(() => [
                C(
                  "div",
                  {
                    class:
                      "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
                    style: mt({
                      width: s.node.attrs.width,
                    }),
                  },
                  [
                    n.value
                      ? (S(),
                        O(
                          "iframe",
                          {
                            key: 1,
                            class: $e([
                              "rounded-md",
                              {
                                "border-2": r.value === "1",
                              },
                            ]),
                            src: s.node.attrs.src,
                            width: s.node.attrs.width,
                            height: s.node.attrs.height,
                            scrolling: "yes",
                            frameborder: r.value,
                            framespacing: "0",
                            allowfullscreen: "true",
                            onMouseenter: o,
                          },
                          null,
                          42,
                          aH
                        ))
                      : (S(),
                        O("div", iH, [
                          je(
                            C(
                              "input",
                              {
                                ref_key: "inputRef",
                                ref: i,
                                "onUpdate:modelValue":
                                  a[0] || (a[0] = (l) => (n.value = l)),
                                class:
                                  "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                                placeholder: I(D).global.t(
                                  "editor.common.placeholder.link_input"
                                ),
                                tabindex: "-1",
                                onFocus: o,
                              },
                              null,
                              40,
                              sH
                            ),
                            [[Ot, n.value, void 0, { lazy: !0 }]]
                          ),
                        ])),
                  ],
                  4
                ),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  }),
  ft = Ze.create({
    name: "iframe",
    fakeSelection: !0,
    inline() {
      return !0;
    },
    group() {
      return "inline";
    },
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        src: {
          default: null,
          parseHTML: (e) => e.getAttribute("src"),
        },
        width: {
          default: "100%",
          parseHTML: (e) => e.getAttribute("width"),
          renderHTML(e) {
            return {
              width: e.width,
            };
          },
        },
        height: {
          default: "300px",
          parseHTML: (e) => e.getAttribute("height"),
          renderHTML: (e) => ({
            height: e.height,
          }),
        },
        scrolling: {
          default: null,
          parseHTML: (e) => e.getAttribute("scrolling"),
          renderHTML: (e) => ({
            scrolling: e.scrolling,
          }),
        },
        frameborder: {
          default: "0",
          parseHTML: (e) => e.getAttribute("frameborder"),
          renderHTML: (e) => ({
            frameborder: e.frameborder,
          }),
        },
        allowfullscreen: {
          default: !0,
          parseHTML: (e) => e.getAttribute("allowfullscreen"),
          renderHTML: (e) => ({
            allowfullscreen: e.allowfullscreen,
          }),
        },
        framespacing: {
          default: 0,
          parseHTML: (e) => {
            const n = e.getAttribute("framespacing");
            return n ? parseInt(n, 10) : null;
          },
          renderHTML: (e) => ({
            framespacing: e.framespacing,
          }),
        },
        style: {
          renderHTML() {
            return {
              style: "display: inline-block",
            };
          },
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "iframe",
          getAttrs: (t) => {
            const e = t.getAttribute("src");
            return !e || !rc(e) ? !1 : { src: e };
          },
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return rc(t.src) ? ["iframe", ge(t)] : ["iframe", ge({ ...t, src: "" })];
    },
    addCommands() {
      return {
        setIframe:
          (t) =>
          ({ commands: e }) =>
            e.insertContent({
              type: this.name,
              attrs: t,
            }),
      };
    },
    addInputRules() {
      return [
        Pa({
          find: /^\$iframe\$$/,
          type: this.type,
          getAttributes: () => ({ width: "100%" }),
        }),
      ];
    },
    addPasteRules() {
      return [
        qO({
          find: /<iframe.*?src="(.*?)".*?<\/iframe>/g,
          type: this.type,
          getAttributes: (t) => {
            const n = document
              .createRange()
              .createContextualFragment(t[0])
              .querySelector("iframe");
            if (n)
              return {
                src: n.src,
                width: n.width || "100%",
                height: n.height || "300px",
              };
          },
        }),
      ];
    },
    addNodeView() {
      return Fa(lH);
    },
    addOptions() {
      return {
        getCommandMenuItems() {
          return {
            priority: 90,
            icon: k(eb),
            title: "editor.extensions.commands_menu.iframe",
            keywords: ["iframe", "qianruwangye"],
            command: ({ editor: t, range: e }) => {
              t.chain()
                .focus()
                .deleteRange(e)
                .insertContent([{ type: "iframe", attrs: { src: "" } }])
                .run();
            },
          };
        },
        getToolboxItems({ editor: t }) {
          return [
            {
              priority: 40,
              component: k(gi),
              props: {
                editor: t,
                icon: k(eb),
                title: D.global.t("editor.extensions.commands_menu.iframe"),
                action: () => {
                  t.chain()
                    .focus()
                    .insertContent([{ type: "iframe", attrs: { src: "" } }])
                    .run();
                },
              },
            },
          ];
        },
        getBubbleMenu({ editor: t }) {
          return {
            pluginKey: "iframeBubbleMenu",
            shouldShow: ({ state: e }) => Jt(e, ft.name),
            items: [
              {
                priority: 10,
                props: {
                  isActive: () => t.getAttributes(ft.name).frameborder === "1",
                  icon: k(
                    t.getAttributes(ft.name).frameborder === "1" ? HB : VB
                  ),
                  action: () => {
                    t.chain()
                      .updateAttributes(ft.name, {
                        frameborder:
                          t.getAttributes(ft.name).frameborder === "1"
                            ? "0"
                            : "1",
                      })
                      .focus()
                      .setNodeSelection(t.state.selection.from)
                      .run();
                  },
                  title:
                    t.getAttributes(ft.name).frameborder === "1"
                      ? D.global.t(
                          "editor.extensions.iframe.disable_frameborder"
                        )
                      : D.global.t(
                          "editor.extensions.iframe.enable_frameborder"
                        ),
                },
              },
              {
                priority: 20,
                component: k(ot),
              },
              {
                priority: 30,
                component: k(oH),
              },
              {
                priority: 40,
                props: {
                  isActive: () => Tl(t, "390px", "844px"),
                  icon: k(WB),
                  action: () => {
                    Ol(t, "390px", "844px");
                  },
                  title: D.global.t("editor.extensions.iframe.phone_size"),
                },
              },
              {
                priority: 50,
                props: {
                  isActive: () => Tl(t, "834px", "1194px"),
                  icon: k(Q2),
                  action: () => {
                    Ol(t, "834px", "1194px");
                  },
                  title: D.global.t(
                    "editor.extensions.iframe.tablet_vertical_size"
                  ),
                },
              },
              {
                priority: 60,
                props: {
                  isActive: () => Tl(t, "1194px", "834px"),
                  icon: k(Q2),
                  iconStyle: "transform: rotate(90deg)",
                  action: () => {
                    Ol(t, "1194px", "834px");
                  },
                  title: D.global.t(
                    "editor.extensions.iframe.tablet_horizontal_size"
                  ),
                },
              },
              {
                priority: 70,
                props: {
                  isActive: () => Tl(t, "100%", "834px"),
                  icon: k(GB),
                  action: () => {
                    Ol(t, "100%", "834px");
                  },
                  title: D.global.t("editor.extensions.iframe.desktop_size"),
                },
              },
              {
                priority: 80,
                component: k(ot),
              },
              {
                priority: 90,
                props: {
                  isActive: () => t.isActive({ textAlign: "left" }),
                  icon: k(us),
                  action: () => Dl(t, "left"),
                },
              },
              {
                priority: 100,
                props: {
                  isActive: () => t.isActive({ textAlign: "center" }),
                  icon: k(Ua),
                  action: () => Dl(t, "center"),
                },
              },
              {
                priority: 110,
                props: {
                  isActive: () => t.isActive({ textAlign: "right" }),
                  icon: k(Wa),
                  action: () => Dl(t, "right"),
                },
              },
              {
                priority: 120,
                props: {
                  isActive: () => t.isActive({ textAlign: "justify" }),
                  icon: k(ja),
                  action: () => Dl(t, "justify"),
                },
              },
              {
                priority: 130,
                component: k(ot),
              },
              {
                priority: 140,
                props: {
                  icon: k(tH),
                  action: () => {
                    t.chain()
                      .updateAttributes(ft.name, {
                        src: t.getAttributes(ft.name).src,
                      })
                      .run();
                  },
                },
              },
              {
                priority: 150,
                props: {
                  icon: k(qa),
                  title: D.global.t("editor.common.button.edit_link"),
                  action: () => k(rH),
                },
              },
              {
                priority: 160,
                props: {
                  icon: k(Ka),
                  title: D.global.t("editor.common.tooltip.open_link"),
                  action: () => {
                    window.open(t.getAttributes(ft.name).src, "_blank");
                  },
                },
              },
              {
                priority: 190,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: e }) => {
                    ls(ft.name, e);
                  },
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: t, view: e }) {
              var o;
              let n = t;
              for (; n && n.tagName !== "P"; ) n = n.parentElement;
              n &&
                (n =
                  (o = n.firstElementChild) == null
                    ? void 0
                    : o.firstElementChild);
              let r;
              if (n.firstElementChild) {
                const i = e.posAtDOM(n.firstElementChild, 0);
                r = e.state.doc.resolve(i).node();
              }
              return {
                node: r,
                el: n,
              };
            },
          };
        },
      };
    },
  }),
  Tl = (t, e, n) => {
    const r = t.getAttributes(ft.name);
    return e === r.width && n === r.height;
  },
  Ol = (t, e, n) => {
    t.chain()
      .updateAttributes(ft.name, { width: e, height: n })
      .focus()
      .setNodeSelection(t.state.selection.from)
      .run();
  },
  Dl = (t, e) => {
    t.chain().focus().setTextAlign(e).run();
  },
  uH = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
  cH = Ze.create({
    name: "image",
    addOptions() {
      return {
        inline: !1,
        allowBase64: !1,
        HTMLAttributes: {},
      };
    },
    inline() {
      return this.options.inline;
    },
    group() {
      return this.options.inline ? "inline" : "block";
    },
    draggable: !0,
    addAttributes() {
      return {
        src: {
          default: null,
        },
        alt: {
          default: null,
        },
        title: {
          default: null,
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: this.options.allowBase64
            ? "img[src]"
            : 'img[src]:not([src^="data:"])',
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["img", ge(this.options.HTMLAttributes, t)];
    },
    addCommands() {
      return {
        setImage:
          (t) =>
          ({ commands: e }) =>
            e.insertContent({
              type: this.name,
              attrs: t,
            }),
      };
    },
    addInputRules() {
      return [
        Pa({
          find: uH,
          type: this.type,
          getAttributes: (t) => {
            const [, , e, n, r] = t;
            return { src: n, alt: e, title: r };
          },
        }),
      ];
    },
  }),
  dH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function fH(t, e) {
  return (
    S(),
    O(
      "svg",
      dH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              d: "M8.5 13.498l2.5 3.006l3.5-4.506l4.5 6H5m16 1v-14a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z",
              fill: "currentColor",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const pH = k({ name: "mdi-file-image-box", render: fH }),
  hH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function mH(t, e) {
  return (
    S(),
    O(
      "svg",
      hH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7a5 5 0 0 0-5 5a5 5 0 0 0 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4a5 5 0 0 0 5-5a5 5 0 0 0-5-5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const gH = k({ name: "mdi-link", render: mH }),
  bH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function yH(t, e) {
  return (
    S(),
    O(
      "svg",
      bH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M10 21H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2h14c1.11 0 2 .89 2 2v5.33c-.3-.12-.63-.19-.96-.19c-.37 0-.72.08-1.04.23V5H5v14h5.11l-.11.11zM7 9h10V7H7zm0 8h5.11L14 15.12V15H7zm0-4h9.12l.88-.88V11H7zm14.7.58l-1.28-1.28a.55.55 0 0 0-.77 0l-1 1l2.05 2.05l1-1a.55.55 0 0 0 0-.77M12 22h2.06l6.05-6.07l-2.05-2.05L12 19.94z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const vH = k({ name: "mdi-text-box-edit-outline", render: yH }),
  _H = ["placeholder"],
  xH = /* @__PURE__ */ se({
    __name: "BubbleItemImageAlt",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(Et.name).alt,
          set: (r) => {
            e.editor
              .chain()
              .updateAttributes(Et.name, { alt: r })
              .setNodeSelection(e.editor.state.selection.from)
              .focus()
              .run();
          },
        });
      return (r, o) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
              placeholder: I(D).global.t("editor.common.placeholder.alt_input"),
              class:
                "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
            },
            null,
            8,
            _H
          )),
          [[Ot, n.value, void 0, { lazy: !0 }]]
        );
    },
  }),
  kH = ["placeholder"],
  wH = { class: "inline-flex items-center mt-2" },
  CH = { class: "ml-2 text-sm text-gray-500" },
  AH = /* @__PURE__ */ se({
    __name: "BubbleItemImageHref",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            const o = e.editor.getAttributes(Zp.name);
            return (
              (o == null ? void 0 : o.href) ||
              e.editor.getAttributes(Et.name).href
            );
          },
          set: (o) => {
            e.editor.commands.setLink({ href: o, target: "_blank" });
          },
        }),
        r = ce({
          get() {
            const o = e.editor.getAttributes(Zp.name);
            return (o == null ? void 0 : o.target) === "_blank";
          },
          set(o) {
            e.editor.commands.setLink({
              href: n.value,
              target: o ? "_blank" : "_self",
            });
          },
        });
      return (o, i) => (
        S(),
        O(
          gt,
          null,
          [
            je(
              C(
                "input",
                {
                  "onUpdate:modelValue": i[0] || (i[0] = (s) => (n.value = s)),
                  placeholder: I(D).global.t(
                    "editor.common.placeholder.alt_href"
                  ),
                  class:
                    "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
                },
                null,
                8,
                kH
              ),
              [[Ot, n.value, void 0, { lazy: !0 }]]
            ),
            C("label", wH, [
              je(
                C(
                  "input",
                  {
                    "onUpdate:modelValue":
                      i[1] || (i[1] = (s) => (r.value = s)),
                    type: "checkbox",
                    class:
                      "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded",
                  },
                  null,
                  512
                ),
                [[bb, r.value]]
              ),
              C(
                "span",
                CH,
                it(I(D).global.t("editor.extensions.link.open_in_new_window")),
                1
              ),
            ]),
          ],
          64
        )
      );
    },
  }),
  SH = ["placeholder"],
  EH = /* @__PURE__ */ se({
    __name: "BubbleItemImageLink",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(Et.name).src,
          set: (r) => {
            e.editor
              .chain()
              .updateAttributes(Et.name, { src: r })
              .setNodeSelection(e.editor.state.selection.from)
              .focus()
              .run();
          },
        });
      return (r, o) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
              placeholder: I(D).global.t(
                "editor.common.placeholder.link_input"
              ),
              class:
                "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
            },
            null,
            8,
            SH
          )),
          [[Ot, n.value, void 0, { lazy: !0 }]]
        );
    },
  }),
  MH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function TH(t, e) {
  return (
    S(),
    O(
      "svg",
      MH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M12 3a9 9 0 0 0-9 9H0l4 4l4-4H5a7 7 0 0 1 7-7a7 7 0 0 1 7 7a7 7 0 0 1-7 7c-1.5 0-2.91-.5-4.06-1.3L6.5 19.14A9.1 9.1 0 0 0 12 21a9 9 0 0 0 9-9a9 9 0 0 0-9-9m2 9a2 2 0 0 0-2-2a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const OH = k({ name: "mdi-backup-restore", render: TH }),
  DH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function NH(t, e) {
  return (
    S(),
    O(
      "svg",
      DH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M21 3H3C2 3 1 4 1 5v14a2 2 0 0 0 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2M5 17l3.5-4.5l2.5 3l3.5-4.5l4.5 6z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const sx = k({ name: "mdi-image-size-select-actual", render: NH }),
  LH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function RH(t, e) {
  return (
    S(),
    O(
      "svg",
      LH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M21 15h2v2h-2zm0-4h2v2h-2zm2 8h-2v2c1 0 2-1 2-2M13 3h2v2h-2zm8 4h2v2h-2zm0-4v2h2c0-1-1-2-2-2M1 7h2v2H1zm16-4h2v2h-2zm0 16h2v2h-2zM3 3C2 3 1 4 1 5h2zm6 0h2v2H9zM5 3h2v2H5zm-4 8v8a2 2 0 0 0 2 2h12V11zm2 8l2.5-3.21l1.79 2.15l2.5-3.22L13 19z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const ax = k({ name: "mdi-image-size-select-large", render: RH }),
  IH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function PH(t, e) {
  return (
    S(),
    O(
      "svg",
      IH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M23 15h-2v2h2zm0-4h-2v2h2zm0 8h-2v2c1 0 2-1 2-2M15 3h-2v2h2zm8 4h-2v2h2zm-2-4v2h2c0-1-1-2-2-2M3 21h8v-6H1v4a2 2 0 0 0 2 2M3 7H1v2h2zm12 12h-2v2h2zm4-16h-2v2h2zm0 16h-2v2h2zM3 3C2 3 1 4 1 5h2zm0 8H1v2h2zm8-8H9v2h2zM7 3H5v2h2z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const lx = k({ name: "mdi-image-size-select-small", render: PH }),
  $H = /* @__PURE__ */ se({
    __name: "BubbleItemImageSize",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(Et.name).width,
          set: (i) => {
            o(i, r.value);
          },
        }),
        r = ce({
          get: () => e.editor.getAttributes(Et.name).height,
          set: (i) => {
            o(n.value, i);
          },
        });
      function o(i, s) {
        e.editor
          .chain()
          .updateAttributes(Et.name, { width: i, height: s })
          .setNodeSelection(e.editor.state.selection.from)
          .focus()
          .run();
      }
      return (i, s) => (
        S(),
        O(
          gt,
          null,
          [
            J(
              I(Fi),
              {
                modelValue: n.value,
                "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_width_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
            J(
              I(Fi),
              {
                modelValue: r.value,
                "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_height_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
            J(I(ot)),
            J(
              I(Li),
              {
                tooltip: I(D).global.t("editor.extensions.image.small_size"),
                selected: i.editor.getAttributes(I(Et).name).width === "25%",
                onClick: s[2] || (s[2] = (a) => o("25%", "auto")),
              },
              {
                icon: me(() => [J(I(lx))]),
                _: 1,
              },
              8,
              ["tooltip", "selected"]
            ),
            J(
              I(Li),
              {
                tooltip: I(D).global.t("editor.extensions.image.medium_size"),
                selected: i.editor.getAttributes(I(Et).name).width === "50%",
                onClick: s[3] || (s[3] = (a) => o("50%", "auto")),
              },
              {
                icon: me(() => [J(I(ax))]),
                _: 1,
              },
              8,
              ["tooltip", "selected"]
            ),
            J(
              I(Li),
              {
                tooltip: I(D).global.t("editor.extensions.image.large_size"),
                selected: i.editor.getAttributes(I(Et).name).width === "100%",
                onClick: s[4] || (s[4] = (a) => o("100%", "100%")),
              },
              {
                icon: me(() => [J(I(sx))]),
                _: 1,
              },
              8,
              ["tooltip", "selected"]
            ),
            J(
              I(Li),
              {
                tooltip: I(D).global.t("editor.extensions.image.restore_size"),
                onClick: s[5] || (s[5] = (a) => o(void 0, void 0)),
              },
              {
                icon: me(() => [J(I(OH))]),
                _: 1,
              },
              8,
              ["tooltip"]
            ),
            J(I(ot)),
          ],
          64
        )
      );
    },
  }),
  BH = {
    key: 0,
    class: "p-1.5 w-full",
  },
  HH = ["placeholder"],
  FH = ["src", "title", "alt", "href"],
  zH = /* @__PURE__ */ se({
    __name: "ImageView",
    props: {
      decorations: {},
      selected: { type: Boolean },
      updateAttributes: { type: Function },
      deleteNode: { type: Function },
      node: {},
      view: {},
      getPos: { type: Function },
      innerDecorations: {},
      editor: {},
      extension: {},
      HTMLAttributes: {},
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            var c;
            return (c = e.node) == null ? void 0 : c.attrs.src;
          },
          set: (c) => {
            e.updateAttributes({
              src: c,
            });
          },
        }),
        r = ce({
          get: () => {
            var c;
            return (c = e.node) == null ? void 0 : c.attrs.alt;
          },
          set: (c) => {
            e.updateAttributes({ alt: c });
          },
        }),
        o = ce({
          get: () => {
            var c;
            return (c = e.node) == null ? void 0 : c.attrs.href;
          },
          set: (c) => {
            e.updateAttributes({ href: c });
          },
        });
      function i() {
        e.editor.commands.setNodeSelection(e.getPos());
      }
      const s = Te(0),
        a = Te(),
        l = Te();
      function u() {
        l.value && (s.value = l.value.clientWidth / l.value.clientHeight);
      }
      return (
        Wr(() => {
          if (!n.value) {
            a.value.focus();
            return;
          }
          if (!l.value) return;
          let c, d;
          l.value.addEventListener("mousedown", function (h) {
            var m;
            (c = h.clientX),
              (d = ((m = l.value) == null ? void 0 : m.clientWidth) || 1),
              document.documentElement.addEventListener("mousemove", f, !1),
              document.documentElement.addEventListener("mouseup", p, !1);
          });
          function f(h) {
            var _;
            if (!l.value) return;
            const m = Math.min(
                d + h.clientX - c,
                ((_ = l.value.parentElement) == null
                  ? void 0
                  : _.clientWidth) || 0
              ),
              g = m.toFixed(0) + "px",
              b = (m / s.value).toFixed(0) + "px";
            e.editor
              .chain()
              .updateAttributes(Et.name, { width: g, height: b })
              .setNodeSelection(e.getPos())
              .focus()
              .run();
          }
          function p() {
            document.documentElement.removeEventListener("mousemove", f, !1),
              document.documentElement.removeEventListener("mouseup", p, !1);
          }
        }),
        (c, d) => (
          S(),
          de(
            I(Ha),
            {
              as: "div",
              class: "inline-block w-full",
            },
            {
              default: me(() => [
                n.value
                  ? (S(),
                    O(
                      "div",
                      {
                        key: 1,
                        ref_key: "resizeRef",
                        ref: l,
                        class: $e([
                          "resize-x inline-block overflow-hidden text-center relative rounded-md max-w-full",
                          {
                            "ring-2 rounded": c.selected,
                          },
                        ]),
                        style: mt({
                          width: c.node.attrs.width,
                          height: c.node.attrs.height,
                        }),
                      },
                      [
                        C(
                          "img",
                          {
                            src: n.value,
                            title: c.node.attrs.title,
                            alt: r.value,
                            href: o.value,
                            class: "w-full h-full",
                            onLoad: u,
                          },
                          null,
                          40,
                          FH
                        ),
                      ],
                      6
                    ))
                  : (S(),
                    O("div", BH, [
                      je(
                        C(
                          "input",
                          {
                            ref_key: "inputRef",
                            ref: a,
                            "onUpdate:modelValue":
                              d[0] || (d[0] = (f) => (n.value = f)),
                            class:
                              "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                            placeholder: I(D).global.t(
                              "editor.common.placeholder.link_input"
                            ),
                            tabindex: "-1",
                            onFocus: i,
                          },
                          null,
                          40,
                          HH
                        ),
                        [[Ot, n.value, void 0, { lazy: !0 }]]
                      ),
                    ])),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  }),
  Et = cH.extend({
    fakeSelection: !0,
    inline() {
      return !0;
    },
    group() {
      return "inline";
    },
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        width: {
          default: void 0,
          parseHTML: (e) => e.getAttribute("width") || e.style.width || null,
          renderHTML: (e) => ({
            width: e.width,
          }),
        },
        height: {
          default: void 0,
          parseHTML: (e) => e.getAttribute("height") || e.style.height || null,
          renderHTML: (e) => ({
            height: e.height,
          }),
        },
        href: {
          default: null,
          parseHTML: (e) => e.getAttribute("href") || null,
          renderHTML: (e) => ({
            href: e.href,
          }),
        },
        style: {
          renderHTML() {
            return {
              style: "display: inline-block",
            };
          },
        },
      };
    },
    addNodeView() {
      return Fa(zH);
    },
    parseHTML() {
      return [
        {
          tag: this.options.allowBase64
            ? "img[src]"
            : 'img[src]:not([src^="data:"])',
        },
      ];
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getToolboxItems({ editor: e }) {
          return [
            {
              priority: 10,
              component: k(gi),
              props: {
                editor: e,
                icon: k(pH),
                title: D.global.t("editor.common.image"),
                action: () => {
                  e.chain()
                    .focus()
                    .insertContent([{ type: "image", attrs: { src: "" } }])
                    .run();
                },
              },
            },
          ];
        },
        getBubbleMenu({ editor: e }) {
          return {
            pluginKey: "imageBubbleMenu",
            shouldShow: ({ state: n }) => Jt(n, Et.name),
            defaultAnimation: !1,
            items: [
              {
                priority: 10,
                component: k($H),
              },
              {
                priority: 20,
                props: {
                  isActive: () => e.isActive({ textAlign: "left" }),
                  icon: k(us),
                  action: () => Nl(e, "left"),
                },
              },
              {
                priority: 30,
                props: {
                  isActive: () => e.isActive({ textAlign: "center" }),
                  icon: k(Ua),
                  action: () => Nl(e, "center"),
                },
              },
              {
                priority: 40,
                props: {
                  isActive: () => e.isActive({ textAlign: "right" }),
                  icon: k(Wa),
                  action: () => Nl(e, "right"),
                },
              },
              {
                priority: 50,
                props: {
                  isActive: () => e.isActive({ textAlign: "justify" }),
                  icon: k(ja),
                  action: () => Nl(e, "justify"),
                },
              },
              {
                priority: 60,
                component: k(ot),
              },
              {
                priority: 70,
                props: {
                  icon: k(qa),
                  title: D.global.t("editor.common.button.edit_link"),
                  action: () => k(EH),
                },
              },
              {
                priority: 80,
                props: {
                  icon: k(Ka),
                  title: D.global.t("editor.common.tooltip.open_link"),
                  action: () => {
                    window.open(e.getAttributes(Et.name).src, "_blank");
                  },
                },
              },
              {
                priority: 90,
                props: {
                  icon: k(vH),
                  title: D.global.t("editor.extensions.image.edit_alt"),
                  action: () => k(xH),
                },
              },
              {
                priority: 100,
                props: {
                  icon: k(gH),
                  title: D.global.t("editor.extensions.image.edit_href"),
                  action: () => k(AH),
                },
              },
              {
                priority: 110,
                component: k(ot),
              },
              {
                priority: 120,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: n }) => {
                    ls(Et.name, n);
                  },
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e, view: n }) {
              var i;
              let r = e;
              for (; r && r.tagName !== "P"; ) r = r.parentElement;
              r &&
                (r =
                  (i = r.firstElementChild) == null
                    ? void 0
                    : i.firstElementChild);
              let o;
              if (r.firstElementChild) {
                const s = n.posAtDOM(r.firstElementChild, 0);
                o = n.state.doc.resolve(s).node();
              }
              return {
                node: o,
                el: r,
                dragDomOffset: {
                  y: -5,
                },
              };
            },
          };
        },
      };
    },
    renderHTML({ HTMLAttributes: t }) {
      return t.href ? ["a", { href: t.href }, ["img", ge(t)]] : ["img", ge(t)];
    },
  }),
  Nl = (t, e) => {
    t.chain().focus().setTextAlign(e).run();
  },
  VH = Ne.create({
    name: "indent",
    addOptions() {
      return {
        names: ["heading", "paragraph"],
        indentRange: 24,
        minIndentLevel: 0,
        maxIndentLevel: 24 * 10,
        defaultIndentLevel: 0,
        HTMLAttributes: {},
        firstLineIndent: !0,
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.names,
          attributes: {
            indent: {
              default: this.options.defaultIndentLevel,
              renderHTML: (t) => ({
                style:
                  t.indent != 0 ? `margin-left: ${t.indent}px!important;` : "",
              }),
              parseHTML: (t) =>
                parseInt(t.style.marginLeft, 10) ||
                this.options.defaultIndentLevel,
            },
            lineIndent: {
              default: !1,
              renderHTML: (t) => ({
                style: t.lineIndent ? "text-indent: 2em" : "",
              }),
              parseHTML: (t) => t.style.textIndent === "2em",
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        indent:
          () =>
          ({ tr: t, state: e, dispatch: n, editor: r }) => {
            const { selection: o } = e;
            return (
              (t = t.setSelection(o)),
              (t = tb(
                t,
                this.options,
                r.extensionManager.extensions,
                "indent"
              )),
              t.docChanged && n && n(t),
              !0
            );
          },
        outdent:
          () =>
          ({ tr: t, state: e, dispatch: n, editor: r }) => {
            const { selection: o } = e;
            return (
              (t = t.setSelection(o)),
              (t = tb(
                t,
                this.options,
                r.extensionManager.extensions,
                "outdent"
              )),
              t.docChanged && n && n(t),
              !0
            );
          },
      };
    },
    addKeyboardShortcuts() {
      return {
        Tab: nb(),
        "Shift-Tab": rb(),
        "Mod-]": nb(),
        "Mod-[": rb(),
      };
    },
    onUpdate() {
      const { editor: t } = this;
      if (t.isActive("listItem")) {
        const e = t.state.selection.$head.node();
        e.attrs.indent &&
          t.commands.updateAttributes(e.type.name, { indent: 0 });
      }
    },
  }),
  UH = (t, e, n) => (t < e ? e : t > n ? n : t);
function jH(t, e, n, r) {
  if (!t.doc) return t;
  const o = t.doc.nodeAt(e);
  if (!o) return t;
  if (r.firstLineIndent && WH(t) && o.attrs.lineIndent !== n > 0) {
    const c = { ...o.attrs, lineIndent: n > 0 };
    return t.setNodeMarkup(e, o.type, c, o.marks);
  }
  const i = r.indentRange * n,
    s = r.minIndentLevel,
    a = r.maxIndentLevel,
    l = UH((o.attrs.indent || 0) + i, s, a);
  if (l === o.attrs.indent) return t;
  const u = { ...o.attrs, indent: l };
  return t.setNodeMarkup(e, o.type, u, o.marks);
}
const WH = (t) => {
    const { selection: e } = t,
      { $from: n, from: r, to: o } = e;
    return r == 0 ? !0 : r != o ? !1 : n.textOffset == 0;
  },
  tb = (t, e, n, r) => {
    const { doc: o, selection: i } = t;
    if (!o || !i || !(i instanceof q)) return t;
    const { from: s, to: a } = i;
    return (
      o.nodesBetween(s, a, (l, u) =>
        e.names.includes(l.type.name)
          ? (qH(t, u) && r === "indent"
              ? t.insertText("	", s, a)
              : (t = jH(t, u, r === "indent" ? 1 : -1, e)),
            !1)
          : !Ip(l.type.name, n)
      ),
      t
    );
  },
  qH = (t, e) => {
    const { selection: n } = t,
      { from: r, to: o } = n;
    return r == 0 ? !1 : r - o == 0 && e != r - 1;
  },
  ux = (t) => t.isActive("table") || t.isActive("columns"),
  nb =
    () =>
    ({ editor: t }) => {
      if (ux(t)) return !1;
      if (_0(t)) {
        const e = t.can().sinkListItem("listItem") ? "listItem" : "taskItem";
        return t.chain().focus().sinkListItem(e).run();
      }
      return t.chain().focus().indent().run();
    },
  rb =
    (t) =>
    ({ editor: e }) => {
      if (ux(e)) return !1;
      if (_0(e)) {
        const n = e.can().liftListItem("listItem") ? "listItem" : "taskItem";
        return e.chain().focus().liftListItem(n).run();
      }
      return e.chain().focus().outdent().run();
    },
  KH = Ne.create({
    name: "nodeSelected",
    addOptions() {
      return {
        className: "has-node-selected",
      };
    },
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("nodeSelected"),
          props: {
            decorations: ({ doc: t, selection: e }) => {
              const { isEditable: n, isFocused: r } = this.editor,
                { anchor: o } = e,
                i = [];
              return !n || !r
                ? ve.create(t, [])
                : (t.descendants((s, a) => {
                    if (s.isText || !(o >= a && o <= a + s.nodeSize - 1))
                      return !1;
                    i.push(
                      Ve.node(a, a + s.nodeSize, {
                        class: this.options.className,
                      })
                    );
                  }),
                  ve.create(t, i));
            },
          },
        }),
      ];
    },
  });
class Kt extends ee {
  /**
   * Creates a RangeSelection between the specified positions.
   *
   * @param $anchor - The starting position of the selection.
   * @param $head - The ending position of the selection.
   */
  constructor(e, n) {
    ob(e, n), super(e, n);
  }
  map(e, n) {
    const r = e.resolve(n.map(this.head)),
      o = e.resolve(n.map(this.anchor));
    return new Kt(o, r);
  }
  eq(e) {
    return e instanceof Kt && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new R0(this.anchor, this.head);
  }
  toJSON() {
    return { type: "range", anchor: this.anchor, head: this.head };
  }
  /**
   * Validates if the given positions can form a valid RangeSelection in the given state.
   *
   * @param state - The editor state.
   * @param anchor - The starting position.
   * @param head - The ending position.
   * @returns True if the positions form a valid RangeSelection, otherwise false.
   */
  static valid(e, n, r) {
    const o = ib(e.doc.resolve(n), e.doc.resolve(r));
    return !(o.length === 0 || o.reverse()[0].pos < 0);
  }
  /**
   * Returns a RangeSelection spanning the given positions.
   *
   * When the given range includes block-level content, if only a part is included,
   * the selection will be expanded to encompass the block-level content at the corresponding depth.
   *
   * Expansion: If the selection includes all depth nodes of the current block-level content but not the entire last node,
   * the selection will be expanded to include the node at that depth.
   *
   * @param $anchor - The starting position of the selection.
   * @param $head - The ending position of the selection.
   * @returns A new RangeSelection that spans the given positions.
   */
  static between(e, n) {
    ob(e, n);
    const r = e.doc,
      o = e.pos < n.pos ? 1 : -1,
      i = o > 0 ? e.pos : n.pos,
      s = o > 0 ? n.pos : e.pos,
      a = ib(e, n);
    if (a.length === 0) return null;
    const l = a[a.length - 1];
    if (l.pos < 0) return null;
    let u = 0;
    a.forEach(({ pos: p }) => {
      p < 0 && (u = p);
    });
    const c = s - i - l.pos - l.node.nodeSize,
      d = o > 0 ? i + u : s - (c > 0 ? 0 : c),
      f = o > 0 ? s - (c > 0 ? 0 : c) : i + u;
    return new Kt(r.resolve(d), r.resolve(f));
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for RangeSelection.fromJSON");
    return new Kt(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r) {
    return new this(e.resolve(n), e.resolve(r));
  }
  static allRange(e) {
    return new Kt(e.resolve(0), e.resolve(e.content.size));
  }
}
ee.jsonID("range", Kt);
class R0 {
  constructor(e, n) {
    (this.anchor = e), (this.head = n);
  }
  map(e) {
    return new R0(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return new Kt(e.resolve(this.anchor), e.resolve(this.head));
  }
}
function ob(t, e) {
  t.pos === e.pos && console.warn("The RangeSelection cannot be empty.");
}
function ib(t, e) {
  const n = t.doc,
    r = t.pos < e.pos ? 1 : -1,
    o = r > 0 ? t.pos : e.pos,
    i = r > 0 ? e.pos : t.pos,
    s = [];
  return (
    n.nodesBetween(
      o,
      i,
      (a, l, u, c) => {
        if (a.isText || a.type.name === "paragraph") return !0;
        s.push({ node: a, pos: l, parent: u, index: c });
      },
      -o
    ),
    s
  );
}
const Vt = {
    anchor: 0,
    head: 0,
    enable: !1,
  },
  GH = Ne.create({
    priority: 100,
    name: "rangeSelectionExtension",
    addProseMirrorPlugins() {
      return [
        new be({
          key: new ke("rangeSelectionPlugin"),
          props: {
            decorations: ({ doc: t, selection: e }) => {
              const { isEditable: n, isFocused: r } = this.editor;
              if (!n || !r || !(e instanceof Kt)) return null;
              const { $from: o, $to: i } = e,
                s = [];
              return (
                t.nodesBetween(o.pos, i.pos, (a, l) => {
                  a.isText ||
                    a.type.name === "paragraph" ||
                    (a.type.spec.fakeSelection &&
                      s.push(
                        Ve.node(l, l + a.nodeSize, {
                          class: "no-selection range-fake-selection",
                        })
                      ));
                }),
                ve.create(t, s)
              );
            },
            createSelectionBetween: (t, e, n) =>
              e.pos === n.pos
                ? null
                : Kt.valid(t.state, e.pos, n.pos)
                ? new Kt(e, n)
                : null,
            handleDOMEvents: {
              mousedown: (t, e) => {
                const n = { left: e.clientX, top: e.clientY },
                  r = t.posAtCoords(n);
                !r || !r.pos || ((Vt.enable = !0), (Vt.anchor = r.pos));
              },
              mousemove: (t, e) => {
                if (!Vt.enable) return;
                const n = { left: e.clientX, top: e.clientY },
                  r = t.posAtCoords(n);
                if (!r || !r.pos || r.pos === Vt.anchor || r.pos === Vt.head)
                  return;
                Vt.head = r.pos;
                const o = Kt.between(
                  t.state.doc.resolve(Vt.anchor),
                  t.state.doc.resolve(Vt.head)
                );
                o && t.dispatch(t.state.tr.setSelection(o));
              },
              mouseup: () => {
                (Vt.enable = !1), (Vt.anchor = 0), (Vt.head = 0);
              },
              mouseleave: () => {
                (Vt.enable = !1), (Vt.anchor = 0), (Vt.head = 0);
              },
            },
          },
        }),
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-a": ({ editor: t }) => (
          t.view.dispatch(
            t.view.state.tr.setSelection(Kt.allRange(t.view.state.doc))
          ),
          !0
        ),
      };
    },
    extendNodeSchema(t) {
      const e = {
        name: t.name,
        options: t.options,
        storage: t.storage,
      };
      return {
        fakeSelection: le(K(t, "fakeSelection", e)) ?? !1,
      };
    },
  }),
  JH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function YH(t, e) {
  return (
    S(),
    O(
      "svg",
      JH,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M15.5 12c2.5 0 4.5 2 4.5 4.5c0 .88-.25 1.71-.69 2.4l3.08 3.1L21 23.39l-3.12-3.07c-.69.43-1.51.68-2.38.68c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5m0 2a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5M5 3h14c1.11 0 2 .89 2 2v8.03c-.5-.8-1.19-1.49-2-2.03V5H5v14h4.5c.31.75.76 1.42 1.31 2H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2m2 4h10v2H7zm0 4h5.03c-.8.5-1.49 1.19-2.03 2H7zm0 4h2.17c-.11.5-.17 1-.17 1.5v.5H7z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const XH = k({ name: "mdi-text-box-search-outline", render: YH }),
  ZH = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function QH(t, e) {
  return (
    S(),
    O(
      "svg",
      ZH,
      e[0] ||
        (e[0] = [
          C(
            "g",
            {
              fill: "none",
              stroke: "currentColor",
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
            },
            [
              C("path", {
                d: "M14 4a2 2 0 0 1 2-2m0 8a2 2 0 0 1-2-2m6-6a2 2 0 0 1 2 2m0 4a2 2 0 0 1-2 2M3 7l3 3l3-3",
              }),
              C("path", { d: "M6 10V5a3 3 0 0 1 3-3h1" }),
              C("rect", {
                width: "8",
                height: "8",
                x: "2",
                y: "14",
                rx: "2",
              }),
            ],
            -1
          ),
        ])
    )
  );
}
const eF = k({ name: "lucide-replace", render: QH }),
  tF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function nF(t, e) {
  return (
    S(),
    O(
      "svg",
      tF,
      e[0] ||
        (e[0] = [
          C(
            "g",
            {
              fill: "none",
              stroke: "currentColor",
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
            },
            [
              C("path", {
                d: "M14 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2m0-18a2 2 0 0 1 2-2m0 8a2 2 0 0 1-2-2m6 6a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2m0-20a2 2 0 0 1 2 2m0 4a2 2 0 0 1-2 2M3 7l3 3l3-3",
              }),
              C("path", { d: "M6 10V5a3 3 0 0 1 3-3h1" }),
              C("rect", {
                width: "8",
                height: "8",
                x: "2",
                y: "14",
                rx: "2",
              }),
            ],
            -1
          ),
        ])
    )
  );
}
const rF = k({ name: "lucide-replace-all", render: nF }),
  oF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function iF(t, e) {
  return (
    S(),
    O(
      "svg",
      oF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M11 4h2v12l5.5-5.5l1.42 1.42L12 19.84l-7.92-7.92L5.5 10.5L11 16z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const sF = k({ name: "mdi-arrow-down", render: iF }),
  aF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function lF(t, e) {
  return (
    S(),
    O(
      "svg",
      aF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13 20h-2V8l-5.5 5.5l-1.42-1.42L12 4.16l7.92 7.92l-1.42 1.42L13 8z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const uF = k({ name: "mdi-arrow-up", render: lF }),
  cF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function dF(t, e) {
  return (
    S(),
    O(
      "svg",
      cF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const fF = k({ name: "mdi-close", render: dF }),
  pF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function hF(t, e) {
  return (
    S(),
    O(
      "svg",
      pF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M20.06 18a4 4 0 0 1-.2-.89c-.67.7-1.48 1.05-2.41 1.05c-.83 0-1.52-.24-2.05-.71c-.53-.45-.8-1.06-.8-1.79c0-.88.33-1.56 1-2.05s1.61-.73 2.83-.73h1.4v-.64q0-.735-.45-1.17c-.3-.29-.75-.43-1.33-.43c-.52 0-.95.12-1.3.36c-.35.25-.52.54-.52.89h-1.46c0-.43.15-.84.45-1.24c.28-.4.71-.71 1.22-.94c.51-.21 1.06-.35 1.69-.35c.98 0 1.74.24 2.29.73s.84 1.16.86 2.02V16c0 .8.1 1.42.3 1.88V18zm-2.4-1.12c.45 0 .88-.11 1.29-.32c.4-.21.7-.49.88-.83v-1.57H18.7c-1.77 0-2.66.47-2.66 1.41c0 .43.15.73.46.96c.3.23.68.35 1.16.35m-12.2-3.17h4.07L7.5 8.29zM6.64 6h1.72l4.71 12h-1.93l-.97-2.57H4.82L3.86 18H1.93z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const mF = k({ name: "mdi-format-letter-case", render: hF }),
  gF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function bF(t, e) {
  return (
    S(),
    O(
      "svg",
      gF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M11.14 4L6.43 16h1.93l.96-2.57h5.35l.97 2.57h1.93L12.86 4M12 6.29l2.03 5.42H9.96M20 14v4H4v-3H2v5h20v-6Z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const yF = k({ name: "mdi-format-letter-matches", render: bF }),
  vF = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function _F(t, e) {
  return (
    S(),
    O(
      "svg",
      vF,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M16 16.92c-.33.05-.66.08-1 .08s-.67-.03-1-.08v-3.51l-2.5 2.48c-.5-.39-1-.89-1.39-1.39l2.48-2.5H9.08c-.05-.33-.08-.66-.08-1s.03-.67.08-1h3.51l-2.48-2.5c.19-.25.39-.5.65-.74c.24-.26.49-.46.74-.65L14 8.59V5.08c.33-.05.66-.08 1-.08s.67.03 1 .08v3.51l2.5-2.48c.5.39 1 .89 1.39 1.39L17.41 10h3.51c.05.33.08.66.08 1s-.03.67-.08 1h-3.51l2.48 2.5c-.19.25-.39.5-.65.74c-.24.26-.49.46-.74.65L16 13.41zM5 19a2 2 0 0 1 2-2a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const xF = k({ name: "mdi-regex", render: _F }),
  kF = ["onKeydown"],
  wF = { class: "w-full flex flex-col gap-1" },
  CF = { class: "flex items-center relative" },
  AF = { class: "relative w-full max-w-[55%]" },
  SF = ["placeholder", "onKeydown"],
  EF = { class: "absolute inset-y-0 end-0 flex items-center pr-1 gap-1" },
  MF = ["title"],
  TF = ["title"],
  OF = ["title"],
  DF = { class: "min-w-[130px] text-sm mx-2" },
  NF = { key: 0 },
  LF = { key: 1 },
  RF = { class: "h-full flex items-center absolute right-0" },
  IF = ["title", "disabled"],
  PF = ["title", "disabled"],
  $F = ["title"],
  BF = { class: "flex items-center" },
  HF = { class: "relative w-full max-w-[55%]" },
  FF = ["placeholder", "onKeydown"],
  zF = { class: "flex items-center gap-2 mx-2" },
  VF = ["title", "disabled"],
  UF = ["title", "disabled"],
  jF = /* @__PURE__ */ se({
    __name: "SearchAndReplace",
    props: {
      editor: {
        type: Object,
        required: !0,
      },
      pluginKey: {
        type: Object,
        required: !0,
      },
      visible: {
        type: Boolean,
        default: !1,
      },
    },
    setup(t) {
      const e = t,
        n = Te(""),
        r = Te(""),
        o = Te(!1),
        i = Te(!1),
        s = Te(!1),
        a = Te(!1),
        l = ce(() => {
          a.value;
          const { editor: g, pluginKey: b } = e;
          if (!g || !b)
            return {
              findIndex: 0,
              findCount: 0,
            };
          const _ = b.getState(g.state);
          return {
            findIndex: (_ == null ? void 0 : _.findIndex) || 0,
            findCount: (_ == null ? void 0 : _.findCount) || 0,
          };
        }),
        u = () => {
          e.editor.commands.findNext();
        },
        c = () => {
          e.editor.commands.findPrevious();
        },
        d = (g) => {
          const { editor: b, pluginKey: _ } = e;
          if (!b || !_) return;
          const v = b.state.tr;
          v.setMeta(_, g), b.view.dispatch(v), (a.value = !a.value);
        },
        f = () => {
          e.editor.commands.replace(), (a.value = !a.value);
        },
        p = () => {
          e.editor.commands.replaceAll(), (a.value = !a.value);
        },
        h = () => {
          e.editor.commands.closeSearch();
        };
      jt(
        () => n.value.trim(),
        (g, b) => {
          g !== b &&
            d({
              setSearchTerm: g,
            });
        }
      ),
        jt(
          () => r.value.trim(),
          (g, b) => {
            g !== b &&
              d({
                setReplaceTerm: g,
              });
          }
        ),
        jt(
          () => o.value,
          (g, b) => {
            g !== b &&
              d({
                setRegex: g,
              });
          }
        ),
        jt(
          () => i.value,
          (g, b) => {
            g !== b &&
              d({
                setCaseSensitive: g,
              });
          }
        ),
        jt(
          () => s.value,
          (g, b) => {
            g !== b &&
              d({
                setMatchWord: g,
              });
          }
        );
      const m = Te(null);
      return (
        jt(
          () => e.visible,
          (g) => {
            g &&
              fh(() => {
                var b;
                (b = m.value) == null || b.focus();
              });
          }
        ),
        (g, b) =>
          je(
            (S(),
            de(
              $x,
              {
                appear: "",
                name: "slide",
              },
              {
                default: me(() => [
                  C(
                    "div",
                    {
                      class:
                        "absolute float-right top-0 right-5 z-50 flex justify-end bg-white shadow p-1 !pt-2 rounded min-w-[500px]",
                      onKeydown: Bl(xs(h, ["prevent"]), ["escape"]),
                    },
                    [
                      C("section", wF, [
                        C("div", CF, [
                          C("div", AF, [
                            je(
                              C(
                                "input",
                                {
                                  ref_key: "searchInput",
                                  ref: m,
                                  "onUpdate:modelValue":
                                    b[0] || (b[0] = (_) => (n.value = _)),
                                  type: "text",
                                  class:
                                    "block w-full p-1 ps-2 !pr-[5.5rem] bg-gray-50 rounded border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                                  placeholder: I(D).global.t(
                                    "editor.extensions.search_and_replace.search_placeholder"
                                  ),
                                  tabindex: "2",
                                  onKeydown: Bl(xs(u, ["prevent"]), ["enter"]),
                                },
                                null,
                                40,
                                SF
                              ),
                              [[Ot, n.value]]
                            ),
                            C("div", EF, [
                              C(
                                "button",
                                {
                                  title: I(D).global.t(
                                    "editor.extensions.search_and_replace.case_sensitive"
                                  ),
                                  type: "button",
                                  class: $e([
                                    "p-0.5 rounded-sm hover:bg-gray-200",
                                    {
                                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                        i.value,
                                    },
                                  ]),
                                  onClick:
                                    b[1] ||
                                    (b[1] = (_) => (i.value = !i.value)),
                                },
                                [J(I(mF))],
                                10,
                                MF
                              ),
                              C(
                                "button",
                                {
                                  title: I(D).global.t(
                                    "editor.extensions.search_and_replace.match_word"
                                  ),
                                  type: "button",
                                  class: $e([
                                    "p-0.5 rounded-sm hover:bg-gray-200",
                                    {
                                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                        s.value,
                                    },
                                  ]),
                                  onClick:
                                    b[2] ||
                                    (b[2] = (_) => (s.value = !s.value)),
                                },
                                [J(I(yF))],
                                10,
                                TF
                              ),
                              C(
                                "button",
                                {
                                  title: I(D).global.t(
                                    "editor.extensions.search_and_replace.use_regex"
                                  ),
                                  type: "button",
                                  class: $e([
                                    "p-0.5 rounded-sm hover:bg-gray-200",
                                    {
                                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200":
                                        o.value,
                                    },
                                  ]),
                                  onClick:
                                    b[3] ||
                                    (b[3] = (_) => (o.value = !o.value)),
                                },
                                [J(I(xF))],
                                10,
                                OF
                              ),
                            ]),
                          ]),
                          C("div", DF, [
                            l.value.findCount === 0
                              ? (S(),
                                O("div", NF, [
                                  C(
                                    "span",
                                    {
                                      class: $e({
                                        "text-red-600": n.value.length > 0,
                                      }),
                                    },
                                    it(
                                      I(D).global.t(
                                        "editor.extensions.search_and_replace.not_found"
                                      )
                                    ),
                                    3
                                  ),
                                ]))
                              : (S(),
                                O("div", LF, [
                                  C(
                                    "span",
                                    null,
                                    it(
                                      I(D).global.t(
                                        "editor.extensions.search_and_replace.occurrence_found",
                                        {
                                          index: l.value.findIndex + 1,
                                          total: l.value.findCount,
                                        }
                                      )
                                    ),
                                    1
                                  ),
                                ])),
                          ]),
                          C("div", RF, [
                            C(
                              "button",
                              {
                                title: I(D).global.t(
                                  "editor.extensions.search_and_replace.find_previous"
                                ),
                                type: "button",
                                class: $e([
                                  "p-0.5 rounded-sm opacity-50",
                                  {
                                    "hover:!bg-gray-200 !opacity-100":
                                      l.value.findCount > 0,
                                  },
                                ]),
                                disabled: l.value.findCount === 0,
                                onClick: c,
                              },
                              [J(I(uF))],
                              10,
                              IF
                            ),
                            C(
                              "button",
                              {
                                title: I(D).global.t(
                                  "editor.extensions.search_and_replace.find_next"
                                ),
                                type: "button",
                                class: $e([
                                  "p-0.5 rounded-sm opacity-50",
                                  {
                                    "hover:!bg-gray-200 !opacity-100":
                                      l.value.findCount > 0,
                                  },
                                ]),
                                disabled: l.value.findCount === 0,
                                onClick: u,
                              },
                              [J(I(sF))],
                              10,
                              PF
                            ),
                            C(
                              "button",
                              {
                                title: I(D).global.t(
                                  "editor.extensions.search_and_replace.close"
                                ),
                                type: "button",
                                class: "p-0.5 rounded-sm hover:bg-gray-200",
                                onClick: h,
                              },
                              [J(I(fF))],
                              8,
                              $F
                            ),
                          ]),
                        ]),
                        C("div", BF, [
                          C("div", HF, [
                            je(
                              C(
                                "input",
                                {
                                  "onUpdate:modelValue":
                                    b[4] || (b[4] = (_) => (r.value = _)),
                                  type: "text",
                                  class:
                                    "block w-full p-1 ps-2 rounded bg-gray-50 border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                                  placeholder: I(D).global.t(
                                    "editor.extensions.search_and_replace.replace_placeholder"
                                  ),
                                  tabindex: "2",
                                  onKeydown: Bl(xs(f, ["prevent"]), ["enter"]),
                                },
                                null,
                                40,
                                FF
                              ),
                              [[Ot, r.value]]
                            ),
                          ]),
                          C("div", zF, [
                            C(
                              "button",
                              {
                                title: I(D).global.t(
                                  "editor.extensions.search_and_replace.replace"
                                ),
                                type: "button",
                                class: $e([
                                  "p-0.5 rounded-sm opacity-50",
                                  {
                                    "hover:!bg-gray-200 !opacity-100":
                                      l.value.findCount > 0,
                                  },
                                ]),
                                disabled: l.value.findCount === 0,
                                onClick: f,
                              },
                              [J(I(eF))],
                              10,
                              VF
                            ),
                            C(
                              "button",
                              {
                                title: I(D).global.t(
                                  "editor.extensions.search_and_replace.replace_all"
                                ),
                                type: "button",
                                class: $e([
                                  "p-0.5 rounded-sm opacity-50",
                                  {
                                    "hover:!bg-gray-200 !opacity-100":
                                      l.value.findCount > 0,
                                  },
                                ]),
                                disabled: l.value.findCount === 0,
                                onClick: p,
                              },
                              [J(I(rF))],
                              10,
                              UF
                            ),
                          ]),
                        ]),
                      ]),
                    ],
                    40,
                    kF
                  ),
                ]),
                _: 1,
              },
              512
            )),
            [[mh, t.visible]]
          )
      );
    },
  }),
  It = new ke("searchAndReplace");
class WF {
  constructor({ view: e, editor: n, element: r }) {
    ue(this, "editor");
    ue(this, "view");
    ue(this, "containerElement");
    ue(this, "init");
    (this.editor = n),
      (this.view = e),
      (this.containerElement = r),
      (this.init = !1);
  }
  update() {
    const { parentElement: e } = this.editor.options.element;
    return (
      !this.init &&
        e &&
        (e.insertAdjacentElement("afterbegin", this.containerElement),
        (this.init = !0)),
      !1
    );
  }
  destroy() {
    return !1;
  }
}
class qF {
  constructor({
    editor: e,
    enable: n,
    regex: r,
    caseSensitive: o,
    wholeWord: i,
  }) {
    ue(this, "_findIndex");
    ue(this, "editor");
    ue(this, "enable");
    // Whether it is necessary to reset the findIndex based on the cursor position.
    ue(this, "findIndexFlag");
    ue(this, "findCount");
    ue(this, "searchTerm");
    ue(this, "replaceTerm");
    ue(this, "regex");
    ue(this, "caseSensitive");
    ue(this, "wholeWord");
    ue(this, "results", []);
    ue(this, "searchResultDecorations", []);
    ue(this, "findIndexDecoration");
    /**
     * Get the regular expression object based on the current search term.
     *
     * @returns Regular expression object
     */
    ue(this, "getRegex", () => {
      const { searchTerm: e, regex: n, caseSensitive: r, wholeWord: o } = this;
      let i = n ? e : e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return o && (i = `\\b${i}\\b`), new RegExp(i, r ? "gu" : "gui");
    });
    (this.editor = e),
      (this.enable = n || !1),
      (this.searchTerm = ""),
      (this.replaceTerm = ""),
      (this.regex = r || !1),
      (this.caseSensitive = o || !1),
      (this.wholeWord = i || !1),
      (this._findIndex = 0),
      (this.findCount = 0),
      (this.searchResultDecorations = []),
      (this.findIndexDecoration = void 0),
      (this.results = []),
      (this.findIndexFlag = !0);
  }
  get findIndex() {
    return this._findIndex;
  }
  set findIndex(e) {
    this._findIndex = this.verifySetIndex(e);
  }
  apply(e) {
    const n = e.getMeta(It);
    if (
      (n &&
        "setEnable" in n &&
        (n.setEnable && !this.enable && (n.setSearchTerm = this.searchTerm),
        (this.enable = n.setEnable)),
      !this.enable)
    )
      return this;
    if (
      (n && n.refresh && this.processSearches(e),
      n && "setReplaceTerm" in n && (this.replaceTerm = n.setReplaceTerm),
      n && "setFindIndex" in n)
    ) {
      const { setFindIndex: r } = n;
      (this.findIndex = r), this.processFindIndexDecoration();
    }
    return (
      n && this.scrollIntoFindIndexView(),
      n &&
        "setRegex" in n &&
        this.regex !== n.setRegex &&
        ((this.regex = n.setRegex), (n.setSearchTerm = this.searchTerm)),
      n &&
        "setWholeWord" in n &&
        this.wholeWord !== n.setWholeWord &&
        ((this.wholeWord = n.setWholeWord),
        (n.setSearchTerm = this.searchTerm)),
      n &&
        "setCaseSensitive" in n &&
        this.caseSensitive !== n.setCaseSensitive &&
        ((this.caseSensitive = n.setCaseSensitive),
        (n.setSearchTerm = this.searchTerm)),
      n && "setSearchTerm" in n
        ? ((this.searchTerm = n.setSearchTerm),
          (this.findIndexFlag = !0),
          this.processSearches(e),
          this.scrollIntoFindIndexView(),
          this)
        : e.docChanged
        ? this.processSearches(e)
        : (e.getMeta("pointer") &&
            (this.getNearestResultBySelection(e.selection),
            this.processFindIndexDecoration()),
          this)
    );
  }
  scrollIntoFindIndexView() {
    const { results: e, editor: n, _findIndex: r } = this;
    if (e.length > r && r >= 0) {
      const o = e[r];
      if (o) {
        const { pos: i } = o,
          { view: s } = n;
        let a = s.nodeDOM(i - 1);
        a instanceof HTMLElement || (a = s.domAtPos(i, 0).node),
          a instanceof HTMLElement &&
            J3(a, {
              behavior: "smooth",
              scrollMode: "if-needed",
            });
      }
    }
  }
  /**
   * Validate if findIndex is within the range
   * If results.length === 0, take 0
   * If less than or equal to -1, take results.length - 1
   * If greater than results.length - 1, take 0
   *
   * @param index new findIndex
   * @returns validated findIndex
   */
  verifySetIndex(e) {
    const { results: n } = this;
    return n.length === 0
      ? 0
      : e <= -1
      ? n.length - 1
      : e > n.length - 1
      ? 0
      : e;
  }
  /**
   * Execute full-text search functionality.
   *
   * @param Transaction
   * @returns
   * @memberof SearchAndReplacePluginState
   */
  processSearches({ doc: e, selection: n }) {
    const r = this.getFullText(e),
      o = this.getRegex();
    this.results.length = 0;
    for (let i = 0; i < r.length; i += 1) {
      const { text: s, pos: a, index: l } = r[i],
        u = Array.from(s.matchAll(o)).filter(([c]) => c.trim());
      for (let c = 0; c < u.length; c += 1) {
        const d = u[c];
        if (d[0] === "") break;
        d.index !== void 0 &&
          this.results.push({
            pos: a,
            index: l,
            from: a + d.index,
            to: a + d.index + d[0].length,
          });
      }
    }
    return (
      this.processResultDecorations(),
      this.findIndexFlag &&
        (this.getNearestResultBySelection(n), (this.findIndexFlag = !1)),
      this.processFindIndexDecoration(),
      this
    );
  }
  /**
   * Highlight the current result based on findIndex.
   *
   * @memberof SearchAndReplacePluginState
   */
  processFindIndexDecoration() {
    const { results: e, findIndex: n } = this,
      r = e[n];
    r &&
      (this.findIndexDecoration = Ve.inline(r.from, r.to, {
        class: "search-result-current",
      }));
  }
  /**
   * Generate highlighted results based on the 'results'.
   *
   * @memberof SearchAndReplacePluginState
   */
  processResultDecorations() {
    const { results: e } = this;
    (this.findCount = e.length), (this.searchResultDecorations.length = 0);
    for (let n = 0; n < e.length; n += 1) {
      const r = e[n];
      this.searchResultDecorations.push(
        Ve.inline(r.from, r.to, {
          class: "search-result",
        })
      );
    }
  }
  /**
   * Reset findIndex based on the current cursor position.
   *
   * @param selection Current cursor position.
   */
  getNearestResultBySelection(e) {
    const { results: n } = this;
    for (let r = 0; r < n.length; r += 1) {
      const o = n[r];
      if (e && e.to <= o.from) {
        this.findIndex = r;
        break;
      }
    }
  }
  /**
   * Convert the entire text into flattened text with positions.
   *
   * @param doc The entire document
   * @returns Flattened text with positions
   */
  getFullText(e) {
    const n = [];
    return (
      e.descendants((r, o, i, s) => {
        r.isText &&
          n.push({
            text: `${r.text}`,
            pos: o,
            index: s,
          });
      }),
      n
    );
  }
}
const KF = (t) =>
    new be({
      key: It,
      view: (e) => new WF({ view: e, ...t }),
      state: {
        init: () => new qF({ ...t }),
        apply: (e, n) => n.apply(e),
      },
      props: {
        decorations: (e) => {
          const n = It.getState(e);
          if (n) {
            const {
              searchResultDecorations: r,
              findIndexDecoration: o,
              enable: i,
            } = n;
            if (!i) return ve.empty;
            const s = [...r];
            if ((o && s.push(o), s.length > 0)) return ve.create(e.doc, s);
          }
          return ve.empty;
        },
      },
    }),
  Di = Zt(jF);
function GF() {
  const t = Di.component;
  return t ? t.props.visible : !1;
}
const JF = Ne.create({
    name: "searchAndReplace",
    // @ts-ignore
    addOptions() {
      return {
        getToolbarItems({ editor: t }) {
          return [
            {
              priority: 230,
              component: k(Xe),
              props: {
                editor: t,
                isActive: GF(),
                icon: k(XH),
                title: D.global.t("editor.extensions.search_and_replace.title"),
                action: () => {
                  const e = Di.component;
                  e &&
                    (e.props.visible
                      ? t.commands.closeSearch()
                      : t.commands.openSearch());
                },
              },
            },
          ];
        },
      };
    },
    addCommands() {
      return {
        replace:
          () =>
          ({ state: t, dispatch: e }) => {
            const n = It.getState(t);
            if (!n) return !1;
            const { replaceTerm: r, results: o, findIndex: i } = n,
              s = o[i];
            if (!s) return !1;
            const { from: a, to: l } = s;
            if (e) {
              const u = t.tr;
              u.insertText(r, a, l),
                u.setMeta(It, {
                  setFindIndex: i,
                  refresh: !0,
                }),
                e(u);
            }
            return !1;
          },
        replaceAll:
          () =>
          ({ state: t, dispatch: e }) => {
            const n = It.getState(t);
            if (!n) return !1;
            const { replaceTerm: r, results: o } = n,
              i = t.tr;
            let s = 0;
            return (
              o.forEach((a) => {
                const { from: l, to: u } = a;
                i.insertText(r, s + l, s + u), (s = s + r.length - (u - l));
              }),
              e && e(i),
              !1
            );
          },
        findNext:
          () =>
          ({ state: t, dispatch: e }) => {
            if (e) {
              const n = t.tr,
                r = It.getState(t);
              if (!r) return !1;
              const { findIndex: o } = r;
              n.setMeta(It, {
                setFindIndex: o + 1,
              }),
                e(n);
            }
            return !1;
          },
        findPrevious:
          () =>
          ({ state: t, dispatch: e }) => {
            if (e) {
              const n = It.getState(t);
              if (!n) return !1;
              const { findIndex: r } = n,
                o = t.tr;
              o.setMeta(It, {
                setFindIndex: r - 1,
              }),
                e(o);
            }
            return !1;
          },
        openSearch:
          () =>
          ({ state: t, dispatch: e }) => {
            if (!It.getState(t)) return !1;
            const r = Di.component;
            if (r) {
              r.props.visible = !0;
              const o = t.tr;
              o.setMeta(It, {
                setEnable: !0,
              }),
                e && e(o);
            }
            return !1;
          },
        closeSearch:
          () =>
          ({ state: t, dispatch: e }) => {
            if (!It.getState(t)) return !1;
            const r = Di.component;
            if (r) {
              r.props.visible = !1;
              const o = t.tr;
              o.setMeta(It, {
                setEnable: !1,
              }),
                e && e(o);
            }
            return !1;
          },
      };
    },
    addProseMirrorPlugins() {
      const t = document.createElement("div");
      return (
        (t.style.position = "sticky"),
        (t.style.top = "0"),
        (t.style.zIndex = "50"),
        (Di.props = {
          editor: this.editor,
          pluginKey: It,
          visible: !1,
        }),
        Ws(Di, t),
        [
          KF({
            editor: this.editor,
            element: t,
          }),
        ]
      );
    },
    addKeyboardShortcuts() {
      return {
        "Mod-f": () => (this.editor.commands.openSearch(), !0),
      };
    },
  }),
  YF = { class: "p-1" },
  XF = { class: "text-xs text-gray-600" },
  ZF = /* @__PURE__ */ se({
    __name: "ColorBubbleItem",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t;
      function n(o) {
        var i;
        o && ((i = e.editor) == null || i.chain().focus().setColor(o).run());
      }
      function r() {
        var o;
        (o = e.editor) == null || o.chain().focus().unsetColor().run();
      }
      return (o, i) => (
        S(),
        de(
          vd,
          { "onUpdate:modelValue": n },
          {
            prefix: me(() => [
              C("div", YF, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: r,
                  },
                  [
                    i[0] ||
                      (i[0] = C(
                        "div",
                        {
                          class:
                            "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black",
                        },
                        null,
                        -1
                      )),
                    C(
                      "span",
                      XF,
                      it(I(D).global.t("editor.common.button.restore_default")),
                      1
                    ),
                  ]
                ),
              ]),
            ]),
            default: me(() => [
              J(I(Th), Fn(e, { editor: o.editor }), null, 16, ["editor"]),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  QF = { class: "p-1" },
  ez = { class: "inline-flex items-center gap-2" },
  tz = { class: "text-xs text-gray-600" },
  nz = { class: "p-1" },
  rz = { class: "text-xs text-gray-600" },
  oz = /* @__PURE__ */ se({
    __name: "HighlightBubbleItem",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t;
      function n(o) {
        var i;
        o &&
          ((i = e.editor) == null ||
            i.chain().focus().toggleHighlight({ color: o }).run());
      }
      function r() {
        var o;
        (o = e.editor) == null || o.chain().focus().unsetHighlight().run();
      }
      return (o, i) => (
        S(),
        de(
          vd,
          { "onUpdate:modelValue": n },
          {
            prefix: me(() => [
              C("div", QF, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: r,
                  },
                  [
                    C("div", ez, [
                      J(I(C3)),
                      C(
                        "span",
                        tz,
                        it(I(D).global.t("editor.extensions.highlight.unset")),
                        1
                      ),
                    ]),
                  ]
                ),
              ]),
              C("div", nz, [
                C(
                  "div",
                  {
                    class:
                      "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
                    onClick: i[1] || (i[1] = (s) => n()),
                  },
                  [
                    i[2] ||
                      (i[2] = C(
                        "div",
                        {
                          class:
                            "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
                          style: { "background-color": "#fff8c5" },
                        },
                        null,
                        -1
                      )),
                    C(
                      "span",
                      rz,
                      it(I(D).global.t("editor.common.button.restore_default")),
                      1
                    ),
                  ]
                ),
              ]),
            ]),
            default: me(() => [
              J(
                I(Th),
                Fn(e, {
                  onClick: i[0] || (i[0] = (s) => n()),
                }),
                null,
                16
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  iz =
    "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
  sz =
    "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
  es = (t, e) => {
    for (const n in e) t[n] = e[n];
    return t;
  },
  ih = "numeric",
  sh = "ascii",
  ah = "alpha",
  Yl = "asciinumeric",
  Ll = "alphanumeric",
  lh = "domain",
  cx = "emoji",
  az = "scheme",
  lz = "slashscheme",
  sb = "whitespace";
function uz(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Yo(t, e, n) {
  e[ih] && ((e[Yl] = !0), (e[Ll] = !0)),
    e[sh] && ((e[Yl] = !0), (e[ah] = !0)),
    e[Yl] && (e[Ll] = !0),
    e[ah] && (e[Ll] = !0),
    e[Ll] && (e[lh] = !0),
    e[cx] && (e[lh] = !0);
  for (const r in e) {
    const o = uz(r, n);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function cz(t, e) {
  const n = {};
  for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function sn(t) {
  t === void 0 && (t = null),
    (this.j = {}),
    (this.jr = []),
    (this.jd = null),
    (this.t = t);
}
sn.groups = {};
sn.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this,
      n = e.j[t];
    if (n) return n;
    for (let r = 0; r < e.jr.length; r++) {
      const o = e.jr[r][0],
        i = e.jr[r][1];
      if (i && o.test(t)) return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || sn.groups;
    let o;
    return (
      e && e.j ? (o = e) : ((o = new sn(e)), n && r && Yo(e, n, r)),
      this.jr.push([t, o]),
      o
    );
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let o = this;
    const i = t.length;
    if (!i) return o;
    for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
    return o.tt(t[i - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || sn.groups;
    const o = this;
    if (e && e.j) return (o.j[t] = e), e;
    const i = e;
    let s,
      a = o.go(t);
    if (
      (a
        ? ((s = new sn()),
          es(s.j, a.j),
          s.jr.push.apply(s.jr, a.jr),
          (s.jd = a.jd),
          (s.t = a.t))
        : (s = new sn()),
      i)
    ) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = es(cz(s.t, r), n);
          Yo(i, l, r);
        } else n && Yo(i, n, r);
      s.t = i;
    }
    return (o.j[t] = s), s;
  },
};
const he = (t, e, n, r, o) => t.ta(e, n, r, o),
  bn = (t, e, n, r, o) => t.tr(e, n, r, o),
  ab = (t, e, n, r, o) => t.ts(e, n, r, o),
  j = (t, e, n, r, o) => t.tt(e, n, r, o),
  Nr = "WORD",
  uh = "UWORD",
  ka = "LOCALHOST",
  ch = "TLD",
  dh = "UTLD",
  Xl = "SCHEME",
  Ni = "SLASH_SCHEME",
  I0 = "NUM",
  dx = "WS",
  P0 = "NL",
  Vs = "OPENBRACE",
  Us = "CLOSEBRACE",
  oc = "OPENBRACKET",
  ic = "CLOSEBRACKET",
  sc = "OPENPAREN",
  ac = "CLOSEPAREN",
  lc = "OPENANGLEBRACKET",
  uc = "CLOSEANGLEBRACKET",
  cc = "FULLWIDTHLEFTPAREN",
  dc = "FULLWIDTHRIGHTPAREN",
  fc = "LEFTCORNERBRACKET",
  pc = "RIGHTCORNERBRACKET",
  hc = "LEFTWHITECORNERBRACKET",
  mc = "RIGHTWHITECORNERBRACKET",
  gc = "FULLWIDTHLESSTHAN",
  bc = "FULLWIDTHGREATERTHAN",
  yc = "AMPERSAND",
  vc = "APOSTROPHE",
  _c = "ASTERISK",
  ao = "AT",
  xc = "BACKSLASH",
  kc = "BACKTICK",
  wc = "CARET",
  po = "COLON",
  $0 = "COMMA",
  Cc = "DOLLAR",
  ir = "DOT",
  Ac = "EQUALS",
  B0 = "EXCLAMATION",
  sr = "HYPHEN",
  Sc = "PERCENT",
  Ec = "PIPE",
  Mc = "PLUS",
  Tc = "POUND",
  Oc = "QUERY",
  H0 = "QUOTE",
  F0 = "SEMI",
  ar = "SLASH",
  js = "TILDE",
  Dc = "UNDERSCORE",
  fx = "EMOJI",
  Nc = "SYM";
var px = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: Nr,
  UWORD: uh,
  LOCALHOST: ka,
  TLD: ch,
  UTLD: dh,
  SCHEME: Xl,
  SLASH_SCHEME: Ni,
  NUM: I0,
  WS: dx,
  NL: P0,
  OPENBRACE: Vs,
  CLOSEBRACE: Us,
  OPENBRACKET: oc,
  CLOSEBRACKET: ic,
  OPENPAREN: sc,
  CLOSEPAREN: ac,
  OPENANGLEBRACKET: lc,
  CLOSEANGLEBRACKET: uc,
  FULLWIDTHLEFTPAREN: cc,
  FULLWIDTHRIGHTPAREN: dc,
  LEFTCORNERBRACKET: fc,
  RIGHTCORNERBRACKET: pc,
  LEFTWHITECORNERBRACKET: hc,
  RIGHTWHITECORNERBRACKET: mc,
  FULLWIDTHLESSTHAN: gc,
  FULLWIDTHGREATERTHAN: bc,
  AMPERSAND: yc,
  APOSTROPHE: vc,
  ASTERISK: _c,
  AT: ao,
  BACKSLASH: xc,
  BACKTICK: kc,
  CARET: wc,
  COLON: po,
  COMMA: $0,
  DOLLAR: Cc,
  DOT: ir,
  EQUALS: Ac,
  EXCLAMATION: B0,
  HYPHEN: sr,
  PERCENT: Sc,
  PIPE: Ec,
  PLUS: Mc,
  POUND: Tc,
  QUERY: Oc,
  QUOTE: H0,
  SEMI: F0,
  SLASH: ar,
  TILDE: js,
  UNDERSCORE: Dc,
  EMOJI: fx,
  SYM: Nc,
});
const Ai = /[a-z]/,
  Rf = new RegExp("\\p{L}", "u"),
  If = new RegExp("\\p{Emoji}", "u"),
  Pf = /\d/,
  lb = /\s/,
  ub = `
`,
  dz = "",
  fz = "";
let Rl = null,
  Il = null;
function pz(t) {
  t === void 0 && (t = []);
  const e = {};
  sn.groups = e;
  const n = new sn();
  Rl == null && (Rl = cb(iz)),
    Il == null && (Il = cb(sz)),
    j(n, "'", vc),
    j(n, "{", Vs),
    j(n, "}", Us),
    j(n, "[", oc),
    j(n, "]", ic),
    j(n, "(", sc),
    j(n, ")", ac),
    j(n, "<", lc),
    j(n, ">", uc),
    j(n, "", cc),
    j(n, "", dc),
    j(n, "", fc),
    j(n, "", pc),
    j(n, "", hc),
    j(n, "", mc),
    j(n, "", gc),
    j(n, "", bc),
    j(n, "&", yc),
    j(n, "*", _c),
    j(n, "@", ao),
    j(n, "`", kc),
    j(n, "^", wc),
    j(n, ":", po),
    j(n, ",", $0),
    j(n, "$", Cc),
    j(n, ".", ir),
    j(n, "=", Ac),
    j(n, "!", B0),
    j(n, "-", sr),
    j(n, "%", Sc),
    j(n, "|", Ec),
    j(n, "+", Mc),
    j(n, "#", Tc),
    j(n, "?", Oc),
    j(n, '"', H0),
    j(n, "/", ar),
    j(n, ";", F0),
    j(n, "~", js),
    j(n, "_", Dc),
    j(n, "\\", xc);
  const r = bn(n, Pf, I0, {
    [ih]: !0,
  });
  bn(r, Pf, r);
  const o = bn(n, Ai, Nr, {
    [sh]: !0,
  });
  bn(o, Ai, o);
  const i = bn(n, Rf, uh, {
    [ah]: !0,
  });
  bn(i, Ai), bn(i, Rf, i);
  const s = bn(n, lb, dx, {
    [sb]: !0,
  });
  j(n, ub, P0, {
    [sb]: !0,
  }),
    j(s, ub),
    bn(s, lb, s);
  const a = bn(n, If, fx, {
    [cx]: !0,
  });
  bn(a, If, a), j(a, dz, a);
  const l = j(a, fz);
  bn(l, If, a);
  const u = [[Ai, o]],
    c = [
      [Ai, null],
      [Rf, i],
    ];
  for (let d = 0; d < Rl.length; d++) Xr(n, Rl[d], ch, Nr, u);
  for (let d = 0; d < Il.length; d++) Xr(n, Il[d], dh, uh, c);
  Yo(
    ch,
    {
      tld: !0,
      ascii: !0,
    },
    e
  ),
    Yo(
      dh,
      {
        utld: !0,
        alpha: !0,
      },
      e
    ),
    Xr(n, "file", Xl, Nr, u),
    Xr(n, "mailto", Xl, Nr, u),
    Xr(n, "http", Ni, Nr, u),
    Xr(n, "https", Ni, Nr, u),
    Xr(n, "ftp", Ni, Nr, u),
    Xr(n, "ftps", Ni, Nr, u),
    Yo(
      Xl,
      {
        scheme: !0,
        ascii: !0,
      },
      e
    ),
    Yo(
      Ni,
      {
        slashscheme: !0,
        ascii: !0,
      },
      e
    ),
    (t = t.sort((d, f) => (d[0] > f[0] ? 1 : -1)));
  for (let d = 0; d < t.length; d++) {
    const f = t[d][0],
      h = t[d][1]
        ? {
            [az]: !0,
          }
        : {
            [lz]: !0,
          };
    f.indexOf("-") >= 0
      ? (h[lh] = !0)
      : Ai.test(f)
      ? Pf.test(f)
        ? (h[Yl] = !0)
        : (h[sh] = !0)
      : (h[ih] = !0),
      ab(n, f, f, h);
  }
  return (
    ab(n, "localhost", ka, {
      ascii: !0,
    }),
    (n.jd = new sn(Nc)),
    {
      start: n,
      tokens: es(
        {
          groups: e,
        },
        px
      ),
    }
  );
}
function hz(t, e) {
  const n = mz(e.replace(/[A-Z]/g, (a) => a.toLowerCase())),
    r = n.length,
    o = [];
  let i = 0,
    s = 0;
  for (; s < r; ) {
    let a = t,
      l = null,
      u = 0,
      c = null,
      d = -1,
      f = -1;
    for (; s < r && (l = a.go(n[s])); )
      (a = l),
        a.accepts()
          ? ((d = 0), (f = 0), (c = a))
          : d >= 0 && ((d += n[s].length), f++),
        (u += n[s].length),
        (i += n[s].length),
        s++;
    (i -= d),
      (s -= f),
      (u -= d),
      o.push({
        t: c.t,
        // token type/name
        v: e.slice(i - u, i),
        // string value
        s: i - u,
        // start index
        e: i,
        // end index (excluding)
      });
  }
  return o;
}
function mz(t) {
  const e = [],
    n = t.length;
  let r = 0;
  for (; r < n; ) {
    let o = t.charCodeAt(r),
      i,
      s =
        o < 55296 ||
        o > 56319 ||
        r + 1 === n ||
        (i = t.charCodeAt(r + 1)) < 56320 ||
        i > 57343
          ? t[r]
          : t.slice(r, r + 2);
    e.push(s), (r += s.length);
  }
  return e;
}
function Xr(t, e, n, r, o) {
  let i;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? (i = t.j[l]) : ((i = new sn(r)), (i.jr = o.slice()), (t.j[l] = i)),
      (t = i);
  }
  return (i = new sn(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
}
function cb(t) {
  const e = [],
    n = [];
  let r = 0,
    o = "0123456789";
  for (; r < t.length; ) {
    let i = 0;
    for (; o.indexOf(t[r + i]) >= 0; ) i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--) n.pop();
      r += i;
    } else n.push(t[r]), r++;
  }
  return e;
}
const wa = {
  defaultProtocol: "http",
  events: null,
  format: db,
  formatHref: db,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
};
function hx(t, e) {
  e === void 0 && (e = null);
  let n = es({}, wa);
  t && (n = es(n, t instanceof hx ? t.o : t));
  const r = n.ignoreTags,
    o = [];
  for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
  (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
}
hx.prototype = {
  o: wa,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let o = this.o[t];
    return (
      o &&
      (typeof o == "object"
        ? ((o = n.t in o ? o[n.t] : wa[t]),
          typeof o == "function" && r && (o = o(e, n)))
        : typeof o == "function" && r && (o = o(e, n.t, n)),
      o)
    );
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  },
};
function db(t) {
  return t;
}
function mx(t, e) {
  (this.t = "token"), (this.v = t), (this.tk = e);
}
mx.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(),
      n = t.get("truncate", e, this),
      r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return (
      t === void 0 && (t = wa.defaultProtocol),
      {
        type: this.t,
        value: this.toString(),
        isLink: this.isLink,
        href: this.toHref(t),
        start: this.startIndex(),
        end: this.endIndex(),
      }
    );
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this,
      n = this.toHref(t.get("defaultProtocol")),
      r = t.get("formatHref", n, this),
      o = t.get("tagName", n, e),
      i = this.toFormattedString(t),
      s = {},
      a = t.get("className", n, e),
      l = t.get("target", n, e),
      u = t.get("rel", n, e),
      c = t.getObj("attributes", n, e),
      d = t.getObj("events", n, e);
    return (
      (s.href = r),
      a && (s.class = a),
      l && (s.target = l),
      u && (s.rel = u),
      c && es(s, c),
      {
        tagName: o,
        attributes: s,
        content: i,
        eventListeners: d,
      }
    );
  },
};
function wd(t, e) {
  class n extends mx {
    constructor(o, i) {
      super(o, i), (this.t = t);
    }
  }
  for (const r in e) n.prototype[r] = e[r];
  return (n.t = t), n;
}
const fb = wd("email", {
    isLink: !0,
    toHref() {
      return "mailto:" + this.toString();
    },
  }),
  pb = wd("text"),
  gz = wd("nl"),
  Pl = wd("url", {
    isLink: !0,
    /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
    toHref(t) {
      return (
        t === void 0 && (t = wa.defaultProtocol),
        this.hasProtocol() ? this.v : `${t}://${this.v}`
      );
    },
    /**
     * Check whether this URL token has a protocol
     * @return {boolean}
     */
    hasProtocol() {
      const t = this.tk;
      return t.length >= 2 && t[0].t !== ka && t[1].t === po;
    },
  }),
  yn = (t) => new sn(t);
function bz(t) {
  let { groups: e } = t;
  const n = e.domain.concat([
      yc,
      _c,
      ao,
      xc,
      kc,
      wc,
      Cc,
      Ac,
      sr,
      I0,
      Sc,
      Ec,
      Mc,
      Tc,
      ar,
      Nc,
      js,
      Dc,
    ]),
    r = [
      vc,
      po,
      $0,
      ir,
      B0,
      Oc,
      H0,
      F0,
      lc,
      uc,
      Vs,
      Us,
      ic,
      oc,
      sc,
      ac,
      cc,
      dc,
      fc,
      pc,
      hc,
      mc,
      gc,
      bc,
    ],
    o = [
      yc,
      vc,
      _c,
      xc,
      kc,
      wc,
      Cc,
      Ac,
      sr,
      Vs,
      Us,
      Sc,
      Ec,
      Mc,
      Tc,
      Oc,
      ar,
      Nc,
      js,
      Dc,
    ],
    i = yn(),
    s = j(i, js);
  he(s, o, s), he(s, e.domain, s);
  const a = yn(),
    l = yn(),
    u = yn();
  he(i, e.domain, a),
    he(i, e.scheme, l),
    he(i, e.slashscheme, u),
    he(a, o, s),
    he(a, e.domain, a);
  const c = j(a, ao);
  j(s, ao, c), j(l, ao, c), j(u, ao, c);
  const d = j(s, ir);
  he(d, o, s), he(d, e.domain, s);
  const f = yn();
  he(c, e.domain, f), he(f, e.domain, f);
  const p = j(f, ir);
  he(p, e.domain, f);
  const h = yn(fb);
  he(p, e.tld, h), he(p, e.utld, h), j(c, ka, h);
  const m = j(f, sr);
  he(m, e.domain, f), he(h, e.domain, f), j(h, ir, p), j(h, sr, m);
  const g = j(h, po);
  he(g, e.numeric, fb);
  const b = j(a, sr),
    _ = j(a, ir);
  he(b, e.domain, a), he(_, o, s), he(_, e.domain, a);
  const v = yn(Pl);
  he(_, e.tld, v),
    he(_, e.utld, v),
    he(v, e.domain, a),
    he(v, o, s),
    j(v, ir, _),
    j(v, sr, b),
    j(v, ao, c);
  const y = j(v, po),
    w = yn(Pl);
  he(y, e.numeric, w);
  const x = yn(Pl),
    M = yn();
  he(x, n, x), he(x, r, M), he(M, n, x), he(M, r, M), j(v, ar, x), j(w, ar, x);
  const N = j(l, po),
    T = j(u, po),
    P = j(T, ar),
    z = j(P, ar);
  he(l, e.domain, a),
    j(l, ir, _),
    j(l, sr, b),
    he(u, e.domain, a),
    j(u, ir, _),
    j(u, sr, b),
    he(N, e.domain, x),
    j(N, ar, x),
    he(z, e.domain, x),
    he(z, n, x),
    j(z, ar, x);
  const H = [
    [Vs, Us],
    // {}
    [oc, ic],
    // []
    [sc, ac],
    // ()
    [lc, uc],
    // <>
    [cc, dc],
    // 
    [fc, pc],
    // 
    [hc, mc],
    // 
    [gc, bc],
    // 
  ];
  for (let U = 0; U < H.length; U++) {
    const [re, te] = H[U],
      Q = j(x, re);
    j(M, re, Q), j(Q, te, x);
    const ne = yn(Pl);
    he(Q, n, ne);
    const fe = yn();
    he(Q, r),
      he(ne, n, ne),
      he(ne, r, fe),
      he(fe, n, ne),
      he(fe, r, fe),
      j(ne, te, x),
      j(fe, te, x);
  }
  return (
    j(i, ka, v),
    j(i, P0, gz),
    {
      start: i,
      tokens: px,
    }
  );
}
function yz(t, e, n) {
  let r = n.length,
    o = 0,
    i = [],
    s = [];
  for (; o < r; ) {
    let a = t,
      l = null,
      u = null,
      c = 0,
      d = null,
      f = -1;
    for (; o < r && !(l = a.go(n[o].t)); ) s.push(n[o++]);
    for (; o < r && (u = l || a.go(n[o].t)); )
      (l = null),
        (a = u),
        a.accepts() ? ((f = 0), (d = a)) : f >= 0 && f++,
        o++,
        c++;
    if (f < 0) (o -= c), o < r && (s.push(n[o]), o++);
    else {
      s.length > 0 && (i.push($f(pb, e, s)), (s = [])), (o -= f), (c -= f);
      const p = d.t,
        h = n.slice(o - c, o);
      i.push($f(p, e, h));
    }
  }
  return s.length > 0 && i.push($f(pb, e, s)), i;
}
function $f(t, e, n) {
  const r = n[0].s,
    o = n[n.length - 1].e,
    i = e.slice(r, o);
  return new t(i, n);
}
const Pt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1,
};
function vz() {
  Pt.scanner = pz(Pt.customSchemes);
  for (let t = 0; t < Pt.tokenQueue.length; t++)
    Pt.tokenQueue[t][1]({
      scanner: Pt.scanner,
    });
  Pt.parser = bz(Pt.scanner.tokens);
  for (let t = 0; t < Pt.pluginQueue.length; t++)
    Pt.pluginQueue[t][1]({
      scanner: Pt.scanner,
      parser: Pt.parser,
    });
  Pt.initialized = !0;
}
function _z(t) {
  return (
    Pt.initialized || vz(), yz(Pt.parser.start, t, hz(Pt.scanner.start, t))
  );
}
function xz(t, e) {
  const n = _z(t);
  return n.length === 1 && n[0].isLink && n[0].t === e;
}
const kz = {
    class:
      "relative rounded-md bg-white overflow-hidden shadow w-96 p-1 max-h-72 overflow-y-auto",
  },
  wz = ["placeholder"],
  Cz = { class: "inline-flex items-center mt-2" },
  Az = { class: "ml-2 text-sm text-gray-500" },
  Sz = /* @__PURE__ */ se({
    __name: "LinkBubbleButton",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get() {
            const i = e.editor.getAttributes("link");
            return i == null ? void 0 : i.href;
          },
          set(i) {
            e.editor.commands.setLink({
              href: i,
              target: r.value ? "_blank" : "_self",
            });
          },
        }),
        r = ce({
          get() {
            const i = e.editor.getAttributes("link");
            return (i == null ? void 0 : i.target) === "_blank";
          },
          set(i) {
            e.editor.commands.setLink({
              href: n.value,
              target: i ? "_blank" : "_self",
            });
          },
        }),
        o = () => {
          var l;
          if (e.isActive({ editor: e.editor })) return;
          const { state: i } = e.editor,
            { selection: s } = i,
            { empty: a } = s;
          if (s instanceof q) {
            if (a) return !1;
            const { content: u } = s.content();
            if (!u || u.childCount !== 1) return !1;
            const c = (l = u.firstChild) == null ? void 0 : l.textContent;
            c &&
              xz(c, "url") &&
              e.editor.commands.setLink({
                href: c,
                target: "_self",
              });
          }
        };
      return (i, s) => (
        S(),
        de(
          I(ii),
          {
            class: "inline-flex",
            triggers: ["click"],
            distance: 10,
            onClick: o,
          },
          {
            popper: me(() => [
              C("div", kz, [
                je(
                  C(
                    "input",
                    {
                      "onUpdate:modelValue":
                        s[0] || (s[0] = (a) => (n.value = a)),
                      placeholder: I(D).global.t(
                        "editor.extensions.link.placeholder"
                      ),
                      class:
                        "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
                    },
                    null,
                    8,
                    wz
                  ),
                  [[Ot, n.value, void 0, { lazy: !0 }]]
                ),
                C("label", Cz, [
                  je(
                    C(
                      "input",
                      {
                        "onUpdate:modelValue":
                          s[1] || (s[1] = (a) => (r.value = a)),
                        type: "checkbox",
                        class:
                          "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded",
                      },
                      null,
                      512
                    ),
                    [[bb, r.value]]
                  ),
                  C(
                    "span",
                    Az,
                    it(
                      I(D).global.t("editor.extensions.link.open_in_new_window")
                    ),
                    1
                  ),
                ]),
              ]),
            ]),
            default: me(() => [
              je(
                (S(),
                O(
                  "button",
                  {
                    class: $e([
                      "text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md",
                      {
                        "bg-gray-200 !text-black": i.isActive({
                          editor: i.editor,
                        }),
                      },
                    ]),
                  },
                  [J(I(qa))],
                  2
                )),
                [
                  [
                    I(Sa),
                    i.isActive({ editor: i.editor })
                      ? I(D).global.t("editor.extensions.link.edit_link")
                      : I(D).global.t("editor.extensions.link.add_link"),
                  ],
                ]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  Ez = Ze.create({
    name: "text",
    group: "inline",
  }),
  Mz = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function Tz(t, e) {
  return (
    S(),
    O(
      "svg",
      Mz,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M2 5.27L3.28 4L20 20.72L18.73 22l-4.83-4.83l-2.61 2.61a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l2.62-2.6l-1.62-1.61c-.01.24-.11.49-.29.68c-.39.39-1.03.39-1.42 0A4.97 4.97 0 0 1 7.72 11zm10.71-1.05a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.33 3.33l-1.41-1.42zm.7 4.95c.39-.39 1.03-.39 1.42 0a5 5 0 0 1 1.23 5.06l-1.78-1.77c-.05-.68-.34-1.35-.87-1.87a.973.973 0 0 1 0-1.42",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Oz = k({ name: "mdi-link-variant-off", render: Tz }),
  Dz = ["audio", "video", "image", "iframe", "codeBlock"],
  Nz = Ez.extend({
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getBubbleMenu() {
          return {
            pluginKey: "textBubbleMenu",
            shouldShow: ({ state: e, from: n, to: r }) => {
              const { doc: o, selection: i } = e,
                { empty: s } = i;
              return !(
                s ||
                Dz.some((l) => Jt(e, l)) ||
                o.textBetween(n || 0, r || 0).length === 0 ||
                (!Ia(i) && !(i instanceof Kt))
              );
            },
            tippyOptions: {
              fixed: !1,
            },
            defaultAnimation: !1,
            items: [
              {
                priority: 10,
                props: {
                  isActive: ({ editor: e }) => e.isActive("bold"),
                  icon: k(g3),
                  title: D.global.t("editor.common.bold"),
                  action: ({ editor: e }) => {
                    e.chain().focus().toggleBold().run();
                  },
                },
              },
              {
                priority: 20,
                props: {
                  isActive: ({ editor: e }) => e.isActive("italic"),
                  icon: k(A3),
                  title: D.global.t("editor.common.italic"),
                  action: ({ editor: e }) => {
                    e.chain().focus().toggleItalic().run();
                  },
                },
              },
              {
                priority: 30,
                props: {
                  isActive: ({ editor: e }) => e.isActive("underline"),
                  icon: k(G3),
                  title: D.global.t("editor.common.underline"),
                  action: ({ editor: e }) =>
                    e.chain().focus().toggleUnderline().run(),
                },
              },
              {
                priority: 40,
                props: {
                  isActive: ({ editor: e }) => e.isActive("strike"),
                  icon: k(F3),
                  title: D.global.t("editor.common.strike"),
                  action: ({ editor: e }) =>
                    e.chain().focus().toggleStrike().run(),
                },
              },
              {
                priority: 50,
                component: k(oz),
                props: {
                  isActive: ({ editor: e }) => e.isActive("highlight"),
                  icon: k(w3),
                  title: D.global.t("editor.common.highlight"),
                },
              },
              {
                priority: 60,
                component: k(ZF),
                props: {
                  isActive: ({ editor: e }) => e.isActive("color"),
                  icon: k(_3),
                  title: D.global.t("editor.common.color"),
                },
              },
              {
                priority: 70,
                props: {
                  isActive: ({ editor: e }) => e.isActive("code"),
                  icon: k(y3),
                  title: D.global.t("editor.common.code"),
                  action: ({ editor: e }) =>
                    e.chain().focus().toggleCode().run(),
                },
              },
              {
                priority: 80,
                props: {
                  isActive: ({ editor: e }) => e.isActive("superscript"),
                  icon: k(V3),
                  title: D.global.t("editor.common.superscript"),
                  action: ({ editor: e }) =>
                    e.chain().focus().toggleSuperscript().run(),
                },
              },
              {
                priority: 90,
                props: {
                  isActive: ({ editor: e }) => e.isActive("subscript"),
                  icon: k(z3),
                  title: D.global.t("editor.common.subscript"),
                  action: ({ editor: e }) =>
                    e.chain().focus().toggleSubscript().run(),
                },
              },
              {
                priority: 100,
                component: k(Sz),
                props: {
                  isActive: ({ editor: e }) => e.isActive("link"),
                },
              },
              {
                priority: 110,
                props: {
                  isActive: () => !1,
                  visible: ({ editor: e }) => e.isActive("link"),
                  icon: k(Oz),
                  title: D.global.t("editor.extensions.link.cancel_link"),
                  action: ({ editor: e }) => e.commands.unsetLink(),
                },
              },
              {
                priority: 120,
                props: {
                  isActive: () => !1,
                  visible: ({ editor: e }) => e.isActive("link"),
                  icon: k(Ka),
                  title: D.global.t("editor.common.tooltip.open_link"),
                  action: ({ editor: e }) => {
                    const n = e.getAttributes("link");
                    n != null && n.href && window.open(n.href, "_blank");
                  },
                },
              },
            ],
          };
        },
      };
    },
  });
function hb({ types: t, node: e }) {
  return (Array.isArray(t) && t.includes(e.type)) || e.type === t;
}
const Lz = Ne.create({
    name: "trailingNode",
    addOptions() {
      return {
        node: "paragraph",
        notAfter: ["paragraph"],
      };
    },
    addProseMirrorPlugins() {
      const t = new ke(this.name),
        e = Object.entries(this.editor.schema.nodes)
          .map(([, r]) => r)
          .filter((r) => this.options.notAfter.includes(r.name)),
        n = this.editor.isEditable;
      return [
        new be({
          key: t,
          appendTransaction: (r, o, i) => {
            if (!n) return;
            const { doc: s, tr: a, schema: l } = i,
              u = t.getState(i),
              c = s.content.size,
              d = l.nodes[this.options.node];
            if (u) return a.insert(c, d.create());
          },
          state: {
            init: (r, o) => {
              if (!n) return !1;
              const i = o.tr.doc.lastChild;
              return !hb({ node: i, types: e });
            },
            apply: (r, o) => {
              if (!n || !r.docChanged) return o;
              const i = r.doc.lastChild;
              return !hb({ node: i, types: e });
            },
          },
        }),
      ];
    },
  }),
  Rz = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function Iz(t, e) {
  return (
    S(),
    O(
      "svg",
      Rz,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13.53 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66c-.04-.32-.07-.64-.07-.97s.03-.66.07-1L2.46 9.37a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.12.22.07.49-.12.64L19.43 11c.04.34.07.67.07 1v.19c-.5-.12-1-.19-1.5-.19c-.92 0-1.78.21-2.56.58c.03-.19.06-.38.06-.58c0-1.93-1.57-3.5-3.5-3.5S8.5 10.07 8.5 12s1.57 3.5 3.5 3.5c.2 0 .39-.03.58-.06a5.97 5.97 0 0 0 .95 6.56M16 15v6l5-3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Pz = k({ name: "mdi-cog-play", render: Iz }),
  $z = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function Bz(t, e) {
  return (
    S(),
    O(
      "svg",
      $z,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M13.54 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66L4.5 12l.07-1l-2.11-1.63a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.13.22.07.49-.12.64L19.43 11l.07 1v.19c-.5-.12-1-.19-1.5-.19c-.17 0-.34 0-.5.03c0-.62-.1-1.24-.3-1.83l2.11-1.55l-.75-1.3l-2.41 1.04a5.42 5.42 0 0 0-3.03-1.77L12.75 4h-1.5l-.37 2.61c-1.2.25-2.26.89-3.03 1.78L5.44 7.35l-.75 1.3L6.8 10.2a5.55 5.55 0 0 0 0 3.6l-2.12 1.56l.75 1.3l2.43-1.04c.77.88 1.82 1.52 3.01 1.76l.37 2.62h1.11c.26.75.65 1.42 1.19 2m2.42-9.64c.04-.12.04-.24.04-.36c0-2.21-1.79-4-4-4s-4 1.79-4 4s1.79 4 4 4c.12 0 .24 0 .36-.04a6.05 6.05 0 0 1 3.6-3.6M12 14c-1.1 0-2-.89-2-2s.9-2 2-2s2 .9 2 2s-.89 2-2 2m4 1v6l5-3z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Hz = k({ name: "mdi-cog-play-outline", render: Bz }),
  Fz = {
    viewBox: "0 0 24 24",
    width: "1.2em",
    height: "1.2em",
  };
function zz(t, e) {
  return (
    S(),
    O(
      "svg",
      Fz,
      e[0] ||
        (e[0] = [
          C(
            "path",
            {
              fill: "currentColor",
              d: "M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4v-11z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const mb = k({ name: "mdi-video", render: zz }),
  Vz = ["placeholder"],
  Uz = /* @__PURE__ */ se({
    __name: "BubbleItemVideoLink",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(Pe.name).src,
          set: (r) => {
            e.editor.chain().updateAttributes(Pe.name, { src: r }).run();
          },
        });
      return (r, o) =>
        je(
          (S(),
          O(
            "input",
            {
              "onUpdate:modelValue": o[0] || (o[0] = (i) => (n.value = i)),
              placeholder: I(D).global.t(
                "editor.common.placeholder.link_input"
              ),
              class:
                "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500",
            },
            null,
            8,
            Vz
          )),
          [[Ot, n.value, void 0, { lazy: !0 }]]
        );
    },
  }),
  jz = /* @__PURE__ */ se({
    __name: "BubbleItemVideoSize",
    props: {
      editor: {},
      isActive: { type: Function },
      visible: { type: Function },
      icon: {},
      title: {},
      action: { type: Function },
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => e.editor.getAttributes(Pe.name).width,
          set: (i) => {
            o(i, r.value);
          },
        }),
        r = ce({
          get: () => e.editor.getAttributes(Pe.name).height,
          set: (i) => {
            o(n.value, i);
          },
        });
      function o(i, s) {
        e.editor
          .chain()
          .updateAttributes(Pe.name, { width: i, height: s })
          .setNodeSelection(e.editor.state.selection.from)
          .focus()
          .run();
      }
      return (i, s) => (
        S(),
        O(
          gt,
          null,
          [
            J(
              I(Fi),
              {
                modelValue: n.value,
                "onUpdate:modelValue": s[0] || (s[0] = (a) => (n.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_width_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
            J(
              I(Fi),
              {
                modelValue: r.value,
                "onUpdate:modelValue": s[1] || (s[1] = (a) => (r.value = a)),
                modelModifiers: { lazy: !0, trim: !0 },
                tooltip: I(D).global.t(
                  "editor.common.tooltip.custom_height_input"
                ),
              },
              null,
              8,
              ["modelValue", "tooltip"]
            ),
          ],
          64
        )
      );
    },
  }),
  Wz = {
    key: 0,
    class: "p-1.5",
  },
  qz = ["placeholder"],
  Kz = ["controls", "autoplay", "loop", "src"],
  Gz = /* @__PURE__ */ se({
    __name: "VideoView",
    props: {
      decorations: {},
      selected: { type: Boolean },
      updateAttributes: { type: Function },
      deleteNode: { type: Function },
      node: {},
      view: {},
      getPos: { type: Function },
      innerDecorations: {},
      editor: {},
      extension: {},
      HTMLAttributes: {},
    },
    setup(t) {
      const e = t,
        n = ce({
          get: () => {
            var l;
            return (l = e.node) == null ? void 0 : l.attrs.src;
          },
          set: (l) => {
            e.updateAttributes({ src: l });
          },
        }),
        r = ce(() => e.node.attrs.controls),
        o = ce(() => e.node.attrs.autoplay),
        i = ce(() => e.node.attrs.loop);
      function s() {
        e.editor.commands.setNodeSelection(e.getPos());
      }
      const a = Te();
      return (
        Wr(() => {
          n.value || a.value.focus();
        }),
        (l, u) => (
          S(),
          de(
            I(Ha),
            {
              as: "div",
              class: "inline-block w-full",
            },
            {
              default: me(() => [
                C(
                  "div",
                  {
                    class:
                      "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
                    style: mt({
                      width: l.node.attrs.width,
                    }),
                  },
                  [
                    n.value
                      ? (S(),
                        O(
                          "video",
                          {
                            key: 1,
                            controls: r.value,
                            autoplay: o.value,
                            loop: i.value,
                            class: "rounded-md m-0",
                            src: l.node.attrs.src,
                            style: mt({
                              width: l.node.attrs.width,
                              height: l.node.attrs.height,
                            }),
                            onMouseenter: s,
                          },
                          null,
                          44,
                          Kz
                        ))
                      : (S(),
                        O("div", Wz, [
                          je(
                            C(
                              "input",
                              {
                                ref_key: "inputRef",
                                ref: a,
                                "onUpdate:modelValue":
                                  u[0] || (u[0] = (c) => (n.value = c)),
                                class:
                                  "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
                                placeholder: I(D).global.t(
                                  "editor.common.placeholder.link_input"
                                ),
                                tabindex: "-1",
                                onFocus: s,
                              },
                              null,
                              40,
                              qz
                            ),
                            [[Ot, n.value, void 0, { lazy: !0 }]]
                          ),
                        ])),
                  ],
                  4
                ),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  }),
  Pe = Ze.create({
    name: "video",
    fakeSelection: !0,
    inline() {
      return !0;
    },
    group() {
      return "inline";
    },
    addAttributes() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        src: {
          default: null,
          parseHTML: (e) => e.getAttribute("src"),
        },
        width: {
          default: "100%",
          parseHTML: (e) => e.getAttribute("width"),
          renderHTML(e) {
            return {
              width: e.width,
            };
          },
        },
        height: {
          default: "auto",
          parseHTML: (e) => e.getAttribute("height"),
          renderHTML: (e) => ({
            height: e.height,
          }),
        },
        autoplay: {
          default: null,
          parseHTML: (e) => e.getAttribute("autoplay"),
          renderHTML: (e) => ({
            autoplay: e.autoplay,
          }),
        },
        controls: {
          default: !0,
          parseHTML: (e) => e.getAttribute("controls"),
          renderHTML: (e) => ({
            controls: e.controls,
          }),
        },
        loop: {
          default: null,
          parseHTML: (e) => e.getAttribute("loop"),
          renderHTML: (e) => ({
            loop: e.loop,
          }),
        },
        textAlign: {
          default: null,
          parseHTML: (e) => e.getAttribute("text-align"),
          renderHTML: (e) => ({
            "text-align": e.textAlign,
          }),
        },
      };
    },
    parseHTML() {
      return [
        {
          tag: "video",
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["video", ge(t)];
    },
    addCommands() {
      return {
        setVideo:
          (t) =>
          ({ commands: e }) =>
            e.insertContent({
              type: this.name,
              attrs: t,
            }),
      };
    },
    addInputRules() {
      return [
        Pa({
          find: /^\$video\$$/,
          type: this.type,
          getAttributes: () => ({ width: "100%" }),
        }),
      ];
    },
    addNodeView() {
      return Fa(Gz);
    },
    addOptions() {
      var t;
      return {
        ...((t = this.parent) == null ? void 0 : t.call(this)),
        getCommandMenuItems() {
          return {
            priority: 100,
            icon: k(mb),
            title: "editor.extensions.commands_menu.video",
            keywords: ["video", "shipin"],
            command: ({ editor: e, range: n }) => {
              e.chain()
                .focus()
                .deleteRange(n)
                .insertContent([
                  { type: "video", attrs: { src: "" } },
                  { type: "paragraph", content: "" },
                ])
                .run();
            },
          };
        },
        getToolboxItems({ editor: e }) {
          return [
            {
              priority: 20,
              component: k(gi),
              props: {
                editor: e,
                icon: k(mb),
                title: D.global.t("editor.extensions.commands_menu.video"),
                action: () => {
                  e.chain()
                    .focus()
                    .insertContent([{ type: "video", attrs: { src: "" } }])
                    .run();
                },
              },
            },
          ];
        },
        getBubbleMenu({ editor: e }) {
          return {
            pluginKey: "videoBubbleMenu",
            shouldShow: ({ state: n }) => Jt(n, Pe.name),
            items: [
              {
                priority: 10,
                props: {
                  isActive: () => e.getAttributes(Pe.name).controls,
                  icon: k(e.getAttributes(Pe.name).controls ? Pz : Hz),
                  action: () =>
                    e
                      .chain()
                      .updateAttributes(Pe.name, {
                        controls: e.getAttributes(Pe.name).controls ? null : !0,
                      })
                      .setNodeSelection(e.state.selection.from)
                      .focus()
                      .run(),
                  title: e.getAttributes(Pe.name).controls
                    ? D.global.t("editor.extensions.video.disable_controls")
                    : D.global.t("editor.extensions.video.enable_controls"),
                },
              },
              {
                priority: 20,
                props: {
                  isActive: () => e.getAttributes(Pe.name).autoplay,
                  icon: k(e.getAttributes(Pe.name).autoplay ? Z3 : Q3),
                  action: () =>
                    e
                      .chain()
                      .updateAttributes(Pe.name, {
                        autoplay: e.getAttributes(Pe.name).autoplay ? null : !0,
                      })
                      .setNodeSelection(e.state.selection.from)
                      .focus()
                      .run(),
                  title: e.getAttributes(Pe.name).autoplay
                    ? D.global.t("editor.extensions.video.disable_autoplay")
                    : D.global.t("editor.extensions.video.enable_autoplay"),
                },
              },
              {
                priority: 30,
                props: {
                  isActive: () => e.getAttributes(Pe.name).loop,
                  icon: k(e.getAttributes(Pe.name).loop ? Y3 : X3),
                  action: () => {
                    e.chain()
                      .updateAttributes(Pe.name, {
                        loop: e.getAttributes(Pe.name).loop ? null : !0,
                      })
                      .setNodeSelection(e.state.selection.from)
                      .focus()
                      .run();
                  },
                  title: e.getAttributes(Pe.name).loop
                    ? D.global.t("editor.extensions.video.disable_loop")
                    : D.global.t("editor.extensions.video.enable_loop"),
                },
              },
              {
                priority: 40,
                component: k(ot),
              },
              {
                priority: 50,
                component: k(jz),
              },
              {
                priority: 60,
                component: k(ot),
              },
              {
                priority: 70,
                props: {
                  isActive: () => e.getAttributes(Pe.name).width === "25%",
                  icon: k(lx),
                  action: () => Bf(e, "25%", "auto"),
                  title: D.global.t("editor.extensions.video.small_size"),
                },
              },
              {
                priority: 80,
                props: {
                  isActive: () => e.getAttributes(Pe.name).width === "50%",
                  icon: k(ax),
                  action: () => Bf(e, "50%", "auto"),
                  title: D.global.t("editor.extensions.video.medium_size"),
                },
              },
              {
                priority: 90,
                props: {
                  isActive: () => e.getAttributes(Pe.name).width === "100%",
                  icon: k(sx),
                  action: () => Bf(e, "100%", "auto"),
                  title: D.global.t("editor.extensions.video.large_size"),
                },
              },
              {
                priority: 100,
                component: k(ot),
              },
              {
                priority: 110,
                props: {
                  isActive: () => e.isActive({ textAlign: "left" }),
                  icon: k(us),
                  action: () => $l(e, "left"),
                },
              },
              {
                priority: 120,
                props: {
                  isActive: () => e.isActive({ textAlign: "center" }),
                  icon: k(Ua),
                  action: () => $l(e, "center"),
                },
              },
              {
                priority: 130,
                props: {
                  isActive: () => e.isActive({ textAlign: "right" }),
                  icon: k(Wa),
                  action: () => $l(e, "right"),
                },
              },
              {
                priority: 140,
                props: {
                  isActive: () => e.isActive({ textAlign: "justify" }),
                  icon: k(ja),
                  action: () => $l(e, "justify"),
                },
              },
              {
                priority: 150,
                component: k(ot),
              },
              {
                priority: 160,
                props: {
                  icon: k(qa),
                  title: D.global.t("editor.common.button.edit_link"),
                  action: () => k(Uz),
                },
              },
              {
                priority: 170,
                props: {
                  icon: k(Ka),
                  title: D.global.t("editor.common.tooltip.open_link"),
                  action: () => {
                    window.open(e.getAttributes(Pe.name).src, "_blank");
                  },
                },
              },
              {
                priority: 180,
                component: k(ot),
              },
              {
                priority: 190,
                props: {
                  icon: k(pi),
                  title: D.global.t("editor.common.button.delete"),
                  action: ({ editor: n }) => {
                    ls(Pe.name, n);
                  },
                },
              },
            ],
          };
        },
        getDraggable() {
          return {
            getRenderContainer({ dom: e, view: n }) {
              var i;
              let r = e;
              for (; r && r.tagName !== "P"; ) r = r.parentElement;
              r &&
                (r =
                  (i = r.firstElementChild) == null
                    ? void 0
                    : i.firstElementChild);
              let o;
              if (r.firstElementChild) {
                const s = n.posAtDOM(r.firstElementChild, 0);
                o = n.state.doc.resolve(s).node();
              }
              return {
                node: o,
                el: r,
              };
            },
          };
        },
      };
    },
  }),
  Bf = (t, e, n) => {
    t.chain()
      .updateAttributes(Pe.name, { width: e, height: n })
      .setNodeSelection(t.state.selection.from)
      .focus()
      .run();
  },
  $l = (t, e) => {
    t.chain().focus().setTextAlign(e).run();
  },
  cU = [
    dN,
    vN,
    CN,
    ON,
    tN,
    nN.configure({
      width: 2,
      class: "dropcursor",
      color: "skyblue",
    }),
    DB,
    rN,
    Up,
    cR,
    oN,
    yR,
    JR,
    tI,
    Nz,
    Et,
    yP,
    nR,
    c7,
    h7,
    Zp.configure({
      autolink: !0,
      openOnClick: !1,
    }),
    OP.configure({
      types: ["heading", "paragraph"],
    }),
    RP,
    Vo.configure({
      resizable: !0,
    }),
    iI,
    uI,
    iN.configure({
      placeholder: D.global.t("editor.extensions.commands_menu.placeholder"),
    }),
    O$.configure({
      suggestion: {},
    }),
    v$,
    ft,
    Pe,
    At,
    VH,
    _a,
    N0,
    KH,
    Lz,
    JF,
    nB,
    EB,
    GH,
  ],
  dU = {
    install(t) {
      t.component("RichTextEditor", eN);
    },
  };
export {
  Pr as AddMarkStep,
  ho as AddNodeMarkStep,
  $t as AllSelection,
  ei as AttrStep,
  Li as BlockActionButton,
  Fi as BlockActionInput,
  ot as BlockActionSeparator,
  Xz as BlockCard,
  Th as BubbleItem,
  rU as BubbleMenu,
  _M as CellBookmark,
  De as CellSelection,
  Vn as Change,
  Ss as ChangeSet,
  id as CommandManager,
  si as ContentMatch,
  VO as CoreEditor,
  zr as DOMParser,
  hi as DOMSerializer,
  Ve as Decoration,
  ve as DecorationSet,
  na as DocAttrStep,
  AV as Dropdown,
  SV as DropdownSubmenu,
  h3 as Editor,
  AD as EditorContent,
  Ri as EditorState,
  mA as EditorView,
  Ne as Extension,
  At as ExtensionAudio,
  dN as ExtensionBlockquote,
  vN as ExtensionBold,
  CN as ExtensionBulletList,
  nB as ExtensionClearFormat,
  ON as ExtensionCode,
  v$ as ExtensionCodeBlock,
  c7 as ExtensionColor,
  N0 as ExtensionColumn,
  _a as ExtensionColumns,
  O$ as ExtensionCommands,
  tN as ExtensionDocument,
  uU as ExtensionDraggable,
  nN as ExtensionDropcursor,
  h7 as ExtensionFontSize,
  EB as ExtensionFormatBrush,
  DB as ExtensionGapcursor,
  rN as ExtensionHardBreak,
  Up as ExtensionHeading,
  nR as ExtensionHighlight,
  cR as ExtensionHistory,
  oN as ExtensionHorizontalRule,
  ft as ExtensionIframe,
  Et as ExtensionImage,
  VH as ExtensionIndent,
  yR as ExtensionItalic,
  Zp as ExtensionLink,
  aU as ExtensionListKeymap,
  KH as ExtensionNodeSelected,
  JR as ExtensionOrderedList,
  Ii as ExtensionParagraph,
  iN as ExtensionPlaceholder,
  GH as ExtensionRangeSelection,
  JF as ExtensionSearchAndReplace,
  tI as ExtensionStrike,
  iI as ExtensionSubscript,
  uI as ExtensionSuperscript,
  Vo as ExtensionTable,
  yP as ExtensionTaskList,
  Nz as ExtensionText,
  OP as ExtensionTextAlign,
  v3 as ExtensionTextStyle,
  Lz as ExtensionTrailingNode,
  RP as ExtensionUnderline,
  Pe as ExtensionVideo,
  oU as FloatingMenu,
  $ as Fragment,
  Qt as GapCursor,
  Ra as InputRule,
  ip as MapResult,
  $i as Mapping,
  tn as Mark,
  Vc as MarkType,
  E8 as MarkdownParser,
  T8 as MarkdownSerializer,
  D8 as MarkdownSerializerState,
  mi as MenuItem,
  Ze as Node,
  OD as NodeBubbleMenu,
  jo as NodePos,
  uu as NodeRange,
  Z as NodeSelection,
  Km as NodeType,
  jO as NodeView,
  SD as NodeViewContent,
  Ha as NodeViewWrapper,
  Do as PMInputRule,
  Oe as PMMark,
  qn as PMNode,
  i0 as PasteRule,
  be as Plugin,
  ke as PluginKey,
  Kt as RangeSelection,
  Un as RemoveMarkStep,
  Ui as RemoveNodeMarkStep,
  bt as ReplaceAroundStep,
  au as ReplaceError,
  pt as ReplaceStep,
  XM as ResizeState,
  ta as ResolvedPos,
  eN as RichTextEditor,
  Uc as Schema,
  ee as Selection,
  pu as SelectionRange,
  W as Slice,
  Ie as Span,
  Nt as Step,
  an as StepMap,
  at as StepResult,
  Ae as TableMap,
  JM as TableView,
  q as TextSelection,
  Xe as ToolbarItem,
  Ut as ToolbarSubItem,
  gi as ToolboxItem,
  tU as Tracker,
  pC as Transaction,
  Nh as Transform,
  ji as TransformError,
  Fa as VueNodeViewRenderer,
  m3 as VueRenderer,
  UM as __clipCells,
  lV as __endComposition,
  wg as __insertCells,
  aV as __parseFromClipboard,
  zM as __pastedCells,
  hA as __serializeForClipboard,
  y_ as addColSpan,
  k_ as addColumn,
  w_ as addColumnAfter,
  EM as addColumnBefore,
  PV as addListNodes,
  C_ as addRow,
  A_ as addRowAfter,
  DM as addRowBefore,
  cU as allExtensions,
  iV as autoJoin,
  sV as baseKeymap,
  LV as blockTypeItem,
  rM as bulletList,
  le as callOrReturn,
  _r as canJoin,
  hr as canSplit,
  is as cellAround,
  bM as cellNear,
  Bh as chainCommands,
  PA as closeDoubleQuote,
  cV as closeHistory,
  BA as closeSingleQuote,
  FV as colCount,
  Qz as collab,
  vM as columnIsHeader,
  YM as columnResizing,
  ln as columnResizingPluginKey,
  uO as combineTransactionSteps,
  od as createChainableState,
  Lp as createDocument,
  Eu as createNodeFromContent,
  Zy as createParagraphNear,
  zO as createStyleTag,
  dU as default,
  cO as defaultBlockAt,
  wV as defaultMarkdownParser,
  CV as defaultMarkdownSerializer,
  cl as deleteCellSelection,
  TM as deleteColumn,
  ls as deleteNode,
  ba as deleteNodeByPos,
  Lg as deleteProps,
  LM as deleteRow,
  Rh as deleteSelection,
  FM as deleteTable,
  EC as dropCursor,
  Iy as dropPoint,
  ys as elementFromString,
  vV as ellipsis,
  yV as emDash,
  WO as escapeForRegEx,
  Xy as exitCode,
  YV as extensions,
  HV as findCell,
  WV as findChildren,
  dO as findChildrenInRange,
  vT as findDuplicates,
  On as findParentNode,
  B_ as findParentNodeClosestToPos,
  jc as findWrapping,
  x_ as fixTables,
  AM as fixTablesKey,
  uT as fromString,
  uV as gapCursor,
  m7 as generateAnchor,
  g7 as generateAnchorId,
  qV as generateHTML,
  KV as generateJSON,
  GV as generateText,
  H_ as getAttributes,
  M_ as getAttributesFromExtensions,
  mO as getChangedRanges,
  gO as getDebugJSON,
  K as getExtensionField,
  ad as getHTMLFromFragment,
  $_ as getMarkAttributes,
  s0 as getMarkRange,
  No as getMarkType,
  c0 as getMarksBetween,
  bO as getNodeAtPosition,
  fO as getNodeAttributes,
  lt as getNodeType,
  Np as getRenderedAttributes,
  l0 as getSchema,
  O_ as getSchemaByResolvedExtensions,
  uf as getSchemaTypeByName,
  cd as getSchemaTypeNameByName,
  ql as getSplittedAttributes,
  u0 as getText,
  D_ as getTextBetween,
  cT as getTextContentFromNodes,
  ud as getTextSerializersFromSchema,
  nV as getVersion,
  _g as goToNextCell,
  KM as handlePaste,
  NA as history,
  La as icons,
  r0 as inSameTable,
  Tg as injectExtensionAttributesToParseRule,
  gV as inputRules,
  fT as inputRulesPlugin,
  iC as insertPoint,
  Jt as isActive,
  yO as isAtEndOfNode,
  vO as isAtStartOfNode,
  lT as isEmptyObject,
  Dg as isExtensionRulesEnabled,
  T_ as isFunction,
  Xn as isInTable,
  Ip as isList,
  P_ as isMacOS,
  Rp as isMarkActive,
  Sn as isNodeActive,
  dd as isNodeEmpty,
  Mu as isNodeSelection,
  hT as isNumber,
  hl as isPlainObject,
  o0 as isRegExp,
  QV as isString,
  Ia as isTextSelection,
  a0 as isiOS,
  jy as joinBackward,
  vC as joinDown,
  Gy as joinForward,
  Wc as joinPoint,
  bC as joinTextblockBackward,
  yC as joinTextblockForward,
  ap as joinUp,
  EV as joinUpItem,
  Gc as keydownHandler,
  PC as keymap,
  lp as lift,
  Qy as liftEmptyBlock,
  MV as liftItem,
  lM as liftListItem,
  ns as liftTarget,
  oM as listItem,
  iv as macBaseKeymap,
  w8 as markDownSchema,
  ci as markInputRule,
  So as markPasteRule,
  Z8 as marks,
  RV as menuBar,
  ge as mergeAttributes,
  bg as mergeCells,
  ld as mergeDeep,
  Hr as minMax,
  yM as moveCellForward,
  Yy as newlineInCode,
  b_ as nextCell,
  Pa as nodeInputRule,
  qO as nodePasteRule,
  sU as nodeViewProps,
  G8 as nodes,
  Su as objectIncludes,
  IA as openDoubleQuote,
  $A as openSingleQuote,
  nM as orderedList,
  yT as pasteRulesPlugin,
  Rr as pcBaseKeymap,
  kV as pmTextblockTypeInputRule,
  xV as pmWrappingInputRule,
  Tp as pointsAtCell,
  d0 as posToDOMRect,
  mC as rebaseSteps,
  eV as receiveTransaction,
  ku as redo,
  hV as redoDepth,
  DV as redoItem,
  fV as redoNoScroll,
  ui as removeColSpan,
  MM as removeColumn,
  pO as removeDuplicates,
  NM as removeRow,
  P8 as renderGrouped,
  qc as replaceStep,
  R_ as resolveFocusPosition,
  JV as rewriteUnknownContent,
  OM as rowIsHeader,
  IV as schema,
  xC as selectAll,
  qy as selectNodeBackward,
  Jy as selectNodeForward,
  up as selectParentNode,
  TV as selectParentNodeItem,
  ov as selectTextblockEnd,
  rv as selectTextblockStart,
  Zn as selectedRect,
  rd as selectionCell,
  $T as selectionToInsertionEnd,
  tV as sendableSteps,
  dp as setBlockType,
  PM as setCellAttr,
  Zz as simplifyChanges,
  dM as sinkListItem,
  _V as smartQuotes,
  ev as splitBlock,
  _C as splitBlockAs,
  rV as splitBlockKeepMarks,
  yg as splitCell,
  IM as splitCellWithType,
  sd as splitExtensions,
  aM as splitListItem,
  $V as splitListItemKeepMarks,
  sT as tableEditing,
  co as tableEditingKey,
  Dt as tableNodeTypes,
  BV as tableNodes,
  ZV as textInputRule,
  eU as textPasteRule,
  Pp as textblockTypeInputRule,
  ha as toggleHeader,
  BM as toggleHeaderCell,
  VV as toggleHeaderColumn,
  zV as toggleHeaderRow,
  oV as toggleMark,
  jV as trailingNode,
  xu as undo,
  pV as undoDepth,
  bV as undoInputRule,
  OV as undoItem,
  dV as undoNoScroll,
  Dp as updateColumnsOnResize,
  iU as useEditor,
  cp as wrapIn,
  iM as wrapInList,
  NV as wrapItem,
  Gi as wrappingInputRule,
};
